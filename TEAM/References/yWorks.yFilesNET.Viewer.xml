<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>yWorks.yFilesNET.Viewer</name>
  </assembly>
  <members>
    <member name="T:yWorks.Annotations.CanBeNullAttribute">
      <summary>
        <para>Indicates that the value of marked element could be <c>null</c> sometimes, so the check for <c>null</c> is necessary before its usage</para>
      </summary>
      <remarks>
        <para>This attribute can be used by tools like Resharper to aid during coding and error analysis.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Annotations.NotNullAttribute">
      <summary>
        <para>Indicates that the value of marked element could never be <c>null</c></para>
      </summary>
      <remarks>
        <para>This attribute can be used by tools like Resharper to aid during coding and error analysis.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Annotations.ItemNotNullAttribute">
      <summary>
        <para>Indicates that a collection or an enumerable does not contain elements whose value is null.</para>
      </summary>
      <remarks>
        <para>This attribute can be used by tools like Resharper to aid during coding and error analysis.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Annotations.ItemCanBeNullAttribute">
      <summary>
        <para>Indicates that a collection or an enumerable can contain elements whose value is null.</para>
      </summary>
      <remarks>
        <para>This attribute can be used by tools like Resharper to aid during coding and error analysis.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.TableAnimation">
      <summary>
        <para>An animation for the <see cref="T:yWorks.Graph.IStripe">stripes</see> in an <see cref="T:yWorks.Graph.ITable" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.TableAnimation.#ctor(yWorks.Graph.ITable,System.Double[],System.Double[])">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.TableAnimation" /> class for the given table, the column widths, and row heights.</para>
      </summary>
      <remarks>
        <para>Note that only the sizes of <b>leaf stripes</b>, i.e. those without child stripes, are considered. The sizes of a stripe with children is implicitly determined by its contents.</para>
      </remarks>
      <param name="table">
        <para>The table to animate.</para>
      </param>
      <param name="columnLayout">
        <para>The sizes of the <b>leaf</b> columns, in natural order.</para>
      </param>
      <param name="rowLayout">
        <para>The sizes of the <b>leaf</b> rows, in natural order.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.TableAnimation.Initialize" />
    <member name="M:yWorks.Controls.TableAnimation.Animate(System.Double)">
      <param name="time" />
    </member>
    <member name="M:yWorks.Controls.TableAnimation.Cleanup" />
    <member name="P:yWorks.Controls.TableAnimation.PreferredDuration">
      <summary>
        <para>Gets or sets the preferred duration of the animation.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.TableAnimation.CreateStripeAnimation(yWorks.Graph.IStripe,System.Double)">
      <summary>
        <para>Create the animation for a single <see cref="T:yWorks.Graph.IStripe" /></para>
      </summary>
      <param name="stripe">
        <para>The stripe</para>
      </param>
      <param name="targetSize">
        <para>The target size of the stripe</para>
      </param>
      <returns>
        <para>An animation that morphs the stripe size</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Animator">
      <summary>
        <para>Runs <see cref="T:yWorks.Controls.IAnimation">animations</see> in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>For running <see cref="T:yWorks.Controls.IAnimation" /> instances, the <see cref="M:yWorks.Controls.Animator.Animate(yWorks.Controls.IAnimation,System.Threading.CancellationToken)" /> method can be used. For simpler cases of custom animations there is also an overload of the methods that accepts an <see cref="T:yWorks.Controls.AnimationCallback" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.IAnimation" />
      <seealso cref="T:yWorks.Controls.AnimationCallback" />
    </member>
    <member name="M:yWorks.Controls.Animator.#ctor(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Animator" /> class using the given <see cref="T:yWorks.Controls.CanvasControl" /> to run the animations in.</para>
      </summary>
      <remarks>
        <para>Using this constructor this instance will query an instance of <see cref="T:yWorks.Controls.Input.WaitInputMode" /> from the <see cref="M:yWorks.Controls.CanvasControl.Lookup(System.Type)">canvas's context</see> to automatically set the <see cref="P:yWorks.Controls.Input.WaitInputMode.Waiting" /> property during animations if <see cref="P:yWorks.Controls.Animator.AllowUserInteraction" /> is set to <c>false</c>. The animation is not started until <see cref="M:yWorks.Controls.Animator.Animate(yWorks.Controls.IAnimation,System.Threading.CancellationToken)" /> or <see cref="M:yWorks.Controls.Animator.Animate(yWorks.Controls.AnimationCallback,System.TimeSpan,System.Threading.CancellationToken)" /> is called.</para>
      </remarks>
      <param name="canvas">
        <para>The canvas control.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Animator.AllowUserInteraction">
      <summary>
        <para>Gets or sets whether user interaction should be allowed during the animation.</para>
      </summary>
      <remarks>
        <para>If <c>false</c>, the <see cref="T:yWorks.Controls.Input.WaitInputMode" /> is queried from the <see cref="T:yWorks.Controls.CanvasControl" /> and <see cref="P:yWorks.Controls.Input.WaitInputMode.Waiting" /> is enabled during the animation. The default is <c>false</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Animator.Control">
      <summary>
        <para>Gets the control the animations are run on.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Animator.Animate(yWorks.Controls.AnimationCallback,System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
        <para>Asynchronously starts an animation with the given callback for the specified duration.</para>
      </summary>
      <remarks>
        <para>The animation will be performed asynchronously in a separate thread.</para>
      </remarks>
      <param name="callback">
        <para>The callback to use for the animation.</para>
      </param>
      <param name="duration">
        <para>The duration in milliseconds that the animation should last.</para>
      </param>
      <param name="token">
        <para>The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Animator.Animate(yWorks.Controls.IAnimation,System.Threading.CancellationToken)">
      <summary>
        <para>Asynchronously animates the given animation instance.</para>
      </summary>
      <remarks>
        <para>The animation will be performed asynchronously in a separate thread.</para>
      </remarks>
      <param name="animation">
        <para>The animation to perform.</para>
      </param>
      <param name="token">
        <para>The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</para>
      </param>
      <returns>
        <para>A task representing the animation. If the animation completed normally, the result is <c>true</c>. If the animation was canceled via the <paramref name="token" />, the result is <c>false</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Animator.CreateTimer(System.Action)">
      <summary>
        <para>Creates the <see cref="T:System.Timers.Timer" /> which invokes the animation steps periodically.</para>
      </summary>
      <param name="action">
        <para>The method to invoke on each step.</para>
      </param>
      <remarks>
        <para>The timer uses the <see cref="P:yWorks.Controls.Animator.Control" /> as <see cref="P:System.Timers.Timer.SynchronizingObject" />, e.e. the calls to <paramref name="action" /> are marshaled on the UI thread.</para>
      </remarks>
      <returns>
        <para>The created timer.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Animator.Destroy">
      <summary>
        <para>Stops the animations and aborts the animation threads.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Animator.InvalidateControl(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Invalidates the control if <see cref="P:yWorks.Controls.Animator.AutoInvalidation" /> is set to <c>true</c>.</para>
      </summary>
      <param name="canvas">
        <para>The control.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Animator.AutoInvalidation">
      <summary>
        <para>Gets or sets a value indicating whether to automatically <see cref="M:yWorks.Controls.Animator.InvalidateControl(yWorks.Controls.CanvasControl)">invalidate the control</see> this instance has been created for.</para>
      </summary>
      <remarks>
        <para>The default is true.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if invalidation should happen automatically; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.AnimationCallback">
      <summary>
        <para>A simple callback method for animations.</para>
      </summary>
      <remarks>
        <para>This can be used in <see cref="M:yWorks.Controls.Animator.Animate(yWorks.Controls.AnimationCallback,System.TimeSpan,System.Threading.CancellationToken)" /> as a simpler alternative to implementing <see cref="T:yWorks.Controls.IAnimation" />. The interface offers more flexibility for reusable animations as well as lifecycle management (<see cref="M:yWorks.Controls.IAnimation.Initialize" />, <see cref="M:yWorks.Controls.IAnimation.Cleanup" />) and a preferred duration. But if the intent is to just run a simple one-off animation, <see cref="T:yWorks.Controls.AnimationCallback" /> is a useful alternative.</para>
      </remarks>
      <param name="time">
        <para>The current (relative) animation time which is a double between 0.0 for the start of the animation and 1.0 for the end of the animation.</para>
      </param>
      <seealso cref="T:yWorks.Controls.IAnimation" />
      <seealso cref="T:yWorks.Controls.Animator" />
    </member>
    <member name="T:yWorks.Controls.IAnimation">
      <summary>
        <para>An interface for animations that can be run by <see cref="T:yWorks.Controls.Animator" />.</para>
      </summary>
      <remarks>
        <para>Instances of classes implementing this interface change their state according to a relative animation time. The animation time is a double between 0 for the start of the animation and 1 for the end of the animation.</para>
        <list type="bullet">
          <item>An animated object is first created using the constructor of a subclass.</item>
          <item>Immediately before the animation a client calls <see cref="M:yWorks.Controls.IAnimation.Initialize" />.</item>
          <item>To change the state of the animated object a client does a series of calls to <see cref="M:yWorks.Controls.IAnimation.Animate(System.Double)" />, usually with an increasing relative time parameter.</item>
          <item>If the animation is done, the client calls <see cref="M:yWorks.Controls.IAnimation.Cleanup" /> once.</item>
          <item>While <see cref="M:yWorks.Controls.IAnimation.Animate(System.Double)" /> uses a relative time scheme, there might be an absolute time value for the preferred duration of the whole sequence of animation steps. Since an IAnimation instance has no control on the number of <see cref="M:yWorks.Controls.IAnimation.Animate(System.Double)" /> calls or the intervals between them, the preferred duration is only a hint on how long the animation should take. Clients can ask for that hint using <see cref="P:yWorks.Controls.IAnimation.PreferredDuration" /> and try to find a suitable sequence of <see cref="M:yWorks.Controls.IAnimation.Animate(System.Double)" /> calls in order to fulfill the preference.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.IAnimation.Initialize">
      <summary>
        <para>Initializes the animation.</para>
      </summary>
      <remarks>
        <para>Call this method once before subsequent calls to <see cref="M:yWorks.Controls.IAnimation.Animate(System.Double)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.IAnimation.Animate(System.Double)">
      <summary>
        <para>Does the animation according to the relative animation time.</para>
      </summary>
      <param name="time">
        <para>the animation time [0,1]</para>
      </param>
      <remarks>
        <para>The animation starts with the time 0 and ends with time 1.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.IAnimation.Cleanup">
      <summary>
        <para>Cleans up after an animation has finished.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.IAnimation.PreferredDuration">
      <summary>
        <para>Gets the preferred duration of the animation.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Animations">
      <summary>
        <para>Contains factory methods for eased, parallel, and path animations.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.IAnimation" />
      <seealso cref="M:yWorks.Controls.Animator.Animate(yWorks.Controls.AnimationCallback,System.TimeSpan,System.Threading.CancellationToken)" />
    </member>
    <member name="M:yWorks.Controls.Animations.CreateEasedAnimation(yWorks.Controls.IAnimation,System.Double,System.Double)">
      <summary>
        <para>Creates an eased animation for the given base animation.</para>
      </summary>
      <remarks>
        <para>The animation speed linearly increases upto a <paramref name="easeIn" /> and linearly decreases from <paramref name="easeOut" />. Between those two points, the animation speed is constant.</para>
        <para>The duration of the ease in and ease out is determined by a mapping [0,1] → [0,1]. The mapping has to be increasing to preserve the order of the frames in the decorated animation. In general, we consider continuously differentiable functions <i>f</i> where integral of <i>f</i>′ equals 1 a suitable choice for the mapping.</para>
      </remarks>
      <param name="animation">
        <para>The decorated animation.</para>
      </param>
      <param name="easeIn">
        <para>The ratio for the ease-in time [0,1] where 0 is the start of the animation and 1 the end. <c>0.5</c> is the default value.</para>
      </param>
      <param name="easeOut">
        <para>The ratio for the ease-out time [0,1] where 0 is the start of the animation and 1 the end. <c>0.5</c> is the default value.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Animations.CreateParallelAnimation(yWorks.Controls.IAnimation,System.Collections.Generic.IEnumerable{yWorks.Controls.IAnimation},System.Boolean)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.IAnimation" /> according to the composite design pattern that animates multiple animations in parallel to this animation.</para>
      </summary>
      <remarks>
        <para>The animations will be synchronized to the longest running animation.</para>
      </remarks>
      <param name="firstAnimation">
        <para>The first animation to add the other animations to.</para>
      </param>
      <param name="otherAnimations">
        <para>The animations to run in parallel.</para>
      </param>
      <param name="synchronized">
        <para>Whether all child animations should be adjusted to have the same (maximum) <see cref="P:yWorks.Controls.IAnimation.PreferredDuration" />. By default this is enabled.</para>
      </param>
      <returns>
        <para>A new instance that is the composite of the given animations.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Animations.CreateParallelAnimation(System.Collections.Generic.IEnumerable{yWorks.Controls.IAnimation},System.Boolean)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.IAnimation" /> according to the composite design pattern that animates multiple animations in parallel.</para>
      </summary>
      <remarks>
        <para>The animations can be synchronized to the longest running animation.</para>
      </remarks>
      <param name="animations">
        <para>The animations to run in parallel.</para>
      </param>
      <param name="synchronized">
        <para>Whether all child animations should be adjusted to have the same (maximum) <see cref="P:yWorks.Controls.IAnimation.PreferredDuration" />. By default this is enabled.</para>
      </param>
      <returns>
        <para>A new instance that is the composite of the given animations.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Animations.CreatePathAnimation(yWorks.Geometry.GeneralPath,yWorks.Geometry.IMutablePoint,System.TimeSpan)">
      <summary>
        <para>Creates a new instance of an <see cref="T:yWorks.Controls.IAnimation" /> that animates the given <see cref="T:yWorks.Geometry.IMutablePoint" /> along a path.</para>
      </summary>
      <param name="path">
        <para>The path to animate the point along.</para>
      </param>
      <param name="animationPoint">
        <para>The mutable point instance that will be manipulated by the animation.</para>
      </param>
      <param name="preferredDuration">
        <para>The preferred duration of the animation.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Animations.CreateGraphAnimation(yWorks.Graph.IGraph,yWorks.Graph.IMapper{yWorks.Graph.INode,yWorks.Geometry.IRectangle},yWorks.Graph.IMapper{yWorks.Graph.IEdge,yWorks.Geometry.IPoint[]},yWorks.Graph.IMapper{yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter},yWorks.Graph.IMapper{yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter},System.TimeSpan)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Controls.IAnimation" /> that animates the given layout of all types of graph items.</para>
      </summary>
      <param name="graph">
        <para>The graph for which the layout should be animated.</para>
      </param>
      <param name="targetNodeLayouts">
        <para>The node layouts after the animation.</para>
      </param>
      <param name="targetBendLocations">
        <para>The bend locations after the animation, for each edge the points are interpreted as the position of the bends along the edge in the given order.</para>
      </param>
      <param name="targetLayoutParameters">
        <para>The label model parameters for each label after the animation.</para>
      </param>
      <param name="targetPortLocations">
        <para>The <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" />s for each <see cref="T:yWorks.Graph.IPort" /> in the graph that will be morphed.</para>
      </param>
      <param name="preferredDuration">
        <para>The preferred duration of the animation in milliseconds.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Animations.CreateNodeAnimation(yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.IRectangle,System.TimeSpan)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Controls.IAnimation" /> that animates the given <paramref name="node" /> from its current layout to the new given <paramref name="targetLayout" />.</para>
      </summary>
      <param name="graph">
        <para>The graph the animated node belongs to.</para>
      </param>
      <param name="node">
        <para>The node whose <see cref="P:yWorks.Graph.INode.Layout" /> to animate.</para>
      </param>
      <param name="targetLayout">
        <para>The expected node layout after the animation.</para>
      </param>
      <param name="preferredDuration">
        <para>The preferred duration of the animation.</para>
      </param>
      <returns>
        <para>A new instance of <see cref="T:yWorks.Controls.IAnimation" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Animations.CreatePortAnimation(yWorks.Graph.IGraph,yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,System.TimeSpan)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Controls.IAnimation" /> that animates the given <paramref name="port" /> from its current location to the new location given by the <paramref name="targetLocationParameter" />.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains the port.</para>
      </param>
      <param name="port">
        <para>The port to animate.</para>
      </param>
      <param name="targetLocationParameter">
        <para>The parameter to linearly interpolate to.</para>
      </param>
      <param name="preferredDuration">
        <para>The <see cref="P:yWorks.Controls.GraphAnimation.PreferredDuration">preferred duration</see> of this animation.</para>
      </param>
      <remarks>
        <para>This animation will as a side effect assign the <paramref name="targetLocationParameter" /> to the port at the <see cref="M:yWorks.Controls.IAnimation.Cleanup">end of the animation</see>.</para>
      </remarks>
      <returns>
        <para>A new instance of <see cref="T:yWorks.Controls.IAnimation" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Animations.CreateLabelAnimation(yWorks.Graph.IGraph,yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter,System.TimeSpan)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Controls.IAnimation" /> that animates the given <paramref name="label" /> from its current layout linearly to the layout given by the <paramref name="targetLayoutParameter" />.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains the labels.</para>
      </param>
      <param name="label">
        <para>The label to animate the parameter of.</para>
      </param>
      <param name="targetLayoutParameter">
        <para>The target parameter of the label.</para>
      </param>
      <param name="preferredDuration">
        <para>The preferred duration of the animation.</para>
      </param>
      <remarks>
        <para>This animation will as a side effect assign the <paramref name="targetLayoutParameter" /> to the label at the <see cref="M:yWorks.Controls.IAnimation.Cleanup">end of the animation</see>.</para>
      </remarks>
      <returns>
        <para>A new instance of <see cref="T:yWorks.Controls.IAnimation" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Animations.CreateEdgeSegmentAnimation(yWorks.Graph.IGraph,yWorks.Graph.IEdge,yWorks.Geometry.IPoint[],yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.TimeSpan)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Controls.IAnimation" /> that animates the given <paramref name="edge" />'s bends from its current shape linearly to the shape given by the <paramref name="endBends" /> and final port locations.</para>
      </summary>
      <remarks>
        <para>The bends of the edge layout are animated from their current location to their target locations. It is assumed that the edge style is a polyline style and the control points are the bends accordingly. The animation works for other styles too, but the effect might not be as expected. The number of bends in <paramref name="endBends" /> can be different to the current number of bends. This will result in the animation automatically removing bends at the end of the animation or inserting new bends accordingly at the beginning of the animation.</para>
        <para>The source and target points are also animated to new locations. However, the ports will not be moved by this animation. Instead a separate <see cref="M:yWorks.Controls.Animations.CreatePortAnimation(yWorks.Graph.IGraph,yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,System.TimeSpan)">animation for the ports</see> is needed to actually move <see cref="T:yWorks.Graph.IPort" />s at the ends of the edge if desired.</para>
      </remarks>
      <param name="graph">
        <para>The graph the animated edge belongs to.</para>
      </param>
      <param name="edge">
        <para>The edge layout to animate.</para>
      </param>
      <param name="endBends">
        <para>The bend positions after the animation.</para>
      </param>
      <param name="endSourceLocation">
        <para>The absolute position of the source port after the animation.</para>
      </param>
      <param name="endTargetLocation">
        <para>The absolute position of the target port after the animation.</para>
      </param>
      <param name="preferredDuration">
        <para>The preferred duration of the animation in milliseconds.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Animations.CreateTableAnimation(yWorks.Graph.ITable,System.Double[],System.Double[])">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Controls.IAnimation" /> for the given table that animates the table and its <see cref="T:yWorks.Graph.IStripe">stripes</see>.</para>
      </summary>
      <remarks>
        <para>Note that only the sizes of <b>leaf stripes</b>, i.e. those without child stripes, are considered. The sizes of a stripe with children is implicitly determined by its contents.</para>
        <para>For more control of the animation, implement a custom <see cref="T:yWorks.Controls.TableAnimation" /> and override method <see cref="M:yWorks.Controls.TableAnimation.CreateStripeAnimation(yWorks.Graph.IStripe,System.Double)" />.</para>
      </remarks>
      <param name="table">
        <para>The table to animate.</para>
      </param>
      <param name="columnLayout">
        <para>The sizes of the <b>leaf</b> columns, in natural order.</para>
      </param>
      <param name="rowLayout">
        <para>The sizes of the <b>leaf</b> rows, in natural order.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.ViewportAnimation">
      <summary>
        <para>Animates changing the viewport bounds and the zoom factor for a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ViewportAnimation.#ctor(yWorks.Controls.CanvasControl,yWorks.Geometry.RectD,System.TimeSpan)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Controls.ViewportAnimation" />.</para>
      </summary>
      <param name="canvas">
        <para>The canvas control.</para>
      </param>
      <param name="targetBounds">
        <para>The target world bounds for the animation.</para>
      </param>
      <param name="preferredDuration">
        <para>The preferred duration.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.ViewportAnimation.TargetBounds">
      <summary>
        <para>Gets or sets the target world bounds.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ViewportAnimation.ConsiderViewportLimiter">
      <summary>
        <para>Gets or sets whether to respect the <see cref="P:yWorks.Controls.CanvasControl.ViewportLimiter" /> of the <see cref="T:yWorks.Controls.CanvasControl" /> whose <see cref="P:yWorks.Controls.CanvasControl.Viewport" /> is animated.</para>
      </summary>
      <remarks>
        <para>Default is <c>false</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the <see cref="P:yWorks.Controls.CanvasControl.ViewportLimiter" /> should be considered, otherwise <c>false</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.ViewportAnimation.PreferredDuration">
      <summary>
        <para>Gets or sets the preferred duration of the animation.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ViewportAnimation.MaximumTargetZoom">
      <summary>
        <para>Gets or sets the maximum zoom level to use after the animation.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:System.Double.PositiveInfinity" />.</para>
      </remarks>
      <value>
        <para>The maximum target zoom.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.ViewportAnimation.Initialize">
      <summary>
        <para>Initializes this animation.</para>
      </summary>
      <remarks>
        <para>This has to be called once before any calls to <see cref="M:yWorks.Controls.ViewportAnimation.Animate(System.Double)" />. An instance of <see cref="T:yWorks.Controls.ViewportAnimation" /> can be reused after an animation by setting new <see cref="P:yWorks.Controls.ViewportAnimation.TargetBounds" /> or a new <see cref="P:yWorks.Controls.ViewportAnimation.PreferredDuration" /> and calling Initialize() again.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ViewportAnimation.ScrollBarVisibility">
      <summary>
        <para>Gets or sets the scroll bar visibility that will be used during the animation.</para>
      </summary>
      <value>
        <para>The scroll bar visibility to use during animation. The default is <c>hidden</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.ViewportAnimation.TargetViewMargins">
      <summary>
        <para>Gets or sets the margins in view coordinate dimensions to use at the target zoom level.</para>
      </summary>
      <value>
        <para>The target view margins. The default is <c>(0,0,0,0)</c></para>
      </value>
    </member>
    <member name="M:yWorks.Controls.ViewportAnimation.Animate(System.Double)">
      <param name="time" />
    </member>
    <member name="M:yWorks.Controls.ViewportAnimation.ApplyViewPoint(yWorks.Geometry.PointD)">
      <summary>
        <para>Effectively applies the view point value.</para>
      </summary>
      <param name="focus" />
    </member>
    <member name="M:yWorks.Controls.ViewportAnimation.ApplyCenterPoint(yWorks.Geometry.PointD)">
      <summary>
        <para>Effectively applies the center point value.</para>
      </summary>
      <param name="focus" />
    </member>
    <member name="M:yWorks.Controls.ViewportAnimation.ApplyZoom(System.Double)">
      <summary>
        <para>Effectively applies the zoom value.</para>
      </summary>
      <param name="value" />
    </member>
    <member name="M:yWorks.Controls.ViewportAnimation.Cancel">
      <summary>
        <para>Cancels this viewport animation so that subsequent calls to <see cref="M:yWorks.Controls.ViewportAnimation.Animate(System.Double)" /> or <see cref="M:yWorks.Controls.ViewportAnimation.Cleanup" /> won't affect the viewport anymore.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ViewportAnimation.Cleanup">
      <summary>
        <para>Cleans up after the animation.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.ScrollBarVisibility">
      <summary>
        <para>Enumeration used by the <see cref="P:yWorks.Controls.CanvasControl.HorizontalScrollBarPolicy" /> and <see cref="P:yWorks.Controls.CanvasControl.VerticalScrollBarPolicy" /> properties.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.ScrollBarVisibility.Never">
      <summary>
        <para>No mouse button.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.ScrollBarVisibility.AsNeeded">
      <summary>
        <para>The left mouse button.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.ScrollBarVisibility.Always">
      <summary>
        <para>Always display the scroll bar. If it is not needed, i.e. if all content is already displaying, the scroll bar will remain visible but cannot be moved.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.MouseWheelBehaviors">
      <summary>
        <para>
          <see cref="T:System.FlagsAttribute">Flaggable</see> enumeration for the mouse wheel behavior options.</para>
      </summary>
      <remarks>
        <para>If <see cref="F:yWorks.Controls.MouseWheelBehaviors.Zoom" /> and <see cref="F:yWorks.Controls.MouseWheelBehaviors.Scroll" /> are both set, scrolling will be the default behavior. The control will zoom with the Control key is pressed. <see cref="F:yWorks.Controls.MouseWheelBehaviors.Zoom" /> and <see cref="F:yWorks.Controls.MouseWheelBehaviors.Scroll" /> can be combined with <see cref="F:yWorks.Controls.MouseWheelBehaviors.OnlyWhenFocused" /> to activate this behavior only when the control has focus.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.MouseWheelBehaviors.None">
      <summary>
        <para>The mouse wheel has no effect.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.MouseWheelBehaviors.Zoom">
      <summary>
        <para>The mouse wheel changes the zoom factor.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.MouseWheelBehaviors.Scroll">
      <summary>
        <para>The mouse wheel scrolls the view.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.MouseWheelBehaviors.OnlyWhenFocused">
      <summary>
        <para>Can be combined with <see cref="F:yWorks.Controls.MouseWheelBehaviors.Zoom" /> or <see cref="F:yWorks.Controls.MouseWheelBehaviors.Scroll" /> to perform the action only when the control has focus.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.PrepareRenderContextEventArgs">
      <summary>
        <para>The event arguments for the <see cref="T:System.EventHandler" /> used by <see cref="E:yWorks.Controls.CanvasControl.PrepareRenderContext" />.</para>
      </summary>
      <remarks>
        <para>This event argument can be used to modify the <see cref="P:yWorks.Controls.PrepareRenderContextEventArgs.Context" /> during <see cref="M:yWorks.Controls.CanvasControl.RenderContent(yWorks.Controls.IRenderContext,System.Drawing.Graphics)" /> call.</para>
      </remarks>
      <seealso cref="E:yWorks.Controls.CanvasControl.PrepareRenderContext" />
    </member>
    <member name="M:yWorks.Controls.PrepareRenderContextEventArgs.#ctor(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.PrepareRenderContextEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The initial context which can be modified by the event handlers using the <see cref="P:yWorks.Controls.PrepareRenderContextEventArgs.Context" /> property.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.PrepareRenderContextEventArgs.Context">
      <summary>
        <para>Gets or sets the context.</para>
      </summary>
      <value>
        <para>The context that can be modified, wrapped, or exchanged by the event handlers. This value may not be <c>null</c>.</para>
      </value>
      <exception cref="T:System.ArgumentNullException">
        <para>If the argument is <c>null</c>.</para>
      </exception>
    </member>
    <member name="T:yWorks.Controls.CanvasControl">
      <summary>
        <para>The <see cref="T:yWorks.Controls.CanvasControl" /> is a custom Windows Forms control that can be used to efficiently display all kinds of data.</para>
      </summary>
      <remarks>
        <para>The control supports high performance zooming and panning of visual content. The control uses double precision world-coordinates to render items that are composed using a scene-graph. In its most simple form the scene graph is a tree-like structure of elements that will be rendered in depth-first-search order.</para>
        <para>The scene graph tree is made up of <see cref="T:yWorks.Controls.ICanvasObject" /> elements. Multiple elements are grouped in <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> elements. An <see cref="T:yWorks.Controls.ICanvasObject" /> consists of a <see cref="P:yWorks.Controls.ICanvasObject.UserObject">user object</see> and an <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> that is used by the rendering engine to query interfaces that perform the actual painting, hit testing, and bounds calculation.</para>
        <para>This control handles the following commands by default:</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.IncreaseZoom" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.DecreaseZoom" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.Zoom" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageDown" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageUp" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageLeft" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageRight" />
          </item>
        </list>
        <para>The handlers for <see cref="F:yWorks.Controls.Input.Commands.IncreaseZoom" /> and <see cref="F:yWorks.Controls.Input.Commands.DecreaseZoom" /> use the specified <see cref="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter">command parameter</see> as the factor by which the <see cref="P:yWorks.Controls.CanvasControl.Zoom" /> value is multiplied or divided, respectively. The parameter is not required. If it is not present a default value is used. The handler for the <see cref="F:yWorks.Controls.Input.Commands.Zoom" /> command needs a parameter. The parameter can either be a number which is interpreted as the new zoom level, or it can be a suitable object. Supported objects are <see cref="T:yWorks.Geometry.RectD" />, <see cref="T:System.Drawing.Rectangle" />, <see cref="T:yWorks.Geometry.PointD" />, <see cref="T:System.Drawing.Point" /> and <see cref="T:yWorks.Graph.ILookup" />. If a rectangle is specified as the parameter for the <see cref="F:yWorks.Controls.Input.Commands.Zoom" /> command, the handler adjusts the <see cref="P:yWorks.Controls.CanvasControl.Viewport" /> such that the rectangle tightly fits into it. If a point is specified, the handler sets the <see cref="P:yWorks.Controls.CanvasControl.Center" /> to that point. If the parameter implements <see cref="T:yWorks.Graph.ILookup" />, then the handler tries to get a <see cref="T:yWorks.Controls.IBoundsProvider" /> from the lookup and uses the bounds obtained from the bounds provider as the rectangle to zoom to.</para>
        <para>Also, <see cref="F:yWorks.Controls.Input.Commands.Print" /> and <see cref="F:yWorks.Controls.Input.Commands.PrintPreview" /> are supported out of the box.</para>
        <para>This control offers convenience methods to <see cref="M:yWorks.Controls.CanvasControl.Print" /> the contents and <see cref="M:yWorks.Controls.CanvasControl.ExportToEmf(System.IO.Stream,yWorks.Geometry.RectD)">export them to EMF</see> files.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.IVisualCreator" />
      <seealso cref="T:yWorks.Controls.Input.IHitTestable" />
      <seealso cref="T:yWorks.Controls.IVisibilityTestable" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.ViewportLimiter">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.CanvasControl.ViewportLimiter" /> instance that can be used to limit the explorable region.</para>
      </summary>
      <remarks>
        <para>By default there are no limits set on the explorable region.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.PixelOffsetMode">
      <summary>
        <para>Gets or sets the PixelOffsetMode that is used during rendering. Upon change the <see cref="M:yWorks.Controls.CanvasControl.OnPixelOffsetModeChanged(System.Drawing.Drawing2D.PixelOffsetMode,System.Drawing.Drawing2D.PixelOffsetMode)" /> method will be called.</para>
      </summary>
      <remarks>
        <para>A value of <see cref="F:System.Drawing.Drawing2D.PixelOffsetMode.Invalid" /> is interpreted as: leave the default value as supplied by the Graphics object.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.TextRenderingHint" />
      <seealso cref="P:yWorks.Controls.CanvasControl.SmoothingMode" />
      <seealso cref="P:yWorks.Controls.CanvasControl.InterpolationMode" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.PixelOffsetModeChanged">
      <summary>
        <para>This event is raised if the <see cref="P:yWorks.Controls.CanvasControl.PixelOffsetMode" /> property has changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.AnimateScrollTo(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Scrolls to the provided view point and zoom level in an animated fashion.</para>
      </summary>
      <param name="viewPoint">
        <para>The new <see cref="P:yWorks.Controls.CanvasControl.ViewPoint" /></para>
      </param>
      <param name="zoom">
        <para>The new zoom level.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnPixelOffsetModeChanged(System.Drawing.Drawing2D.PixelOffsetMode,System.Drawing.Drawing2D.PixelOffsetMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.CanvasControl.PixelOffsetMode" /> property value changes and after initialization of the field. Triggers the <see cref="E:yWorks.Controls.CanvasControl.PixelOffsetModeChanged" /> event.</para>
      </summary>
      <param name="oldPixelOffsetMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newPixelOffsetMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.TextRenderingHint">
      <summary>
        <para>Gets or sets the TextRenderingHint property. Upon change the <see cref="M:yWorks.Controls.CanvasControl.OnTextRenderingHintChanged(System.Drawing.Text.TextRenderingHint,System.Drawing.Text.TextRenderingHint)" /> method will be called.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.TextRenderingHintChanged">
      <summary>
        <para>Event that will be triggered if the <see cref="P:yWorks.Controls.CanvasControl.TextRenderingHint" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnTextRenderingHintChanged(System.Drawing.Text.TextRenderingHint,System.Drawing.Text.TextRenderingHint)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.CanvasControl.TextRenderingHint" /> property value changes and after initialization of the field. Triggers the <see cref="E:yWorks.Controls.CanvasControl.TextRenderingHintChanged" /> event.</para>
      </summary>
      <param name="oldTextRenderingHint">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newTextRenderingHint">
        <para>the new value</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.InterpolationMode">
      <summary>
        <para>Gets the computed suggested visibility of a horizontal scrollbar.</para>
      </summary>
      <remarks>
        <para>A value of <see cref="F:System.Drawing.Drawing2D.InterpolationMode.Invalid" /> is interpreted as: leave the default value as supplied by the Graphics object. Upon change the <see cref="M:yWorks.Controls.CanvasControl.OnInterpolationModeChanged(System.Drawing.Drawing2D.InterpolationMode,System.Drawing.Drawing2D.InterpolationMode)" /> method will be called.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.TextRenderingHint" />
      <seealso cref="P:yWorks.Controls.CanvasControl.SmoothingMode" />
      <seealso cref="P:yWorks.Controls.CanvasControl.PixelOffsetMode" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.InterpolationModeChanged">
      <summary>
        <para>This event is raised when the <see cref="P:yWorks.Controls.CanvasControl.InterpolationMode" /> property value changes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnInterpolationModeChanged(System.Drawing.Drawing2D.InterpolationMode,System.Drawing.Drawing2D.InterpolationMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.CanvasControl.InterpolationMode" /> property value changes and after initialization of the field. Triggers the <see cref="E:yWorks.Controls.CanvasControl.InterpolationModeChanged" /> event.</para>
      </summary>
      <param name="oldInterpolationMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newInterpolationMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.SmoothingMode">
      <summary>
        <para>Specifies the <see cref="P:yWorks.Controls.CanvasControl.SmoothingMode" /> to use for the rendering.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="F:System.Drawing.Drawing2D.SmoothingMode.AntiAlias" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.TextRenderingHint" />
      <seealso cref="P:yWorks.Controls.CanvasControl.PixelOffsetMode" />
      <seealso cref="P:yWorks.Controls.CanvasControl.InterpolationMode" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnSmoothingModeChanged(System.ComponentModel.PropertyChangedEventArgs)">
      <summary>
        <para>Callback when the <see cref="P:yWorks.Controls.CanvasControl.SmoothingMode" /> property changes.</para>
      </summary>
      <param name="e">
        <para>the property change event argument</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.SmoothingModeChanged">
      <summary>
        <para>A property change event that gets fired when the <see cref="P:yWorks.Controls.CanvasControl.SmoothingMode" /> property has been changed.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.MouseWheelBehavior">
      <summary>
        <para>Gets or sets the behavior of the mouse wheel.</para>
      </summary>
      <remarks>
        <para>The behavior can be switched between <see cref="F:yWorks.Controls.MouseWheelBehaviors.Zoom" />, <see cref="F:yWorks.Controls.MouseWheelBehaviors.Scroll" /> and <see cref="F:yWorks.Controls.MouseWheelBehaviors.None" />. Additionally, this property can be configured to perform the action <see cref="F:yWorks.Controls.MouseWheelBehaviors.OnlyWhenFocused">only when the control is focused</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.CenterZoomEventRecognizer">
      <summary>
        <para>Gets or sets an <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that determines whether the zooming to the center of the view, rather than at the mouse location should be used.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlPressed" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.VerticalScrollBarPolicy">
      <summary>
        <para>Gets or sets the visibility policy for the vertical scrollbar.</para>
      </summary>
      <remarks>
        <para>Scrollbars don't need to be displayed in order to move the viewport. This can be achieved programmatically or using special IInputMode instances. The default is <see cref="F:yWorks.Controls.ScrollBarVisibility.AsNeeded" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.MoveViewportInputMode" />
      <seealso cref="P:yWorks.Controls.CanvasControl.HorizontalScrollBarPolicy" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.HorizontalScrollBarPolicy">
      <summary>
        <para>Gets or sets the visibility policy for the vertical scrollbar.</para>
      </summary>
      <remarks>
        <para>Scrollbars don't need to be displayed in order to move the viewport. This can be achieved programmatically or using special IInputMode instances. The default is <see cref="F:yWorks.Controls.ScrollBarVisibility.AsNeeded" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.MoveViewportInputMode" />
      <seealso cref="P:yWorks.Controls.CanvasControl.VerticalScrollBarPolicy" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.AnimateScrollCommands">
      <summary>
        <para>Gets or sets a value indicating whether <see cref="T:yWorks.Controls.ICommand" />s for scrolling like for example <see cref="F:yWorks.Controls.Input.Commands.ScrollPageDown" />, the scrolling should be performed in animated fashion.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if scrolling should be animated; <c>false</c> otherwise. The default is <c>true</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.ContentRect">
      <summary>
        <para>Gets and sets the Rectangle in world coordinates that holds the contents.</para>
      </summary>
      <remarks>
        <para>This influences the display of the scroll bars. If the content rectangle is not currently visible in the viewport, scroll bars will be displayed, unless they are turned off completely. Note that in general the content rectangle is not updated automatically but declared as a fixed rectangle. Rather the application programmer needs to set this value or call respective automatic update methods.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnContentRectChanged(System.EventArgs)">
      <summary>
        <para>Callback when the <see cref="P:yWorks.Controls.CanvasControl.ContentRect" /> property changes.</para>
      </summary>
      <param name="eventArgs" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.ContentRectChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.ContentRect">content rectangle</see> has been changed.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.FitContentViewMargins">
      <summary>
        <para>Gets and sets the insets in view coordinates that should be used by the <see cref="M:yWorks.Controls.CanvasControl.FitContent" /> operation.</para>
      </summary>
      <remarks>
        <para>This influences the amount of visible whitespace in the view coordinate system around the <see cref="P:yWorks.Controls.CanvasControl.ContentRect" /> after a <see cref="M:yWorks.Controls.CanvasControl.FitContent" /> operation. The default value is <c>(10,10,10,10)</c>.</para>
        <para>Note limits that are enforced by the <see cref="P:yWorks.Controls.CanvasControl.ViewportLimiter" /> have a higher priority than these insets.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.Mouse2DExited">
      <summary>
        <para>Occurs when the mouse has exited the canvas.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> in world coordinates using double precision floating points.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.Mouse2DEntered">
      <summary>
        <para>Occurs when the mouse has entered the canvas.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> in world coordinates using double precision floating points.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.Mouse2DMoved">
      <summary>
        <para>Occurs when the mouse has been moved in world coordinates.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> in world coordinates using double precision floating points.</para>
        <para>Move elements are delivered if no mouse button is pressed. This event will be fired, too, if the mouse does not move but the world coordinates to which the current mouse position maps change. E.g. this will happen if the zoom level or the view point is changed.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.Mouse2DPressed">
      <summary>
        <para>Occurs when a mouse button has been pressed.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> in world coordinates using double precision floating points.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.Mouse2DDragged">
      <summary>
        <para>Occurs when the mouse is being moved while at least one of the mouse buttons is pressed.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> in world coordinates using double precision floating points.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.Mouse2DReleased">
      <summary>
        <para>Occurs when the mouse button has been released.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> in world coordinates using double precision floating points.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.Mouse2DLostCapture">
      <summary>
        <para>Occurs when the mouse capture has been lost.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> in world coordinates using double precision floating points.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.Mouse2DWheelTurned">
      <summary>
        <para>Occurs when the mouse wheel has turned.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> in world coordinates using double precision floating points.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.Mouse2DClicked">
      <summary>
        <para>Occurs when the user clicked the mouse.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> in world coordinates using double precision floating points.</para>
        <para>This happens if press and release happens at the same position.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.CompoundKeyPressed">
      <summary>
        <para>Occurs when keys are being pressed.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.CompoundKeyEventArgs" />.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.CompoundKeyTyped">
      <summary>
        <para>Occurs when keys are being typed.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.CompoundKeyEventArgs" />.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.CompoundKeyReleased">
      <summary>
        <para>Occurs when keys are being released.</para>
      </summary>
      <remarks>
        <para>This event delivers <see cref="T:yWorks.Controls.CompoundKeyEventArgs" />.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.ViewportChanged">
      <summary>
        <para>A property change event that gets fired when the <see cref="P:yWorks.Controls.CanvasControl.Viewport" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnCompoundKeyReleased(yWorks.Controls.CompoundKeyEventArgs)">
      <summary>
        <para>Callback method that will be invoked if a key has been released.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.CompoundKeyReleased" /> event. Subclasses overriding this method should make sure to invoke the super class implementation.</para>
      </remarks>
      <param name="e">
        <para>the event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnCompoundKeyTyped(yWorks.Controls.CompoundKeyEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnCompoundKeyPressed(yWorks.Controls.CompoundKeyEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.CompoundKeyReleased" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnCompoundKeyTyped(yWorks.Controls.CompoundKeyEventArgs)">
      <summary>
        <para>Callback method that will be invoked if a key has been typed.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.CompoundKeyTyped" /> event. Subclasses overriding this method should make sure to invoke the super class implementation.</para>
      </remarks>
      <param name="e">
        <para>the event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnCompoundKeyReleased(yWorks.Controls.CompoundKeyEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnCompoundKeyPressed(yWorks.Controls.CompoundKeyEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.CompoundKeyTyped" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnCompoundKeyPressed(yWorks.Controls.CompoundKeyEventArgs)">
      <summary>
        <para>Callback method that will be invoked if a key has been pressed.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.CompoundKeyPressed" /> event. Subclasses overriding this method should make sure to invoke the super class implementation.</para>
      </remarks>
      <param name="e">
        <para>the event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnCompoundKeyReleased(yWorks.Controls.CompoundKeyEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnCompoundKeyTyped(yWorks.Controls.CompoundKeyEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.CompoundKeyPressed" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>Callback method that is called when a mouse button has been released.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.Mouse2DReleased" /> event. Subclasses overriding this method should make sure to invoke the super class implementation. <see cref="T:yWorks.Controls.Mouse2DEventArgs">Mouse 2D Events</see> use the world coordinate system rather than the view-coordinate system of the control itself.</para>
      </remarks>
      <param name="e">
        <para>the mouse event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.Mouse2DReleased" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouse2DLostCapture(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>Callback method that is called when the mouse capture is lost.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.Mouse2DLostCapture" /> event. Subclasses overriding this method should make sure to invoke the super class implementation. <see cref="T:yWorks.Controls.Mouse2DEventArgs">Mouse 2D Events</see> use the world coordinate system rather than the view-coordinate system of the control itself.</para>
      </remarks>
      <param name="e">
        <para>the mouse event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.Mouse2DReleased" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>Callback method that is called when the mouse wheel has been turned.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.Mouse2DWheelTurned" /> event. Subclasses overriding this method should make sure to invoke the super class implementation. This method will call the <see cref="M:yWorks.Controls.CanvasControl.MouseWheelZoom(yWorks.Controls.Mouse2DEventArgs)" /> or <see cref="M:yWorks.Controls.CanvasControl.MouseWheelScroll(yWorks.Controls.Mouse2DEventArgs)" /> methods, if the corresponding <see cref="P:yWorks.Controls.CanvasControl.MouseWheelBehavior">behavior</see> is enabled. <see cref="T:yWorks.Controls.Mouse2DEventArgs">Mouse 2D Events</see> use the world coordinate system rather than the view-coordinate system of the control itself. In order to customize the mouse wheel behavior, set the <see cref="P:yWorks.Controls.CanvasControl.MouseWheelBehavior">behavior</see> to <see cref="F:yWorks.Controls.MouseWheelBehaviors.None">None</see>. Register to the <see cref="E:yWorks.Controls.CanvasControl.Mouse2DWheelTurned" /> event and execute the custom action.</para>
      </remarks>
      <param name="e">
        <para>the mouse event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.Mouse2DWheelTurned" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.MouseWheelZoom(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>This method will be called by the <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" /> method, if the <see cref="P:yWorks.Controls.CanvasControl.MouseWheelBehavior" /> property is set to <see cref="F:yWorks.Controls.MouseWheelBehaviors.Zoom" />.</para>
      </summary>
      <remarks>
        <para>This method will adjust the current zoom level. If the Control key modifier has been pressed this method will keep the world coordinates at the current mouse position, i.e. the zoom will not necessarily be into the center of the canvas.</para>
      </remarks>
      <param name="e">
        <para>the event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="P:yWorks.Controls.CanvasControl.MouseWheelBehavior" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.MouseWheelScroll(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>This method will be called by the <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" /> method, if the <see cref="P:yWorks.Controls.CanvasControl.MouseWheelBehavior" /> property is set to <see cref="F:yWorks.Controls.MouseWheelBehaviors.Scroll" />.</para>
      </summary>
      <remarks>
        <para>This method will scroll the view in vertical direction. If the Shift key modifier has been pressed this method will scroll in horizontal direction.</para>
      </remarks>
      <param name="e">
        <para>the event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="P:yWorks.Controls.CanvasControl.MouseWheelBehavior" />
      <seealso cref="P:yWorks.Controls.CanvasControl.MouseWheelScrollFactor" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>Callback method that is called when a mouse button has been pressed.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.Mouse2DPressed" /> event. Subclasses overriding this method should make sure to invoke the super class implementation. <see cref="T:yWorks.Controls.Mouse2DEventArgs">Mouse 2D Events</see> use the world coordinate system rather than the view-coordinate system of the control itself.</para>
      </remarks>
      <param name="e">
        <para>the mouse event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.Mouse2DPressed" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>Callback method that is called when the mouse has been moved and no button has been pressed.</para>
      </summary>
      <remarks>
        <para>If a button has been pressed the <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" /> method would have been called. This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.Mouse2DMoved" /> event. Subclasses overriding this method should make sure to invoke the super class implementation. <see cref="T:yWorks.Controls.Mouse2DEventArgs">Mouse 2D Events</see> use the world coordinate system rather than the view-coordinate system of the control itself.</para>
      </remarks>
      <param name="e">
        <para>the mouse event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.Mouse2DMoved" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>Callback method that is called when the mouse enters the control.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.Mouse2DEntered" /> event. Subclasses overriding this method should make sure to invoke the super class implementation. <see cref="T:yWorks.Controls.Mouse2DEventArgs">Mouse 2D Events</see> use the world coordinate system rather than the view-coordinate system of the control itself.</para>
      </remarks>
      <param name="e">
        <para>the mouse event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.Mouse2DEntered" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>Callback method that is called when the mouse exits the control.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.Mouse2DExited" /> event. Subclasses overriding this method should make sure to invoke the super class implementation. <see cref="T:yWorks.Controls.Mouse2DEventArgs">Mouse 2D Events</see> use the world coordinate system rather than the view-coordinate system of the control itself.</para>
      </remarks>
      <param name="e">
        <para>the mouse event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.Mouse2DExited" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>Callback method that is called when the mouse gets dragged.</para>
      </summary>
      <remarks>
        <para>Moving the mouse while at least one button is pressed is considered dragging. This method will trigger the <see cref="E:yWorks.Controls.CanvasControl.Mouse2DDragged" /> event. Subclasses overriding this method should make sure to invoke the super class implementation. <see cref="T:yWorks.Controls.Mouse2DEventArgs">Mouse 2D Events</see> use the world coordinate system rather than the view-coordinate system of the control itself.</para>
      </remarks>
      <param name="e">
        <para>the mouse event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.Mouse2DDragged" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)">
      <summary>
        <para>Callback method that is called when the mouse has been clicked.</para>
      </summary>
      <remarks>
        <para>This callback will be called after the <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)" /> method has been invoked and only if the mouse has not been moved by a great amount since the last <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" /> event. This method will raise the <see cref="E:yWorks.Controls.CanvasControl.Mouse2DClicked" /> event. Subclasses overriding this method should make sure to invoke the super class implementation. <see cref="T:yWorks.Controls.Mouse2DEventArgs">Mouse 2D Events</see> use the world coordinate system rather than the view-coordinate system of the control itself.</para>
      </remarks>
      <param name="e">
        <para>the mouse event describing the action</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.Mouse2DClicked" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.LastMouse2DEvent">
      <summary>
        <para>Gets the last <see cref="T:yWorks.Controls.Mouse2DEventArgs">mouse event</see> triggered by this instance.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.LastEventLocation">
      <summary>
        <para>Gets the last location provided by a pointing device (for instance mouse or touch).</para>
      </summary>
      <remarks>
        <para>Unlike <see cref="P:yWorks.Controls.CanvasControl.LastMouse2DEvent" /> this will always contain the latest location, regardless of what input method generated it.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.LastMouse2DEvent" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.InputModeChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.InputMode" /> property is changed.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.CanvasControl.InputMode" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.InputMode">
      <summary>
        <para>Gets or sets the single <see cref="T:yWorks.Controls.Input.IInputMode" /> instance that shall be installed for this canvas.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnInputModeChanged(yWorks.Controls.Input.IInputMode,yWorks.Controls.Input.IInputMode)">
      <summary>
        <para>Callback that is invoked when the <see cref="P:yWorks.Controls.CanvasControl.InputMode" /> property changes. This will raise the <see cref="E:yWorks.Controls.CanvasControl.InputModeChanged" /> event.</para>
      </summary>
      <param name="oldInputMode">
        <para>The input mode before the change.</para>
      </param>
      <param name="newInputMode">
        <para>The new input mode.</para>
      </param>
      <seealso cref="P:yWorks.Controls.CanvasControl.InputMode" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.HitTestRadius">
      <summary>
        <para>Gets or sets the radius of the area around the mouse in view coordinates in which a <see cref="T:yWorks.Controls.Input.IHitTestable" /> may lie to be considered a valid hit.</para>
      </summary>
      <remarks>
        <para>This value can be queried from within the <see cref="T:yWorks.Controls.Input.IHitTestable" /> implementation from the <see cref="P:yWorks.Controls.ICanvasContext.HitTestRadius" /> property. The default value is <c>3.0d</c></para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.HitTestRadiusChanged">
      <summary>
        <para>Event that is raised when the <see cref="P:yWorks.Controls.CanvasControl.HitTestRadius" /> property changes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnHitTestRadiusChanged(System.EventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.CanvasControl.HitTestRadiusChanged" /> event when <see cref="P:yWorks.Controls.CanvasControl.HitTestRadius" /> has changed.</para>
      </summary>
      <param name="eventArgs" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.Zoom">
      <summary>
        <para>Gets or sets the zoom factor for this <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>A zoom level of <c>1.0f</c> will make each unit in world-coordinate space appear exactly one unit in screen coordinates wide. The default is <c>1.0f</c>. If this property is written, the canvas will zoom to the new value while keeping the center of view at the same world coordinates.</para>
        <para>The valid range is bounded by <see cref="P:yWorks.Controls.CanvasControl.MinimumZoom" /> and <see cref="P:yWorks.Controls.CanvasControl.MaximumZoom" /></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnZoomChanged(System.EventArgs)" />
      <seealso cref="E:yWorks.Controls.CanvasControl.ZoomChanged" />
      <seealso cref="P:yWorks.Controls.CanvasControl.MinimumZoom" />
      <seealso cref="P:yWorks.Controls.CanvasControl.MaximumZoom" />
      <seealso cref="P:yWorks.Controls.CanvasControl.Scale" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnZoomChanged(System.EventArgs)">
      <summary>
        <para>Callback that is invoked when the <see cref="P:yWorks.Controls.CanvasControl.Zoom" /> property changes. This method raises the <see cref="E:yWorks.Controls.CanvasControl.ZoomChanged" /> event.</para>
      </summary>
      <param name="eventArgs" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.ZoomChanged">
      <summary>
        <para>Occurs when the value of the <see cref="P:yWorks.Controls.CanvasControl.Zoom" /> property has been changed.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.MaximumZoom">
      <summary>
        <para>Gets or sets the maximum zoom factor for this canvas control.</para>
      </summary>
      <remarks>
        <para>This property sets an upper bound for the allowed values of the <see cref="P:yWorks.Controls.CanvasControl.Zoom" /> property. The default is <c>100000.0</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.Zoom" />
      <seealso cref="P:yWorks.Controls.CanvasControl.MaximumZoom" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.MinimumZoom">
      <summary>
        <para>Gets or sets the minimum zoom factor for this canvas control.</para>
      </summary>
      <remarks>
        <para>This property sets a lower bound for the allowed values of the <see cref="P:yWorks.Controls.CanvasControl.Zoom" /> property. The default is <c>0.0001</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.Zoom" />
      <seealso cref="P:yWorks.Controls.CanvasControl.MinimumZoom" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.ViewPoint">
      <summary>
        <para>Gets or sets the current view point.</para>
      </summary>
      <remarks>
        <para>The view point is the point in world coordinates that is mapped to the top left corner point in the current viewport. Setting this point to another value will redispatch the last mouse event as the mouse will appear to have been moved or dragged in the world coordinate system.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.InnerSize">
      <summary>
        <para>Gets the size of the usable area (in view coordinates) in which the graph will be displayed.</para>
      </summary>
      <remarks>
        <para>This value excludes the area occupied by the scroll bars.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnViewportChanged(System.ComponentModel.PropertyChangedEventArgs)">
      <summary>
        <para>Callback method that is triggered when the view port has changed.</para>
      </summary>
      <remarks>
        <para>The view port is the visible portion of the world rectangle in the world coordinate system. This method raised the <see cref="E:yWorks.Controls.CanvasControl.ViewportChanged" /> event.</para>
      </remarks>
      <param name="eventArgs">
        <para>The event argument.</para>
      </param>
      <seealso cref="P:yWorks.Controls.CanvasControl.Viewport" />
      <seealso cref="E:yWorks.Controls.CanvasControl.ViewportChanged" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.Viewport">
      <summary>
        <para>Gets the currently visible viewing region in world coordinates.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.CanvasControl.ViewPoint" />
      <seealso cref="P:yWorks.Controls.CanvasControl.Zoom" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>The canvas will be empty with no associated <see cref="P:yWorks.Controls.CanvasControl.InputMode" />s.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.PrintCommandsEnabled">
      <summary>
        <para>Gets or sets a value indicating whether printing related command bindings are enabled.</para>
      </summary>
      <remarks>
        <para>By default this feature is enabled.</para>
        <para>This property enables/disables the following commands:</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.Print">ApplicationCommands.Print</see>
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.PrintPreview">ApplicationCommands.PrintPreview</see>
          </item>
        </list>
        <para>Note that this doesn't affect the the convenience methods <see cref="M:yWorks.Controls.CanvasControl.Print" /> and <see cref="M:yWorks.Controls.CanvasControl.Print(yWorks.Geometry.RectD,System.Boolean,System.Boolean,System.Boolean)" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the commands are enabled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.CoerceViewportLimits">
      <summary>
        <para>Helper method that ensures that the view port limit as returned by the <see cref="P:yWorks.Controls.CanvasControl.ViewportLimiter" /> are obeyed.</para>
      </summary>
      <remarks>
        <para>This method will <see cref="M:yWorks.Controls.CanvasControl.ZoomTo(yWorks.Geometry.RectD)" /> the limited bounds if necessary.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.ViewportLimiter" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.InputModeContextLookupChain">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.LookupChain" /> that can be used do decorate the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> call in the <see cref="P:yWorks.Controls.CanvasControl.InputModeContext" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnVisibleChanged(System.EventArgs)">
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnResize(System.EventArgs)">
      <summary>
        <para>Raises the event.</para>
      </summary>
      <param name="e">
        <para>An <see cref="T:System.EventArgs"></see> that contains the event data.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.CanvasContext">
      <summary>
        <para>Gets an implementation of <see cref="T:yWorks.Controls.ICanvasContext" /> that describes the state of this <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.IHitTestable" />
      <seealso cref="T:yWorks.Controls.IBoundsProvider" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.Center">
      <summary>
        <para>Gets or sets the world coordinate at the center of the control.</para>
      </summary>
      <remarks>
        <para>This can be used to move the view port.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.AutoDrag">
      <summary>
        <para>Gets or sets a property that causes the control to automatically pan the view when the mouse gets dragged outside of the bounds of the control.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.AutoDragChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.AutoDrag" /> property is changed.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnAutoDragChanged(System.EventArgs)" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnAutoDragChanged(System.EventArgs)">
      <summary>
        <para>Called when <see cref="P:yWorks.Controls.CanvasControl.AutoDrag" /> property has changed.</para>
      </summary>
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.InvalidateWorld(yWorks.Geometry.RectD)">
      <summary>
        <para>Invalidates the control at the given world coordinates.</para>
      </summary>
      <param name="worldRect">
        <para>the region in the world coordinate system to invalidate</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnSizeChanged(System.EventArgs)">
      <summary>
        <para>Raises the <see cref="E:System.Windows.Forms.Control.SizeChanged" /> event.</para>
      </summary>
      <param name="e">
        <para>An <see cref="T:System.EventArgs"></see> that contains the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.Invalidate">
      <summary>
        <para>Invalidates the current control.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnPaint(System.Windows.Forms.PaintEventArgs)">
      <summary>
        <para>Implements the painting for the CanvasControl. This will ultimately call the <see cref="M:yWorks.Controls.CanvasControl.RenderContent(yWorks.Controls.IRenderContext,System.Drawing.Graphics)" /> method which performs the actual painting.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.PrepareRenderContext">
      <summary>
        <para>Occurs before the <see cref="M:yWorks.Controls.CanvasControl.RenderContent(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">visual tree is updated</see> to prepare the <see cref="T:yWorks.Controls.IRenderContext" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.GetCanvasObjects">
      <summary>
        <para>Enumerates over all possible <see cref="T:yWorks.Controls.ICanvasObject" /> instances in the tree.</para>
      </summary>
      <returns>
        <para>An enumerable for all <see cref="T:yWorks.Controls.ICanvasObject" />s in the tree.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.GetCanvasObjects(yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Enumerates over all possible <see cref="T:yWorks.Controls.ICanvasObject" /> instances in the tree below the given group.</para>
      </summary>
      <returns>
        <para>An enumerable for all <see cref="T:yWorks.Controls.ICanvasObject" />s in the tree below the given group.</para>
      </returns>
      <param name="group" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.HitElementsAt(yWorks.Geometry.PointD,yWorks.Controls.ICanvasObjectGroup,System.Predicate{yWorks.Controls.ICanvasObject})">
      <summary>
        <para>Enumerates all hit elements in the canvas below the given group that are accepted by a given filter.</para>
      </summary>
      <remarks>
        <para>Hit testing is performed using the <see cref="M:yWorks.Controls.ICanvasObjectDescriptor.GetHitTestable(System.Object)" /> instance returned for each visible <see cref="T:yWorks.Controls.ICanvasObject" /> in the current scene graph. The enumeration is performed lazily.</para>
      </remarks>
      <param name="location">
        <para>the coordinates to perform the hit test at</para>
      </param>
      <param name="root">
        <para>the root of the scene graph to use</para>
      </param>
      <param name="filter">
        <para>The predicate that decides whether a given canvas object should be considered for testing at all or <c>null</c>.</para>
      </param>
      <returns>
        <para>a live enumeration of the elements that are hit</para>
      </returns>
      <seealso cref="T:yWorks.Controls.Input.IHitTestable" />
      <seealso cref="P:yWorks.Controls.CanvasControl.HitTestRadius" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.HitElementsAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Controls.ICanvasObjectGroup,System.Predicate{yWorks.Controls.ICanvasObject})">
      <summary>
        <para>Enumerates all hit elements in the canvas below the given group that are accepted by a given filter using a specific <see cref="T:yWorks.Controls.ICanvasContext" /> as the argument to the <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> method.</para>
      </summary>
      <remarks>
        <para>Hit testing is performed using the <see cref="M:yWorks.Controls.ICanvasObjectDescriptor.GetHitTestable(System.Object)" /> instance returned for each visible <see cref="T:yWorks.Controls.ICanvasObject" /> in the current scene graph. The enumeration is performed lazily.</para>
      </remarks>
      <param name="context">
        <para>The context instance to pass to <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />.</para>
      </param>
      <param name="location">
        <para>the coordinates to perform the hit test at</para>
      </param>
      <param name="root">
        <para>the root of the scene graph to use</para>
      </param>
      <param name="filter">
        <para>The predicate that decides whether a given canvas object should be considered for testing at all or <c>null</c>.</para>
      </param>
      <returns>
        <para>a live enumeration of the elements that are hit</para>
      </returns>
      <seealso cref="T:yWorks.Controls.Input.IHitTestable" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.RootGroup">
      <summary>
        <para>Gets the root of the scene graph.</para>
      </summary>
      <remarks>
        <para>This group cannot be <see cref="M:yWorks.Controls.ICanvasObject.Remove">removed</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.ContentGroup">
      <summary>
        <para>Gets or sets the ContentGroup property.</para>
      </summary>
      <remarks>
        <para>The content group is the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> that should be used by the application code to put actual content in.</para>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.CanvasControl.CreateContentGroup" /> will be called. Upon change the <see cref="M:yWorks.Controls.CanvasControl.OnContentGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)" /> method will be called.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.ContentGroupChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.ContentGroup" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnContentGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.CanvasControl.ContentGroup" /> property value changes and after initialization of the field. Triggers the <see cref="E:yWorks.Controls.CanvasControl.ContentGroupChanged" /> event.</para>
      </summary>
      <param name="oldContentGroup">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newContentGroup">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.CreateContentGroup">
      <summary>
        <para>Factory method for the ContentGroup property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.CanvasControl.ContentGroup" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of ICanvasObjectGroup</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.HighlightGroup">
      <summary>
        <para>Gets or sets the HighlightGroup property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.CanvasControl.CreateHighlightGroup" /> will be called. Upon change the <see cref="M:yWorks.Controls.CanvasControl.OnHighlightGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)" /> method will be called.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.FocusGroup">
      <summary>
        <para>Gets or sets the HighlightGroup property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.CanvasControl.CreateHighlightGroup" /> will be called. Upon change the <see cref="M:yWorks.Controls.CanvasControl.OnHighlightGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)" /> method will be called.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.FocusGroupChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.FocusGroup" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnFocusGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.CanvasControl.FocusGroup" /> property value changes and after initialization of the field.</para>
      </summary>
      <remarks>
        <para>Triggers the <see cref="E:yWorks.Controls.CanvasControl.FocusGroupChanged" /> event.</para>
      </remarks>
      <param name="oldFocusGroup">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newFocusGroup">
        <para>the new value</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.HighlightGroupChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.HighlightGroup" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnHighlightGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.CanvasControl.HighlightGroup" /> property value changes and after initialization of the field.</para>
      </summary>
      <remarks>
        <para>Triggers the <see cref="E:yWorks.Controls.CanvasControl.HighlightGroupChanged" /> event.</para>
      </remarks>
      <param name="oldHighlightGroup">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newHighlightGroup">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.CreateHighlightGroup">
      <summary>
        <para>Factory method for the HighlightGroup property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.CanvasControl.HighlightGroup" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of ICanvasObjectGroup</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.CreateFocusGroup">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.CanvasControl.FocusGroup" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.CanvasControl.FocusGroup" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of ICanvasObjectGroup</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.SelectionGroup">
      <summary>
        <para>Gets or sets the SelectionGroup property.</para>
      </summary>
      <remarks>
        <para>The selection group is the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> that should be used by the application code to put the selection paintables in.</para>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.CanvasControl.CreateSelectionGroup" /> will be called. Upon change the <see cref="M:yWorks.Controls.CanvasControl.OnSelectionGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)" /> method will be called.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.SelectionGroupChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.SelectionGroup" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnSelectionGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.CanvasControl.SelectionGroup" /> property value changes and after initialization of the field. Triggers the <see cref="E:yWorks.Controls.CanvasControl.SelectionGroupChanged" /> event.</para>
      </summary>
      <param name="oldSelectionGroup">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newSelectionGroup">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.CreateSelectionGroup">
      <summary>
        <para>Factory method for the SelectionGroup property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.CanvasControl.SelectionGroup" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of ICanvasObjectGroup</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.InputModeGroup">
      <summary>
        <para>Gets or sets the InputModeGroup property.</para>
      </summary>
      <remarks>
        <para>This is the canvas object group where the <see cref="T:yWorks.Controls.Input.IInputMode" />s should add their temporary content to. This group by default is in front of the <see cref="P:yWorks.Controls.CanvasControl.ContentGroup" />.</para>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.CanvasControl.CreateInputModeGroup" /> will be called. Upon change the <see cref="M:yWorks.Controls.CanvasControl.OnInputModeGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)" /> method will be called.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.ContentGroup" />
      <seealso cref="P:yWorks.Controls.CanvasControl.BackgroundGroup" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.InputModeGroupChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.InputModeGroup" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnInputModeGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.CanvasControl.InputModeGroup" /> property value changes and after initialization of the field. Triggers the <see cref="E:yWorks.Controls.CanvasControl.InputModeGroupChanged" /> event.</para>
      </summary>
      <param name="oldInputModeGroup">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newInputModeGroup">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.CreateInputModeGroup">
      <summary>
        <para>Factory method for the InputModeGroup property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.CanvasControl.InputModeGroup" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of ICanvasObjectGroup</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.BackgroundGroup">
      <summary>
        <para>Gets or sets the BackgroundGroup property.</para>
      </summary>
      <remarks>
        <para>The background group is the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> that should be used by the application code to put background elements in.</para>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.CanvasControl.CreateBackgroundGroup" /> will be called. Upon change the <see cref="M:yWorks.Controls.CanvasControl.OnBackgroundGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)" /> method will be called.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.ContentGroup" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.BackgroundGroupChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.BackgroundGroup" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnBackgroundGroupChanged(yWorks.Controls.ICanvasObjectGroup,yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.CanvasControl.BackgroundGroup" /> property value changes and after initialization of the field. Triggers the <see cref="E:yWorks.Controls.CanvasControl.BackgroundGroupChanged" /> event.</para>
      </summary>
      <param name="oldBackgroundGroup">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newBackgroundGroup">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.CreateBackgroundGroup">
      <summary>
        <para>Factory method for the BackgroundGroup property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.CanvasControl.BackgroundGroup" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of ICanvasObjectGroup</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.DragTime">
      <summary>
        <para>Gets or sets the value of the drag time.</para>
      </summary>
      <remarks>
        <para>This value indicates the amount of time that may pass before a mouse movement is considered a drag when the mouse stays within its <see cref="P:yWorks.Controls.CanvasControl.DragSize" /> area. The higher the value the later a mouse movement will be recognized as a drag. This influences the click-sensitivity, since a mouse button release is only considered a click if there was no drag since the last mouse button press. The default value is 300 milliseconds.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.DragSize" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.DragSize">
      <summary>
        <para>Gets or sets the area in view coordinates the mouse may stay in before a movement is considered a drag.</para>
      </summary>
      <remarks>
        <para>If the mouse is moved within this area longer than <see cref="P:yWorks.Controls.CanvasControl.DragTime" /> milliseconds, the movement will be considered a drag, nevertheless. The larger the area the later a mouse movement will be recognized as a drag. This influences the click-sensitivity, since a mouse button release is only considered a click if there was no drag since the last mouse button press. By default, this property is retrieved from <see cref="P:System.Windows.Forms.SystemInformation.DragSize" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.DragSize" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.DoubleClickTime">
      <summary>
        <para>Gets or sets the value of the double click time.</para>
      </summary>
      <remarks>
        <para>This value indicates the amount of time that may pass within which two subsequent mouse clicks are considered multi clicks. The higher the value the easier it will be to double-click. By default, this property is retrieved from <see cref="P:System.Windows.Forms.SystemInformation.DoubleClickTime" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.DoubleClickSize" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.DoubleClickSize">
      <summary>
        <para>Gets or sets the area in view coordinates the mouse needs to stay in before multiple clicks are considered multiple single clicks instead of multi-clicks.</para>
      </summary>
      <remarks>
        <para>If the mouse stays within this within than <see cref="P:yWorks.Controls.CanvasControl.DoubleClickTime" />, multiple clicks will be considered double or multi-clicks. By default, this property is retrieved from <see cref="P:System.Windows.Forms.SystemInformation.DoubleClickSize" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.DoubleClickTime" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.MouseWheelZoomFactor">
      <summary>
        <para>Gets or sets the factor by which the zoom level changes when the mouse wheel is turned.</para>
      </summary>
      <remarks>
        <para>The default value is 1.2.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouseWheelZoomFactorChanged(System.EventArgs)">
      <summary>
        <para>Callback that is triggered when the value of the <see cref="P:yWorks.Controls.CanvasControl.MouseWheelZoomFactor" /> property has been changed.</para>
      </summary>
      <param name="args">
        <para>the event arguments</para>
      </param>
      <seealso cref="E:yWorks.Controls.CanvasControl.MouseWheelZoomFactorChanged" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.MouseWheelZoomFactorChanged">
      <summary>
        <para>Occurs when the value of the <see cref="P:yWorks.Controls.CanvasControl.MouseWheelZoomFactor" /> property has been changed.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.MouseWheelScrollFactor">
      <summary>
        <para>Gets or sets a factor that controls how fast the viewport scrolls when the mouse wheel is turned.</para>
      </summary>
      <remarks>
        <para>Scrolling can work either a few lines at a time (per notch of the scroll wheel) or one page at a time. This is a system setting. This property controls how many pixels represent a line if scrolling is done by line. In case scrolling is done by page, this property has no effect.</para>
        <para>The default value of 5 pixels. To speed up scrolling, set a larger value, to slow down scrolling, set a smaller value.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.MouseWheelZoomFactor" />
      <seealso cref="P:yWorks.Controls.CanvasControl.MouseWheelBehavior" />
      <seealso cref="P:yWorks.Controls.Mouse2DEventArgs.ScrollAmount" />
      <seealso cref="P:yWorks.Controls.Mouse2DEventArgs.ScrollType" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouseWheelScrollFactorChanged(System.EventArgs)">
      <summary>
        <para>Callback that is triggered when the value of the <see cref="P:yWorks.Controls.CanvasControl.MouseWheelScrollFactor" /> property has been changed.</para>
      </summary>
      <param name="args">
        <para>the event arguments</para>
      </param>
      <seealso cref="E:yWorks.Controls.CanvasControl.MouseWheelScrollFactorChanged" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.MouseWheelScrollFactorChanged">
      <summary>
        <para>Occurs when the value of the <see cref="P:yWorks.Controls.CanvasControl.MouseWheelScrollFactor" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouseDown(System.Windows.Forms.MouseEventArgs)">
      <summary>
        <para>Tries to gain the focus if the control is enabled. This will transform the mouse event to a <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> and invoke the <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DPressed(yWorks.Controls.Mouse2DEventArgs)" /> method.</para>
      </summary>
      <param name="e">
        <para>the event argument</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouseEnter(System.EventArgs)">
      <summary>
        <para>This will transform the mouse event to a <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> and invoke the <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DEntered(yWorks.Controls.Mouse2DEventArgs)" /> method.</para>
      </summary>
      <param name="e">
        <para>the event argument</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouseLeave(System.EventArgs)">
      <summary>
        <para>This will transform the mouse event to a <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> event and invoke the <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DExited(yWorks.Controls.Mouse2DEventArgs)" /> method.</para>
      </summary>
      <param name="e">
        <para>the event argument</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnDragOver(System.Windows.Forms.DragEventArgs)">
      <summary>
        <para>Raises the event.</para>
      </summary>
      <param name="args">
        <para>A <see cref="T:System.Windows.Forms.DragEventArgs"></see> that contains the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnDragLeave(System.EventArgs)">
      <summary>
        <para>Raises the event.</para>
      </summary>
      <param name="e">
        <para>An <see cref="T:System.EventArgs"></see> that contains the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnDragDrop(System.Windows.Forms.DragEventArgs)">
      <summary>
        <para>Raises the event.</para>
      </summary>
      <param name="args">
        <para>A <see cref="T:System.Windows.Forms.DragEventArgs"></see> that contains the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouseMove(System.Windows.Forms.MouseEventArgs)">
      <summary>
        <para>This will transform the mouse event to a <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> event and invoke the <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DMoved(yWorks.Controls.Mouse2DEventArgs)" /> or <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DDragged(yWorks.Controls.Mouse2DEventArgs)" /> methods.</para>
      </summary>
      <remarks>
        <para>This method will not necessarily trigger drag events immediately. This depends on the values of <see cref="P:yWorks.Controls.CanvasControl.DragTime" /> and <see cref="P:yWorks.Controls.CanvasControl.DragSize" />.</para>
      </remarks>
      <param name="e">
        <para>the event argument</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouseUp(System.Windows.Forms.MouseEventArgs)">
      <summary>
        <para>This will transform the mouse event to a <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> event and invoke the <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DReleased(yWorks.Controls.Mouse2DEventArgs)" /> and possibly <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DClicked(yWorks.Controls.Mouse2DEventArgs)" /> methods.</para>
      </summary>
      <remarks>
        <para>This method will not necessarily trigger the click event. This depends on the values of <see cref="P:System.Windows.Forms.SystemInformation.DoubleClickSize" /> and <see cref="P:System.Windows.Forms.SystemInformation.DoubleClickTime" /> as well as if there has been a drag event delivered since the last mouse press.</para>
      </remarks>
      <param name="e">
        <para>the event argument</para>
      </param>
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.AutoDragInsets">
      <summary>
        <para>Gets or sets the auto drag insets.</para>
      </summary>
      <remarks>
        <para>If the mouse is being dragged within the insets of the control specified using this property, the control will automatically scroll.</para>
      </remarks>
      <value>
        <para>The new auto drag insets.</para>
      </value>
      <seealso cref="P:yWorks.Controls.CanvasControl.AutoDrag" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.AutoDragInsetsChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.AutoDragInsets" /> property was changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnAutoDragInsetsChanged(System.EventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.CanvasControl.AutoDragInsetsChanged" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:System.EventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.RedispatchMouse2DEvent">
      <summary>
        <para>Redispatches a previously fired mouse event appropriately, for example if the view port has changed.</para>
      </summary>
      <remarks>
        <para>This is needed to supply <see cref="T:yWorks.Controls.Input.IInputMode" /> implementations with the necessary events even if the mouse has not actually been moved.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnMouseWheel(System.Windows.Forms.MouseEventArgs)">
      <summary>
        <para>This will transform the mouse event to a <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> event and invoke the <see cref="M:yWorks.Controls.CanvasControl.OnMouse2DWheelTurned(yWorks.Controls.Mouse2DEventArgs)" /> method.</para>
      </summary>
      <remarks>
        <para>This method will not necessarily trigger drag events immediately. This depends on the values of <see cref="P:yWorks.Controls.CanvasControl.DragTime" /> and <see cref="P:yWorks.Controls.CanvasControl.DragSize" />.</para>
      </remarks>
      <param name="e">
        <para>the event argument</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ToWorldCoordinates(yWorks.Geometry.PointD)">
      <summary>
        <para>Converts view coordinates (expressed in the control's coordinate system) to world coordinates.</para>
      </summary>
      <param name="viewPoint">
        <para>the coordinates in pixels relative to the controls upper left corner</para>
      </param>
      <returns>
        <para>returns the coordinates in the world coordinate system</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ToViewCoordinates(yWorks.Geometry.PointD,System.Boolean)">
      <summary>
        <para>Converts world coordinates to view coordinates expressed in the control's coordinate system.</para>
      </summary>
      <returns>
        <para>returns the coordinates in pixels relative to the controls upper left corner</para>
      </returns>
      <param name="worldPoint">
        <para>the coordinates in the world coordinate system</para>
      </param>
      <param name="roundToPixels">
        <para>whether the result should be rounded to integral pixel values</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.IsInputKey(System.Windows.Forms.Keys)">
      <summary>
        <para>Overridden to return <c>true</c> for modifier keys.</para>
      </summary>
      <param name="keyData" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnKeyDown(System.Windows.Forms.KeyEventArgs)">
      <summary>
        <para>This will transform the key event to a <see cref="T:yWorks.Controls.CompoundKeyEventArgs" /> event and invoke the <see cref="M:yWorks.Controls.CanvasControl.OnCompoundKeyPressed(yWorks.Controls.CompoundKeyEventArgs)" /> methods as well as redispatch the last mouse event.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.CanvasControl.RedispatchMouse2DEvent" />
      <param name="e">
        <para>the event argument</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)">
      <summary>
        <para>This will transform the key event to a <see cref="T:yWorks.Controls.CompoundKeyEventArgs" /> event and invoke the <see cref="M:yWorks.Controls.CanvasControl.OnCompoundKeyTyped(yWorks.Controls.CompoundKeyEventArgs)" /> methods as well as redispatch the last mouse event.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.CanvasControl.RedispatchMouse2DEvent" />
      <param name="e">
        <para>the event argument</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnKeyUp(System.Windows.Forms.KeyEventArgs)">
      <summary>
        <para>This will transform the key event to a <see cref="T:yWorks.Controls.CompoundKeyEventArgs" /> event and invoke the <see cref="M:yWorks.Controls.CanvasControl.OnCompoundKeyReleased(yWorks.Controls.CompoundKeyEventArgs)" /> methods as well as redispatch the last mouse event.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.CanvasControl.RedispatchMouse2DEvent" />
      <param name="e">
        <para>the event argument</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.RenderContent(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <summary>
        <para>Performs the actual painting on the graphics context.</para>
      </summary>
      <remarks>
        <para>The graphics context is considered to be configured to paint in the world coordinates system at the time of invocation</para>
      </remarks>
      <param name="context" />
      <param name="g">
        <para>the graphics context to paint into</para>
      </param>
      <seealso cref="T:yWorks.Controls.RenderContext" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnPrepareRenderContextEvent(yWorks.Controls.PrepareRenderContextEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.CanvasControl.PrepareRenderContext" /> event.</para>
      </summary>
      <param name="args">
        <para>The event arguments to raise.</para>
      </param>
      <seealso cref="E:yWorks.Controls.CanvasControl.PrepareRenderContext" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ExportToEmf(System.String)">
      <summary>
        <para>Convenience method that exports the current <see cref="P:yWorks.Controls.CanvasControl.ContentRect" /> of the control to an EMF file.</para>
      </summary>
      <remarks>
        <para>For full control over the output use the <see cref="T:yWorks.Controls.EmfImageExporter" />.</para>
      </remarks>
      <param name="emfFile">
        <para>the name of the file to write</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ExportToEmf(System.String,yWorks.Geometry.RectD)">
      <summary>
        <para>Convenience method that exports the given world rectangle of the control to an EMF file.</para>
      </summary>
      <remarks>
        <para>For full control over the output use the <see cref="T:yWorks.Controls.EmfImageExporter" />.</para>
      </remarks>
      <param name="emfFile">
        <para>The name of the file to write</para>
      </param>
      <param name="worldRect">
        <para>The rectangle in the world coordinate system to export.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ExportToEmf(System.IO.Stream)">
      <summary>
        <para>Convenience method that exports the current <see cref="P:yWorks.Controls.CanvasControl.ContentRect" /> of the control to an EMF stream.</para>
      </summary>
      <remarks>
        <para>For full control over the output use the <see cref="T:yWorks.Controls.EmfImageExporter" />.</para>
      </remarks>
      <param name="stream">
        <para>the name of the file to write</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ExportToEmf(System.IO.Stream,yWorks.Geometry.RectD)">
      <summary>
        <para>Convenience method that exports the given world rectangle of the control to an EMF stream.</para>
      </summary>
      <remarks>
        <para>For full control over the output use the <see cref="T:yWorks.Controls.EmfImageExporter" />.</para>
      </remarks>
      <param name="stream">
        <para>The stream to write the EMF file to.</para>
      </param>
      <param name="worldRect">
        <para>The rectangle in the world coordinate system to export.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ExportToBitmap(System.String,System.String)">
      <summary>
        <para>Convenience method that exports the <see cref="P:yWorks.Controls.CanvasControl.ContentRect" /> of the control to an image in a stream.</para>
      </summary>
      <remarks>
        <para>For full control over the output use the <see cref="T:yWorks.Controls.PixelImageExporter" />.</para>
      </remarks>
      <param name="file">
        <para>The name of the file to write the image to.</para>
      </param>
      <param name="format">
        <para>The output format to use. This must be one of <c>"image/jpeg"</c>, <c>"image/tiff"</c>, <c>"image/gif"</c>, <c>"image/png"</c>, or<c>"image/bmp"</c></para>
      </param>
      <exception cref="T:System.IO.IOException">
        <para>If there is not enough memory to complete the operation.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ExportToBitmap(System.IO.Stream,System.String,yWorks.Geometry.RectD)">
      <summary>
        <para>Convenience method that exports the given world rectangle of the control to an image in a stream.</para>
      </summary>
      <remarks>
        <para>For full control over the output use the <see cref="T:yWorks.Controls.PixelImageExporter" />.</para>
      </remarks>
      <param name="stream">
        <para>The stream to write the image to.</para>
      </param>
      <param name="worldRect">
        <para>The rectangle in the world coordinate system to export.</para>
      </param>
      <param name="format">
        <para>The output format to use. This must be one of <c>"image/jpeg"</c>, <c>"image/tiff"</c>, <c>"image/gif"</c>, <c>"image/png"</c>, or<c>"image/bmp"</c></para>
      </param>
      <exception cref="T:System.IO.IOException">
        <para>If there is not enough memory to complete the operation.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.GetCanvasObject(yWorks.Geometry.PointD)">
      <summary>
        <para>Returns the top most canvas object instance that is hit at the given coordinate set.</para>
      </summary>
      <remarks>
        <para>This will return the canvas object that is painted last at the given position.</para>
      </remarks>
      <param name="location">
        <para>the coordinates of the query in the world coordinate system</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.GetCanvasObjects(yWorks.Geometry.PointD)">
      <summary>
        <para>Returns a list of all canvas objects in hit order at the given world coordinate location.</para>
      </summary>
      <remarks>
        <para>The order of the elements in the list is the natural hit test order, i.e. elements painted on top of others will be reported first in the list.</para>
      </remarks>
      <param name="location">
        <para>the coordinates of the query in the world coordinate system</para>
      </param>
      <returns>
        <para>an enumerable of canvas object that are hit in reverse painting order</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.CompareRenderOrder(yWorks.Controls.ICanvasObject,yWorks.Controls.ICanvasObject)">
      <summary>
        <para>Compares two <see cref="T:yWorks.Controls.ICanvasObject" /> instances that are live in this canvas.</para>
      </summary>
      <remarks>
        <para>The comparison will yield values greater than zero if and only if the second object is rendered after the first one.</para>
      </remarks>
      <param name="canvasObject1">
        <para>the first object to compare</para>
      </param>
      <param name="canvasObject2">
        <para>the second object to compare</para>
      </param>
      <returns>
        <para>0 if canvasObject1 == canvasObject2 <br /> &gt;0 if canvasObject1 is painted before canvasObject2 &lt;0 if canvasObject1 is painted after canvasObject2</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.UpdateContentRect(yWorks.Geometry.InsetsD,yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Updates the <see cref="P:yWorks.Controls.CanvasControl.ContentRect" /> to encompass the bounds by all elements in the current scene graph plus the given margins.</para>
      </summary>
      <remarks>
        <para>This method will traverse all <see cref="P:yWorks.Controls.ICanvasObject.Visible">visible</see> elements in the scene graph and query their <see cref="M:yWorks.Controls.ICanvasObjectDescriptor.GetBoundsProvider(System.Object)">bounds</see> The resulting bounds will be set to the content rectangle plus the provided <paramref name="margins" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.IBoundsProvider" />
      <seealso cref="P:yWorks.Controls.CanvasControl.ContentRect" />
      <param name="margins" />
      <param name="group" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.FitContent">
      <summary>
        <para>Adjusts the view port to fully encompass the <see cref="P:yWorks.Controls.CanvasControl.ContentRect" />.</para>
      </summary>
      <remarks>
        <para>The zoom level will not be greater than <c>1.0d</c> (see the remarks). If the view port is limited by the <see cref="P:yWorks.Controls.CanvasControl.ViewportLimiter" /> the zoom level might be greater than <c>1.0d</c> to respect the limits.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.CanvasControl.UpdateContentRect(yWorks.Geometry.InsetsD,yWorks.Controls.ICanvasObjectGroup)" />
      <seealso cref="P:yWorks.Controls.CanvasControl.Zoom" />
      <seealso cref="M:yWorks.Controls.CanvasControl.ZoomTo(yWorks.Geometry.PointD,System.Double)" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ZoomTo(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Sets the zoom level and view port center to the given values.</para>
      </summary>
      <param name="center">
        <para>the new center of the view port in world coordinates</para>
      </param>
      <param name="zoom">
        <para>the new zoom level</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.EnsureVisible(yWorks.Geometry.RectD)">
      <summary>
        <para>Ensures that the provided bounds are visible in this control by adjusting the viewport correspondingly.</para>
      </summary>
      <param name="bounds">
        <para>The bounds to make visible.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ZoomTo(yWorks.Geometry.RectD)">
      <summary>
        <para>Sets the zoom level and view port center so that the given rectangle in world coordinates fits the viewport.</para>
      </summary>
      <param name="bounds">
        <para>The coordinates of the rectangle to zoom to.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.ReplaceCursor(System.Windows.Forms.Cursor)">
      <summary />
      <remarks>
        <para>This implementation inspects the <see cref="T:System.Windows.Forms.RightToLeft" /> property and in case of a <see cref="F:System.Windows.Forms.RightToLeft.Yes" /> swaps the cursors that need to be mirrored horizontally.</para>
      </remarks>
      <param name="cursor">
        <para>The cursor to adjust, can be <c>null</c>.</para>
      </param>
      <returns>
        <para>The cursor to set on the control, may be <c>null</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.InputModeContext">
      <summary>
        <para>Gets or sets the InputModeContext property.</para>
      </summary>
      <remarks>
        <para>This context object is passed to <see cref="T:yWorks.Controls.Input.IInputMode" /> instances during <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installation</see> and removal. <br /> If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.CanvasControl.CreateInputModeContext" /> will be called. Upon change the <see cref="M:yWorks.Controls.CanvasControl.OnInputModeContextChanged(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.IInputModeContext)" /> method will be called.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.CanvasControl.InputModeContextChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.InputModeContext" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnInputModeContextChanged(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.CanvasControl.InputModeContext" /> property value changes and after initialization of the field. Triggers the <see cref="E:yWorks.Controls.CanvasControl.InputModeContextChanged" /> event.</para>
      </summary>
      <param name="oldContext">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newContext">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.CreateInputModeContext">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.CanvasControl.InputModeContext" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.CanvasControl.InputModeContext" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="P:yWorks.Controls.CanvasControl.InputModeContext" /> that has this instance set as it's <see cref="P:yWorks.Controls.ICanvasContext.CanvasControl" /> and uses this instance's <see cref="M:yWorks.Controls.CanvasControl.InputModeContextLookup(System.Type)" /> callback to satisfy requests.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.InputModeContextLookup(System.Type)">
      <summary>
        <para>Callback that is used by the default implementation of <see cref="P:yWorks.Controls.CanvasControl.InputModeContext" /> to resolve <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> calls.</para>
      </summary>
      <param name="type">
        <para>The Type to query</para>
      </param>
      <returns>
        <para>The result of the query.</para>
      </returns>
      <seealso cref="T:yWorks.Controls.Input.IInputModeContext" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.GetBounds(yWorks.Controls.ICanvasObject)">
      <summary>
        <para>Convenience method that calculates the bounds for a given canvas object in the scene graph.</para>
      </summary>
      <remarks>
        <para>This method queries the descriptor for the <see cref="T:yWorks.Controls.IBoundsProvider" /> for the user object and returns the result.</para>
      </remarks>
      <param name="canvasObject">
        <para>the canvas object to query the bounds from</para>
      </param>
      <returns>
        <para>the non-<c>null</c> bounds</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.IsHit(yWorks.Controls.ICanvasObject,yWorks.Geometry.PointD)">
      <summary>
        <para>Convenience method that calculates the hit tests a given canvas object in the scene graph.</para>
      </summary>
      <remarks>
        <para>This method queries the descriptor for the <see cref="T:yWorks.Controls.Input.IHitTestable" /> for the user object and returns the result of the hit test query. If there is no <c>IHitTestable</c> returned by the descriptor this method returns <c>false</c>.</para>
      </remarks>
      <param name="canvasObject">
        <para>the canvas object to query the bounds from</para>
      </param>
      <returns>
        <para>whether the canvas object is hit at the given coordinates</para>
      </returns>
      <param name="location">
        <para>the coordinates of the query in the world coordinate system</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.Print(yWorks.Geometry.RectD,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Convenience method that optionally shows a print dialog and prints the contents of the given world rectangle to a printer.</para>
      </summary>
      <remarks>
        <para>For more control over the printing process, use the <see cref="T:yWorks.Controls.CanvasPrintDocument" /> class.</para>
      </remarks>
      <param name="worldRect">
        <para>The rectangle in the world coordinate system to print.</para>
      </param>
      <param name="showPreview">
        <para>Whether to show a print preview or just print the rectangle unconditionally.</para>
      </param>
      <param name="showPageSetupDialog">
        <para>Whether to show a page setup dialog.</para>
      </param>
      <param name="showPrintDialog">
        <para>Whether to show a print dialog.</para>
      </param>
      <returns>
        <para>Whether printing has been performed. This has a meaningful value only if <paramref name="showPreview" /> is <c>false</c>, since otherwise this method returns before actual printing has been initiated.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.CreateCanvasPrintDocument">
      <summary>
        <para>Factory method that creates a temporary <see cref="T:yWorks.Controls.CanvasPrintDocument" /> that is used inside the <see cref="M:yWorks.Controls.CanvasControl.Print(yWorks.Geometry.RectD,System.Boolean,System.Boolean,System.Boolean)" /> method</para>
      </summary>
      <returns>
        <para>A new <see cref="T:yWorks.Controls.CanvasPrintDocument" /> instance for the <see cref="M:yWorks.Controls.CanvasControl.Print(yWorks.Geometry.RectD,System.Boolean,System.Boolean,System.Boolean)" /> method.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.Print">
      <summary>
        <para>Prints this canvas' contents to the default printer.</para>
      </summary>
      <returns>
        <para>Whether printing has been performed.</para>
      </returns>
      <remarks>
        <para>This is the same as calling <see cref="M:yWorks.Controls.CanvasControl.Print(yWorks.Geometry.RectD,System.Boolean,System.Boolean,System.Boolean)" /> with the <see cref="P:yWorks.Controls.CanvasControl.ContentRect" /> and <c>true</c>, <c>false</c>, <c>new InsetsD()</c> as arguments. For more control over the printing process, use the <see cref="T:yWorks.Controls.CanvasPrintDocument" /> class.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.GetVisual(yWorks.Controls.ICanvasObject)">
      <summary>
        <para>Convenience method that retrieves the <see cref="T:yWorks.Controls.IVisual" /> for a given <see cref="T:yWorks.Controls.ICanvasObject" />.</para>
      </summary>
      <param name="canvasObject">
        <para>the canvas object to query the visual creator implementation from</para>
      </param>
      <returns>
        <para>an instance of the visual creator interface</para>
      </returns>
      <seealso cref="M:yWorks.Controls.ICanvasObjectDescriptor.GetVisualCreator(System.Object)" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)">
      <summary>
        <para>Raises the event.</para>
      </summary>
      <param name="e">
        <para>An <see cref="T:System.Windows.Forms.InvalidateEventArgs"></see> that contains the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.Invalidate(yWorks.Controls.ICanvasObject)">
      <summary>
        <para>Invalidate the Control using the bounds provided by the canvas object.</para>
      </summary>
      <param name="canvasObject">
        <para>the canvas object to query the bounds from</para>
      </param>
      <seealso cref="M:yWorks.Controls.ICanvasObjectDescriptor.GetBoundsProvider(System.Object)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.InvalidateWorld(yWorks.Geometry.RectD)" />
      <seealso cref="M:yWorks.Controls.CanvasControl.Invalidate" />
    </member>
    <member name="M:yWorks.Controls.CanvasControl.GrowContentRect(yWorks.Geometry.RectD)">
      <summary>
        <para>Assures that the <see cref="P:yWorks.Controls.CanvasControl.ContentRect">content rectangle</see> encompasses the given rectangle.</para>
      </summary>
      <remarks>
        <para>Note that this will not change the view port, it will only change the scroll bars if necessary.</para>
      </remarks>
      <param name="rectangle">
        <para>the rectangle that should be included in the content rectangle</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.NavigationCommandsEnabled">
      <summary>
        <para>Gets or sets a value indicating whether navigation related command bindings are enabled.</para>
      </summary>
      <remarks>
        <para>By default this feature is enabled.</para>
        <para>This property enables/disables the following commands:</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.IncreaseZoom" />NavigationCommands.IncreaseZoom</item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.Zoom" />NavigationCommands.Zoom</item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.DecreaseZoom" />NavigationCommands.DecreaseZoom</item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageDown" />ComponentCommands.ScrollPageDown</item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageUp" />ComponentCommands.ScrollPageUp</item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageLeft" />ComponentCommands.ScrollPageLeft</item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageRight" />ComponentCommands.ScrollPageRight</item>
        </list>
      </remarks>
      <value>
        <para>
          <c>true</c> if the commands are enabled; otherwise, <c>false</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.CanvasControl.Resources">
      <summary>
        <para>Gets the resources for this instance.</para>
      </summary>
      <remarks>
        <para>Resources are named instances of objects that can be retrieved by other parts of the infrastructure that deal with this instance, either directly or indirectly.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.ApplicationResources" />
      <seealso cref="T:yWorks.Controls.ResourceKey" />
    </member>
    <member name="P:yWorks.Controls.CanvasControl.Scale">
      <summary>
        <para>Gets or sets the scale factor for the contents.</para>
      </summary>
      <remarks>
        <para>This scale factor is intended to enable high-DPI display scenarios where all content in the CanvasControl is uniformly scaled. This means that a <see cref="P:yWorks.Controls.CanvasControl.Zoom">zoom level</see> of 1.0 will appear larger by this factor and decorations like handles, etc. are scaled as well (which they won't be when changing <see cref="P:yWorks.Controls.CanvasControl.Zoom" />).</para>
        <para>To configure the CanvasControl for high-DPI displays, either call the <see cref="M:yWorks.Graph.GraphExtensions.SetDpiScale(yWorks.Controls.CanvasControl)" /> convenience method, or calculate your desired scaling factor and set that one instead.</para>
        <para>When using a scale different from 1.0, the <em>view</em> coordinate system of the CanvasControl (cf. <see cref="M:yWorks.Controls.CanvasControl.ToViewCoordinates(yWorks.Geometry.PointD,System.Boolean)" /> is scaled. Thus is no longer coincides with the screen's coordinate system. This has to be accounted for when dealing with other controls on the screen, e.g. when positioning a tooltip over the CanvasControl, or showing another control in a precise location. Handles, snaplines, and other decorations are drawn in view coordinates, so no special care has to be taken for those.</para>
        <para>To convert from view coordinates to the control's coordinates on the screen, use the following formulas:</para>
        <code>// worldPoint is a point in world coordinates.
// Call ToViewCoordinates to convert world to view coordinates.
var viewPoint = canvasControl.ToViewCoordinates(worldPoint);
// Divide by Scale to obtain the coordinates on the control
var controlPoint = new Point((int) viewPoint.X / canvasControl.Scale, (int) viewPoint.Y / canvasControl.Scale);
// Multiply with Scale to obtain a point in view coordinates again
var viewPoint2 = new PointD(controlPoint.X * canvasControl.Scale, controlPoint.Y * canvasControl.Scale);
// Call ToWorldCoordinates to convert view to world coordinates.
var worldPoint2 = canvasControl.ToWorldCoordinates(viewPoint2);</code>
      </remarks>
      <seealso cref="P:yWorks.Controls.CanvasControl.Zoom" />
      <seealso cref="M:yWorks.Graph.GraphExtensions.SetDpiScale(yWorks.Controls.CanvasControl)" />
    </member>
    <member name="E:yWorks.Controls.CanvasControl.ScaleChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.CanvasControl.Scale" /> property changes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasControl.OnScaleChanged">
      <summary>
        <para>Callback that is invoked when the <see cref="P:yWorks.Controls.CanvasControl.Scale" /> property changes.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.CanvasObjectDescriptors">
      <summary>
        <para>Static utility class that serves as a factory for various <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> implementations.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.CanvasObjectDescriptors.Void">
      <summary>
        <para>An implementation that returns an <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> that does nothing.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.CanvasObjectDescriptors.DynamicDirtyInstance">
      <summary>
        <para>An implementation that treats <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> as an instance of <see cref="T:yWorks.Controls.IVisualCreator" /> and considers the <see cref="P:yWorks.Controls.ICanvasObject.Dirty" /> flag.</para>
      </summary>
      <remarks>
        <para>This descriptor tries to cast the <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> to <see cref="T:yWorks.Controls.IVisualCreator" /> and use this instance to handle the visual representation of the <see cref="T:yWorks.Controls.ICanvasObject" />.</para>
        <para>If the <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> does not implement <see cref="T:yWorks.Controls.IVisualCreator" /> nothing will be displayed.</para>
        <para>This descriptor will respect the <see cref="P:yWorks.Controls.ICanvasObject.Dirty" /> flag.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.CanvasObjectDescriptors.AlwaysDirtyInstance">
      <summary>
        <para>A descriptor that treats <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> as an instance of <see cref="T:yWorks.Controls.IVisualCreator" /> and ignores the <see cref="P:yWorks.Controls.ICanvasObject.Dirty" /> flag.</para>
      </summary>
      <remarks>
        <para>This descriptor tries to cast the <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> to <see cref="T:yWorks.Controls.IVisualCreator" /> and use this instance to handle the visual representation of the <see cref="T:yWorks.Controls.ICanvasObject" />.</para>
        <para>If the <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> does not implement <see cref="T:yWorks.Controls.IVisualCreator" /> nothing will be displayed.</para>
        <para>This descriptor will always <see cref="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">update the visual</see> and thus ignore the <see cref="P:yWorks.Controls.ICanvasObject.Dirty" /> flag.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.CanvasObjectDescriptors.DynamicDirtyLookup">
      <summary>
        <para>A descriptor that treats <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> as an instance of <see cref="T:yWorks.Graph.ILookup" /> to obtain suitable interface implementations and considers the <see cref="P:yWorks.Controls.ICanvasObject.Dirty" /> flag.</para>
      </summary>
      <remarks>
        <para>This descriptor tries to cast the <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> to <see cref="T:yWorks.Graph.ILookup" /> and obtain the appropriate interface implementations for its methods from it.</para>
        <para>If the <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> does not implement <see cref="T:yWorks.Graph.ILookup" /> nothing will be displayed.</para>
        <para>This descriptor will respect the <see cref="P:yWorks.Controls.ICanvasObject.Dirty" /> flag.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.CanvasObjectDescriptors.AlwaysDirtyLookup">
      <summary>
        <para>A descriptor that treats <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> as an instance of <see cref="T:yWorks.Graph.ILookup" /> to obtain suitable interface implementations and ignores the <see cref="P:yWorks.Controls.ICanvasObject.Dirty" /> flag.</para>
      </summary>
      <remarks>
        <para>This descriptor tries to cast the <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> to <see cref="T:yWorks.Graph.ILookup" /> and obtain the appropriate interface implementations for its methods from it.</para>
        <para>If the <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> does not implement <see cref="T:yWorks.Graph.ILookup" /> nothing will be displayed.</para>
        <para>This descriptor will always <see cref="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">update the IVisual</see> and thus ignore the <see cref="P:yWorks.Controls.ICanvasObject.Dirty" /> flag.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.CanvasObjectDescriptors.Visual">
      <summary>
        <para>A descriptor that treats <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> as <see cref="T:yWorks.Controls.IVisual" /> to use directly.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> is not a <see cref="T:yWorks.Controls.IVisual" /> nothing will be displayed.</para>
        <para>This descriptor ignores the <see cref="P:yWorks.Controls.ICanvasObject.Dirty" /> flag.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.CanvasPrintDocument">
      <summary>
        <para>This class provides printing capabilities for a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>This instance controls the printing output. Clients can set the <see cref="P:yWorks.Controls.CanvasPrintDocument.Canvas" />, the <see cref="P:yWorks.Controls.CanvasPrintDocument.PrintRectangle">rectangle in the world coordinate system to print</see>, and a <see cref="P:yWorks.Controls.CanvasPrintDocument.Scale">scale factor</see>. It allows for <see cref="P:yWorks.Controls.CanvasPrintDocument.CenterContent">centering the output</see> on the printed pages and printing <see cref="P:yWorks.Controls.CanvasPrintDocument.PageMarkPrinting">page marks</see>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.CanvasPrintDocument.Print(System.Windows.Forms.IWin32Window,System.Boolean,System.Boolean,System.Boolean)" />
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.#ctor">
      <summary>
        <para>Initializes a new instance with no initial <see cref="P:yWorks.Controls.CanvasPrintDocument.Canvas" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Controls.CanvasPrintDocument.Canvas" /> property needs to be set before printing can be performed.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.#ctor(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.CanvasPrintDocument" /> class using the provided control for printing.</para>
      </summary>
      <remarks>
        <para>This method sets the <see cref="P:yWorks.Controls.CanvasPrintDocument.PrintRectangle" /> to the <see cref="P:yWorks.Controls.CanvasControl.ContentRect" />.</para>
      </remarks>
      <param name="canvas">
        <para>The control to print.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.CanvasPrintDocument.Canvas">
      <summary>
        <para>Gets or sets the canvas to print.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.CanvasPrintDocument.Scale">
      <summary>
        <para>Gets or sets a scale factor to apply for printing.</para>
      </summary>
      <remarks>
        <para>A value of 1 makes 96 units in the world coordinate system appear exactly one inch long. This is the same as the default display (screen) resolution.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasPrintDocument.PrintRectangle">
      <summary>
        <para>Gets or sets the rectangle that will be printed.</para>
      </summary>
      <remarks>
        <para>This rectangle determines the portion to print in the world coordinate system.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasPrintDocument.ColumnCount">
      <summary>
        <para>Gets or sets the number of columns to use internally for this document.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.CanvasPrintDocument.Scale" />
    </member>
    <member name="P:yWorks.Controls.CanvasPrintDocument.RowCount">
      <summary>
        <para>Gets or sets the number of rows to use internally for this document.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.CanvasPrintDocument.Scale" />
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.CalculatePosterSize">
      <summary>
        <para>Calculates the size in columns and rows for the currently set <see cref="P:yWorks.Controls.CanvasPrintDocument.Scale" />, <see cref="P:yWorks.Controls.CanvasPrintDocument.PrintRectangle" />, and <see cref="P:System.Drawing.Printing.PrintDocument.DefaultPageSettings" /></para>
      </summary>
      <returns>
        <para>The size in paper columns (<see cref="P:System.Drawing.Size.Width" />) and rows (<see cref="P:System.Drawing.Size.Height" />).</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.CanvasPrintDocument.CenterContent">
      <summary>
        <para>Gets or sets a property that determines whether the contents should be centered on the page.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.CanvasPrintDocument.PageCount">
      <summary>
        <para>Gets the number of pages for this document.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.OnBeginPrint(System.Drawing.Printing.PrintEventArgs)">
      <summary>
        <para>Initializes the printing process.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.OnEndPrint(System.Drawing.Printing.PrintEventArgs)">
      <summary>
        <para>Finishes the printing process.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.OnPrintPage(System.Drawing.Printing.PrintPageEventArgs)">
      <summary>
        <para>Actually prints the pages.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.CreateContextConfigurator(System.Int32,System.Drawing.Printing.PrintPageEventArgs)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Controls.ContextConfigurator" /> instance that is used to <see cref="M:yWorks.Controls.ContextConfigurator.Setup(yWorks.Controls.CanvasControl,System.Drawing.Graphics)" /> the individual page visuals.</para>
      </summary>
      <param name="pageNumber">
        <para>The current page number.</para>
      </param>
      <param name="e">
        <para>The print event args for the current page</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Controls.ContextConfigurator" /> instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.PreparePosterPrinting(System.Drawing.Printing.PrintPageEventArgs)">
      <summary>
        <para>Called to initialize poster printing.</para>
      </summary>
      <remarks>
        <para>This method is called during printing initialization. It adjusts the <see cref="P:yWorks.Controls.CanvasPrintDocument.ColumnCount" /> and <see cref="P:yWorks.Controls.CanvasPrintDocument.RowCount" /> properties for the given scale.</para>
      </remarks>
      <param name="e" />
    </member>
    <member name="P:yWorks.Controls.CanvasPrintDocument.PageMarkPrinting">
      <summary>
        <para>Gets or sets a property that determines whether to print page margins.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.Print(System.Windows.Forms.IWin32Window,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Convenience method that actually <see cref="M:System.Drawing.Printing.PrintDocument.Print">prints this document</see>.</para>
      </summary>
      <param name="owner">
        <para>The owner to show the dialogs for. May be <c>null</c> if all other parameters are <c>false</c>.</para>
      </param>
      <param name="showPrintDialog">
        <para>Whether to show the print dialog.</para>
      </param>
      <param name="showPageSetupDialog">
        <para>Whether to show the page setup dialog.</para>
      </param>
      <param name="showPreview">
        <para>Whether to show the print preview dialog.</para>
      </param>
      <returns>
        <para>Whether printing has been performed.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.CanvasPrintDocument.ScaleDownToFitPage">
      <summary>
        <para>Gets or sets a property that determines whether to scale down the content so that it always fits on one page.</para>
      </summary>
      <remarks>
        <para>If this is <c>true</c>, properties <see cref="P:yWorks.Controls.CanvasPrintDocument.ColumnCount" />, <see cref="P:yWorks.Controls.CanvasPrintDocument.RowCount" /> and <see cref="P:yWorks.Controls.CanvasPrintDocument.Scale" /> are ignored. Default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CanvasPrintDocument.ScaleUpToFitPage">
      <summary>
        <para>Gets or sets a property that determines whether to scale up the content so that it always fills one page as large as possible.</para>
      </summary>
      <remarks>
        <para>Default is <c>false</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.PrintPageMarks(System.Drawing.Graphics,System.Drawing.Printing.PrintPageEventArgs)">
      <summary>
        <para>Prints the page marks and decorations around the contents.</para>
      </summary>
      <param name="gfx">
        <para>The graphics.</para>
      </param>
      <param name="e">
        <para>The <see cref="T:System.Drawing.Printing.PrintPageEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CanvasPrintDocument.GetWorldBounds(System.Int32,System.Drawing.Printing.PrintPageEventArgs)">
      <summary>
        <para>Callback method during an <see cref="M:yWorks.Controls.CanvasPrintDocument.OnPrintPage(System.Drawing.Printing.PrintPageEventArgs)" /> call that determines the world rectangle to print on the given page.</para>
      </summary>
      <param name="page">
        <para>The page index (zero-based).</para>
      </param>
      <param name="e">
        <para>The event arguments.</para>
      </param>
      <returns>
        <para>The world rectangle to print on the page.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.ContextConfigurator">
      <summary>
        <para>This class sets up an <see cref="T:yWorks.Controls.IRenderContext" /> object for exporting the contents of a <see cref="T:yWorks.Controls.CanvasControl" /> (see <see cref="M:yWorks.Controls.ContextConfigurator.Setup(yWorks.Controls.CanvasControl,System.Drawing.Graphics)" />).</para>
      </summary>
      <remarks>
        <list type="bullet">
          <item>It is possible to export only a part of the contents, see <see cref="P:yWorks.Controls.ContextConfigurator.WorldBounds" />.</item>
          <item>The size of the target graphics is controlled by the <see cref="P:yWorks.Controls.ContextConfigurator.Scale" />. For a given target width or height, the apropriate scale can be calculated using <see cref="M:yWorks.Controls.ContextConfigurator.CalculateScaleForWidth(System.Double)" /> and <see cref="M:yWorks.Controls.ContextConfigurator.CalculateScaleForHeight(System.Double)" />.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.ContextConfigurator.#ctor(yWorks.Geometry.RectD,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Controls.ContextConfigurator" /> instance for the given world bounds and scale.</para>
      </summary>
      <param name="worldBounds">
        <para>the bounds of the content to export, see <see cref="P:yWorks.Controls.ContextConfigurator.WorldBounds" /></para>
      </param>
      <param name="scale">
        <para>the scale, see <see cref="P:yWorks.Controls.ContextConfigurator.Scale" /></para>
      </param>
    </member>
    <member name="P:yWorks.Controls.ContextConfigurator.WorldBounds">
      <summary>
        <para>Gets or sets the bounds of the content to export in world coordinates.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ContextConfigurator.Scale">
      <summary>
        <para>Gets or sets the scale for the export.</para>
      </summary>
      <remarks>
        <para>A scale of <c>1</c> preserves the original size, a scale of <c>0.5</c> results in a target image with half the original size and so on.</para>
        <para>This value has to be strictly greater than <c>0</c>. Its default value is <c>1.0</c></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ContextConfigurator.Zoom">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.ICanvasContext.Zoom" /> property to use during the creation of the visualization.</para>
      </summary>
      <remarks>
        <para>In contrast to the <see cref="P:yWorks.Controls.ContextConfigurator.Scale" /> property, which works on the output graphics, this property determines what zoom value is to be assumed on the canvas when creating the visual. This can affect the rendering of zoom dependent visuals.</para>
        <para>This value has to be strictly greater than <c>0</c>. Its default value is <c>1.0</c></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ContextConfigurator.Margins">
      <summary>
        <para>Gets or sets the margins for the exported image.</para>
      </summary>
      <remarks>
        <para>The margins are added to the content. This means that an image with non-zero margins is larger than the <see cref="P:yWorks.Controls.ContextConfigurator.WorldBounds" /> even if the <see cref="P:yWorks.Controls.ContextConfigurator.Scale" /> is <c>1.0</c>. The margins are not scaled. They are interpreted to be in units (pixels for bitmaps) for the resulting image. The default is an empty margin instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ContextConfigurator.ViewWidth">
      <summary>
        <para>Gets the resulting width of the target image with respect to <see cref="P:yWorks.Controls.ContextConfigurator.WorldBounds" />, <see cref="P:yWorks.Controls.ContextConfigurator.Scale" /> and <see cref="P:yWorks.Controls.ContextConfigurator.Margins" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ContextConfigurator.ViewHeight">
      <summary>
        <para>Gets the resulting height of the target image with respect to <see cref="P:yWorks.Controls.ContextConfigurator.WorldBounds" />, <see cref="P:yWorks.Controls.ContextConfigurator.Scale" /> and <see cref="P:yWorks.Controls.ContextConfigurator.Margins" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ContextConfigurator.CalculateScaleForWidth(System.Double)">
      <summary>
        <para>Calculates the value to set the <see cref="P:yWorks.Controls.ContextConfigurator.Scale" /> to in order to achieve the given target width (without <see cref="P:yWorks.Controls.ContextConfigurator.Margins" />).</para>
      </summary>
      <param name="width">
        <para>the width of the target image</para>
      </param>
      <returns>
        <para>the scale value to use</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ContextConfigurator.CalculateScaleForHeight(System.Double)">
      <summary>
        <para>Calculates the value to set the <see cref="P:yWorks.Controls.ContextConfigurator.Scale" /> to in order to achieve the given target height (without <see cref="P:yWorks.Controls.ContextConfigurator.Margins" />).</para>
      </summary>
      <param name="height">
        <para>the height of the target image</para>
      </param>
      <returns>
        <para>the scale value to use</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ContextConfigurator.Setup(yWorks.Controls.CanvasControl,System.Drawing.Graphics)">
      <summary>
        <para>Returns an initialized <see cref="T:yWorks.Controls.IRenderContext" /> and changes the transforms and the clip bounds of the given <see cref="T:System.Drawing.Graphics" /> instance such that a part of the given <see cref="T:yWorks.Controls.CanvasControl" /> instance can be exported to an image.</para>
      </summary>
      <param name="canvas">
        <para>the <see cref="T:yWorks.Controls.CanvasControl" /> instance to export from</para>
      </param>
      <param name="graphics">
        <para>the <see cref="T:System.Drawing.Graphics" /> instance to draw on</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Controls.IRenderContext" /> to use</para>
      </returns>
      <example>
        <para>Use the <see cref="T:yWorks.Controls.ContextConfigurator" /> as follows to export the currently visible part of a <see cref="T:yWorks.Controls.CanvasControl" /> instance <c>myCanvas</c> to a <see cref="T:System.Drawing.Bitmap" />.</para>
        <code>ContextConfigurator config = new ContextConfigurator(myCanvas.Viewport);
Bitmap bitmap = new Bitmap(config.ViewWidth, config.ViewHeight);
Graphics graphics = Graphics.FromImage(bitmap);
IRenderContext paintContext = config.SetUp(myCanvas, graphics);
canvas.PaintContent(graphics, paintContext);</code>
        <para>Using the method <see cref="M:yWorks.Controls.PixelImageExporter.ExportBitmap(yWorks.Controls.CanvasControl)" /> from class <see cref="T:yWorks.Controls.PixelImageExporter" /> this can also be achieved with less code.</para>
      </example>
    </member>
    <member name="T:yWorks.Controls.GraphControl">
      <summary>
        <para>A control for displaying and editing an <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <remarks>
        <para>This is a specialized <see cref="T:yWorks.Controls.CanvasControl" /> that can hold, display, and edit an <see cref="T:yWorks.Graph.IGraph" /> instance. It provides access to the <see cref="P:yWorks.Controls.GraphControl.Graph" /> and <see cref="P:yWorks.Controls.GraphControl.Selection" /> instances. Additionally it provides convenience methods for <see cref="M:yWorks.Controls.GraphControl.ExportToGraphML(System.IO.Stream)">exporting the graph to GraphML</see> and <see cref="M:yWorks.Controls.GraphControl.ImportFromGraphML(System.IO.Stream)">importing a graph from GraphML</see>.</para>
        <para>The following commands are bound to methods implemented by this class, but are <b>disabled</b> by default:</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.Open">ApplicationCommands.Open</see>
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.Save">ApplicationCommands.Save</see>
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.SaveAs">ApplicationCommands.SaveAs</see>
          </item>
        </list>
        <para>To enable these command, set the <see cref="P:yWorks.Controls.GraphControl.FileOperationsEnabled" /> property to <c>true</c>.</para>
        <para>In addition to that this class supports the following new <see cref="T:yWorks.Controls.ICommand" />s.</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.FitGraphBounds" /> that invokes <see cref="M:yWorks.Controls.GraphControl.FitGraphBounds(System.Nullable{yWorks.Geometry.InsetsD})" /></item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.SetCurrentItem" /> for setting the <see cref="P:yWorks.Controls.GraphControl.CurrentItem" /></item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ZoomToCurrentItem" /> for adjusting the <see cref="P:yWorks.Controls.CanvasControl.Viewport" /> to the <see cref="P:yWorks.Controls.GraphControl.CurrentItem" /></item>
        </list>
        <para>The <see cref="F:yWorks.Controls.Input.Commands.ZoomToCurrentItem" /> is enabled, if <see cref="P:yWorks.Controls.CanvasControl.NavigationCommandsEnabled" /> is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphControl.#ctor">
      <summary>
        <para>Creates a new instance of the <see cref="T:yWorks.Controls.GraphControl" />.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Controls.GraphControl.Graph" /> and <see cref="T:yWorks.Controls.GraphSelection" /> properties are not populated externally they will be initialized with default values upon first access. Thus this instance can be used right away without any further initialization.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphControl.OnLostFocus(System.EventArgs)">
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.GraphControl.OnGotFocus(System.EventArgs)">
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.GraphControl.OnCurrentItemChanged(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.GraphControl.CurrentItem" /> Property changed.</para>
      </summary>
      <remarks>
        <para>This implementation updates the <see cref="P:yWorks.Controls.GraphControl.FocusIndicatorManager" />'s <see cref="P:yWorks.Controls.FocusIndicatorManager`1.FocusedItem" /> property.</para>
      </remarks>
      <param name="oldItem">
        <para>The old item.</para>
      </param>
      <param name="newItem">
        <para>The new item.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.GraphControl.CurrentItem">
      <summary>
        <para>Gets or sets the 'current' item.</para>
      </summary>
      <value>
        <para>The current item by default is given focus indication using the <see cref="P:yWorks.Controls.GraphControl.FocusIndicatorManager" />.</para>
      </value>
    </member>
    <member name="E:yWorks.Controls.GraphControl.CurrentItemChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.GraphControl.CurrentItem" /> property has changed its value.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphControl.OpenFile">
      <summary>
        <para>Default implementation of <see cref="F:yWorks.Controls.Input.Commands.Open" /> that shows a <see cref="M:yWorks.Controls.GraphControl.CreateOpenFileDialog">open file dialog</see> and <see cref="M:yWorks.Controls.GraphControl.ImportFromGraphML(System.IO.Stream)">imports the GraphML</see>.</para>
      </summary>
      <remarks>
        <para>This method is called in response to the <see cref="F:yWorks.Controls.Input.Commands.Open" /> commands if <see cref="P:yWorks.Controls.GraphControl.FileOperationsEnabled" /> is <c>true</c>.</para>
        <para>Any exception thrown during loading of the GraphML file will be caught and an error message displayed to the user. For more control over error behaviour it is recommended to use <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> directly, e.g. from a custom command handler.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphControl.FileOperationsEnabled" />
      <seealso cref="M:yWorks.Controls.GraphControl.SaveFile" />
      <seealso cref="M:yWorks.Controls.GraphControl.SaveFileAs" />
      <returns>
        <para>Whether the file was successfully opened.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphControl.SaveFile">
      <summary>
        <para>Default implementation of <see cref="F:yWorks.Controls.Input.Commands.Save" /> that possibly shows a <see cref="M:yWorks.Controls.GraphControl.CreateSaveFileDialog">save file dialog</see> and <see cref="M:yWorks.Controls.GraphControl.ExportToGraphML(System.IO.Stream)">exports the GraphML</see> to the selected file or the last known file.</para>
      </summary>
      <remarks>
        <para>This method is called in response to the <see cref="F:yWorks.Controls.Input.Commands.Save" /> command if <see cref="P:yWorks.Controls.GraphControl.FileOperationsEnabled" /> is <c>true</c>.</para>
        <para>Any exception thrown during loading of the GraphML file will be caught and an error message displayed to the user. For more control over error behaviour it is recommended to use <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> directly, e.g. from a custom command handler.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphControl.FileOperationsEnabled" />
      <seealso cref="M:yWorks.Controls.GraphControl.SaveFileAs" />
      <seealso cref="M:yWorks.Controls.GraphControl.OpenFile" />
      <returns>
        <para>Whether the file was successfully saved.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphControl.SaveFileAs">
      <summary>
        <para>Default implementation of <see cref="F:yWorks.Controls.Input.Commands.SaveAs" /> that shows a <see cref="M:yWorks.Controls.GraphControl.CreateSaveFileDialog">save file dialog</see> and <see cref="M:yWorks.Controls.GraphControl.ExportToGraphML(System.IO.Stream)">exports the GraphML</see> to the selected file.</para>
      </summary>
      <remarks>
        <para>This method is called in response to the <see cref="F:yWorks.Controls.Input.Commands.SaveAs" /> and possibly <see cref="F:yWorks.Controls.Input.Commands.Save" /> commands if <see cref="P:yWorks.Controls.GraphControl.FileOperationsEnabled" /> is <c>true</c>.</para>
        <para>Any exception thrown during loading of the GraphML file will be caught and an error message displayed to the user. For more control over error behaviour it is recommended to use <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> directly, e.g. from a custom command handler.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphControl.FileOperationsEnabled" />
      <seealso cref="M:yWorks.Controls.GraphControl.SaveFile" />
      <seealso cref="M:yWorks.Controls.GraphControl.OpenFile" />
    </member>
    <member name="M:yWorks.Controls.GraphControl.CreateOpenFileDialog">
      <summary>
        <para>Helper callback method that creates the <see cref="T:System.Windows.Forms.OpenFileDialog" /> for use in the handling of the <see cref="F:yWorks.Controls.Input.Commands.Open" /> command.</para>
      </summary>
      <remarks>
        <para>The open command that is enabled if <see cref="P:yWorks.Controls.GraphControl.FileOperationsEnabled" /> is set to <c>true</c> will use this method to create the dialog for opening the files.</para>
      </remarks>
      <returns>
        <para>The preconfigured dialog to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphControl.CreateSaveFileDialog">
      <summary>
        <para>Helper callback method that creates the <see cref="T:System.Windows.Forms.SaveFileDialog" /> for use in the handling of the <see cref="F:yWorks.Controls.Input.Commands.Save" /> and <see cref="F:yWorks.Controls.Input.Commands.SaveAs" /> commands.</para>
      </summary>
      <remarks>
        <para>The save commands that are enabled if <see cref="P:yWorks.Controls.GraphControl.FileOperationsEnabled" /> is set to <c>true</c> will use this method to create the dialog for saving the files.</para>
      </remarks>
      <returns>
        <para>The preconfigured dialog to use.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphControl.SelectionIndicatorManager">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.GraphControl.SelectionIndicatorManager" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphControl.CreateSelectionIndicatorManager" /> will be called. Upon change the <see cref="M:yWorks.Controls.GraphControl.OnSelectionIndicatorManagerChanged(yWorks.Controls.SelectionIndicatorManager{yWorks.Graph.IModelItem},yWorks.Controls.SelectionIndicatorManager{yWorks.Graph.IModelItem})" /> method will be called.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphControl.OnSelectionIndicatorManagerChanged(yWorks.Controls.SelectionIndicatorManager{yWorks.Graph.IModelItem},yWorks.Controls.SelectionIndicatorManager{yWorks.Graph.IModelItem})">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.GraphControl.SelectionIndicatorManager" /> property value changes and after initialization of the field.</para>
      </summary>
      <remarks>
        <para>Configures the <see cref="P:yWorks.Controls.GraphControl.SelectionIndicatorManager" />. Overriding implementations have to call the base method.</para>
      </remarks>
      <param name="oldSelectionIndicatorManager">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newSelectionIndicatorManager">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.CreateSelectionIndicatorManager">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.GraphControl.SelectionIndicatorManager" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.GraphControl.SelectionIndicatorManager" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="T:yWorks.Controls.SelectionIndicatorManager`1" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphControl.HighlightIndicatorManager">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.GraphControl.HighlightIndicatorManager" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphControl.CreateHighlightIndicatorManager" /> will be called. Upon change the <see cref="M:yWorks.Controls.GraphControl.OnHighlightIndicatorManagerChanged(yWorks.Controls.HighlightIndicatorManager{yWorks.Graph.IModelItem},yWorks.Controls.HighlightIndicatorManager{yWorks.Graph.IModelItem})" /> method will be called.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphControl.OnHighlightIndicatorManagerChanged(yWorks.Controls.HighlightIndicatorManager{yWorks.Graph.IModelItem},yWorks.Controls.HighlightIndicatorManager{yWorks.Graph.IModelItem})">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.GraphControl.HighlightIndicatorManager" /> property value changes and after initialization of the field.</para>
      </summary>
      <remarks>
        <para>Overriding implemenations have to call the base method.</para>
      </remarks>
      <param name="oldHighlightIndicatorManager">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newHighlightIndicatorManager">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.CreateHighlightIndicatorManager">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.GraphControl.HighlightIndicatorManager" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.GraphControl.HighlightIndicatorManager" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="P:yWorks.Controls.GraphControl.HighlightIndicatorManager" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphControl.FocusIndicatorManager">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.GraphControl.FocusIndicatorManager" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphControl.CreateFocusIndicatorManager" /> will be called. Upon change the <see cref="M:yWorks.Controls.GraphControl.OnFocusIndicatorManagerChanged(yWorks.Controls.FocusIndicatorManager{yWorks.Graph.IModelItem},yWorks.Controls.FocusIndicatorManager{yWorks.Graph.IModelItem})" /> method will be called.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphControl.OnFocusIndicatorManagerChanged(yWorks.Controls.FocusIndicatorManager{yWorks.Graph.IModelItem},yWorks.Controls.FocusIndicatorManager{yWorks.Graph.IModelItem})">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.GraphControl.FocusIndicatorManager" /> property value changes and after initialization of the field.</para>
      </summary>
      <remarks>
        <para>Overriding implemenations have to call the base method.</para>
      </remarks>
      <param name="oldFocusIndicatorManager">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newFocusIndicatorManager">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.CreateFocusIndicatorManager">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.GraphControl.FocusIndicatorManager" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.GraphControl.FocusIndicatorManager" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="T:yWorks.Controls.FocusIndicatorManager`1" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphControl.GraphModelManager">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.GraphControl.GraphModelManager" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphControl.CreateGraphModelManager" /> will be called. Upon change the <see cref="M:yWorks.Controls.GraphControl.OnGraphModelManagerChanged(yWorks.Controls.GraphModelManager,yWorks.Controls.GraphModelManager)" /> method will be called.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphControl.OnGraphModelManagerChanged(yWorks.Controls.GraphModelManager,yWorks.Controls.GraphModelManager)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.GraphControl.GraphModelManager" /> property value changes and after initialization of the field.</para>
      </summary>
      <remarks>
        <para>Configures the <see cref="P:yWorks.Controls.GraphControl.GraphModelManager" />. Overriding implemenations have to call the base method.</para>
      </remarks>
      <param name="oldGraphModelManager">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newGraphModelManager">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.CreateGraphModelManager">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.GraphControl.GraphModelManager" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.GraphControl.GraphModelManager" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="T:yWorks.Controls.GraphModelManager" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphControl.Graph">
      <summary>
        <para>Gets or sets the graph that is displayed in this control.</para>
      </summary>
      <remarks>
        <para>Normally the <see cref="T:yWorks.Controls.GraphSelection" /> property must be adjusted accordingly if the graph instance is replaced. Also depending on the <see cref="T:yWorks.Controls.Input.IInputMode" /> implementation the instances used in this control might need to be replaced or adjusted, too. If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphControl.CreateGraph" /> will be called. Upon change the <see cref="M:yWorks.Controls.GraphControl.OnGraphChanged(yWorks.Graph.IGraph,yWorks.Graph.IGraph)" /> method will be called.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.GraphControl.GraphChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.GraphControl.Graph" /> property has been changed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphControl.OnGraphChanged(yWorks.Graph.IGraph,yWorks.Graph.IGraph)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.GraphControl.Graph" /> property value changes and after initialization of the field.</para>
      </summary>
      <remarks>
        <para>Configures the <see cref="T:yWorks.Controls.GraphControl" /> for the new <see cref="P:yWorks.Controls.GraphControl.Graph" /> and triggers the <see cref="E:yWorks.Controls.GraphControl.GraphChanged" /> event. Overriding implementations have to call the base method.</para>
      </remarks>
      <param name="oldGraph">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newGraph">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.CreateGraph">
      <summary>
        <para>Factory method for the Graph property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.GraphControl.Graph" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="T:yWorks.Graph.DefaultGraph" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphControl.Selection">
      <summary>
        <para>Gets or sets the selection model that is used for this control.</para>
      </summary>
      <remarks>
        <para>The selection model instance needs to be adjusted, normally if the <see cref="P:yWorks.Controls.GraphControl.Graph" /> instance is changed. If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphControl.CreateSelection" /> will be called. Upon change the <see cref="M:yWorks.Controls.GraphControl.OnSelectionChanged(yWorks.Controls.IGraphSelection,yWorks.Controls.IGraphSelection)" /> method will be called.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphControl.OnSelectionChanged(yWorks.Controls.IGraphSelection,yWorks.Controls.IGraphSelection)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.GraphControl.Selection" /> property value changes and after initialization of the field.</para>
      </summary>
      <remarks>
        <para>Overriding implementations have to call the base method.</para>
      </remarks>
      <param name="oldGraphSelection">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newGraphSelection">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.CreateSelection">
      <summary>
        <para>Factory method for the Selection property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.GraphControl.Selection" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="T:yWorks.Controls.GraphSelection" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphControl.FitGraphBounds(System.Nullable{yWorks.Geometry.InsetsD})">
      <summary>
        <para>
          <see cref="M:yWorks.Controls.CanvasControl.UpdateContentRect(yWorks.Geometry.InsetsD,yWorks.Controls.ICanvasObjectGroup)">Updates the content rectangle</see> for the <see cref="P:yWorks.Controls.CanvasControl.ContentGroup" /> considering the provided insets and <see cref="M:yWorks.Controls.CanvasControl.FitContent">adjusts the viewport to encompass the contents</see>.</para>
      </summary>
      <param name="insets" />
    </member>
    <member name="M:yWorks.Controls.GraphControl.ExportToGraphML(System.IO.Stream)">
      <summary>
        <para>Convenience method that exports the <see cref="P:yWorks.Controls.GraphControl.Graph" /> to a <see cref="T:yWorks.GraphML.GraphMLIOHandler">GraphML</see> file.</para>
      </summary>
      <remarks>
        <para>For full control over the output use the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> class. To change the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> instance used implicitly, set the <see cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" /> property.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" />
      <param name="stream">
        <para>The stream to export the graph to.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.GraphControl.GraphMLIOHandler">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> that is used for the various I/O methods as well as the <see cref="F:yWorks.Controls.Input.Commands.Save" />, <see cref="F:yWorks.Controls.Input.Commands.SaveAs" />, and <see cref="F:yWorks.Controls.Input.Commands.Open" /> commands.</para>
      </summary>
      <remarks>
        <para>Querying the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method for <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> will return the value of this property.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphControl.ExportToGraphML(System.String)">
      <summary>
        <para>Convenience method that exports the <see cref="P:yWorks.Controls.GraphControl.Graph" /> to a <see cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler">GraphML</see> file.</para>
      </summary>
      <remarks>
        <para>For full control over the output use the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> class. To change the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> instance used implicitly, set the <see cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" /> property.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" />
      <param name="filename">
        <para>The file name to export the graph to.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.ExportToGraphML(System.IO.TextWriter)">
      <summary>
        <para>Convenience method that exports the <see cref="P:yWorks.Controls.GraphControl.Graph" /> to a <see cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler">GraphML</see> file.</para>
      </summary>
      <remarks>
        <para>For full control over the output use the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> class. To change the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> instance used implicitly, set the <see cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" /> property.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" />
      <param name="writer">
        <para>The writer to export the graph to.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.ImportFromGraphML(System.IO.FileInfo)">
      <summary>
        <para>Convenience method that imports the <see cref="P:yWorks.Controls.GraphControl.Graph" /> from a <see cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler">GraphML</see> file.</para>
      </summary>
      <remarks>
        <para>For full control over the input use the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> class. To change the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> instance used implicitly, set the <see cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" /> property.</para>
        <para>After the graph has been loaded the <see cref="P:yWorks.Controls.CanvasControl.Viewport" /> will be <see cref="M:yWorks.Controls.GraphControl.FitGraphBounds(System.Nullable{yWorks.Geometry.InsetsD})">updated</see> to display the entire graph. If undo is enabled the <see cref="P:yWorks.Controls.GraphControl.Graph" />'s <see cref="T:yWorks.Graph.UndoEngine" /> will be <see cref="M:yWorks.Graph.UndoEngine.Clear">cleared</see>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" />
      <param name="fileInfo">
        <para>The file of the GraphML file to read the graph from.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.ImportFromGraphML(System.String)">
      <summary>
        <para>Convenience method that imports the <see cref="P:yWorks.Controls.GraphControl.Graph" /> from a <see cref="T:yWorks.GraphML.GraphMLIOHandler">GraphML</see> file.</para>
      </summary>
      <remarks>
        <para>For full control over the input use the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> class. To change the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> instance used implicitly, set the <see cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" /> property.</para>
        <para>After the graph has been loaded the <see cref="P:yWorks.Controls.CanvasControl.Viewport" /> will be <see cref="M:yWorks.Controls.GraphControl.FitGraphBounds(System.Nullable{yWorks.Geometry.InsetsD})">updated</see> to display the entire graph. If undo is enabled the <see cref="P:yWorks.Controls.GraphControl.Graph" />'s undo engine will be <see cref="M:yWorks.Graph.UndoEngine.Clear">cleared</see>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" />
      <param name="filename">
        <para>The file of the GraphML file to read the graph from.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.ImportFromGraphML(System.IO.Stream)">
      <summary>
        <para>Convenience method that imports the <see cref="P:yWorks.Controls.GraphControl.Graph" /> from a <see cref="T:yWorks.GraphML.GraphMLIOHandler">GraphML</see> file.</para>
      </summary>
      <remarks>
        <para>For full control over the input use the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> class. To change the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> instance used implicitly, set the <see cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" /> property.</para>
        <para>After the graph has been loaded the <see cref="P:yWorks.Controls.CanvasControl.Viewport" /> will be <see cref="M:yWorks.Controls.GraphControl.FitGraphBounds(System.Nullable{yWorks.Geometry.InsetsD})">updated</see> to display the entire graph. If undo is enabled the <see cref="P:yWorks.Controls.GraphControl.Graph" />'s undo engine will be <see cref="M:yWorks.Graph.UndoEngine.Clear">cleared</see>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" />
      <param name="stream">
        <para>The stream to read the graph from.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphControl.ImportFromGraphML(System.IO.TextReader)">
      <summary>
        <para>Convenience method that imports the <see cref="P:yWorks.Controls.GraphControl.Graph" /> from a <see cref="T:yWorks.GraphML.GraphMLIOHandler">GraphML</see> file.</para>
      </summary>
      <remarks>
        <para>For full control over the input use the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> class. To change the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> instance used implicitly, set the <see cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" /> property.</para>
        <para>After the graph has been loaded the <see cref="P:yWorks.Controls.CanvasControl.Viewport" /> will be <see cref="M:yWorks.Controls.GraphControl.FitGraphBounds(System.Nullable{yWorks.Geometry.InsetsD})">updated</see> to display the entire graph. If undo is enabled the <see cref="P:yWorks.Controls.GraphControl.Graph" />'s undo engine will be <see cref="M:yWorks.Graph.UndoEngine.Clear">cleared</see>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphControl.GraphMLIOHandler" />
      <param name="reader">
        <para>The reader to read the graph from.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.GraphControl.FileOperationsEnabled">
      <summary>
        <para>Gets or sets a value indicating whether integrated handling of commands for <see cref="F:yWorks.Controls.Input.Commands.Open" />/<see cref="F:yWorks.Controls.Input.Commands.Save" />/<see cref="F:yWorks.Controls.Input.Commands.SaveAs" /> is enabled.</para>
      </summary>
      <remarks>
        <para>By default this feature is disabled.</para>
        <para>Setting this property to <c>true</c> enables handling of the following commands:</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.Open" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.Save" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.SaveAs" />
          </item>
        </list>
        <para>Note that this doesn't affect the convenience methods <see cref="M:yWorks.Controls.GraphControl.ImportFromGraphML(System.String)" />, <see cref="M:yWorks.Controls.GraphControl.ExportToGraphML(System.String)" /> and their overloads.</para>
        <para>The default implementations delegate to the <see cref="M:yWorks.Controls.GraphControl.OpenFile" />, <see cref="M:yWorks.Controls.GraphControl.SaveFile" /> and <see cref="M:yWorks.Controls.GraphControl.SaveFileAs" /> methods respectively.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the commands are enabled; <c>false</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Controls.GraphControl.CreateOpenFileDialog" />
      <seealso cref="M:yWorks.Controls.GraphControl.CreateSaveFileDialog" />
      <seealso cref="M:yWorks.Controls.GraphControl.OpenFile" />
      <seealso cref="M:yWorks.Controls.GraphControl.SaveFile" />
      <seealso cref="M:yWorks.Controls.GraphControl.SaveFileAs" />
    </member>
    <member name="P:yWorks.Controls.GraphControl.Clipboard">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.GraphClipboard" /> associated with this control.</para>
      </summary>
      <remarks>
        <para>If no instance has been configured with this control, a default implementation will be used.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphControl.CreateGraphClipboard">
      <summary>
        <para>Creates the default instance to use if no custom instance has been set.</para>
      </summary>
      <returns>
        <para>A default <see cref="T:yWorks.Graph.GraphClipboard" /> instance.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.GraphOverviewControl">
      <summary>
        <para>Convenience control implementation that shows an overview of an <see cref="T:yWorks.Graph.IGraph" /> contained in another <see cref="P:yWorks.Controls.GraphOverviewControl.GraphControl" />.</para>
      </summary>
      <remarks>
        <para>This control uses a <see cref="P:yWorks.Controls.GraphOverviewControl.GraphVisualCreator" /> to display the graph in a preview mode and an <see cref="P:yWorks.Controls.GraphOverviewControl.OverviewInputMode" /> to allow for easily navigating in the <see cref="P:yWorks.Controls.GraphOverviewControl.GraphControl" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphOverviewControl.#ctor">
      <summary>
        <para>Creates a new instance that is not bound to a control</para>
      </summary>
      <remarks>
        <para>In order to be useful, either the <see cref="P:yWorks.Controls.GraphOverviewControl.GraphControl" /> or the <see cref="P:yWorks.Controls.GraphOverviewControl.Graph" /> property need to be set.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphOverviewControl.#ctor(yWorks.Controls.GraphControl)">
      <summary>
        <para>Creates a new instance that is initially bound to the given control.</para>
      </summary>
      <param name="graphControl">
        <para>The <see cref="T:yWorks.Controls.GraphControl" /> that is initially bound to this control.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.GraphOverviewControl.GraphVisualCreator">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.OverviewGraphVisualCreator" /> that is used to render the over view graph.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.GraphOverviewControl.OverviewInputMode">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.OverviewInputMode" /> that is used to navigate the client control.</para>
      </summary>
      <remarks>
        <para>Setting this property will automatically update the <see cref="P:yWorks.Controls.Input.OverviewInputMode.ClientCanvas" /> property of the new <see cref="T:yWorks.Controls.Input.OverviewInputMode" />.</para>
        <para>This property is merely a convenience alias for the <see cref="P:yWorks.Controls.CanvasControl.InputMode" /> property. Setting either this property or the <see cref="P:yWorks.Controls.CanvasControl.InputMode" /> property has the same effect if the input mode is an <see cref="T:yWorks.Controls.Input.OverviewInputMode" />. On the other hand, if an input mode is set that is not an <see cref="T:yWorks.Controls.Input.OverviewInputMode" />, then the value of this property is <c>null</c></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.GraphOverviewControl.Graph">
      <summary>
        <para>Gets or sets the graph that is rendered in the overview.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphOverviewControl.OnInputModeChanged(yWorks.Controls.Input.IInputMode,yWorks.Controls.Input.IInputMode)">
      <param name="oldInputMode" />
      <param name="newInputMode" />
    </member>
    <member name="M:yWorks.Controls.GraphOverviewControl.CreateGraphVisualCreator(yWorks.Graph.IGraph)">
      <summary>
        <para>Factory method that creates the <see cref="T:yWorks.Controls.IVisualCreator" /> that renders the preview of the graph.</para>
      </summary>
      <param name="graph">
        <para>The graph to draw.</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Controls.IVisualCreator" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphOverviewControl.GraphControl">
      <summary>
        <para>Gets or sets the client control, that will be used to retrieve the graph from and that will be used for navigating.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphOverviewControl.Dispose(System.Boolean)">
      <param name="disposing" />
    </member>
    <member name="T:yWorks.Controls.GridInfo">
      <summary>
        <para>This class describes a grid by providing the grid's origin as well as the horizontal and vertical spacing between the grid points.</para>
      </summary>
      <remarks>
        <para>It is used by the <see cref="T:yWorks.Controls.Input.IGridConstraintProvider`1" /> as well as by the <c>GridSnapResultVisualCreator&lt;T&gt;</c></para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.IGridConstraintProvider`1" />
    </member>
    <member name="M:yWorks.Controls.GridInfo.#ctor(System.Double)">
      <summary>
        <para>Creates a new instance using "25" as the grid spacing.</para>
      </summary>
      <param name="spacing">
        <para>The horizontal and vertical spacing between the grid points.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GridInfo.#ctor(System.Double,System.Double,yWorks.Geometry.PointD)">
      <summary>
        <para>Creates a new instance using the given horizontal and vertical grid spacing as well as the given origin.</para>
      </summary>
      <param name="horizontalSpacing">
        <para>The horizontal spacing between the grid points.</para>
      </param>
      <param name="verticalSpacing">
        <para>The vertical spacing between the grid points.</para>
      </param>
      <param name="origin">
        <para>The canonic origin of the grid.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.GridInfo.HorizontalSpacing">
      <summary>
        <para>Gets or sets the horizontal spacing between grid points in the world coordinate system.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.GridInfo.VerticalSpacing">
      <summary>
        <para>Gets or sets the vertical spacing between grid points in the world coordinate system.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.GridInfo.Origin">
      <summary>
        <para>Gets or sets the canonic origin of the grid.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.GridSnapTypes">
      <summary>
        <para>The values of this enum describe to which grid elements an object shall snap.</para>
      </summary>
      <remarks>
        <para>It can be used for the GraphSnapContext's GridSnapType property to determine what <see cref="T:yWorks.Controls.Input.SnapResult" />s shall be created for the set <see cref="T:yWorks.Controls.Input.IGridConstraintProvider`1" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.GridSnapTypes.None">
      <summary>
        <para>There is no grid snapping at all.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.GridSnapTypes.HorizontalLines">
      <summary>
        <para>Elements shall be snapped to horizontal grid lines.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.GridSnapTypes.VerticalLines">
      <summary>
        <para>Elements shall be snapped to vertical grid lines.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.GridSnapTypes.Lines">
      <summary>
        <para>Elements shall be snapped to horizontal and vertical grid lines.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.GridSnapTypes.GridPoints">
      <summary>
        <para>Elements shall be snapped to grid points.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.GridSnapTypes.All">
      <summary>
        <para>Elements shall be snapped to horizontal and vertical grid lines as well as to grid points.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.IHitTester`1">
      <summary>
        <para>An interface that can enumerate hits of a given type for a certain position in world coordinates.</para>
      </summary>
      <typeparam name="T">
        <para>the type of hits returned by the enumerator</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.Input.IHitTester`1.EnumerateHits(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Yields an enumerable that enumerates the hits for a given world coordinate.</para>
      </summary>
      <param name="context">
        <para>The context in which to perform the hit testing.</para>
      </param>
      <param name="location">
        <para>the coordinates in the world coordinate system</para>
      </param>
      <returns>
        <para>an enumerable that yields hits for the given coordinates</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.ICanvasContext">
      <summary>
        <para>This interface describes the context for many operations performed on items in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>This interface extends the <see cref="T:yWorks.Graph.ILookup" /> interface to provide <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)">dynamic lookup capability</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ICanvasContext.Zoom">
      <summary>
        <para>Gets the current zoom level that is the ratio of world coordinates to screen pixels.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ICanvasContext.Scale">
      <summary>
        <para>Gets the current scale, that is, an additional scaling factor that enlarges everything in the view.</para>
      </summary>
      <remarks>
        <para>This usually represents <see cref="P:yWorks.Controls.ICanvasContext.CanvasControl" />.<see cref="P:yWorks.Controls.CanvasControl.Scale" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ICanvasContext.HitTestRadius">
      <summary>
        <para>Gets the radius for hit tests and marquee selection tests in world coordinates.</para>
      </summary>
      <remarks>
        <para>This value already takes the zoom level into account.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ICanvasContext.CanvasControl">
      <summary>
        <para>Gets the Canvas that is associated with this context.</para>
      </summary>
      <remarks>
        <para>This value may be null in those cases where no control can be associated with the current context.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.ICanvasObject">
      <summary>
        <para>This is the interface implemented by the basic building blocks of a scene graph in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>The interface is not meant to be implemented by application programmers. Instead, instances implementing this interface can be retrieved from the factory methods in the canvas control.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ICanvasObject.Visible">
      <summary>
        <para>Gets or sets the visibility state of this instance.</para>
      </summary>
      <remarks>
        <para>If an ICanvasObject is not visible, it will not be considered for hit tests.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ICanvasObject.Dirty">
      <summary>
        <para>Gets or sets a flag that indicates whether <see cref="T:yWorks.Controls.ICanvasObject" /> needs to be updated during the next call to <see cref="M:yWorks.Controls.CanvasControl.RenderContent(yWorks.Controls.IRenderContext,System.Drawing.Graphics)" />.</para>
      </summary>
      <remarks>
        <para>Note that it is up to the implementation of the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> to determine the actual dirty state of this instance. <see cref="M:yWorks.Controls.ICanvasObjectDescriptor.IsDirty(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObject)" /> can use any strategy to indicate dirtiness. The <see cref="T:yWorks.Controls.CanvasControl" /> will reset this flag during <see cref="M:yWorks.Controls.CanvasControl.RenderContent(yWorks.Controls.IRenderContext,System.Drawing.Graphics)" /> to <c>false</c> if the visual is created or updated.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if dirty; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.ICanvasObject.Group">
      <summary>
        <para>Gets or sets the parent group of this instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ICanvasObject.UserObject">
      <summary>
        <para>Gets or sets the user object associated with this instance.</para>
      </summary>
      <remarks>
        <para>The user object will be used by the <see cref="P:yWorks.Controls.ICanvasObject.Descriptor" /> during rendering, hit testing, and bounds calculation</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ICanvasObject.Descriptor">
      <summary>
        <para>Gets or sets the descriptor instance that interprets the <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> during rendering, hit testing, and bounds calculation.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ICanvasObject.ToFront">
      <summary>
        <para>Moves this instance to the end of the group rendering list, so that it will be painted in front of all other items in the same group.</para>
      </summary>
      <remarks>
        <para>As a convenience, this method returns the current instance so that calls can be conveniently chained, e.g. <c>object.ToFront().Lower()</c></para>
      </remarks>
      <returns>
        <para>
          <c>this</c> so that calls can be chained.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ICanvasObject.ToBack">
      <summary>
        <para>Moves this instance to the beginning of the group rendering list, so that it will be painted behind all other items in the same group.</para>
      </summary>
      <remarks>
        <para>As a convenience, this method returns the current instance so that calls can be conveniently chained, e.g. <c>object.ToBack().Raise().Raise()</c></para>
      </remarks>
      <returns>
        <para>
          <c>this</c> so that calls can be chained.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ICanvasObject.Raise">
      <summary>
        <para>Moves this instance one step closer to the end of the group rendering list, so that it will be painted on top of its current successor.</para>
      </summary>
      <remarks>
        <para>As a convenience, this method returns the current instance so that calls can be conveniently chained, e.g. <c>object.Raise().Raise().Raise()</c></para>
      </remarks>
      <returns>
        <para>
          <c>this</c> so that calls can be chained.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ICanvasObject.Lower">
      <summary>
        <para>Moves this instance one step closer to the beginning of the group rendering list, so that it will be painted behind its current predecessor.</para>
      </summary>
      <remarks>
        <para>As a convenience, this method returns the current instance so that calls can be conveniently chained, e.g. <c>object.Lower().Lower()</c></para>
      </remarks>
      <returns>
        <para>
          <c>this</c> so that calls can be chained.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ICanvasObject.Above(yWorks.Controls.ICanvasObject)">
      <summary>
        <para>Moves this instance exactly behind the reference item in the referenced item's group rendering list, so that it will be painted directly above the given reference.</para>
      </summary>
      <remarks>
        <para>This method returns the current instance so that calls can be chained, e.g. <c>object.Above(other).Raise()</c>.</para>
        <para>Observe that this instance will move into the referenced item's group if needed.</para>
      </remarks>
      <returns>
        <para>
          <c>this</c> so that calls can be chained.</para>
      </returns>
      <param name="reference" />
    </member>
    <member name="M:yWorks.Controls.ICanvasObject.Below(yWorks.Controls.ICanvasObject)">
      <summary>
        <para>Moves this instance exactly before the reference item in the referenced item's group rendering list, so that it will be painted directly behind the given reference.</para>
      </summary>
      <remarks>
        <para>This method returns the current instance so that calls can be chained, e.g. <c>object.Below(other).Lower()</c>.</para>
        <para>Observe that this instance will move into the referenced item's group if needed.</para>
      </remarks>
      <returns>
        <para>
          <c>this</c> so that calls can be chained.</para>
      </returns>
      <param name="reference" />
    </member>
    <member name="P:yWorks.Controls.ICanvasObject.Next">
      <summary>
        <para>Gets the next item in the list of rendered items that is owned by this element's <see cref="P:yWorks.Controls.ICanvasObject.Group" />.</para>
      </summary>
      <remarks>
        <para>The returned item will be rendered after this item is rendered. If this item is the last one in the list, this method returns <c>null</c>.</para>
      </remarks>
      <returns>
        <para>
          <c>null</c> if this item is last in the rendering list of its group or the next item otherwise.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.ICanvasObject.Previous">
      <summary>
        <para>Gets the previous item in the list of rendered items that is owned by this element's <see cref="P:yWorks.Controls.ICanvasObject.Group" />.</para>
      </summary>
      <remarks>
        <para>The returned item will be rendered directly before this item is rendered. If this item is the first one in the list, this method returns <c>null</c>.</para>
      </remarks>
      <returns>
        <para>
          <c>null</c> if this item is first in the rendering list of its group or the previous item otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ICanvasObject.Invalidate">
      <summary>
        <para>Marks this item as in need of validation.</para>
      </summary>
      <remarks>
        <para>If this item is currently visible in a CanvasControl, the control will be invalidated.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.ICanvasObject.Remove">
      <summary>
        <para>Removes this item from the scene graph it currently belongs to.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.ICanvasObjectDescriptor">
      <summary>
        <para>Central interface used by the <see cref="T:yWorks.Controls.CanvasControl" /> to render elements from the scene graph.</para>
      </summary>
      <remarks>
        <para>Implementations will be queried using the user object obtained from <see cref="P:yWorks.Controls.ICanvasObject.UserObject" /> for the corresponding implementations of the various aspects of the user object. Implementations of this interface need to be provided by the application programmer to <see cref="T:yWorks.Controls.ICanvasObjectGroup" />'s <see cref="M:yWorks.Controls.ICanvasObjectGroup.AddChild(System.Object,yWorks.Controls.ICanvasObjectDescriptor)" /> method.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.CanvasObjectDescriptors" />
    </member>
    <member name="M:yWorks.Controls.ICanvasObjectDescriptor.GetVisualCreator(System.Object)">
      <summary>
        <para>Returns an implementation of <see cref="T:yWorks.Controls.IVisualCreator" /> that will create the <see cref="T:yWorks.Controls.IVisual" /> tree for the user object.</para>
      </summary>
      <remarks>
        <para>This method may always return the same instance. By contract, clients will not cache instances returned, but will always call this method before the methods on the instance will be called. This contract enables the use of the fly-weight design pattern. Implementations of this class can always return the same instance and reconfigure this instance upon each call to this method.</para>
      </remarks>
      <param name="forUserObject">
        <para>the user object to create an <see cref="T:yWorks.Controls.IVisual" /> for</para>
      </param>
      <returns>
        <para>An implementation of <see cref="T:yWorks.Controls.IVisualCreator" /> or <c>null</c> if nothing shall be rendered</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ICanvasObjectDescriptor.IsDirty(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObject)">
      <summary>
        <para>Determines whether the given canvas object is deemed dirty and needs updating.</para>
      </summary>
      <param name="context">
        <para>The context that will be used for the update.</para>
      </param>
      <param name="canvasObject">
        <para>The object to check.</para>
      </param>
      <returns>
        <para>Whether an update is needed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ICanvasObjectDescriptor.GetBoundsProvider(System.Object)">
      <summary>
        <para>Returns an implementation of <see cref="T:yWorks.Controls.IBoundsProvider" /> that can determine the visible bounds of the rendering of the user object.</para>
      </summary>
      <remarks>
        <para>This method may always return the same instance. By contract, clients will not cache instances returned, but will always call this method before the methods on the instance will be called. This contract enables the use of the fly-weight design pattern. Implementations of this class can always return the same instance and reconfigure this instance upon each call to this method.</para>
      </remarks>
      <param name="forUserObject">
        <para>the user object to query the bounds for</para>
      </param>
      <returns>
        <para>An implementation of <see cref="T:yWorks.Controls.IBoundsProvider" /> to determine the bounds of the visualization.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ICanvasObjectDescriptor.GetVisibilityTestable(System.Object)">
      <summary>
        <para>Returns an implementation of <see cref="T:yWorks.Controls.IVisibilityTestable" /> that can determine if the rendering of the user object would be visible in a given context.</para>
      </summary>
      <remarks>
        <para>This method may always return the same instance. By contract clients will not cache instances returned but will always call this method before the methods on the instance will be called. This contract enables the use of the fly-weight design pattern. Implementations of this class can always return the same instance and reconfigure this instance upon each call to this method.</para>
      </remarks>
      <param name="forUserObject">
        <para>the user object to query visibility for</para>
      </param>
      <returns>
        <para>An implementation of <see cref="T:yWorks.Controls.IVisibilityTestable" /> to determine visibility.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ICanvasObjectDescriptor.GetHitTestable(System.Object)">
      <summary>
        <para>Returns an implementation of <see cref="T:yWorks.Controls.Input.IHitTestable" /> that can determine whether the rendering of the user object has been hit at a given coordinate.</para>
      </summary>
      <remarks>
        <para>This method may always return the same instance. By contract, clients will not cache instances returned, but will always call this method before the methods on the instance will be called. This contract enables the use of the fly-weight design pattern. Implementations of this class can always return the same instance and reconfigure this instance upon each call to this method.</para>
      </remarks>
      <param name="forUserObject">
        <para>the user object to do the hit testing for</para>
      </param>
      <returns>
        <para>An implementation of <see cref="T:yWorks.Controls.Input.IHitTestable" /> to determine visibility.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.ICanvasObjectGroup">
      <summary>
        <para>This is the interface implemented by the composite building blocks of a scene graph in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>It is meant to group multiple <see cref="T:yWorks.Controls.ICanvasObject" /> instances as a logic unit. The interface is not meant to be implemented by application programmers. Instances implementing this interface can be retrieved from the factory methods in the canvas control. The interface extends the <see cref="T:yWorks.Utils.IListEnumerable`1" /> interface to allow for easy iteration and determination of the size of the group.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ICanvasObjectGroup.First">
      <summary>
        <para>Gets the first item in the rendering list of this group or <c>null</c>.</para>
      </summary>
      <remarks>
        <para>This is the item that will be rendered first, i.e. behind all of the other items in the rendering list. In order to iterate over all immediate children, use the following idiom:</para>
      </remarks>
      <seealso cref="T:yWorks.Utils.IListEnumerable`1" />
      <seealso cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
    </member>
    <member name="P:yWorks.Controls.ICanvasObjectGroup.Last">
      <summary>
        <para>Gets the last item in the rendering list of this group or <c>null</c>.</para>
      </summary>
      <remarks>
        <para>This is the item that will be on top of all other items in the list. In order to iterate over all immediate children in reverse order, use the following idiom:</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.ICanvasObjectGroup.AddChild(System.Object,yWorks.Controls.ICanvasObjectDescriptor)">
      <summary>
        <para>Adds a child element to the scene graph as a child of this group.</para>
      </summary>
      <remarks>
        <para>The descriptor will be queried for the various rendering related implementations for the given <paramref name="userObject" /> at rendering time.</para>
      </remarks>
      <param name="userObject">
        <para>The user object to associate with this child element. This object will be passed to the <paramref name="descriptor" />'s methods.</para>
      </param>
      <param name="descriptor">
        <para>An implementation of the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> interface that will be passed the <paramref name="userObject" /> to provide the various implementations that are used during rendering.</para>
      </param>
      <returns>
        <para>A handle that can be used to control the rendering order and to later <see cref="M:yWorks.Controls.ICanvasObject.Remove">remove</see> the element from the scene graph, again.</para>
      </returns>
      <seealso cref="T:yWorks.Controls.ICanvasObjectDescriptor" />
      <seealso cref="F:yWorks.Controls.CanvasObjectDescriptors.DynamicDirtyInstance" />
    </member>
    <member name="M:yWorks.Controls.ICanvasObjectGroup.AddGroup">
      <summary>
        <para>Adds a new <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> to this group in the current scene graph.</para>
      </summary>
      <remarks>
        <para>This can be used to build groups of <see cref="T:yWorks.Controls.ICanvasObject" /> instances that can be moved within the scene graph or whose <see cref="P:yWorks.Controls.ICanvasObject.Visible">visibility</see> can be controlled easily. The group will have a <c>null</c> <see cref="P:yWorks.Controls.ICanvasObject.UserObject" />.</para>
      </remarks>
      <returns>
        <para>A handle to the newly created group that can be used to control the rendering order and to later <see cref="M:yWorks.Controls.ICanvasObject.Remove">remove</see> the group from the scene graph, again.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.EmfImageExporter">
      <summary>
        <para>This class exports the contents of a <see cref="T:yWorks.Controls.CanvasControl" /> to a <see cref="T:System.IO.Stream" /> in Windows Enhanced Metafile (EMF) format.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.EmfImageExporter.#ctor(yWorks.Controls.ContextConfigurator)">
      <summary>
        <para>Creates a new instance of class <see cref="T:yWorks.Controls.EmfImageExporter" /> for the given <see cref="T:yWorks.Controls.ContextConfigurator" /> instance.</para>
      </summary>
      <param name="configuration">
        <para>the configuration</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.EmfImageExporter.Configurator">
      <summary>
        <para>Gets the used configuration.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.EmfImageExporter.Export(yWorks.Controls.CanvasControl,System.IO.Stream)">
      <summary>
        <para>Exports a part of the given <see cref="T:yWorks.Controls.CanvasControl" /> to the given <see cref="T:System.IO.Stream" />.</para>
      </summary>
      <param name="canvas">
        <para>the <see cref="T:yWorks.Controls.CanvasControl" /></para>
      </param>
      <param name="exportStream">
        <para>the <see cref="T:System.IO.Stream" /></para>
      </param>
      <remarks>
        <para>This takes the context parameters from the <see cref="P:yWorks.Controls.EmfImageExporter.Configurator" /> into account.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.EmfImageExporter.FillBackground">
      <summary>
        <para>Whether to fill the background of the emf or leave it transparent.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.XamlAttributeWritePolicy">
      <summary>
        <para>Enumeration that controls whether properties should be written as elements or attributes.</para>
      </summary>
      <seealso cref="P:yWorks.GraphML.GraphMLAttribute.WriteAsAttribute" />
      <seealso cref="T:yWorks.GraphML.XamlSerializer" />
    </member>
    <member name="F:yWorks.GraphML.XamlAttributeWritePolicy.Auto">
      <summary>
        <para>Specifies that the write mode of a member should be determined automatically according to the current property value and the presence of <see cref="T:System.ComponentModel.TypeConverter" />s, <see cref="T:System.Windows.Markup.ValueSerializer" />s and the like.</para>
      </summary>
      <remarks>
        <para>Usually, an implementation would write the member as attribute if the content can somehow be (directly or indirectly) converted to a valid XML attribute content (i.e. a simple string)</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.XamlAttributeWritePolicy.Never">
      <summary>
        <para>Never write as a XML attribute, even if a possible conversion exists.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.XamlAttributeWritePolicy.Always">
      <summary>
        <para>Always write as XML attribute.</para>
      </summary>
      <remarks>
        <para>This can be used for special cases where the default implementation does not detect a valid conversion, but some part of the (de)serialization is handled manually.</para>
      </remarks>
    </member>
    <member name="T:yWorks.GraphML.GraphMLSharingPolicy">
      <summary>
        <para>Enumeration that controls whether resources should be shared or not.</para>
      </summary>
      <seealso cref="P:yWorks.GraphML.GraphMLAttribute.Shareable" />
      <seealso cref="T:yWorks.GraphML.XamlSerializer" />
    </member>
    <member name="F:yWorks.GraphML.GraphMLSharingPolicy.Auto">
      <summary>
        <para>Specifies that the share mode of a member should be determined automatically according to the current property value.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.GraphMLSharingPolicy.Never">
      <summary>
        <para>Never share the object.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.GraphMLSharingPolicy.Always">
      <summary>
        <para>Always share the object.</para>
      </summary>
      <remarks>
        <para>This will also always place the object in the resources section, even if it only occurs once in the document.</para>
      </remarks>
    </member>
    <member name="T:yWorks.GraphML.GraphMLAttribute">
      <summary>
        <para>Custom attribute to control specific aspects of GraphML deserialization.</para>
      </summary>
      <remarks>
        <para>The specialized <see cref="T:yWorks.GraphML.XamlSerializer" /> will evaluate this attribute to override its built in serialization rules. The main use cases for this attribute are to override object reference sharing, configure consistent member naming and handle legacy serialization.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.XamlSerializer" />
    </member>
    <member name="P:yWorks.GraphML.GraphMLAttribute.Name">
      <summary>
        <para>Gets or sets the name of the attributed member.</para>
      </summary>
      <remarks>
        <para>This will be used as the XML element or XML attribute name.</para>
        <para>This property should only be used to rename members. To rename type declarations please use <see cref="M:yWorks.GraphML.GraphMLIOHandler.AddXamlNamespaceMapping(System.String,System.String,System.Type)" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.GraphMLAttribute.XmlNamespace">
      <summary>
        <para>Gets or sets the XML namespace URI for the attributed member.</para>
      </summary>
      <remarks>
        <para>This will be used as the XML namespace URI for the XML element or XML attribute.</para>
        <para>This property should only be used to rename members. To rename type declarations please use <see cref="M:yWorks.GraphML.GraphMLIOHandler.AddXamlNamespaceMapping(System.String,System.String,System.Type)" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.GraphMLAttribute.WriteEnclosingTag">
      <summary>
        <para>Gets or sets whether an enclosing tag for the property itself is written.</para>
      </summary>
      <remarks>
        <para>If <c>true</c>, the resulting XML will look like</para>
        <code>&lt;ParentObjectName.Name&gt;
   &lt;PropertyTypeName&gt;
      content
   &lt;/PropertyTypeName&gt;
&lt;/ParentObjectName.Name&gt;</code>
        <para>Default value is <c>true</c>.</para>
        <para>This property is ignored if the attribute targets a type declaration.</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.GraphMLAttribute.WriteAsAttribute">
      <summary>
        <para>Gets or sets whether the member should be written as an XML element or as an XML attribute.</para>
      </summary>
      <remarks>
        <para>Default value is <see cref="F:yWorks.GraphML.XamlAttributeWritePolicy.Auto" />.</para>
        <para>This property is ignored if the attribute targets a type declaration.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.XamlAttributeWritePolicy" />
    </member>
    <member name="P:yWorks.GraphML.GraphMLAttribute.Shareable">
      <summary>
        <para>Gets or sets whether the object reference identity of the property values should be kept intact.</para>
      </summary>
      <remarks>
        <para>Default value is <see cref="F:yWorks.GraphML.GraphMLSharingPolicy.Auto" />.</para>
        <para>This property is ignored if the attribute targets a type declaration.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.IImageExporter">
      <summary>
        <para>This is an interface for classes exporting the contents of a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.IImageExporter.Configurator">
      <summary>
        <para>Gets the configurator used for the export.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.IImageExporter.Export(yWorks.Controls.CanvasControl,System.IO.Stream)">
      <summary>
        <para>Exports part of the given <see cref="T:yWorks.Controls.CanvasControl" /> instance to the given <see cref="T:System.IO.Stream" /> instance using the <see cref="P:yWorks.Controls.IImageExporter.Configurator" />.</para>
      </summary>
      <param name="canvas">
        <para>the <see cref="T:yWorks.Controls.CanvasControl" /> to export from</para>
      </param>
      <param name="stream">
        <para>the <see cref="T:System.IO.Stream" /> to export to</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.PixelImageExporter">
      <summary>
        <para>This class exports the contents of a <see cref="T:yWorks.Controls.CanvasControl" /> to a <see cref="T:System.IO.Stream" /> using a pixel based image format.</para>
      </summary>
      <remarks>
        <para>The supported formats are JPEG, PNG, TIFF, GIF and BMP.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.PixelImageExporter.GetOutputFormats">
      <summary>
        <para>Returns a list of supported output formats.</para>
      </summary>
      <returns>
        <para>the supported output formats</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.PixelImageExporter.GetExtensionsForFormat(System.String)">
      <summary>
        <para>Returns a list of file name extensions for a given format.</para>
      </summary>
      <param name="format">
        <para>the format</para>
      </param>
      <returns>
        <para>extensions for the given format</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.PixelImageExporter.GetOutputFormat(System.String)">
      <summary>
        <para>Returns an output format supported by this class for a given file name based on its extension.</para>
      </summary>
      <param name="filename">
        <para>the file name</para>
      </param>
      <returns>
        <para>the supported output format or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.PixelImageExporter.IsValidOutputFormat(System.String)">
      <summary>
        <para>Returns whether the given format is valid for this class.</para>
      </summary>
      <param name="formatString">
        <para>the format</para>
      </param>
      <returns>
        <para>
          <c>true</c> if and only if the format is valid</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.PixelImageExporter.#ctor(yWorks.Controls.ContextConfigurator)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Controls.PixelImageExporter" /> for the given configurator.</para>
      </summary>
      <param name="configurator">
        <para>the configurator</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.PixelImageExporter.SmoothingMode">
      <summary>
        <para>Gets or sets <see cref="P:System.Drawing.Graphics.SmoothingMode" /> set on the <see cref="T:System.Drawing.Graphics" /> object.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:System.Drawing.Drawing2D.SmoothingMode.Default" /></para>
      </remarks>
      <value>
        <para>The smoothing mode to use for the graphics.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.PixelImageExporter.PixelOffsetMode">
      <summary>
        <para>Gets or sets <see cref="P:System.Drawing.Graphics.PixelOffsetMode" /> set on the <see cref="T:System.Drawing.Graphics" /> object.</para>
      </summary>
      <remarks>
        <para>If the value is set to <see cref="F:System.Drawing.Drawing2D.PixelOffsetMode.Invalid" />, the value will not be changed.</para>
      </remarks>
      <value>
        <para>The pixel offset mode to use for the graphics.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.PixelImageExporter.InterpolationMode">
      <summary>
        <para>Gets or sets <see cref="P:System.Drawing.Graphics.InterpolationMode" /> set on the <see cref="T:System.Drawing.Graphics" /> object.</para>
      </summary>
      <remarks>
        <para>If the value is set to <see cref="F:System.Drawing.Drawing2D.InterpolationMode.Invalid" />, the value will not be changed.</para>
      </remarks>
      <value>
        <para>The interpolation mode to use for the graphics.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.PixelImageExporter.TextRenderingHint">
      <summary>
        <para>Gets or sets the <see cref="P:System.Drawing.Graphics.TextRenderingHint" /> set on the <see cref="T:System.Drawing.Graphics" /> object.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:System.Drawing.Text.TextRenderingHint.SystemDefault" /></para>
      </remarks>
      <value>
        <para>The text rendering hint.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.PixelImageExporter.Configurator">
      <summary>
        <para>Gets the used configurator.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.PixelImageExporter.OutputFormat">
      <summary>
        <para>Gets or sets the output format to use.</para>
      </summary>
      <remarks>
        <para>The supported formats contain the following formats.</para>
        <list type="bullet">
          <item>
            <c>"image/jpeg"</c>
          </item>
          <item>
            <c>"image/tiff"</c>
          </item>
          <item>
            <c>"image/gif"</c>
          </item>
          <item>
            <c>"image/png"</c>
          </item>
          <item>
            <c>"image/bmp"</c>
          </item>
        </list>
        <para>The complete list can be obtained with <see cref="M:yWorks.Controls.PixelImageExporter.GetOutputFormats" />. The default output format is <c>"image/jpeg"</c>.</para>
      </remarks>
      <exception cref="T:System.FormatException">
        <para>If the format is not supported.</para>
      </exception>
    </member>
    <member name="P:yWorks.Controls.PixelImageExporter.Quality">
      <summary>
        <para>Gets or set the quality of the output.</para>
      </summary>
      <remarks>
        <para>This only has an effect for JPEG images (output format "image/jpeg"). The quality has to be between 0 and 1. The default is <c>0.9d</c></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.PixelImageExporter.Compression">
      <summary>
        <para>Gets or sets the compression to be used for TIFF images.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.PixelImageExporter.ColorDepthValue">
      <summary>
        <para>These are the possible values for <see cref="P:yWorks.Controls.PixelImageExporter.ColorDepth" /></para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.PixelImageExporter.ColorDepthValue.ColorDepth24bpp">
      <summary>
        <para>Enum constant for 24bpp color depth</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.PixelImageExporter.ColorDepthValue.ColorDepth32bpp">
      <summary>
        <para>Enum constant for 32bpp color depth</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.PixelImageExporter.ColorDepth">
      <summary>
        <para>Gets or sets the color depth to be used for TIFF images.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.PixelImageExporter.BackColor">
      <summary>
        <para>Gets or sets the background color for the output image.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.PixelImageExporter.Export(yWorks.Controls.CanvasControl,System.IO.Stream)">
      <summary>
        <para>Exports a part of the given <see cref="T:yWorks.Controls.CanvasControl" /> to the given <see cref="T:System.IO.Stream" />.</para>
      </summary>
      <param name="canvas">
        <para>the <see cref="T:yWorks.Controls.CanvasControl" /></para>
      </param>
      <param name="stream">
        <para>the <see cref="T:System.IO.Stream" /></para>
      </param>
      <remarks>
        <para>This takes the context parameters from the <see cref="P:yWorks.Controls.PixelImageExporter.Configurator" /> and the output parameters from this instance into account.</para>
      </remarks>
      <exception cref="T:System.IO.IOException">
        <para>If there is not enough memory to complete the operation.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.PixelImageExporter.Export(yWorks.Controls.CanvasControl,System.IO.Stream,System.String)">
      <summary>
        <para>Exports a part of the given <see cref="T:yWorks.Controls.CanvasControl" /> to the given <see cref="T:System.IO.Stream" /> using the given output format.</para>
      </summary>
      <param name="canvas">
        <para>the <see cref="T:yWorks.Controls.CanvasControl" /></para>
      </param>
      <param name="stream">
        <para>the <see cref="T:System.IO.Stream" /></para>
      </param>
      <param name="format">
        <para>the output format</para>
      </param>
      <remarks>
        <para>
          <see cref="M:yWorks.Controls.PixelImageExporter.GetOutputFormats" /> returns a list of valid output formats.</para>
      </remarks>
      <exception cref="T:System.IO.IOException">
        <para>If there is not enough memory to complete the operation.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.PixelImageExporter.Export(yWorks.Controls.CanvasControl,System.IO.Stream,System.Drawing.Imaging.ImageCodecInfo,System.Drawing.Imaging.EncoderParameters)">
      <summary>
        <para>Exports a part of the given <see cref="T:yWorks.Controls.CanvasControl" /> to the given <see cref="T:System.IO.Stream" /> using an image encoder specified by the given <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /> and <see cref="T:System.Drawing.Imaging.EncoderParameters" />.</para>
      </summary>
      <param name="canvas">
        <para>the <see cref="T:yWorks.Controls.CanvasControl" /></para>
      </param>
      <param name="stream">
        <para>the <see cref="T:System.IO.Stream" /></para>
      </param>
      <param name="codecInfo">
        <para>the <see cref="T:System.Drawing.Imaging.ImageCodecInfo" /></para>
      </param>
      <param name="parameters">
        <para>the <see cref="T:System.Drawing.Imaging.EncoderParameters" /></para>
      </param>
      <exception cref="T:System.IO.IOException">
        <para>If there is not enough memory to complete the operation.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.PixelImageExporter.ExportBitmap(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Returns a <see cref="T:System.Drawing.Bitmap" /> containing the specified part of the given <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <param name="canvas">
        <para>the <see cref="T:yWorks.Controls.CanvasControl" /></para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.Controls.PixelImageExporter.ConfigureGraphics(System.Drawing.Graphics)">
      <summary>
        <para>Callback that configures the graphics instance prior to the export.</para>
      </summary>
      <param name="graphics">
        <para>The graphics context.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.InputModeBase">
      <summary>
        <para>Abstract base class implementation of an <see cref="T:yWorks.Controls.Input.IInputMode" /> that can be used concurrently with other <see cref="T:yWorks.Controls.Input.IInputMode" /> implementations if its <see cref="P:yWorks.Controls.Input.InputModeBase.Exclusive" /> property is <c>true</c>.</para>
      </summary>
      <remarks>
        <para>This class adds convenience methods for derived classes.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.InputModeBase.Initializing">
      <summary>
        <para>Occurs before the call to <see cref="M:yWorks.Controls.Input.InputModeBase.Initialize" /></para>
      </summary>
      <remarks>
        <para>Clients can use this event to perform configuration of the instance shortly before the initialization begins.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" />
    </member>
    <member name="E:yWorks.Controls.Input.InputModeBase.Initialized">
      <summary>
        <para>Occurs after the call to <see cref="M:yWorks.Controls.Input.InputModeBase.Initialize" /></para>
      </summary>
      <remarks>
        <para>Clients can use this event to perform post configuration steps of the instance shortly after the initialization has been performed.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" />
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.InputModeBase" /> class that is <see cref="P:yWorks.Controls.Input.InputModeBase.Exclusive" /> by default.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.#ctor(System.Boolean)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.InputModeBase" /> class.</para>
      </summary>
      <param name="exclusive">
        <para>Iff this mode should be <see cref="P:yWorks.Controls.Input.InputModeBase.Exclusive" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.CreateInputModeEventArgs(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Helper method that yields a suitably configured <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> for this input mode.</para>
      </summary>
      <param name="context">
        <para>An input mode context that is available in the <see cref="T:yWorks.Controls.Input.InputModeEventArgs" />.</para>
        <para>Can be <c>null</c> in which case a new context for this instance is created automatically.</para>
      </param>
      <returns>
        <para>An input mode event argument that is configured for this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.OnCanceled(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Event dispatch method that will dispatch the <see cref="E:yWorks.Controls.Input.InputModeBase.Canceled" /> event.</para>
      </summary>
      <remarks>
        <para>This method is called by subclasses when the editing process has been <see cref="M:yWorks.Controls.Input.InputModeBase.Cancel" />ed.</para>
      </remarks>
      <param name="eventArgs">
        <para>The event arguments.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.Initialize" />
    </member>
    <member name="E:yWorks.Controls.Input.InputModeBase.Canceled">
      <summary>
        <para>Occurs after the call to <see cref="M:yWorks.Controls.Input.InputModeBase.Cancel" /></para>
      </summary>
      <remarks>
        <para>Clients can use this event to perform post cleanup steps of the instance shortly after the mode has been canceled.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.OnCanceled(yWorks.Controls.Input.InputModeEventArgs)" />
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.Cancel" />
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.TryStop" />
      <seealso cref="E:yWorks.Controls.Input.InputModeBase.Stopped" />
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.OnStopped(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Event dispatch method that will dispatch the <see cref="E:yWorks.Controls.Input.InputModeBase.Stopped" /> event.</para>
      </summary>
      <remarks>
        <para>This method will be called by <see cref="M:yWorks.Controls.Input.InputModeBase.TryStop" /> or can be called by subclasses during a <see cref="M:yWorks.Controls.Input.InputModeBase.TryStop" /> operation.</para>
      </remarks>
      <param name="eventArgs">
        <para>The event arguments.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.TryStop" />
      <seealso cref="E:yWorks.Controls.Input.InputModeBase.Stopped" />
    </member>
    <member name="E:yWorks.Controls.Input.InputModeBase.Stopped">
      <summary>
        <para>Occurs after the call to <see cref="M:yWorks.Controls.Input.InputModeBase.TryStop" /></para>
      </summary>
      <remarks>
        <para>Clients can use this event to perform post cleanup steps of the instance shortly after the mode has been stopped.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.OnStopped(yWorks.Controls.Input.InputModeEventArgs)" />
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.Cancel" />
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.TryStop" />
      <seealso cref="E:yWorks.Controls.Input.InputModeBase.Canceled" />
    </member>
    <member name="P:yWorks.Controls.Input.InputModeBase.Installed">
      <summary>
        <para>Gets whether this mode is currently installed so a call to <see cref="P:yWorks.Controls.Input.InputModeBase.InputModeContext" /> will yield a non-<c>null</c> result.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" />
    </member>
    <member name="P:yWorks.Controls.Input.InputModeBase.InputModeContext">
      <summary>
        <para>Gets the context instance this mode is currently installed in or <c>null</c> if this instance is not installed.</para>
      </summary>
      <remarks>
        <para>Note that this instance should not be passed down to subordinate modes or instances. Instead a corresponding context that has this instance set as the <see cref="P:yWorks.Controls.Input.IInputModeContext.ParentInputMode" /> should be used. One such instance can be obtained through helper method <see cref="M:yWorks.Controls.Input.InputModeBase.CreateChildInputModeContext" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.InputModeBase.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.InputModeBase.Active">
      <summary>
        <para>Gets if this mode is active.</para>
      </summary>
      <remarks>
        <para>This mode is active if a <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" /> is installed and is <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.InputModeBase.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.InputModeBase.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" />.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.RequestMutex" />
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.ReleaseMutex" />
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.HasMutex" />
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.CanRequestMutex" />
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into a <see cref="T:yWorks.Controls.CanvasControl" /> using the provided <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </summary>
      <remarks>
        <para>Subclasses should override this method and call<c>base.Install(context)</c>, first. One-time initialization should be performed in the <see cref="M:yWorks.Controls.Input.InputModeBase.Initialize" /> method. This implementation will call the <see cref="M:yWorks.Controls.Input.InputModeBase.Initialize" /> method the first time this mode gets installed. The initialization will be surrounded by calls to <see cref="M:yWorks.Controls.Input.InputModeBase.OnInitializing(yWorks.Controls.Input.InputModeEventArgs)" /> and <see cref="M:yWorks.Controls.Input.InputModeBase.OnInitialized(yWorks.Controls.Input.InputModeEventArgs)" /> to trigger the corresponding events.</para>
      </remarks>
      <param name="context">
        <para>the context to install this mode into</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" /> for this mode.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.InputModeBase.Canvas" />
      <seealso cref="P:yWorks.Controls.Input.InputModeBase.InputModeContext" />
      <seealso cref="P:yWorks.Controls.CanvasControl.InputMode" />
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.OnInitializing(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Event dispatch method that will dispatch the <see cref="E:yWorks.Controls.Input.InputModeBase.Initializing" /> event.</para>
      </summary>
      <remarks>
        <para>This method will be called by <see cref="M:yWorks.Controls.Input.InputModeBase.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> for the first installation directly before <see cref="M:yWorks.Controls.Input.InputModeBase.Initialize" /> is invoked.</para>
      </remarks>
      <param name="eventArgs">
        <para>The event arguments.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.Initialize" />
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.OnInitialized(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Event dispatch method that will dispatch the <see cref="E:yWorks.Controls.Input.InputModeBase.Initialized" /> event.</para>
      </summary>
      <remarks>
        <para>This method will be called by <see cref="M:yWorks.Controls.Input.InputModeBase.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> for the first installation directly after <see cref="M:yWorks.Controls.Input.InputModeBase.Initialize" /> has returned.</para>
      </remarks>
      <param name="eventArgs">
        <para>The event arguments.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.Initialize" />
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.Initialize">
      <summary>
        <para>Performs one-time initialization of this instance.</para>
      </summary>
      <remarks>
        <para>This method should not be invoked by subclasses. This will be done automatically upon first <see cref="M:yWorks.Controls.Input.InputModeBase.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installation</see> of this mode.</para>
        <para>This code will be executed only once per instance. The <see cref="P:yWorks.Controls.Input.InputModeBase.InputModeContext" /> property will be <c>null</c> when this code is executed. This method should not be used to install this mode into a specific canvas. Subclasses should always call <c>base.Initialize()</c> first.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" />
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.Cancel">
      <summary>
        <para>Cancels the editing of this mode by first disabling and afterwards reenabling the installed <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" />.</para>
      </summary>
      <remarks>
        <para>This implementation disables and reenables the <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" /> and fires the <see cref="M:yWorks.Controls.Input.InputModeBase.OnCanceled(yWorks.Controls.Input.InputModeEventArgs)" /> event afterwards. Classes that need to perform clean-up should override the <see cref="M:yWorks.Controls.Input.InputModeBase.OnConcurrencyControllerDeactivated" /> method and invoke <b>base.OnConcurrencyControllerDeactivated</b> as the last statement.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.OnCanceled(yWorks.Controls.Input.InputModeEventArgs)" />
      <seealso cref="E:yWorks.Controls.Input.InputModeBase.Canceled" />
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.TryStop">
      <summary>
        <para>Tries to stop the editing.</para>
      </summary>
      <remarks>
        <para>This implementation returns if this instance does not currently <see cref="M:yWorks.Controls.Input.InputModeBase.HasMutex">have the input mutex</see>.</para>
        <para>This implementation calls <see cref="M:yWorks.Controls.Input.InputModeBase.OnStopped(yWorks.Controls.Input.InputModeEventArgs)" />. Subclasses that want to prevent a stop or need to do special clean up should do this here if the base class implementation of <see cref="M:yWorks.Controls.Input.InputModeBase.TryStop" /> returns <c>true</c>. A typical implementation should follow this idiom if it wants to stop:</para>
        <para>and if it doesn't want to stop simply return <c>false</c> immediately.</para>
        <para>Calling this method raises the <see cref="E:yWorks.Controls.Input.InputModeBase.Stopped" /> event.</para>
      </remarks>
      <returns>
        <para>
          <c>true</c> iff this instance does not <see cref="M:yWorks.Controls.Input.InputModeBase.HasMutex">own the mutex</see>.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.InputModeBase.OnStopped(yWorks.Controls.Input.InputModeEventArgs)" />
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the canvas.</para>
      </summary>
      <remarks>
        <para>Subclasses should always call <c>base.Uninstall(context)</c> as the last statement.</para>
      </remarks>
      <param name="context">
        <para>The context to remove this mode from. This is the same instance that has been passed to <see cref="M:yWorks.Controls.Input.InputModeBase.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.CreateChildInputModeContext">
      <summary>
        <para>Creates an implementation of <see cref="T:yWorks.Controls.Input.IInputModeContext" /> that is specific to this mode.</para>
      </summary>
      <remarks>
        <para>This is needed for events that are triggered by this InputMode to signalize where the event is coming from. A common usage for this is for example in <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> calls.</para>
        <para>The result can be given to <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> or <see cref="M:yWorks.Controls.CanvasControl.HitElementsAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Controls.ICanvasObjectGroup,System.Predicate{yWorks.Controls.ICanvasObject})" /> to let implementations of <see cref="T:yWorks.Controls.Input.IHitTestable" /> get access to the current <see cref="T:yWorks.Controls.Input.IInputModeContext" />. This can be done by looking up <see cref="T:yWorks.Controls.Input.IInputModeContext" /> from the <see cref="T:yWorks.Controls.ICanvasContext" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method or simply downcasting.</para>
      </remarks>
      <returns>
        <para>A readily configured <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.CanvasControl.HitElementsAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Controls.ICanvasObjectGroup,System.Predicate{yWorks.Controls.ICanvasObject})" />
      <seealso cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
      <seealso cref="T:yWorks.Controls.Input.IInputModeContext" />
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.RequestMutex">
      <summary>
        <para>Requests the mutex from the current <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" />.</para>
      </summary>
      <remarks>
        <para>This implementation will call the <see cref="M:yWorks.Controls.Input.InputModeBase.OnMutexObtained" /> method if the mutex has been successfully obtained. If the mutex cannot be obtained this method will trigger an exception.</para>
      </remarks>
      <exception cref="T:System.Exception">
        <para>If the mutex could not be obtained.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.HasMutex">
      <summary>
        <para>Determines whether this instance owns the input mutex.</para>
      </summary>
      <remarks>
        <para>If no <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" /> had been associated with this instance upon the call to <see cref="M:yWorks.Controls.Input.InputModeBase.RequestMutex" /> this method will return <c>false</c>.</para>
      </remarks>
      <returns>
        <para>Whether this instance has the input mutex.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.OnMutexObtained">
      <summary>
        <para>Called when this instance obtains the mutex.</para>
      </summary>
      <remarks>
        <para>If no <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" /> had been associated with this instance upon the call to <see cref="M:yWorks.Controls.Input.InputModeBase.RequestMutex" /> this method will not be called.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.ReleaseMutex">
      <summary>
        <para>Releases the mutex that is currently owned by this instance.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="M:yWorks.Controls.Input.InputModeBase.OnMutexReleased" /> method if this instance previously owned the mutex.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.OnMutexReleased">
      <summary>
        <para>Called when this instance released the mutex.</para>
      </summary>
      <remarks>
        <para>If no <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" /> had been associated with this instance upon the call to <see cref="M:yWorks.Controls.Input.InputModeBase.RequestMutex" /> this method will not be called.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeBase.CanRequestMutex">
      <summary>
        <para>Determines whether this instance can request the mutex.</para>
      </summary>
      <remarks>
        <para>This will return true, iff a <see cref="P:yWorks.Controls.Input.InputModeBase.Controller" /> has been injected and the helper allows requesting the mutex.</para>
      </remarks>
      <returns>
        <para>Whether a call to <see cref="M:yWorks.Controls.Input.InputModeBase.RequestMutex" /> would currently succeed.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.ClickEventArgs">
      <summary>
        <para>Event arguments used by <see cref="E:yWorks.Controls.Input.ClickInputMode.Clicked" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ClickEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,System.Windows.Forms.Keys,System.Windows.Forms.MouseButtons,System.Int32)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.ClickEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context in which the click occurred.</para>
      </param>
      <param name="location">
        <para>The location.</para>
      </param>
      <param name="modifiers">
        <para>State of the modifiers.</para>
      </param>
      <param name="mouseButtons">
        <para>The mouse button(s) that have changed</para>
      </param>
      <param name="clickCount" />
    </member>
    <member name="P:yWorks.Controls.Input.ClickEventArgs.Location">
      <summary>
        <para>Gets the location of the click.</para>
      </summary>
      <value>
        <para>The location.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ClickEventArgs.Modifiers">
      <summary>
        <para>Gets the state of the modifiers at the time of the click.</para>
      </summary>
      <value>
        <para>The state of the modifiers.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ClickEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Controls.Input.ClickEventArgs" /> have been handled.</para>
      </summary>
      <remarks>
        <para>Client code that is triggered by the event and does not want the event to become handled by other handles should set this property to <c>true</c> to stop propagation of the event.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if handled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ClickEventArgs.MouseButtons">
      <summary>
        <para>Gets the <see cref="T:System.Windows.Forms.MouseButtons" /> that have changed for this event.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ClickEventArgs.ClickCount">
      <summary>
        <para>Gets the number of clicks associated with this event.</para>
      </summary>
      <remarks>
        <para>This can be used to distinguish between single and multiple clicks. Note that for compatibility reasons, a negative value means that no click count has been provided at event creation time.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.DoubleClickPolicy">
      <summary>
        <para>Policy to determine how single and double click events are raised in response to mouse clicks.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy" />
    </member>
    <member name="F:yWorks.Controls.Input.DoubleClickPolicy.DoubleClickOnly">
      <summary>
        <para>In case of a double click, only the double click event is raised, but no single click events.</para>
      </summary>
      <remarks>
        <para>Single clicks not belonging to a double click will be reported with a short delay to ensure that they do not become double clicks.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.DoubleClickPolicy.InitialSingleAndDoubleClick">
      <summary>
        <para>In case of a double click, one single click event is raised, followed by a double click event.</para>
      </summary>
      <remarks>
        <para>The second click of the double click is not reported as a single click. Single clicks not belonging to a double click will be reported instantly.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.DoubleClickPolicy.BothSingleClicksAndDoubleClick">
      <summary>
        <para>In case of a double click, two single click events are raised, followed by a double click event.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.ClickInputMode">
      <summary>
        <para>An input mode that recognizes simple mouse clicks.</para>
      </summary>
      <remarks>
        <para>Clients register to <see cref="E:yWorks.Controls.Input.ClickInputMode.Clicked" /> to get notified of mouse clicks. The <see cref="P:yWorks.Controls.Input.ClickInputMode.ActiveButtons" /> property can be used to switch between the detection of right and left mouse clicks.<br /> This mode can be instructed to <see cref="P:yWorks.Controls.Input.ClickInputMode.SwallowFocusClick">swallow clicks</see> if they lead happen shortly after the control gained focus. This is useful to prevent accidental clicks from being processed if the user wanted to put the focus into the control, only.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.ClickInputMode.Exclusive" /> by default.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy" />
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.SwallowFocusClick" />
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.ActiveButtons" />
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.ClickInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.TryStop" />
    <member name="M:yWorks.Controls.Input.ClickInputMode.Cancel">
      <summary>
        <para>Cancels the editing of this mode.</para>
      </summary>
      <remarks>
        <para>This implementation <see cref="M:yWorks.Controls.Input.ConcurrencyController.ReleaseMutex">releases</see> the mutex if it is currently owned by this instance and calls <see cref="M:yWorks.Controls.Input.ClickInputMode.OnCanceled" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.ClickInputMode.OnCanceled" />
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.ClickInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.ClickInputMode.Controller" />.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" />
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.ClickInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.ClickInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.#ctor">
      <summary>
        <para>Creates a new instance of this mode that detects left mouse clicks.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.ClickInputMode.Clicked">
      <summary>
        <para>Occurs once a click has been detected.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ClickEventArgs" />
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy" />
    </member>
    <member name="E:yWorks.Controls.Input.ClickInputMode.LeftClicked">
      <summary>
        <para>Occurs once a left click has been detected.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ClickEventArgs" />
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy" />
    </member>
    <member name="E:yWorks.Controls.Input.ClickInputMode.RightClicked">
      <summary>
        <para>Occurs once a right click has been detected.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ClickEventArgs" />
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy" />
    </member>
    <member name="E:yWorks.Controls.Input.ClickInputMode.DoubleClicked">
      <summary>
        <para>Occurs once a double-click has been detected.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ClickEventArgs" />
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy" />
    </member>
    <member name="E:yWorks.Controls.Input.ClickInputMode.LeftDoubleClicked">
      <summary>
        <para>Occurs once a left double-click has been detected.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ClickEventArgs" />
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy" />
    </member>
    <member name="E:yWorks.Controls.Input.ClickInputMode.RightDoubleClicked">
      <summary>
        <para>Occurs once a right double-click has been detected.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ClickEventArgs" />
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy" />
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy">
      <summary>
        <para>Gets or sets the click handling mode that determines the triggering behavior of <see cref="E:yWorks.Controls.Input.ClickInputMode.Clicked" /> and <see cref="E:yWorks.Controls.Input.ClickInputMode.DoubleClicked" />.</para>
      </summary>
      <value>
        <para>The click handling mode to use for this instance. The default is <see cref="F:yWorks.Controls.Input.DoubleClickPolicy.BothSingleClicksAndDoubleClick" /></para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy" />
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.ValidClickHitTestable">
      <summary>
        <para>Gets or sets a hit test that determines where this mode should recognize clicks.</para>
      </summary>
      <remarks>
        <para>This implementation is tested during the <see cref="M:yWorks.Controls.Input.ClickInputMode.IsValidPress(System.Object,System.EventArgs)" /> to determine whether it is valid to click here. The default implementation is <see cref="F:yWorks.Controls.Input.HitTestables.Always" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.RequestMutexOnClick">
      <summary>
        <para>Gets or sets whether to <see cref="M:yWorks.Controls.Input.ConcurrencyController.RequestMutex">request the mutex</see> on a click.</para>
      </summary>
      <remarks>
        <para>If set to <c>true</c> this will discard other concurrent input modes on a click. The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.ValidClickHitCursor">
      <summary>
        <para>Gets or sets the cursor to use when hovering over a valid hit region.</para>
      </summary>
      <remarks>
        <para>The default is <c>null</c> and the current cursor is used instead.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.ActiveButtons">
      <summary>
        <para>Gets or sets for which button(s) mouse clicks should be processed.</para>
      </summary>
      <remarks>
        <para>Default value is <see cref="F:System.Windows.Forms.MouseButtons.Left" /></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.ClickInputMode.CreateClickRecognizer" />
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.ClickInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.SwallowFocusClick">
      <summary>
        <para>Gets or sets a property that determines whether clicks should be swallowed if they happen within a short amount of time after the CanvasControl <see cref="E:System.Windows.Forms.Control.Enter">got focus</see>.</para>
      </summary>
      <remarks>
        <para>The default is <c>false</c>. If set to <c>true</c> clicks are discarded within 100 ms after the focus entered.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.CreateClickRecognizer">
      <summary>
        <para>Creates the event recognizer that is used to recognize the clicks for this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.IsValidClick(System.Object,System.EventArgs)">
      <summary>
        <para>Determines whether the given event is a valid click event.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.ValidClickHitTestable" />
      <param name="src" />
      <param name="arg" />
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.CreateReleaseRecognizer">
      <summary>
        <para>Creates the event recognizer that is used to recognize the release event for this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.IsValidRelease(System.Object,System.EventArgs)">
      <summary>
        <para>Determines whether the given event is a valid release event.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.ValidClickHitTestable" />
      <param name="src" />
      <param name="arg" />
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.CreatePressRecognizer">
      <summary>
        <para>Creates the event recognizer that is used to recognize the press event for this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.IsValidPress(System.Object,System.EventArgs)">
      <summary>
        <para>Determines whether the given event is a valid press event.</para>
      </summary>
      <param name="eventSource" />
      <param name="eventArg" />
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.IsInvalidPress(System.Object,System.EventArgs)">
      <summary>
        <para>Determines whether the given event is a press event that occurred at an invalid location.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.ClickInputMode.ValidClickHitTestable" />
      <param name="eventSource" />
      <param name="eventArg" />
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.ClickLocation">
      <summary>
        <para>Gets the location of the last click.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ClickInputMode.Modifiers">
      <summary>
        <para>Gets the state of the modifier keys at the time <see cref="E:yWorks.Controls.Input.ClickInputMode.Clicked" /> is invoked.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.OnClicked(yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Called once this mode has recognized a click gesture.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.Input.ClickInputMode.Clicked" /> event.</para>
      </remarks>
      <param name="eventArgs">
        <para>The arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.OnLeftClicked(yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Called once this mode has recognized a left click gesture.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.Input.ClickInputMode.LeftClicked" /> event.</para>
      </remarks>
      <param name="eventArgs">
        <para>The arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.OnRightClicked(yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Called once this mode has recognized a right click gesture.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.Input.ClickInputMode.RightClicked" /> event.</para>
      </remarks>
      <param name="eventArgs">
        <para>The arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.OnDoubleClicked(yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Called once this mode has recognized a double-click gesture.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.Input.ClickInputMode.DoubleClicked" /> event.</para>
      </remarks>
      <param name="eventArgs">
        <para>The arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.OnLeftDoubleClicked(yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Called once this mode has recognized a left double-click gesture.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.Input.ClickInputMode.LeftDoubleClicked" /> event.</para>
      </remarks>
      <param name="eventArgs">
        <para>The arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.OnRightDoubleClicked(yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Called once this mode has recognized a double-click gesture.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.Input.ClickInputMode.RightDoubleClicked" /> event.</para>
      </remarks>
      <param name="eventArgs">
        <para>The arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.PreventNextDoubleClick">
      <summary>
        <para>Prevents a double-click event from being issued if the next click would do so and sends only a single click instead.</para>
      </summary>
      <remarks>
        <para>The intention is for "breaking" a double click if an input mode using <see cref="T:yWorks.Controls.Input.ClickInputMode" /> performs actions that would lead to surprising behavior if the next click would lead to a double-click. Examples of this are <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />'s selection cycling where several clicks in short succession may occur, as well as creating a node by clicking on the canvas and selecting it immediately afterwards with another click.</para>
        <para>This method's effect is very short-lived. It really only prevents a double-click event for the very next click that this input mode handles. The internal flag set by this method is re-set on every click received. This also means that if you call this method and the next click is just a regular single-click the flag is cleared nonetheless.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ClickInputMode.QueryAndResetPreventNextDoubleClick">
      <summary>
        <para>Returns and resets the flag set by <see cref="M:yWorks.Controls.Input.ClickInputMode.PreventNextDoubleClick" />.</para>
      </summary>
      <remarks>
        <para>To ensure that the flag really acts just once, this method resets the flag and returns its value prior to the reset.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.CollectSnapResultsEventArgs">
      <summary>
        <para>Event arguments for the <see cref="E:yWorks.Controls.Input.SnapContext.CollectSnapResults" /> event.</para>
      </summary>
      <remarks>
        <para>Event handlers can use the <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)" /> method to add snapping results for the current move operation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double,System.Collections.Generic.ICollection{yWorks.Controls.Input.SnapResult})">
      <summary>
        <para>Creates a new instance of the event arguments using the provided values for initialization.</para>
      </summary>
      <param name="context">
        <para>The context for which the event is queried.</para>
      </param>
      <param name="originalLocation">
        <para>The original location of the mouse at the beginning of the gesture.</para>
      </param>
      <param name="newLocation">
        <para>The new (current) location of the mouse.</para>
      </param>
      <param name="snapDistance">
        <para>The zoom invariant snap distance.</para>
      </param>
      <param name="snapResults">
        <para>The collection to store the snap results in.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.CollectSnapResultsEventArgs.OriginalLocation">
      <summary>
        <para>Gets the original location of the mouse at the beginning of the gesture.</para>
      </summary>
      <value>
        <para>The original location.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.CollectSnapResultsEventArgs.NewLocation">
      <summary>
        <para>Gets the new (current) location of the mouse that is going to be manipulated by the snapping process.</para>
      </summary>
      <value>
        <para>The new (current) location.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.CollectSnapResultsEventArgs.Delta">
      <summary>
        <para>Gets the vector by which the mouse has been moved since initialization of the snapping process.</para>
      </summary>
      <value>
        <para>The delta.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">
      <summary>
        <para>Adds a <see cref="T:yWorks.Controls.Input.SnapResult" /> to the collection of snap results.</para>
      </summary>
      <remarks>
        <para>
          <c>null</c> values will be discarded.</para>
      </remarks>
      <param name="snapResult">
        <para>The result to add.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.CollectSnapResultsEventArgs.SnapDistance">
      <summary>
        <para>Gets the zoom invariant snap distance.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.ConcurrencyController">
      <summary>
        <para>A controller class that manages a single <see cref="T:yWorks.Controls.Input.IInputMode" /> implementation.</para>
      </summary>
      <remarks>
        <para>The controller will be passed to its associated <see cref="T:yWorks.Controls.Input.IInputMode" /> in the input mode's <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. The associated mode can <see cref="M:yWorks.Controls.Input.ConcurrencyController.RequestMutex">request</see> an input mutex to <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active">deactivate</see> other modes added to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> and using <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> controllers. <see cref="M:yWorks.Controls.Input.ConcurrencyController.ReleaseMutex">Releasing the mutex</see> will reactivate the controller of other modes.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.IInputMode" />
      <seealso cref="T:yWorks.Controls.Input.MultiplexingInputMode" />
    </member>
    <member name="M:yWorks.Controls.Input.ConcurrencyController.#ctor(yWorks.Controls.Input.IInputMode)">
      <summary>
        <para>Creates an instance that can be used to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> the given <paramref name="mode" />.</para>
      </summary>
      <remarks>
        <para>The returned <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> is not synchronized with any other one so the <paramref name="mode" /> will effectively run in a non-<see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive">exclusive</see> mode.</para>
      </remarks>
      <param name="mode">
        <para>The mode, the <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> shall be created for.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">
      <summary>
        <para>Determines whether this instance owns the input mutex.</para>
      </summary>
      <remarks>
        <para>The instance owns the input mutex if it has successfully <see cref="M:yWorks.Controls.Input.ConcurrencyController.RequestMutex">requested</see> the mutex in the past and not yet <see cref="M:yWorks.Controls.Input.ConcurrencyController.ReleaseMutex">released</see> it.</para>
      </remarks>
      <returns>
        <para>Whether this instance has the input mutex.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ConcurrencyController.CanRequestMutex">
      <summary>
        <para>Determines if the mutex can be successfully requested currently.</para>
      </summary>
      <remarks>
        <para>This will return <c>true</c>, iff this instance is <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> and doesn't hold the mutex.</para>
      </remarks>
      <returns>
        <para>Whether a call to <see cref="M:yWorks.Controls.Input.ConcurrencyController.RequestMutex" /> would currently succeed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ConcurrencyController.RequestMutex">
      <summary>
        <para>Can be called to request an input mutex for the input mode.</para>
      </summary>
      <remarks>
        <para>Modes should call this method to request exclusive editing for a canvas control. <see cref="M:yWorks.Controls.Input.ConcurrencyController.CanRequestMutex" /> should be called before requesting the mutex. If the mutex cannot be obtained, this method will trigger an exception.</para>
      </remarks>
      <exception cref="T:System.Exception">
        <para>If the mutex could not be obtained.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.ConcurrencyController.ReleaseMutex">
      <summary>
        <para>Releases the input mutex.</para>
      </summary>
      <remarks>
        <para>Modes should call this method when they have finished editing the contents exclusively. This will reactivate those modes whose controller that had been <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active">deactivated</see> at the time the mutex has been requested.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.ConcurrencyController.MutexObtained">
      <summary>
        <para>Occurs when the mutex has been successfully obtained.</para>
      </summary>
      <remarks>
        <para>This event is invoked with <see cref="F:System.EventArgs.Empty" /> per default.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.ConcurrencyController.MutexReleased">
      <summary>
        <para>Occurs when the mutex has been released.</para>
      </summary>
      <remarks>
        <para>This event is invoked with <see cref="F:System.EventArgs.Empty" /> per default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ConcurrencyController.MutexOwner">
      <summary>
        <para>Gets the current owner of the input mutex or <c>null</c> if no mode currently owns the mutex.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ConcurrencyController.Enabled">
      <summary>
        <para>Gets or sets if this controller is enabled.</para>
      </summary>
      <remarks>
        <para>The default state is disabled. A disabled controller is always <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active">inactive</see>.</para>
        <para>When the controller is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see> and the input mode is ready for editing, it has to set this property to <c>true</c> if it wants to use the input mutex.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.ConcurrencyController.Active" />
      <seealso cref="E:yWorks.Controls.Input.ConcurrencyController.ActiveChanged" />
    </member>
    <member name="P:yWorks.Controls.Input.ConcurrencyController.Active">
      <summary>
        <para>Gets if this controller is active.</para>
      </summary>
      <remarks>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> should only handle events and gestures if this property on its associated <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> is set to <c>true</c>.</para>
        <para>If this controller is set as <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive">non-exclusive</see> by its input mode it is active iff it is <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled" />. Otherwise it has to be <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled" /> and no other input mode may have the <see cref="M:yWorks.Controls.Input.ConcurrencyController.RequestMutex">input mutex</see>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the associated input mode should handle events and gestures.</para>
      </value>
      <seealso cref="E:yWorks.Controls.Input.ConcurrencyController.ActiveChanged" />
    </member>
    <member name="E:yWorks.Controls.Input.ConcurrencyController.ActiveChanged">
      <summary>
        <para>Occurs the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property changes.</para>
      </summary>
      <remarks>
        <para>This event is invoked with <see cref="F:System.EventArgs.Empty" /> per default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ConcurrencyController.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this controller will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>If this controller is marked as exclusive and has the mutex, all controllers of other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active">deactivated</see>. Otherwise it will always run concurrently with all other controllers.</para>
        <para>Changing this property will temporarily <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">disable</see> the controller.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ConcurrencyController.PreferredCursor">
      <summary>
        <para>Returns the cursor the associated mode of this controller would like to have displayed in the <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>To indicate that the mode does not have any preferences the property should be set to <c>null</c>.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.ConcurrencyController.PreferredCursorChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.Input.ConcurrencyController.PreferredCursor" /> property changes.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> listens to property changes of the controller of its sub modes. properties. This event is invoked with <see cref="F:System.EventArgs.Empty" /> per default.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ConcurrencyController.OnPriorityChanged">
      <summary>
        <para>Triggers a <see cref="E:yWorks.Controls.Input.ConcurrencyController.PriorityChanged" /> event with <see cref="F:System.EventArgs.Empty" />.</para>
      </summary>
      <remarks>
        <para>This method should be called by the associated mode if its <see cref="P:yWorks.Controls.Input.IInputMode.Priority" /> has changed.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.ConcurrencyController.PriorityChanged">
      <summary>
        <para>Occurs when <see cref="M:yWorks.Controls.Input.ConcurrencyController.OnPriorityChanged" /> is called by the associated mode.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> listens to priority changes of the controller of its sub modes.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.EventSource">
      <summary>
        <para>Specifies the source device for an event.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.EventSource.Unknown">
      <summary>
        <para>The source for the event is unknown or could not be determined.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.EventSource.Mouse">
      <summary>
        <para>The source was a mouse event, for example a click.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.EventSource.Keyboard">
      <summary>
        <para>The source was a keyboard event, for example a key press.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.PopulateMenuEventArgs">
      <summary>
        <para>Event arguments for the <see cref="E:yWorks.Controls.Input.ContextMenuInputMode.PopulateMenu" /> event.</para>
      </summary>
      <remarks>
        <para>Event handlers can modify the <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.Menu" /> accordingly and set <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.ShowMenu" /> to <c>true</c>. Setting <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.ShowMenu" /> to <c>false</c> will cause the event to be marked as <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.Handled" /> and no menu will be shown.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.PopulateMenuEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,System.Windows.Forms.ContextMenuStrip,yWorks.Controls.Input.EventSource)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.PopulateMenuEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="queryLocation">
        <para>The query location.</para>
      </param>
      <param name="menu">
        <para>The context menu.</para>
      </param>
      <param name="eventSource">
        <para>The source device of the event.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.PopulateMenuEventArgs.QueryLocation">
      <summary>
        <para>Gets the queried location in world coordinates.</para>
      </summary>
      <value>
        <para>The queried location.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.PopulateMenuEventArgs.EventSource">
      <summary>
        <para>Gets the source that triggered this event.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.PopulateMenuEventArgs.Menu">
      <summary>
        <para>Gets the context menu to populate.</para>
      </summary>
      <value>
        <para>The context menu to populate.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.PopulateMenuEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Controls.Input.PopulateMenuEventArgs" /> has been handled.</para>
      </summary>
      <remarks>
        <para>This property is automatically set to <c>true</c> if <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.ShowMenu" /> has been assigned a value. Marking this event as handled tells the issuer of the query whether the <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.ShowMenu" /> property should be used or whether additional logic should be used to determine whether to show the menu.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if handled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.PopulateMenuEventArgs.ShowMenu">
      <summary>
        <para>Gets or sets a value indicating whether to actually display the context menu.</para>
      </summary>
      <remarks>
        <para>This will set the <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.Handled" /> property to <c>true</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the menu should be shown; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.Input.ContextMenuInputMode">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.Controls.Input.IInputMode" /> interface that will display a <see cref="T:System.Windows.Forms.ContextMenuStrip" /> when the user right clicks on the <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>One can register a callback that can be used to customize the contents of the menu strip depending on the coordinate in the world coordinate system where the menu strip has been opened.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.ContextMenuInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ContextMenuInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.ContextMenuInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ContextMenuInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.ContextMenuInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ContextMenuInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.ContextMenuInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.ContextMenuInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ContextMenuInputMode.ClearMenu">
      <summary>
        <para>Gets or sets a value indicating whether to clear <see cref="T:System.Windows.Forms.ContextMenu" />'s <see cref="P:System.Windows.Forms.ToolStrip.Items" /> before the <see cref="E:yWorks.Controls.Input.ContextMenuInputMode.PopulateMenu" /> event is triggered.</para>
      </summary>
      <value>
        <para>
          <c>true</c> (the default value) if the context menu should be cleared before the query; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="E:yWorks.Controls.Input.ContextMenuInputMode.PopulateMenu">
      <summary>
        <para>Occurs when the context menu is about to be shown.</para>
      </summary>
      <remarks>
        <para>Handlers of the event can populate the <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.Menu" />, set the <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.ShowMenu" /> and set or respect the <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.Handled" /> property. Note that all handlers will be called, even if one of them sets the <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.Handled" /> property to <c>true</c>. Every handler should query this property and decide carefully what to do.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ContextMenuInputMode.ValidMenuLocationHitTestable">
      <summary>
        <para>Gets or sets an <see cref="T:yWorks.Controls.Input.IHitTestable" /> that determines whether it is valid to open a context menu at the queried position.</para>
      </summary>
      <remarks>
        <para>If the instance yields <c>false</c> <see cref="M:yWorks.Controls.Input.ContextMenuInputMode.OnMenuOpening(System.Windows.Forms.ContextMenuStrip,yWorks.Geometry.PointD,yWorks.Controls.Input.EventSource)" /> will not be queried and the context menu will not be shown. By default there is a hit testable instance that always yields <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ContextMenuInputMode.Menu">
      <summary>
        <para>Gets or sets the menu to show.</para>
      </summary>
      <remarks>
        <para>If no menu has been configured with this instance this will create the menu using the <see cref="M:yWorks.Controls.Input.ContextMenuInputMode.CreateMenu" /> callback.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.OnMenuOpening(System.Windows.Forms.ContextMenuStrip,yWorks.Geometry.PointD,yWorks.Controls.Input.EventSource)">
      <summary>
        <para>This will populate the context menu for the given world coordinate.</para>
      </summary>
      <remarks>
        <para>This implementation will trigger the <see cref="E:yWorks.Controls.Input.ContextMenuInputMode.PopulateMenu" /> event and will use the <see cref="P:yWorks.Controls.Input.PopulateMenuEventArgs.ShowMenu" /> value as the return value. If the event will not be handled, this method will return <c>true</c> if the menu already contains elements.</para>
      </remarks>
      <param name="menu">
        <para>The menu to optionally populate with items.</para>
      </param>
      <param name="location">
        <para>The location in the world coordinate system for which the context menu has been invoked.</para>
      </param>
      <param name="eventSource">
        <para>The source of the context menu event.</para>
      </param>
      <returns>
        <para>Whether to show the context menu.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.OnPopulateMenu(yWorks.Controls.Input.PopulateMenuEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.ContextMenuInputMode.PopulateMenu" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.PopulateMenuEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.CreatePopulateMenuContext">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> for use with the <see cref="E:yWorks.Controls.Input.ContextMenuInputMode.PopulateMenu" /> call in the upcoming query.</para>
      </summary>
      <returns>
        <para>An instance of <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.#ctor">
      <summary>
        <para>Creates a new instance with no initial context menu.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.ContextMenuInputMode.CreateMenu" />
      <seealso cref="P:yWorks.Controls.Input.ContextMenuInputMode.Menu" />
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.#ctor(System.Windows.Forms.ContextMenuStrip)">
      <summary>
        <para>Creates a new instance using the provided menu.</para>
      </summary>
      <param name="menu">
        <para>The menu to show.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.CreateMenu">
      <summary>
        <para>Factory method that creates the initial menu strip.</para>
      </summary>
      <remarks>
        <para>Subclasses may override this with more sophisticated implementations.</para>
      </remarks>
      <returns>
        <para>An empty <see cref="T:System.Windows.Forms.ContextMenuStrip" /></para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.ContextMenuInputMode.Menu" />
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode in the canvas, registering the <see cref="P:yWorks.Controls.Input.ContextMenuInputMode.Menu" /> as the canvas' <see cref="P:System.Windows.Forms.Control.ContextMenuStrip" /></para>
      </summary>
      <param name="context">
        <para>The context to install this mode into.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.ContextMenuInputMode.Controller" /> for this mode.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.Cancel">
      <summary>
        <para>Makes the menu invisible.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.TryStop">
      <summary>
        <para>Makes the menu invisible.</para>
      </summary>
      <returns>
        <para>
          <c>base.Stop()</c>
        </para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ContextMenuInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Removes the menu from the context and replaces it with the old instance.</para>
      </summary>
      <param name="context">
        <para>The context to uninstall this mode from.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.DropInputMode">
      <summary>
        <para>This is an input mode handling drag and drop related events on a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>An instance of <c>DropInputMode</c> is initialized for an expected data format in the constructor. There are four events raised by an instance of this class.</para>
        <list type="bullet">
          <item>
            <see cref="E:yWorks.Controls.Input.DropInputMode.DragEntered" /> is raised, if a drag operation enters the <see cref="T:yWorks.Controls.CanvasControl" />.</item>
          <item>
            <see cref="E:yWorks.Controls.Input.DropInputMode.DragOver" /> is raised, if a drag operation moves over the <see cref="T:yWorks.Controls.CanvasControl" /> after having entered it.</item>
          <item>
            <see cref="E:yWorks.Controls.Input.DropInputMode.DragDropped" /> is raised, if a drag is dropped onto the <see cref="T:yWorks.Controls.CanvasControl" />.</item>
          <item>
            <see cref="E:yWorks.Controls.Input.DropInputMode.DragLeft" /> is raised, if a drag is operation leaves the <see cref="T:yWorks.Controls.CanvasControl" />.</item>
        </list>
        <para>Clients can query the current <see cref="P:yWorks.Controls.Input.DropInputMode.MousePosition" /> which is updated while a drag is in progress. Clients get the data from the drag operation by calling <see cref="P:yWorks.Controls.Input.DropInputMode.DropData" /> from an event handler registered for any of these events.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.DropInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.DropInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.DropInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.DropInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.DropInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.TryStop">
      <summary>
        <para>Overridden to only return <c>true</c> if this instance does not currently <see cref="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">have the input mutex</see>.</para>
      </summary>
      <returns>
        <para>
          <c>true</c> iff this instance does not <see cref="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">own the mutex</see>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.DropInputMode.Controller">
      <summary>
        <para>Returns the installed <see cref="P:yWorks.Controls.Input.DropInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.CreateInputModeEventArgs">
      <summary>
        <para>Helper method that yields a suitably configured <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> for this input mode.</para>
      </summary>
      <returns>
        <para>An input mode event argument that is configured for this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.DropInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.DropInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.DropInputMode.DragEntered">
      <summary>
        <para>Occurs when a drag operation enters the <see cref="T:yWorks.Controls.CanvasControl" /> into which this instance is installed.</para>
      </summary>
      <remarks>
        <para>No event is raised</para>
        <list type="bullet">
          <item>if this instance is not <see cref="P:yWorks.Controls.Input.DropInputMode.Enabled" />,</item>
          <item>if another concurrent input mode is active or</item>
          <item>the data from the drag operation does not conform to the expected format.</item>
        </list>
        <para>To get additional data for the event, clients should use the sender which is set to the sending <see cref="T:yWorks.Controls.Input.DropInputMode" />. The <see cref="T:System.EventArgs" /> provide no useful data.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.DropInputMode.DragOver">
      <summary>
        <para>Occurs when a drag operation drags over the <see cref="T:yWorks.Controls.CanvasControl" /> into which this instance is installed.</para>
      </summary>
      <remarks>
        <para>No event is raised</para>
        <list type="bullet">
          <item>if this instance is not <see cref="P:yWorks.Controls.Input.DropInputMode.Enabled" />,</item>
          <item>if another concurrent input mode is active or</item>
          <item>the data from the drag operation does not conform to the expected format.</item>
        </list>
        <para>To get additional data for the event, clients should use the sender which is set to the sending <see cref="T:yWorks.Controls.Input.DropInputMode" />. The <see cref="T:System.EventArgs" /> provide no useful data.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.DropInputMode.DragLeft">
      <summary>
        <para>Occurs when a drag operation leaves the <see cref="T:yWorks.Controls.CanvasControl" /> into which this instance is installed.</para>
      </summary>
      <remarks>
        <para>No event is raised</para>
        <list type="bullet">
          <item>if this instance is not <see cref="P:yWorks.Controls.Input.DropInputMode.Enabled" />,</item>
          <item>if another concurrent input mode is active or</item>
          <item>the data from the drag operation does not conform to the expected format.</item>
        </list>
        <para>To get additional data for the event, clients should use the sender which is set to the sending <see cref="T:yWorks.Controls.Input.DropInputMode" />. The <see cref="T:System.EventArgs" /> provide no useful data.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.DropInputMode.DragDropped">
      <summary>
        <para>Occurs when a drag operation is dropped onto the <see cref="T:yWorks.Controls.CanvasControl" /> into which this instance is installed.</para>
      </summary>
      <remarks>
        <para>No event is raised</para>
        <list type="bullet">
          <item>if this instance is not <see cref="P:yWorks.Controls.Input.DropInputMode.Enabled" />,</item>
          <item>if another concurrent input mode is active or</item>
          <item>the data from the drag operation does not conform to the expected format.</item>
        </list>
        <para>To get additional data for the event, clients should use the sender which is set to the sending <see cref="T:yWorks.Controls.Input.DropInputMode" />. The <see cref="T:System.EventArgs" /> provide no useful data.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.#ctor(System.String)">
      <summary>
        <para>Constructs a new instance of class <see cref="T:yWorks.Controls.Input.DropInputMode" /> for the expected data format.</para>
      </summary>
      <param name="expectedDataFormat">
        <para>This is a string which can be given to <see cref="M:System.Windows.Forms.DataObject.GetData(System.String)" />.</para>
      </param>
      <remarks>
        <para>The input mode fires events (see <see cref="E:yWorks.Controls.Input.DropInputMode.DragEntered" /> and <see cref="E:yWorks.Controls.Input.DropInputMode.DragDropped" />) only if a drag operation carries data conforming to the given format.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.#ctor(System.Type)">
      <summary>
        <para>Constructs a new instance of class <see cref="T:yWorks.Controls.Input.DropInputMode" /> for the expected data format.</para>
      </summary>
      <param name="expectedType">
        <para>This is a type which can be given to <see cref="M:System.Windows.Forms.DataObject.GetData(System.Type)" />.</para>
      </param>
      <remarks>
        <para>The input mode fires events (see <see cref="E:yWorks.Controls.Input.DropInputMode.DragEntered" /> and <see cref="E:yWorks.Controls.Input.DropInputMode.DragDropped" />) only if a drag operation carries data conforming to the given type.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.DropInputMode.DragDropEffect">
      <summary>
        <para>Gets or sets the <see cref="T:System.Windows.Forms.DragDropEffects" /> that will be used for drags on the canvas.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.DropInputMode.ValidDropHitTestable">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.IHitTestable" /> that determines whether the given location is a valid drop location.</para>
      </summary>
      <value>
        <para>The hit testable that yields <c>true</c> for valid drop locations.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.DropInputMode.LastDragEventArgs">
      <summary>
        <para>Gets the last processed drag event argument.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.DropInputMode.MousePosition">
      <summary>
        <para>Gets the current mouse position during drag operations.</para>
      </summary>
      <remarks>
        <para>The position is returned in world coordinates according to the <see cref="T:yWorks.Controls.CanvasControl" /> into which this input mode is installed.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.DropInputMode.DropLocation">
      <summary>
        <para>Gets the mouse position after dropping an item.</para>
      </summary>
      <remarks>
        <para>The position is returned in world coordinates according to the <see cref="T:yWorks.Controls.CanvasControl" /> into which this input mode is installed.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.DropInputMode.DropData">
      <summary>
        <para>Gets the data carried by a drag operation.</para>
      </summary>
      <remarks>
        <para>This is only valid, if a drag entered the <see cref="T:yWorks.Controls.CanvasControl" /> first.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.Cancel">
      <summary>
        <para>Cleanly cancels this mode.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given canvas.</para>
      </summary>
      <remarks>
        <para>Clients should not call this method as this is handled by the framework.</para>
      </remarks>
      <param name="context">
        <para>the context to install this mode into</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.DropInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="T:yWorks.Controls.CanvasControl" />
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the canvas.</para>
      </summary>
      <remarks>
        <para>Clients should not call this method as this is handled by the framework.</para>
      </remarks>
      <param name="context">
        <para>the context</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.OnDragEntered(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Called once a drag has entered the canvas.</para>
      </summary>
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.OnDraggedOver(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Called whenever a drag is over the canvas.</para>
      </summary>
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.OnDragDropped(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Called once a drag has been dropped on the canvas.</para>
      </summary>
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.OnDragLeft(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Called once a drag has left the canvas.</para>
      </summary>
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.AdjustEffect(System.Windows.Forms.DragEventArgs)">
      <summary>
        <para>Callback that adjusts the effect accordingly.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.Input.DropInputMode.SetDragLocation(yWorks.Geometry.PointD)">
      <summary>
        <para>This method updates the <see cref="P:yWorks.Controls.Input.DropInputMode.MousePosition" /> according to the coordinates passed in.</para>
      </summary>
      <remarks>
        <para>It is called prior to the <see cref="M:yWorks.Controls.Input.DropInputMode.OnDragEntered(yWorks.Controls.Input.InputModeEventArgs)" />, <see cref="M:yWorks.Controls.Input.DropInputMode.OnDraggedOver(yWorks.Controls.Input.InputModeEventArgs)" />, <see cref="M:yWorks.Controls.Input.DropInputMode.OnDragDropped(yWorks.Controls.Input.InputModeEventArgs)" /> and <see cref="M:yWorks.Controls.Input.DropInputMode.OnDragLeft(yWorks.Controls.Input.InputModeEventArgs)" /> methods.</para>
      </remarks>
      <param name="location">
        <para>The current location of the mouse in world coordinates.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.FocusGuardInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> that can be added to a <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> to suppress other modes from doing unwanted things if the control has just become focused.</para>
      </summary>
      <remarks>
        <para>This mode requests the input mutex once the canvas gains focus. It returns the mutex after the mode has regained focus and the mouse has been clicked or 100 milliseconds have passed. This mode should be registered with the <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> using the <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)" /> method and a large priority number (e.g. <c>1000</c>). So that other modes don't receive the input mutex once this one has released the mutex.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.FocusGuardInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.FocusGuardInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.FocusGuardInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.FocusGuardInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.FocusGuardInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.FocusGuardInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.FocusGuardInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.FocusGuardInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.FocusGuardInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.FocusGuardInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.FocusGuardInputMode.#ctor">
      <summary>
        <para>Creates a new instance of this mode.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.FocusGuardInputMode.GuardCursor">
      <summary>
        <para>Gets or sets the <see cref="T:System.Windows.Forms.Cursor" /> that will be shown during active guards.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="P:System.Windows.Forms.Cursors.Arrow" /></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.FocusGuardInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.FocusGuardInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.FocusGuardInputMode.Cancel" />
    <member name="M:yWorks.Controls.Input.FocusGuardInputMode.TryStop" />
    <member name="M:yWorks.Controls.Input.FocusGuardInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.HandleInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> implementation that can handle a collection of <see cref="T:yWorks.Controls.Input.IHandle" />s.</para>
      </summary>
      <remarks>
        <para>This mode will render a visual representation of <see cref="T:yWorks.Controls.Input.IHandle" />s in the <see cref="T:yWorks.Controls.CanvasControl" /> and deal with mouse gestures that drag the visual representations accordingly.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.HandleInputMode.Exclusive" /> by default.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.IHandle" />
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.HandleInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.TryStop" />
    <member name="M:yWorks.Controls.Input.HandleInputMode.Cancel" />
    <member name="P:yWorks.Controls.Input.HandleInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.HandleInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
        <para>Disabling this mode will hide the handles and prevent the user from interacting with them.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.HandleInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.CreateInputModeEventArgs">
      <summary>
        <para>Helper method that yields a suitably configured <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> for this input mode.</para>
      </summary>
      <returns>
        <para>An input mode event argument that is configured for this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.HandleInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.HandleInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingDefaultKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Default" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingMoveKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Move" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingResizeKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Resize" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingRotateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Rotate" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingShearKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Shear" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingInvisibleKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Invisible" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingInvisibleVariant2Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Invisible" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant2" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingInvisibleVariant3Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Invisible" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant3" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingInvisibleVariant4Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Invisible" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant4" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingDefaultVariant2Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> H<see cref="F:yWorks.Controls.Input.HandleTypes.Default" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant2" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingMoveVariant2Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Move" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant2" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingResizeVariant2Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Resize" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant2" /></para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingRotateVariant2Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Rotate" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant2" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingShearVariant2Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Shear" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant2" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingDefaultVariant3Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Default" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant3" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingMoveVariant3Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Move" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant3" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingResizeVariant3Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Resize" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant3" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingRotateVariant3Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Rotate" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant3" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingShearVariant3Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Shear" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant3" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingDefaultVariant4Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Default" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant4" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingMoveVariant4Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Move" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant4" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingResizeVariant4Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Resize" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant4" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingRotateVariant4Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Rotate" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant4" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingShearVariant4Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Shear" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant4" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingWarpKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Warp" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingWarpVariant2Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Warp" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant2" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingWarpVariant3Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Warp" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant3" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleInputMode.HandleDrawingWarpVariant4Key">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for the rendering of <see cref="T:yWorks.Controls.Input.IHandle" />s of <see cref="T:yWorks.Controls.Input.HandleTypes">type</see> <see cref="F:yWorks.Controls.Input.HandleTypes.Warp" /> | <see cref="F:yWorks.Controls.Input.HandleTypes.Variant4" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.#ctor">
      <summary>
        <para>Creates a new mode with no handles initially.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.HandleInputMode.Handles" />
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.DisableSnappingRecognizer">
      <summary>
        <para>Gets or sets event recognizer that recognizes when the user temporarily disables snapping.</para>
      </summary>
      <value>
        <para>The instance to use for disabling snapping. The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlDown" /></para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.HandleInputMode.EnableSnappingRecognizer" />
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.EnableSnappingRecognizer">
      <summary>
        <para>Gets or sets event recognizer that recognizes when the user reenables temporarily disabled snapping.</para>
      </summary>
      <value>
        <para>The instance to use for reenabling snapping. The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlUp" /></para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.Invalidate">
      <summary>
        <para>Convenience method that invalidates the canvas this mode is currently installed in.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.PressedRecognizer">
      <summary>
        <para>Gets or sets the "pressed" state recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance will be used to determine when the user begins to move a handle.</para>
      </remarks>
      <value>
        <para>The "pressed" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.DraggedRecognizer">
      <summary>
        <para>Gets or sets the "dragged" recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance determines when the user is moving a handle.</para>
      </remarks>
      <value>
        <para>The "dragged" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.CancelRecognizer">
      <summary>
        <para>Gets or sets the "cancel" recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer recognizes the cancel action during the move.</para>
      </remarks>
      <value>
        <para>The "cancel" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.ReleasedRecognizer">
      <summary>
        <para>Gets or sets the "released" recognizer.</para>
      </summary>
      <remarks>
        <para>This instance determines when the user has finished moving the handle.</para>
      </remarks>
      <value>
        <para>The "released" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.Handles">
      <summary>
        <para>Gets or sets the collection of <see cref="T:yWorks.Controls.Input.IHandle" />s this mode manages.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs the visual representation of the handles into the canvas into the <see cref="P:yWorks.Controls.CanvasControl.InputModeGroup" />.</para>
      </summary>
      <param name="context" />
      <param name="controller" />
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Removes the <see cref="T:yWorks.Controls.ICanvasObject" /> that displays the handles from the canvas.</para>
      </summary>
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.BeginDragging(yWorks.Controls.Input.IHandle)">
      <summary>
        <para>Method that can be used to initialize the dragging of a given handle by hand.</para>
      </summary>
      <remarks>
        <para>This will simulate the user having initialized a drag of the given handle.</para>
      </remarks>
      <param name="handle">
        <para>The handle to be dragged.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.IsHovering(System.Object,System.EventArgs)">
      <summary>
        <para>Event recognizer callback used to determine whether the mouse is currently hovering over a handle.</para>
      </summary>
      <returns>
        <para>Whether the mouse is hovering over handle.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.HandleInputMode.GetClosestHitHandle(yWorks.Geometry.PointD)" />
      <param name="sender" />
      <param name="args" />
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.Arm(yWorks.Controls.Input.IHandle)">
      <summary>
        <para>Callback method that is invoked when this mode gets "armed".</para>
      </summary>
      <remarks>
        <para>This happens when the mouse pointer hovers over a handle. This changes the mouse cursor to the <paramref name="handle" />'s <see cref="P:yWorks.Controls.Input.IHandle.Cursor" />.</para>
      </remarks>
      <param name="handle" />
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.Disarm">
      <summary>
        <para>Callback method that is invoked when this mode gets "disarmed".</para>
      </summary>
      <remarks>
        <para>This happens when the mouse stops hovering over a handle. This resets the mouse cursor</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.SnapContext">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.HandleInputMode.SnapContext" /> which manages snapping model items to certain coordinates (for instance, other items).</para>
      </summary>
      <remarks>
        <para>If set to <c>null</c> (the default) this input mode tries to obtain the <see cref="P:yWorks.Controls.Input.HandleInputMode.SnapContext" /> from the <see cref="T:yWorks.Controls.Input.IInputModeContext" />. To explicitly disable snapping, a <see cref="P:yWorks.Controls.Input.HandleInputMode.SnapContext" /> implementation that does nothing has to be set to this instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.CurrentHandle">
      <summary>
        <para>Gets the handle that is currently being moved or <c>null</c> otherwise.</para>
      </summary>
      <value>
        <para>The current handle or <c>null</c>.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.CreateHandleInputModeContext">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> for use with the <see cref="T:yWorks.Controls.Input.IHandle" /> interface for the upcoming drag operation.</para>
      </summary>
      <returns>
        <para>An instance of <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.HandleInputMode.AffectedItems">
      <summary>
        <para>Gets an immutable snapshot of the <see cref="T:yWorks.Graph.IModelItem" />s affected by the currently modified <see cref="P:yWorks.Controls.Input.HandleInputMode.CurrentHandle">handle</see> gesture.</para>
      </summary>
      <remarks>
        <para>When the gesture is <see cref="E:yWorks.Controls.Input.HandleInputMode.DragStarting">starting</see> and the <see cref="P:yWorks.Controls.Input.HandleInputMode.CurrentHandle" /> is <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">initialized</see>, the implementation can <see cref="M:yWorks.Controls.Input.IModelItemCollector.Add(yWorks.Graph.IModelItem)">register</see> the affected item(s) through the <see cref="T:yWorks.Controls.Input.IModelItemCollector" /> instance that is bound to the <see cref="M:yWorks.Controls.Input.HandleInputMode.CreateHandleInputModeContext">context</see> available via its <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
        <para>Client code can register with the <see cref="E:yWorks.Controls.Input.HandleInputMode.DragStarted" /> event, as well as the <see cref="E:yWorks.Controls.Input.HandleInputMode.DragFinished" /> event to get notified of the elements that may be or have been affected respectively by this input mode.</para>
      </remarks>
      <value>
        <para>A snapshot of the current collection of the items that are affected by the handle drag operation.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.HandleIsHit(yWorks.Controls.Input.IHandle,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Determines whether a given handle has been visually hit by the mouse at the given world coordinates.</para>
      </summary>
      <remarks>
        <para>This implementation uses the manhatten distance as a metric to determine if the handle was hit.</para>
      </remarks>
      <param name="handle">
        <para>The handle to check</para>
      </param>
      <param name="location">
        <para>The view coordinates to check.</para>
      </param>
      <param name="distance">
        <para>The distance of the handle to the location. In the default implementation, this is a tuple representing the x- and y-distance of the handle to the location.</para>
      </param>
      <returns>
        <para>Whether the handle has been hit.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.GetClosestHitHandle(yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the closest hit handle for the given world coordinate pair.</para>
      </summary>
      <remarks>
        <para>The default implementation compares the manhatten distance of the handles to find the closest handle.</para>
      </remarks>
      <param name="location">
        <para>The coordinates in the world coordinate system.</para>
      </param>
      <returns>
        <para>The closest handle that has been hit or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.AddHandle(yWorks.Geometry.IMutablePoint,System.Windows.Forms.Cursor,yWorks.Controls.Input.HandleTypes)">
      <summary>
        <para>Factory method that creates and <see cref="M:yWorks.Controls.Input.HandleInputMode.AddHandle(yWorks.Controls.Input.IHandle)">adds</see> a handle to this mode by wrapping a given <see cref="T:yWorks.Geometry.IMutablePoint" /> instance.</para>
      </summary>
      <remarks>
        <para>The <paramref name="cursor" /> and <paramref name="type" /> are used to initialize the <see cref="T:yWorks.Controls.Input.IHandle" /> instance.</para>
      </remarks>
      <param name="location">
        <para>The point to use as a handle.</para>
      </param>
      <param name="cursor">
        <para>The cursor to use.</para>
      </param>
      <param name="type">
        <para>The type of the handle to create.</para>
      </param>
      <returns>
        <para>The handle created.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.AddHandle(yWorks.Controls.Input.IHandle)">
      <summary>
        <para>Adds a handle to the collection of handles managed by this instance.</para>
      </summary>
      <param name="handle">
        <para>The handle to add.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.RemoveHandle(yWorks.Controls.Input.IHandle)">
      <summary>
        <para>Removes a handle from the collection of handles managed by this instance.</para>
      </summary>
      <param name="handle">
        <para>The handle to remove.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.HandleInputMode.DragFinishing">
      <summary>
        <para>Occurs before the drag will be finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.HandleInputMode.DragFinished">
      <summary>
        <para>Occurs once the drag has been finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.HandleInputMode.DragStarting">
      <summary>
        <para>Occurs once the drag is starting.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.HandleInputMode.DragStarted">
      <summary>
        <para>Occurs once the drag is initialized and has started.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.HandleInputMode.Dragging">
      <summary>
        <para>Occurs at the start of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.HandleInputMode.Dragged">
      <summary>
        <para>Occurs at the end of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.HandleInputMode.DragCanceled">
      <summary>
        <para>Occurs when the drag has been canceled.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.HandleInputMode.DragCanceling">
      <summary>
        <para>Occurs before the drag will be canceled.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnDragStarting(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.HandleInputMode.DragStarting" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnDragStarted(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.HandleInputMode.DragStarted" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnDragging(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the start of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.HandleInputMode.Dragging" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnDragged(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the end of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.HandleInputMode.Dragged" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnDragFinished(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered once the drag has been finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.HandleInputMode.DragFinished" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnDragFinishing(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered before the drag will be finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.HandleInputMode.DragFinishing" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnDragCanceled(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.HandleInputMode.DragCanceled" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.HandleInputMode.OnDragCanceling(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.HandleInputMode.DragCanceling" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.IDragHandler">
      <summary>
        <para>Interface for an object that can be used to drag something displayed in a <see cref="T:yWorks.Controls.CanvasControl" /></para>
      </summary>
      <remarks>
        <para>Items can be dragged with the mouse and an instance of this class will modify their position accordingly. A drag will trigger the invocation of <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />, zero or more <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> calls, and will be finalized by either <see cref="M:yWorks.Controls.Input.IDragHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> or <see cref="M:yWorks.Controls.Input.IDragHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.IPositionHandler" />
      <seealso cref="T:yWorks.Controls.Input.IHandle" />
      <seealso cref="T:yWorks.Controls.Input.IInputModeContext" />
    </member>
    <member name="P:yWorks.Controls.Input.IDragHandler.Location">
      <summary>
        <para>Gets a view of the location of the item.</para>
      </summary>
      <remarks>
        <para>The point describes the current world coordinate of the element that can be modified by this handler.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Called by clients to indicate that the element is going to be dragged.</para>
      </summary>
      <remarks>
        <para>This call will be followed by one or more calls to <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />, and a final <see cref="M:yWorks.Controls.Input.IDragHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> or <see cref="M:yWorks.Controls.Input.IDragHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve information about the drag from.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Called by clients to indicate that the element has been dragged and its position should be updated.</para>
      </summary>
      <remarks>
        <para>This method may be called more than once after an initial <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> and will the final call will be followed by either one <see cref="M:yWorks.Controls.Input.IDragHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> or one <see cref="M:yWorks.Controls.Input.IDragHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> call.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve information about the drag from.</para>
      </param>
      <param name="originalLocation">
        <para>The value of the <see cref="P:yWorks.Controls.Input.IDragHandler.Location" /> property at the time of <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
      <param name="newLocation">
        <para>The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the implementation the <see cref="P:yWorks.Controls.Input.IDragHandler.Location" /> may or may not be modified to reflect the new value.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.IDragHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Called by clients to indicate that the dragging has been canceled by the user.</para>
      </summary>
      <remarks>
        <para>This method may be called after the initial <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> and zero or more invocations of <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />. Implementations should reset the position of the items they modify to their initial state. Alternatively to this method the <see cref="M:yWorks.Controls.Input.IDragHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> method might be called.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve information about the drag from.</para>
      </param>
      <param name="originalLocation">
        <para>The value of the coordinate of the <see cref="P:yWorks.Controls.Input.IDragHandler.Location" /> property at the time of <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.IDragHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Called by clients to indicate that the repositioning has just been finished.</para>
      </summary>
      <remarks>
        <para>This method may be called after the initial <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> and zero or more invocations of <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />. Alternatively to this method the <see cref="M:yWorks.Controls.Input.IDragHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> method might be called.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve information about the drag from.</para>
      </param>
      <param name="newLocation">
        <para>The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the implementation the <see cref="P:yWorks.Controls.Input.IDragHandler.Location" /> may or may not be modified to reflect the new value. This is the same value as delivered in the last invocation of <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /></para>
      </param>
      <param name="originalLocation">
        <para>The value of the <see cref="P:yWorks.Controls.Input.IDragHandler.Location" /> property at the time of <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.SnapPolicy">
      <summary>
        <para>The policy constants used by <see cref="T:yWorks.Controls.Input.IGridConstraintProvider`1" /></para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapPolicy.NoSnapping">
      <summary>
        <para>Don't perform snapping.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapPolicy.ToNearest">
      <summary>
        <para>Snap to the nearest grid coordinate.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapPolicy.ToGreater">
      <summary>
        <para>Snap to the nearest grid coordinate whose value is not less than the current coordinate.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapPolicy.ToSmaller">
      <summary>
        <para>Snap to the nearest grid coordinate whose value is not greater than the current coordinate.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.IGridConstraintProvider`1">
      <summary>
        <para>Interface for classes that can snap coordinates of items of a specific type to a grid.</para>
      </summary>
      <typeparam name="T">
        <para>The type of the items this class can snap</para>
      </typeparam>
      <seealso cref="T:yWorks.Controls.Input.GridConstraintProvider`1" />
    </member>
    <member name="P:yWorks.Controls.Input.IGridConstraintProvider`1.HorizontalGridWidth">
      <summary>
        <para>Gets the canonic grid width in horizontal direction.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.IGridConstraintProvider`1.VerticalGridWidth">
      <summary>
        <para>Gets the canonic grid width in vertical direction.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.IGridConstraintProvider`1.GridOrigin">
      <summary>
        <para>Gets the canonic origin of the grid.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.IGridConstraintProvider`1.SnapToGrid(yWorks.Controls.Input.IInputModeContext,`0,yWorks.Geometry.IMutablePoint,yWorks.Controls.Input.SnapPolicy,yWorks.Controls.Input.SnapPolicy)">
      <summary>
        <para>Performs the actual snapping to grid coordinates.</para>
      </summary>
      <param name="context">
        <para>The context in which the snapping should occur.</para>
      </param>
      <param name="item">
        <para>The item of which the coordinates should be snapped.</para>
      </param>
      <param name="location">
        <para>The coordinates to snap.</para>
      </param>
      <param name="xSnapPolicy">
        <para>The policy for the x coordinate.</para>
      </param>
      <param name="ySnapPolicy">
        <para>The policy for the y coordinate.</para>
      </param>
      <returns>
        <para>Whether the point has been snapped.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.GridConstraintProvider`1">
      <summary>
        <para>A simple integer based implementation of <see cref="T:yWorks.Controls.Input.IGridConstraintProvider`1" />.</para>
      </summary>
      <typeparam name="T">
        <para>The type of the items.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.Input.GridConstraintProvider`1.#ctor(System.Double)">
      <summary>
        <para>Creates a new instance using the given grid distances.</para>
      </summary>
      <param name="gridSize" />
    </member>
    <member name="M:yWorks.Controls.Input.GridConstraintProvider`1.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new instance using the given grid specification.</para>
      </summary>
      <param name="gridWidth">
        <para>Width of the grid.</para>
      </param>
      <param name="gridHeight">
        <para>Height of the grid.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GridConstraintProvider`1.#ctor(yWorks.Controls.GridInfo)">
      <summary>
        <para>Creates a new instance using the given grid info.</para>
      </summary>
      <param name="gridInfo">
        <para>The grid info object.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GridConstraintProvider`1.GridInfo">
      <summary>
        <para>Gets or sets the grid info that describes the geometry of the grid.</para>
      </summary>
      <value>
        <para>The grid info.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.GridConstraintProvider`1.HorizontalGridWidth">
      <summary>
        <para>Gets the grid height.</para>
      </summary>
      <remarks>
        <para>This implementation delegates to the <see cref="P:yWorks.Controls.Input.GridConstraintProvider`1.GridInfo" /></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GridConstraintProvider`1.VerticalGridWidth">
      <summary>
        <para>Gets the grid width.</para>
      </summary>
      <remarks>
        <para>This implementation delegates to the <see cref="P:yWorks.Controls.Input.GridConstraintProvider`1.GridInfo" /></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GridConstraintProvider`1.GridOrigin">
      <summary>
        <para>Gets the grid origin.</para>
      </summary>
      <remarks>
        <para>This implementation delegates to the <see cref="P:yWorks.Controls.Input.GridConstraintProvider`1.GridInfo" /></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GridConstraintProvider`1.SnapToGrid(yWorks.Controls.Input.IInputModeContext,`0,yWorks.Geometry.IMutablePoint,yWorks.Controls.Input.SnapPolicy,yWorks.Controls.Input.SnapPolicy)">
      <param name="context" />
      <param name="item" />
      <param name="location" />
      <param name="xSnapPolicy" />
      <param name="ySnapPolicy" />
    </member>
    <member name="T:yWorks.Controls.Input.HandleTypes">
      <summary>
        <para>Describes the type of a <see cref="T:yWorks.Controls.Input.IHandle" />.</para>
      </summary>
      <remarks>
        <para>This type can be used by the rendering engine to render different types of handles differently.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.IHandle.Type" />
      <seealso cref="T:yWorks.Controls.Input.HandleInputMode" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Invisible">
      <summary>
        <para>A handle which serves a general purpose but should not be displayed.</para>
      </summary>
      <remarks>
        <para>This is the basic type of a handle and can be queried using the <see cref="F:yWorks.Controls.Input.HandleTypes.TypeMask" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Default">
      <summary>
        <para>A default handle which serves a general purpose.</para>
      </summary>
      <remarks>
        <para>This is the basic type of a handle and can be queried using the <see cref="F:yWorks.Controls.Input.HandleTypes.TypeMask" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Resize">
      <summary>
        <para>A handle which can be used to resize something.</para>
      </summary>
      <remarks>
        <para>This is the basic type of a handle and can be queried using the <see cref="F:yWorks.Controls.Input.HandleTypes.TypeMask" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Rotate">
      <summary>
        <para>A handle which can be used to rotate something.</para>
      </summary>
      <remarks>
        <para>This is the basic type of a handle and can be queried using the <see cref="F:yWorks.Controls.Input.HandleTypes.TypeMask" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Move">
      <summary>
        <para>A handle which can be used to move something.</para>
      </summary>
      <remarks>
        <para>This is the basic type of a handle and can be queried using the <see cref="F:yWorks.Controls.Input.HandleTypes.TypeMask" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Shear">
      <summary>
        <para>A handle which can be used to shear an object.</para>
      </summary>
      <remarks>
        <para>This is the basic type of a handle and can be queried using the <see cref="F:yWorks.Controls.Input.HandleTypes.TypeMask" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Warp">
      <summary>
        <para>A handle which can be used to warp an object.</para>
      </summary>
      <remarks>
        <para>This is the basic type of a handle and can be queried using the <see cref="F:yWorks.Controls.Input.HandleTypes.TypeMask" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.TypeMask">
      <summary>
        <para>A bitmask that can be used to query the basic type of a handle type.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.Default" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.Move" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.Resize" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.Rotate" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.Shear" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.Warp" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Variant1">
      <summary>
        <para>A default variant modifier that decorates a basic type.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.VariantMask" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Variant2">
      <summary>
        <para>The second variant modifier that decorates a basic type.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.VariantMask" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Variant3">
      <summary>
        <para>The third variant modifier that decorates a basic type.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.VariantMask" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.Variant4">
      <summary>
        <para>The forth variant modifier that decorates a basic type.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.VariantMask" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.VariantMask">
      <summary>
        <para>A bitmask that can be used to query the variant of a basic handle type.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.Variant1" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.Variant2" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.Variant3" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.Variant4" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.OffsetNorth">
      <summary>
        <para>A modifier that can be used to tell the rendering engine to render the visual representation of this handle with an offset to the north.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.OffsetMask" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.OffsetEast">
      <summary>
        <para>A modifier that can be used to tell the rendering engine to render the visual representation of this handle with an offset to the east.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.OffsetMask" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.OffsetSouth">
      <summary>
        <para>A modifier that can be used to tell the rendering engine to render the visual representation of this handle with an offset to the south.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.OffsetMask" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.OffsetWest">
      <summary>
        <para>A modifier that can be used to tell the rendering engine to render the visual representation of this handle with an offset to the west.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.OffsetMask" />
    </member>
    <member name="F:yWorks.Controls.Input.HandleTypes.OffsetMask">
      <summary>
        <para>A bitmask that can be used to query the offsets of a basic handle type.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.OffsetNorth" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.OffsetEast" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.OffsetSouth" />
      <seealso cref="F:yWorks.Controls.Input.HandleTypes.OffsetWest" />
    </member>
    <member name="T:yWorks.Controls.Input.HandlePositions">
      <summary>
        <para>The possible positions of a rectangle <see cref="T:yWorks.Controls.Input.IHandle" />s.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.None">
      <summary>
        <para>Indicates no position at all.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.NorthWest">
      <summary>
        <para>Indicates the position at north west.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.North">
      <summary>
        <para>Indicates the position at north.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.NorthEast">
      <summary>
        <para>Indicates the position at north east.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.West">
      <summary>
        <para>Indicates the position at west.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.Center">
      <summary>
        <para>Indicates the position at the center.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.East">
      <summary>
        <para>Indicates the position at east.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.SouthWest">
      <summary>
        <para>Indicates the position at south west.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.South">
      <summary>
        <para>Indicates the position at south.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.SouthEast">
      <summary>
        <para>Indicates the position at south east.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.Corners">
      <summary>
        <para>A combined bitset of all possible handle positions at the four corners of a rectangle.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.Horizontal">
      <summary>
        <para>A combined bitset of the two horizontal handles of a rectangle.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.Vertical">
      <summary>
        <para>A combined bitset of the two vertical handles of a rectangle.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.Border">
      <summary>
        <para>A combined bitset of all possible handle positions at the border of a rectangle.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HandlePositions.All">
      <summary>
        <para>A combined bitset of all possible handle positions.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.IHandle">
      <summary>
        <para>Interface for a handle that can be displayed in a <see cref="T:yWorks.Controls.CanvasControl" /> as a UI element for the user to modify the contents of the control.</para>
      </summary>
      <remarks>
        <para>Handles can be dragged with the mouse and will thereby modify their context. Typically client code will use the <see cref="P:yWorks.Controls.Input.IDragHandler.Location" /> to render a visual handle that can be dragged using the mouse. A drag will trigger the invocation of <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />, zero or more <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> calls, and will be finalized by either <see cref="M:yWorks.Controls.Input.IDragHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> or <see cref="M:yWorks.Controls.Input.IDragHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.HandleInputMode" />
      <seealso cref="T:yWorks.Controls.Input.IDragHandler" />
    </member>
    <member name="P:yWorks.Controls.Input.IHandle.Type">
      <summary>
        <para>Gets the type of the handle that can be used by the rendering engine to render types differently.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.IHandle.Cursor">
      <summary>
        <para>Gets the cursor to display when the mouse hovers over or drags this handle.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.IHandleProvider">
      <summary>
        <para>Interface for an object that provides a number of <see cref="T:yWorks.Controls.Input.IHandle" /> implementations.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.IHandleProvider.GetHandles(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Returns a collection of zero or more <see cref="T:yWorks.Controls.Input.IHandle" /> implementations that are associated with this instance.</para>
      </summary>
      <returns>
        <para>A collection of handles.</para>
      </returns>
      <param name="context" />
    </member>
    <member name="T:yWorks.Controls.Input.IReshapeHandleProvider">
      <summary>
        <para>A specialized version of the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> interface that can be used to query <see cref="T:yWorks.Controls.Input.IHandle" /> implementation for resizing an object.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.IReshapeHandleProvider.GetAvailableHandles(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Returns a bitwise combination of all of the <see cref="T:yWorks.Controls.Input.HandlePositions" /> this interface can provide an implementation for.</para>
      </summary>
      <remarks>
        <para>Client code will use this method to query the available positions and may then call for each of the positions the <see cref="M:yWorks.Controls.Input.IReshapeHandleProvider.GetHandle(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.HandlePositions)" /> method to retrieve an implementation.</para>
      </remarks>
      <param name="context">
        <para>The context for which the handles are queried.</para>
      </param>
      <returns>
        <para>A bitwise combination of all positions the <see cref="M:yWorks.Controls.Input.IReshapeHandleProvider.GetHandle(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.HandlePositions)" /> method can be queried for.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IReshapeHandleProvider.GetHandle(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.HandlePositions)">
      <summary>
        <para>Returns an implementation of an <see cref="T:yWorks.Controls.Input.IHandle" /> for the given position, that can be used to reshape an object.</para>
      </summary>
      <remarks>
        <para>This method may be called for each possible single position contained in the set as returned by <see cref="M:yWorks.Controls.Input.IReshapeHandleProvider.GetAvailableHandles(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </remarks>
      <param name="context">
        <para>The context for which the handles are queried.</para>
      </param>
      <param name="position">
        <para>The single position a handle implementation should be returned for.</para>
      </param>
      <returns>
        <para>An implementation of <see cref="T:yWorks.Controls.Input.IHandle" /> for the given position.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.IHighlightIndicatorInstaller">
      <summary>
        <para>An interface for objects that can install a visual representation of a highlight decoration of an item in the model displayed in a canvas.</para>
      </summary>
      <remarks>
        <para>This interface is a tagging sub interface of the <see cref="T:yWorks.Controls.ICanvasObjectInstaller" />. This interface is used for <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> operations.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.HighlightIndicatorManager`1" />
      <seealso cref="T:yWorks.Controls.ISelectionIndicatorInstaller" />
    </member>
    <member name="T:yWorks.Controls.IFocusIndicatorInstaller">
      <summary>
        <para>An interface for objects that can install a visual focus indicator decoration of an item in the model displayed in a canvas.</para>
      </summary>
      <remarks>
        <para>This interface is a tagging sub interface of the <see cref="T:yWorks.Controls.ICanvasObjectInstaller" />. This interface is used for <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> operations.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.FocusIndicatorManager`1" />
      <seealso cref="T:yWorks.Controls.ISelectionIndicatorInstaller" />
      <seealso cref="T:yWorks.Controls.IHighlightIndicatorInstaller" />
    </member>
    <member name="T:yWorks.Controls.Input.IInputMode">
      <summary>
        <para>Interface implemented by input modes that can be registered with a <see cref="T:yWorks.Controls.CanvasControl" /> instance.</para>
      </summary>
      <remarks>
        <para>Input modes capture user gestures (or any other kind of "input") and manipulate the contents of the scene graph or the model behind the scene graph.</para>
        <para>Implementations may request an input mutex from the <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> that will be given to them in their <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. This allows them to exclusively modify the contents of the view. If another <see cref="T:yWorks.Controls.Input.IInputMode" /> successfully acquires the mutex, the <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> will be <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active">deactivated</see>.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.InputModeBase" />
    </member>
    <member name="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with. <br /> When this instance gets <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">uninstalled</see> from the context the same context instance will be passed to it. <br /> Implementations may hold a reference to the <paramref name="context" /> instance and use it while they are being installed.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.IInputMode.TryStop">
      <summary>
        <para>Called by the client in order to stop a current editing progress.</para>
      </summary>
      <remarks>
        <para>This should stop the current edit, if one is in progress and possibly commit all of the changes. If stopping is not possible, this method can return <c>false</c></para>
      </remarks>
      <returns>
        <para>
          <c>true</c> if and only if the editing has been stopped or there was no edit in progress</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Cancel" />
    </member>
    <member name="M:yWorks.Controls.Input.IInputMode.Cancel">
      <summary>
        <para>Called by the client to unconditionally cancel all editing.</para>
      </summary>
      <remarks>
        <para>This will be called prior to the uninstalling of this instance.</para>
        <para>In order to stop an active input mode manually, client code should use the following idiom:</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.IInputMode.InputModeContext">
      <summary>
        <para>Gets the context instance this mode is currently installed in or <c>null</c> if this instance is not installed.</para>
      </summary>
      <remarks>
        <para>Note that this instance should not be passed down to subordinate modes or instances. Instead a corresponding context that has this instance set as the <see cref="P:yWorks.Controls.Input.IInputModeContext.ParentInputMode" /> should be used.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.IInputMode.Priority">
      <summary>
        <para>Gets the priority of this input mode.</para>
      </summary>
      <remarks>
        <para>The priority will influence the order in which the modes will be <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see> into the canvas control. The lower the priority value, the earlier it will be installed. If two modes are installed using the same priority value, the first one will be installed earlier.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.IInputModeContext">
      <summary>
        <para>The interface for the context object that is passed to <see cref="T:yWorks.Controls.Input.IInputMode" /> instances during <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> and <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" /> and <see cref="T:yWorks.Controls.Input.IDragHandler" /> implementations like <see cref="T:yWorks.Controls.Input.IPositionHandler" /> and <see cref="T:yWorks.Controls.Input.IHandle" /> to provide additional context for the implementations.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface can carry additional information through their <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.ILookup" />
      <seealso cref="T:yWorks.Controls.Input.IInputMode" />
    </member>
    <member name="P:yWorks.Controls.Input.IInputModeContext.ParentInputMode">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.Input.IInputMode" /> which issued the context object.</para>
      </summary>
      <remarks>
        <para>This can be <c>null</c> if this context is used outside the context of an IInputMode.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.IModelItemCollector">
      <summary>
        <para>An interface that allows input modes to collect <see cref="T:yWorks.Graph.IModelItem" />s for various purposes.</para>
      </summary>
      <remarks>
        <para>This is mainly used for <see cref="T:yWorks.Controls.Input.HandleInputMode" /> and <see cref="T:yWorks.Controls.Input.MoveInputMode" /> to allow access to the items that were affected during the respective operation.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.HandleInputMode.AffectedItems" />
      <seealso cref="P:yWorks.Controls.Input.MoveInputMode.AffectedItems" />
    </member>
    <member name="M:yWorks.Controls.Input.IModelItemCollector.Add(yWorks.Graph.IModelItem)">
      <summary>
        <para>Adds a model item to this collector instance.</para>
      </summary>
      <param name="item">
        <para>The model item to add.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.IPositionHandler">
      <summary>
        <para>Interface for an object that can handle the position of an item displayed in a <see cref="T:yWorks.Controls.CanvasControl" /></para>
      </summary>
      <remarks>
        <para>The point as indicated by <see cref="P:yWorks.Controls.Input.IDragHandler.Location" /> describes the current world coordinate position of the element. It is up to the implementation how this position is interpreted. The values returned by that instance will be used for the "originalLocation" parameter in the <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />, <see cref="M:yWorks.Controls.Input.IDragHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> and <see cref="M:yWorks.Controls.Input.IDragHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> methods. Items can be dragged with the mouse and an instance of this class will modify their position accordingly. Typically client code will use the <see cref="P:yWorks.Controls.Input.IDragHandler.Location" />'s coordinates to determine the current position of the elements. A drag will trigger the invocation of <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />, zero or more <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> calls, and finally by either <see cref="M:yWorks.Controls.Input.IDragHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> or <see cref="M:yWorks.Controls.Input.IDragHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.IDragHandler" />
      <seealso cref="T:yWorks.Controls.Input.IHandle" />
      <seealso cref="T:yWorks.Controls.Input.MoveInputMode" />
    </member>
    <member name="T:yWorks.Controls.Input.IReshapeHandler">
      <summary>
        <para>Interface for an object that can be interactively reshaped in a <see cref="T:yWorks.Controls.CanvasControl" /></para>
      </summary>
      <remarks>
        <para>Items can be reshaped interactively and an instance of this class can be used to handle that process. A reshape operation will be initialized by a call to <see cref="M:yWorks.Controls.Input.IReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" />, then zero or more <see cref="M:yWorks.Controls.Input.IReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /> calls follow, and the operation will be finalized by a call to either <see cref="M:yWorks.Controls.Input.IReshapeHandler.ReshapeFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /> or <see cref="M:yWorks.Controls.Input.IReshapeHandler.CancelReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />. Note that implementations of this class will only be used during interactive reshape operations.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.IDragHandler" />
      <seealso cref="T:yWorks.Controls.Input.IPositionHandler" />
      <seealso cref="T:yWorks.Controls.Input.IHandle" />
      <seealso cref="T:yWorks.Controls.Input.IInputModeContext" />
    </member>
    <member name="P:yWorks.Controls.Input.IReshapeHandler.Bounds">
      <summary>
        <para>Gets a view of the bounds of the item.</para>
      </summary>
      <remarks>
        <para>The rectangle describes the current world coordinate of the element that can be modified by this handler.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Called by clients to indicate that the element is going to be reshaped.</para>
      </summary>
      <remarks>
        <para>This call will be followed by one or more calls to <see cref="M:yWorks.Controls.Input.IReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" />, and a final <see cref="M:yWorks.Controls.Input.IReshapeHandler.ReshapeFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /> or <see cref="M:yWorks.Controls.Input.IReshapeHandler.CancelReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve information about the drag from.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.IReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Called by clients to indicate that the element has been dragged and its position should be updated.</para>
      </summary>
      <remarks>
        <para>This method may be called more than once after an initial <see cref="M:yWorks.Controls.Input.IReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" /> and will the final call will be followed by either one <see cref="M:yWorks.Controls.Input.IReshapeHandler.ReshapeFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /> or one <see cref="M:yWorks.Controls.Input.IReshapeHandler.CancelReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /> call.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve information about the reshaping from.</para>
      </param>
      <param name="originalBounds">
        <para>The value of the <see cref="P:yWorks.Controls.Input.IReshapeHandler.Bounds" /> property at the time of <see cref="M:yWorks.Controls.Input.IReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
      <param name="newBounds">
        <para>The coordinates of the bounds in the world coordinate system that the client wants the shape to be at. Depending on the implementation the <see cref="P:yWorks.Controls.Input.IReshapeHandler.Bounds" /> may or may not be modified to reflect the new value.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.IReshapeHandler.CancelReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Called by clients to indicate that the reshaping has been canceled by the user.</para>
      </summary>
      <remarks>
        <para>This method may be called after the initial <see cref="M:yWorks.Controls.Input.IReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" /> and zero or more invocations of <see cref="M:yWorks.Controls.Input.IReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" />. Implementations should reset the bounds of the items they modify to their initial state. Alternatively to this method the <see cref="M:yWorks.Controls.Input.IReshapeHandler.ReshapeFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /> method might be called.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve information about the reshaping from.</para>
      </param>
      <param name="originalBounds">
        <para>The value of the coordinate of the <see cref="P:yWorks.Controls.Input.IReshapeHandler.Bounds" /> property at the time of <see cref="M:yWorks.Controls.Input.IReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.IReshapeHandler.ReshapeFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Called by clients to indicate that the reshaping has just been finished.</para>
      </summary>
      <remarks>
        <para>This method may be called after the initial <see cref="M:yWorks.Controls.Input.IReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" /> and zero or more invocations of <see cref="M:yWorks.Controls.Input.IReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" />. Alternatively to this method the <see cref="M:yWorks.Controls.Input.IReshapeHandler.CancelReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /> method might be called.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve information about the drag from.</para>
      </param>
      <param name="newBounds">
        <para>The coordinates of the bounds in the world coordinate system that the client wants the shape to be at. Depending on the implementation the <see cref="P:yWorks.Controls.Input.IReshapeHandler.Bounds" /> may or may not be modified to reflect the new value. This is the same value as delivered in the last invocation of <see cref="M:yWorks.Controls.Input.IReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /></para>
      </param>
      <param name="originalBounds">
        <para>The value of the coordinate of the <see cref="P:yWorks.Controls.Input.IReshapeHandler.Bounds" /> property at the time of <see cref="M:yWorks.Controls.Input.IReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.InputModeEventArgs">
      <summary>
        <para>Event argument base class that is used by events that are triggered by <see cref="T:yWorks.Controls.Input.IInputMode" /> implementations</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.InputModeEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context to initialize the <see cref="P:yWorks.Controls.Input.InputModeEventArgs.Context" /> property with.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.InputModeEventArgs.Context">
      <summary>
        <para>Gets the context for the current event.</para>
      </summary>
      <value>
        <para>The context.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.Input.KeyboardInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> that recognizes simple key events and invokes a registered handler.</para>
      </summary>
      <remarks>
        <para>This mode is <see cref="P:yWorks.Controls.Input.KeyboardInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.KeyboardInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.KeyboardInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.KeyboardInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.KeyboardInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.TryStop">
      <summary>
        <para>Overridden to only return <c>true</c> if this instance does not currently <see cref="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">have the input mutex</see>.</para>
      </summary>
      <returns>
        <para>
          <c>true</c> iff this instance does not <see cref="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">own the mutex</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.Cancel" />
    <member name="P:yWorks.Controls.Input.KeyboardInputMode.Canvas">
      <summary>
        <para>Gets the canvas instance this mode is currently installed in or <c>null</c>.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.KeyboardInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.KeyboardInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.KeyboardInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.KeyboardInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.KeyboardInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.AddRecognizerBinding(yWorks.Controls.Input.EventRecognizer,yWorks.Controls.ICommand,System.Object)">
      <summary>
        <para>Adds a given handler to this instance that will be triggered if the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> recognizes a <see cref="T:yWorks.Controls.CompoundKeyEventArgs">key event</see> that has been triggered by the <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <param name="recognizer">
        <para>An event recognizer that will be fed with all key events.</para>
      </param>
      <param name="command">
        <para>The command to invoke if the recognizer matches a key event.</para>
      </param>
      <param name="commandParameter">
        <para>The optional parameter to provide to the command.</para>
      </param>
      <returns>
        <para>The newly constructed binding on which <see cref="M:yWorks.Controls.Input.KeyboardInputModeBinding.Remove" /> can be called to remove the resulting binding from this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.AddKeyBinding(System.Windows.Forms.Keys,System.Windows.Forms.Keys,yWorks.Controls.ICommand,System.Object)">
      <summary>
        <para>Adds an event handler for a specific key press gesture to this mode.</para>
      </summary>
      <param name="key">
        <para>The key constant that should be recognized.</para>
      </param>
      <param name="modifiers">
        <para>The modifiers that should be recognized when the key is pressed.</para>
      </param>
      <param name="command">
        <para>The command to execute.</para>
      </param>
      <param name="commandParameter">
        <para>The command parameter to use for the <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">execution</see>; <c>null</c> if omitted.</para>
      </param>
      <returns>
        <para>A token for the newly created command binding that can used to later <see cref="M:yWorks.Controls.Input.KeyboardInputModeBinding.Remove">remove</see> this binding from this instance again.</para>
      </returns>
      <remarks>
        <para>Using this registration method, the command will not be allowed to execute if this mode is <see cref="P:yWorks.Controls.Input.KeyboardInputMode.Enabled">disabled</see> or <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active">inactive</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})">
      <summary>
        <para>Adds a command and associated execution handlers to this instance.</para>
      </summary>
      <remarks>
        <para>The command will not be allowed to execute if this mode is <see cref="P:yWorks.Controls.Input.KeyboardInputMode.Enabled">disabled</see> or <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active">inactive</see>.</para>
      </remarks>
      <param name="command">
        <para>The command to register handlers with.</para>
      </param>
      <param name="executedHandler">
        <para>The handler for the execution; a handler that will do nothing if omitted.</para>
      </param>
      <param name="canExecuteHandler">
        <para>The handler that determines executability; a handler that is always enabled if omitted.</para>
      </param>
      <returns>
        <para>A token for the newly created command binding that can used to later <see cref="M:yWorks.Controls.Input.KeyboardInputModeBinding.Remove">remove</see> this binding from this instance again.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.RemoveCommand(yWorks.Controls.ICommand)">
      <summary>
        <para>Removes all previously registered commands from this instance.</para>
      </summary>
      <param name="command">
        <para>The command to remove from all registered bindings.</para>
      </param>
      <remarks>
        <para>This effectively disables the command for the instance managed by this mode.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddKeyBinding(System.Windows.Forms.Keys,System.Windows.Forms.Keys,yWorks.Controls.ICommand,System.Object)" />
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddRecognizerBinding(yWorks.Controls.Input.EventRecognizer,yWorks.Controls.ICommand,System.Object)" />
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Disables the registered commands and can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Enables the registered commands and can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.KeyboardInputModeBinding">
      <summary>
        <para>A token returned by <see cref="T:yWorks.Controls.Input.KeyboardInputMode" />'s factory methods that can be used to <see cref="M:yWorks.Controls.Input.KeyboardInputModeBinding.Remove" /> the binding again.</para>
      </summary>
      <remarks>
        <para>Instances of this class can only be obtained from <see cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />, <see cref="M:yWorks.Controls.Input.KeyboardInputMode.AddKeyBinding(System.Windows.Forms.Keys,System.Windows.Forms.Keys,yWorks.Controls.ICommand,System.Object)" />, and <see cref="M:yWorks.Controls.Input.KeyboardInputMode.AddRecognizerBinding(yWorks.Controls.Input.EventRecognizer,yWorks.Controls.ICommand,System.Object)" />. Removing the instances is done via the instance method <see cref="M:yWorks.Controls.Input.KeyboardInputModeBinding.Remove" /> of this type.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.KeyboardInputModeBinding.Command">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.ICommand" /> that is associated with this binding.</para>
      </summary>
      <value>
        <para>The command instance.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.KeyboardInputModeBinding.Remove">
      <summary>
        <para>Removes the binding represented by this instance from the <see cref="T:yWorks.Controls.Input.KeyboardInputMode" /> it has been created for.</para>
      </summary>
      <remarks>
        <para>Once this method has been called, the instance can be</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.MarqueeSelectionInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> implementation that can handle marquee selections performed by the user with a mouse.</para>
      </summary>
      <remarks>
        <para>This implementation will request the mutex as soon as it recognizes a mouse drag.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.MarqueeSelectionInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MarqueeSelectionInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.MarqueeSelectionInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.TryStop" />
    <member name="P:yWorks.Controls.Input.MarqueeSelectionInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.MarqueeSelectionInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MarqueeSelectionInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.MarqueeSelectionInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.CreateInputModeEventArgs">
      <summary>
        <para>Helper method that yields a suitably configured <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> for this input mode.</para>
      </summary>
      <returns>
        <para>An input mode event argument that is configured for this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.MarqueeSelectionInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.MarqueeSelectionInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.#ctor">
      <summary>
        <para>Creates a new instance of the marquee selection mode.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.Cancel">
      <summary>
        <para>Cancels any pending marquee selection.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MarqueeSelectionInputMode.SelectionRectangle">
      <summary>
        <para>Gets the current or last marquee selection rectangle.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.MarqueeSelectionInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="P:yWorks.Controls.Input.MarqueeSelectionInputMode.Template">
      <summary>
        <para>Gets or sets the template that is used for the visualization of the marquee rectangle.</para>
      </summary>
      <value>
        <para>The template.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.MarqueeSelectionInputMode.CancelRecognizer">
      <summary>
        <para>Gets or sets the "cancel" recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer recognizes the cancel action during the marquee selection.</para>
      </remarks>
      <value>
        <para>The "cancel" recognizer.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.MarqueeSelectionInputMode.MarqueeRectangleTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used to store a <see cref="T:yWorks.Controls.TemplateVisual" /> that can be used to create the visual that will be used to draw the marquee box.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MarqueeSelectionInputMode.MarqueeCursor">
      <summary>
        <para>Gets or sets the cursor to use during the dragging of the marquee.</para>
      </summary>
      <remarks>
        <para>The default is <c>Cursors.Cross</c></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MarqueeSelectionInputMode.PressedRecognizer">
      <summary>
        <para>Gets or sets the "pressed" state recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance will be used to determine when the user begins to draw the marquee.</para>
      </remarks>
      <value>
        <para>The "pressed" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MarqueeSelectionInputMode.DraggedRecognizer">
      <summary>
        <para>Gets or sets the "dragged" recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance determines when the user is dragging the marquee.</para>
      </remarks>
      <value>
        <para>The "dragged" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MarqueeSelectionInputMode.ReleasedRecognizer">
      <summary>
        <para>Gets or sets the "released" recognizer.</para>
      </summary>
      <remarks>
        <para>This instance determines when the user has finished creating the marquee.</para>
      </remarks>
      <value>
        <para>The "released" recognizer.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnDragStarting(yWorks.Controls.Input.MarqueeSelectionEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragStarting" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnDragStarted(yWorks.Controls.Input.MarqueeSelectionEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragStarted" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnDragging(yWorks.Controls.Input.MarqueeSelectionEventArgs)">
      <summary>
        <para>Callback triggered at the start of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MarqueeSelectionInputMode.Dragging" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnDragged(yWorks.Controls.Input.MarqueeSelectionEventArgs)">
      <summary>
        <para>Callback triggered at the end of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MarqueeSelectionInputMode.Dragged" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnDragFinished(yWorks.Controls.Input.MarqueeSelectionEventArgs)">
      <summary>
        <para>Callback triggered once the drag has been finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragFinished" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnDragFinishing(yWorks.Controls.Input.MarqueeSelectionEventArgs)">
      <summary>
        <para>Callback triggered before the drag will be finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragFinishing" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnDragCanceled(yWorks.Controls.Input.MarqueeSelectionEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragCanceled" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MarqueeSelectionInputMode.OnDragCanceling(yWorks.Controls.Input.MarqueeSelectionEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragCanceling" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.MarqueeSelectionInputMode.Dragging">
      <summary>
        <para>Occurs at the start of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MarqueeSelectionInputMode.Dragged">
      <summary>
        <para>Occurs at the end of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragCanceled">
      <summary>
        <para>Occurs when the drag has been canceled.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragCanceling">
      <summary>
        <para>Occurs before the drag will be canceled.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragFinishing">
      <summary>
        <para>Occurs before the drag will be finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragFinished">
      <summary>
        <para>Occurs the drag has been finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragStarting">
      <summary>
        <para>Occurs once the drag is starting.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MarqueeSelectionInputMode.DragStarted">
      <summary>
        <para>Occurs once the drag is initialized and has started.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.MarqueeSelectionEventArgs">
      <summary>
        <para>Event arguments used by <see cref="T:yWorks.Controls.Input.MarqueeSelectionInputMode" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MarqueeSelectionEventArgs.Rectangle">
      <summary>
        <para>Gets the current <see cref="P:yWorks.Controls.Input.MarqueeSelectionInputMode.SelectionRectangle">selection rectangle</see> of the <see cref="T:yWorks.Controls.Input.MarqueeSelectionInputMode" />.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.ToolTipQueryEventArgs">
      <summary>
        <para>Event argument that can be used to query the text to display when the mouse hovers over the given point in world coordinate space.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.MouseHoverInputMode" />
    </member>
    <member name="M:yWorks.Controls.Input.ToolTipQueryEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.ToolTipQueryEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context of the query.</para>
      </param>
      <param name="queryLocation">
        <para>The query location.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.ToolTipQueryEventArgs.QueryLocation">
      <summary>
        <para>Gets the query location in world coordinates.</para>
      </summary>
      <value>
        <para>The query location.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ToolTipQueryEventArgs.ToolTip">
      <summary>
        <para>Gets or sets the tool tip content to use.</para>
      </summary>
      <remarks>
        <para>Setting this property will set the <see cref="P:yWorks.Controls.Input.ToolTipQueryEventArgs.Handled" /> property to <c>true</c>.</para>
      </remarks>
      <value>
        <para>The tool tip content.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ToolTipQueryEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Controls.Input.ToolTipQueryEventArgs" /> has been handled.</para>
      </summary>
      <remarks>
        <para>This property is automatically set to <c>true</c> if <see cref="P:yWorks.Controls.Input.ToolTipQueryEventArgs.ToolTip" /> property has been assigned a value. Marking this event as handled tells the issuer of the query whether the <see cref="P:yWorks.Controls.Input.ToolTipQueryEventArgs.ToolTip" /> property should be used or whether additional logic should be used to determine whether to show the menu.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if handled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.Input.MouseHoverInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> that detects when the mouse hovers over the <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>This implementation will show a <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.ToolTip">ToolTip</see>. In order to make use of this instance one has to register with the <see cref="E:yWorks.Controls.Input.MouseHoverInputMode.QueryToolTip" /> event. Setting a custom <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.ValidHoverLocationHitTestable" /> will restrict the area where a tool tip can be shown.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MouseHoverInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MouseHoverInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.TryStop">
      <summary>
        <para>Overridden to only return <c>true</c> if this instance does not currently <see cref="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">have the input mutex</see>.</para>
      </summary>
      <returns>
        <para>
          <c>true</c> iff this instance does not <see cref="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">own the mutex</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.Cancel" />
    <member name="P:yWorks.Controls.Input.MouseHoverInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.MouseHoverInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.MouseHoverInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.#ctor">
      <summary>
        <para>Creates a new instance with default values.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.#ctor(System.Windows.Forms.ToolTip,System.EventHandler{yWorks.Controls.Input.ToolTipQueryEventArgs})">
      <summary>
        <para>Creates a new instance using the provided <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.ToolTip" /> and query callback.</para>
      </summary>
      <param name="toolTip" />
      <param name="textProvider" />
    </member>
    <member name="P:yWorks.Controls.Input.MouseHoverInputMode.ValidHoverLocationHitTestable">
      <summary>
        <para>Gets or sets an <see cref="T:yWorks.Controls.Input.IHitTestable" /> that determines where the mouse may hover and a tool tip can be <see cref="M:yWorks.Controls.Input.MouseHoverInputMode.OnShow(yWorks.Geometry.PointD)">shown</see>.</para>
      </summary>
      <remarks>
        <para>The default value of this property is <see cref="F:yWorks.Controls.Input.HitTestables.Always" /></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MouseHoverInputMode.ToolTip">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.ToolTip" /> instance to use during display.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="M:yWorks.Controls.Input.MouseHoverInputMode.CreateToolTip" /> method if no tool tip has been set.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.Show(yWorks.Geometry.PointD)">
      <summary>
        <para>Immediately shows the tool tip at the given location.</para>
      </summary>
      <param name="location">
        <para>The location in the world coordinate system.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.Hide">
      <summary>
        <para>Immediately hides the tool tip.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MouseHoverInputMode.Showing">
      <summary>
        <para>Gets or sets whether the tool tip is currently showing.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.OnShow(yWorks.Geometry.PointD)">
      <summary>
        <para>Triggered when the mouse hovers over the given coordinates.</para>
      </summary>
      <remarks>
        <para>This method will call <see cref="M:yWorks.Controls.Input.MouseHoverInputMode.GetToolTipContent(yWorks.Geometry.PointD)" /> to query the content and will display the <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.ToolTip" /> at the location returned by <see cref="M:yWorks.Controls.Input.MouseHoverInputMode.GetToolTipLocation(yWorks.Geometry.PointD)" /> if the content is not <c>null</c>.</para>
      </remarks>
      <param name="location" />
    </member>
    <member name="P:yWorks.Controls.Input.MouseHoverInputMode.ToolTipLocationOffset">
      <summary>
        <para>Gets or sets the tool tip location offset in view coordinates.</para>
      </summary>
      <remarks>
        <para>The value of this property is used by <see cref="M:yWorks.Controls.Input.MouseHoverInputMode.GetToolTipLocation(yWorks.Geometry.PointD)" /> in order to move the tool tip away from the mouse pointer. The default value is (0,0).</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.MouseHoverInputMode.GetToolTipLocation(yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.GetToolTipLocation(yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the position in canvas view coordinates to display the tool tip at for the given world coordinates.</para>
      </summary>
      <remarks>
        <para>This method adds the <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.ToolTipLocationOffset" /> after converting the given location to view coordinates.</para>
      </remarks>
      <param name="location">
        <para>The position in world coordinates.</para>
      </param>
      <returns>
        <para>The position in view coordinates.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.MouseHoverInputMode.ToolTipLocationOffset" />
    </member>
    <member name="P:yWorks.Controls.Input.MouseHoverInputMode.Duration">
      <summary>
        <para>Gets or sets the duration to show the tool tip.</para>
      </summary>
      <remarks>
        <para>The default value is 3 seconds.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MouseHoverInputMode.Delay">
      <summary>
        <para>Gets or sets the duration the mouse has to hover in one place to show a tool tip.</para>
      </summary>
      <remarks>
        <para>The default is retrieved from <see cref="P:System.Windows.Forms.SystemInformation.MouseHoverTime" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MouseHoverInputMode.MouseHoverSize">
      <summary>
        <para>Gets or sets the amount the mouse pointer has to move in order to hide the tooltip.</para>
      </summary>
      <remarks>
        <para>The default is retrieved from <see cref="P:System.Windows.Forms.SystemInformation.MouseHoverSize" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.CreateToolTip">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.ToolTip" />.</para>
      </summary>
      <returns>
        <para>A simple <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.ToolTip" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.GetToolTipContent(yWorks.Geometry.PointD)">
      <summary>
        <para>Callback method that provides a text for the given location or <c>null</c>.</para>
      </summary>
      <param name="location">
        <para>The location to find a text for.</para>
      </param>
      <returns>
        <para>A string or <c>null</c> to indicate that no tool tip should be shown.</para>
      </returns>
      <seealso cref="E:yWorks.Controls.Input.MouseHoverInputMode.QueryToolTip" />
      <seealso cref="M:yWorks.Controls.Input.MouseHoverInputMode.CreateHoverInputModeContext" />
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.OnQueryToolTip(yWorks.Controls.Input.ToolTipQueryEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.MouseHoverInputMode.QueryToolTip" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.ToolTipQueryEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.CreateHoverInputModeContext">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> for use with the <see cref="E:yWorks.Controls.Input.MouseHoverInputMode.QueryToolTip" /> event for the upcoming text query operation.</para>
      </summary>
      <returns>
        <para>An instance of <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </returns>
    </member>
    <member name="E:yWorks.Controls.Input.MouseHoverInputMode.QueryToolTip">
      <summary>
        <para>Occurs when this mode queries the tool tip for a certain query location.</para>
      </summary>
      <remarks>
        <para>Handlers should set the <see cref="P:yWorks.Controls.Input.ToolTipQueryEventArgs.ToolTip" /> property or set/respect the <see cref="P:yWorks.Controls.Input.ToolTipQueryEventArgs.Handled" /> property accordingly.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.MouseHoverInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.OnHide">
      <summary>
        <para>Called when the tooltip should be hidden.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MouseHoverInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.MoveInputMode">
      <summary>
        <para>Generic <see cref="T:yWorks.Controls.Input.IInputMode" /> implementation that can be used to move something in the canvas using the mouse.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.MoveInputMode.HitTestable" /> to determine where the user can begin dragging the selection. It will then use the <see cref="P:yWorks.Controls.Input.MoveInputMode.PositionHandler" /> to delegate the actual work of moving the elements to.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.MoveInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.TryStop" />
    <member name="M:yWorks.Controls.Input.MoveInputMode.Cancel">
      <summary>
        <para>Cancels the editing of this mode.</para>
      </summary>
      <remarks>
        <para>This implementation <see cref="M:yWorks.Controls.Input.ConcurrencyController.ReleaseMutex">releases</see> the mutex if it is currently owned by this instance and calls <see cref="M:yWorks.Controls.Input.MoveInputMode.OnCanceled" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.MoveInputMode.OnCanceled" />
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.MoveInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.MoveInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.MoveInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.MoveInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.MoveInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.MoveInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.MoveInputMode" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.DisableSnappingRecognizer">
      <summary>
        <para>Gets or sets event recognizer that recognizes when the user temporarily disables snapping.</para>
      </summary>
      <value>
        <para>The instance to use for disabling snapping. The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlDown" /></para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.MoveInputMode.EnableSnappingRecognizer" />
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.EnableSnappingRecognizer">
      <summary>
        <para>Gets or sets event recognizer that recognizes when the user reenables temporarily disabled snapping.</para>
      </summary>
      <value>
        <para>The instance to use for reenabling snapping. The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlUp" /></para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.PressedRecognizer">
      <summary>
        <para>Gets or sets the "pressed" state recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance will be used to determine when the user begins to move the selection.</para>
      </remarks>
      <value>
        <para>The "pressed" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.HoverRecognizer">
      <summary>
        <para>Gets or sets the "hovering" state recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance will be used to determine whether the user is hovering over an item where pressing can initialize a move operation. The default implementation uses the <see cref="M:yWorks.Controls.Input.MoveInputMode.IsValidStartLocation(yWorks.Geometry.PointD)" /> method to determine whether the mode can be initialized, here.</para>
      </remarks>
      <value>
        <para>The "hover" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.DraggedRecognizer">
      <summary>
        <para>Gets or sets the "dragged" recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance determines when the user is moving the selection</para>
      </remarks>
      <value>
        <para>The "dragged" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.CancelRecognizer">
      <summary>
        <para>Gets or sets the "cancel" recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer recognizes a cancel action during the move.</para>
      </remarks>
      <value>
        <para>The "cancel" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.ReleasedRecognizer">
      <summary>
        <para>Gets or sets the "released" recognizer.</para>
      </summary>
      <remarks>
        <para>This instance determines when the user has finished the move.</para>
      </remarks>
      <value>
        <para>The "released" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.HitTestable">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.IHitTestable" /> that will be used by this mode to determine where the user may start dragging.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.PositionHandler">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> that will be used as fallback to handle that actual movement of the elements during the drag.</para>
      </summary>
      <remarks>
        <para>Note that the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> retrieved by the <see cref="E:yWorks.Controls.Input.MoveInputMode.QueryPositionHandler" /> event has priority before this property. Only if the event is not <see cref="P:yWorks.Controls.Input.QueryPositionHandlerEventArgs.Handled" /> this property is used.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.IsValidStartLocation(yWorks.Geometry.PointD)">
      <summary>
        <para>Determines whether the given location is a valid start location for the move gesture.</para>
      </summary>
      <remarks>
        <para>This implementation delegates to the <see cref="P:yWorks.Controls.Input.MoveInputMode.HitTestable" />. During this callback it is possible to reset or reconfigure the <see cref="P:yWorks.Controls.Input.MoveInputMode.PositionHandler" />.</para>
      </remarks>
      <param name="location">
        <para>The location in the world coordinate system.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if at the given location it is valid to start the move gesture; otherwise, <c>false</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.MoveCursor">
      <summary>
        <para>Gets or sets the cursor to use during the move.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.Arm">
      <summary>
        <para>Callback that is called when this mode is "armed".</para>
      </summary>
      <remarks>
        <para>This happens when the mouse <see cref="P:yWorks.Controls.Input.MoveInputMode.HoverRecognizer">hovers</see> over the item(s) to move. This implementation sets the mouse cursor to <see cref="P:yWorks.Controls.Input.MoveInputMode.MoveCursor" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.Disarm">
      <summary>
        <para>Callback that is called when this mode is "disarmed".</para>
      </summary>
      <remarks>
        <para>This happens when the mouse stops hovering over the item(s). This implementation resets the mouse cursor again.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.SnapContext">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.MoveInputMode.SnapContext" /> which manages snapping model items to certain coordinates (for instance, other items).</para>
      </summary>
      <remarks>
        <para>If set to <c>null</c> (the default) this input mode tries to obtain the <see cref="P:yWorks.Controls.Input.MoveInputMode.SnapContext" /> from the <see cref="T:yWorks.Controls.Input.IInputModeContext" />. To explicitly disable snapping, a <see cref="P:yWorks.Controls.Input.MoveInputMode.SnapContext" /> implementation that does nothing has to be set to this instance.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.MoveInputMode.QueryPositionHandler">
      <summary>
        <para>Occurs when a drag is recognized for the <see cref="T:yWorks.Controls.Input.MoveInputMode" />.</para>
      </summary>
      <remarks>
        <para>If the event args are <see cref="P:yWorks.Controls.Input.QueryPositionHandlerEventArgs.Handled" />, the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> that is carried with the event args is used to actually move the items. Otherwise the pre-set <see cref="P:yWorks.Controls.Input.MoveInputMode.PositionHandler" /> property is used.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnQueryPositionHandler(yWorks.Controls.Input.QueryPositionHandlerEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.MoveInputMode.QueryPositionHandler" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.QueryPositionHandlerEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.IsDragging">
      <summary>
        <para>Gets a value indicating whether a drag operation is currently in progress.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.CreatePositionHandlerInputModeContext">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> for use with the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> interface for the upcoming drag operation.</para>
      </summary>
      <returns>
        <para>An instance of <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.InitialLocation">
      <summary>
        <para>Gets the initial position where the dragging was initiated.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MoveInputMode.AffectedItems">
      <summary>
        <para>Gets an immutable snapshot of the <see cref="T:yWorks.Graph.IModelItem" />s affected by the currently <see cref="P:yWorks.Controls.Input.MoveInputMode.IsDragging">active</see> gesture.</para>
      </summary>
      <remarks>
        <para>When the gesture is <see cref="E:yWorks.Controls.Input.MoveInputMode.DragStarting">starting</see> and the <see cref="P:yWorks.Controls.Input.MoveInputMode.PositionHandler" /> is <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">initialized</see>, the implementation can <see cref="M:yWorks.Controls.Input.IModelItemCollector.Add(yWorks.Graph.IModelItem)">register</see> the affected item(s) through the <see cref="T:yWorks.Controls.Input.IModelItemCollector" /> instance that is bound to the <see cref="M:yWorks.Controls.Input.MoveInputMode.CreatePositionHandlerInputModeContext">context</see> available via its <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
        <para>Client code can register with the <see cref="E:yWorks.Controls.Input.MoveInputMode.DragStarted" /> event, as well as the <see cref="E:yWorks.Controls.Input.MoveInputMode.DragFinished" /> event to get notified of the elements that may be or have been affected respectively by this input mode.</para>
      </remarks>
      <value>
        <para>A snapshot of the current collection of the items that are affected by the move operation.</para>
      </value>
    </member>
    <member name="E:yWorks.Controls.Input.MoveInputMode.DragFinishing">
      <summary>
        <para>Occurs before the drag will be finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveInputMode.DragFinished">
      <summary>
        <para>Occurs once the drag has been finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveInputMode.DragStarting">
      <summary>
        <para>Occurs once the drag is starting.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveInputMode.DragStarted">
      <summary>
        <para>Occurs once the drag is initialized and has started.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveInputMode.Dragging">
      <summary>
        <para>Occurs at the start of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveInputMode.Dragged">
      <summary>
        <para>Occurs at the end of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveInputMode.DragCanceled">
      <summary>
        <para>Occurs when the drag has been canceled.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveInputMode.DragCanceling">
      <summary>
        <para>Occurs before the drag will be canceled.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnDragStarting(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MoveInputMode.DragStarting" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnDragStarted(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MoveInputMode.DragStarted" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnDragging(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the start of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MoveInputMode.Dragging" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnDragged(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the end of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MoveInputMode.Dragged" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnDragFinished(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered once the drag has been finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MoveInputMode.DragFinished" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnDragFinishing(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered before the drag will be finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MoveInputMode.DragFinishing" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnDragCanceled(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MoveInputMode.DragCanceled" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.OnDragCanceling(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MoveInputMode.DragCanceling" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveInputMode.DoStartDrag(yWorks.Geometry.PointD)">
      <summary>
        <para>Simulates the start of a drag and puts the state machine into the dragging state.</para>
      </summary>
      <remarks>
        <para>Subsequent moves of input devices will behave as if the dragging has been successfully initiated at <paramref name="location" />.</para>
      </remarks>
      <param name="location">
        <para>The location where the drag had been initialized.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.QueryPositionHandlerEventArgs">
      <summary>
        <para>Event argument that is used to query the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> that is used to move the items while dragging via <see cref="T:yWorks.Controls.Input.MoveInputMode" />.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.MoveInputMode" />
      <seealso cref="E:yWorks.Controls.Input.MoveInputMode.QueryPositionHandler" />
    </member>
    <member name="M:yWorks.Controls.Input.QueryPositionHandlerEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Instantiates a new <see cref="T:yWorks.Controls.Input.QueryPositionHandlerEventArgs" /></para>
      </summary>
      <param name="context">
        <para>The <see cref="T:yWorks.Controls.Input.IInputModeContext" /> of the operation.</para>
      </param>
      <param name="queryLocation">
        <para>The initial location of the movement.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.QueryPositionHandlerEventArgs.PositionHandler">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> to use for the movement of the items that are affected by the <see cref="T:yWorks.Controls.Input.MoveInputMode" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.QueryPositionHandlerEventArgs.QueryLocation">
      <summary>
        <para>Gets the location of the movement (where the drag has started).</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.QueryPositionHandlerEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Controls.Input.QueryPositionHandlerEventArgs" /> has been handled.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if handled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.Input.InertiaPolicies">
      <summary>
        <para>Flaggable enumeration used by <see cref="P:yWorks.Controls.Input.MoveViewportInputMode.Inertia" /> to determine when to use inertia moving.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.InertiaPolicies.Never">
      <summary>
        <para>Never move the viewport using inertia.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.InertiaPolicies.Mouse">
      <summary>
        <para>Move the viewport using inertia when the mouse has been used to drag the viewport.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.MoveViewportInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> implementation that can be used to grab and drag the viewport of the control it is installed in.</para>
      </summary>
      <remarks>
        <para>This implementation will request the mutex as soon as it recognizes a drag with the mouse or touch. Zooming is done with two fingers using the pinch zoom gesture. If the primary pointer is released during pinch, the secondary pointer is used for viewpoint dragging. The pinch zoom then can be restarted by touching another pointer that is recognized as the primary pointer.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.MoveViewportInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.MoveViewportInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.TryStop" />
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.MoveViewportInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.MoveViewportInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.MoveViewportInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.MoveViewportInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.PrimaryDownRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that starts the 'move viewport' gesture.</para>
      </summary>
      <value>
        <para>The recognizer instance that identifies the event that starts the viewport moving gesture. The default instance recognizes if the user presses the primary touch device down.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.PrimaryMoveRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that moves the viewport or zooms the canvas if a secondary device is down.</para>
      </summary>
      <value>
        <para>The recognizer instance that identifies the event that moves the viewport or zooms the canvas. The default instance recognizes if the user moves the primary touch device.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.PrimaryUpRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that ends the 'move viewport' or 'pinch' gesture.</para>
      </summary>
      <value>
        <para>The recognizer instance that identifies the event that ends the viewport moving or pinch gesture. The default instance recognizes if the user releases the primary touch device.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.SecondaryDownRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that starts the 'pinch' gesture</para>
      </summary>
      <value>
        <para>The recognizer instance that identifies the event that starts the pinch gesture. The default instance recognizes if the user presses the secondary touch device down.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.SecondaryMoveRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that zooms the canvas using the 'pinch' gesture or moves the viewport if no primary device is down.</para>
      </summary>
      <value>
        <para>The recognizer instance that identifies the event that zooms the canvas or moves the viewport if no primary device is down. The default instance recognizes if the user moves the secondary touch device.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.SecondaryUpRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that ends the pinch zoom gesture or ends the move if no primary device is down.</para>
      </summary>
      <value>
        <para>The recognizer instance that identifies the event that ends the pinch zoom gesture or ends the move if no primary device is down. The default instance recognizes if the user releases the secondary touch device.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.InertiaFactor">
      <summary>
        <para>Gets or sets the factor that determines how much the recent movement data is taken into account for the calculation of inertia speed and direction.</para>
      </summary>
      <remarks>
        <para>The default value is <c>0.02d</c></para>
      </remarks>
      <value>
        <para>A value between 0 and 1. Lesser values mean less influence of old data.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.InertiaThreshold">
      <summary>
        <para>Gets or sets the threshold that determines when inertia movement should stop.</para>
      </summary>
      <remarks>
        <para>The default value is <c>30</c></para>
      </remarks>
      <value>
        <para>A positive value that determines the threshold in pixels per second.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.InertiaDamping">
      <summary>
        <para>Gets or sets the amount of damping that is applied to the inertia movement.</para>
      </summary>
      <remarks>
        <para>The default value is <c>0.15d</c></para>
      </remarks>
      <value>
        <para>A value between 0 and 1 that determines the factor the inertia speed is reduced by after one second.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.Inertia">
      <summary>
        <para>Gets or sets the mode that determines when to use inertia when dragging the viewport.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.#ctor">
      <summary>
        <para>Creates a new instance of the move viewport mode</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.DragCursor">
      <summary>
        <para>Gets or sets the cursor to use during the dragging.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="P:System.Windows.Forms.Cursors.Hand" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.PressedRecognizer">
      <summary>
        <para>Gets or sets the "pressed" state recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance will be used to determine when the user begins the navigation gesture.</para>
      </remarks>
      <value>
        <para>The "pressed" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.DraggedRecognizer">
      <summary>
        <para>Gets or sets the "dragged" recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance determines when the user is dragging the viewport.</para>
      </remarks>
      <value>
        <para>The "dragged" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MoveViewportInputMode.ReleasedRecognizer">
      <summary>
        <para>Gets or sets the "released" recognizer.</para>
      </summary>
      <remarks>
        <para>This instance determines when the user has finished dragging the viewport.</para>
      </remarks>
      <value>
        <para>The "released" recognizer.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.Cancel">
      <summary>
        <para>Cancels navigation.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.Arm">
      <summary>
        <para>Called to prepare moving the viewport when the mouse is pressed.</para>
      </summary>
      <remarks>
        <para>This will set the mouse cursor to <see cref="P:yWorks.Controls.Input.MoveViewportInputMode.DragCursor" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.Disarm">
      <summary>
        <para>Called after moving the viewport is finished or canceled.</para>
      </summary>
      <remarks>
        <para>This will reset the mouse cursor.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnDragged(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the end of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MoveViewportInputMode.Dragged" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnDragging(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the start of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MoveViewportInputMode.Dragging" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.MoveViewportInputMode.Dragging">
      <summary>
        <para>Occurs at the start of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveViewportInputMode.Dragged">
      <summary>
        <para>Occurs at the end of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveViewportInputMode.DragFinishing">
      <summary>
        <para>Occurs before the drag will be finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveViewportInputMode.DragFinished">
      <summary>
        <para>Occurs once the drag has been finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveViewportInputMode.DragStarting">
      <summary>
        <para>Occurs once the drag is starting.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveViewportInputMode.DragStarted">
      <summary>
        <para>Occurs once the drag is initialized and has started.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveViewportInputMode.DragCanceled">
      <summary>
        <para>Occurs when the drag has been canceled.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.MoveViewportInputMode.DragCanceling">
      <summary>
        <para>Occurs before the drag will be canceled.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnDragStarting(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MoveViewportInputMode.DragStarting" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnDragStarted(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MoveViewportInputMode.DragStarted" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnDragFinished(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered once the drag has been finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MoveViewportInputMode.DragFinished" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnDragFinishing(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered before the drag will be finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.MoveViewportInputMode.DragFinishing" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnDragCanceled(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MoveViewportInputMode.DragCanceled" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.OnDragCanceling(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.MoveViewportInputMode.DragCanceling" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.MoveViewportInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.MoveViewportInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="T:yWorks.Controls.Input.MultiplexingInputMode">
      <summary>
        <para>A composite <see cref="T:yWorks.Controls.Input.IInputMode" /> implementation that additionally can deal with <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> instances.</para>
      </summary>
      <remarks>
        <para>Instances of this class can <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> and <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" /> multiple <see cref="T:yWorks.Controls.Input.IInputMode" />s. Child input modes can be added using the <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)" /> method. By providing <see cref="P:yWorks.Controls.Input.IInputMode.Priority">priorities</see> to the different modes, their <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installation</see> order can be influenced. Input modes with lower priorities are handled earlier.</para>
        <para>Child input modes can run exclusively while they hold the mutex. Other exclusive input modes are temporarily <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active">deactivated</see> until the mutex is released. This can be controlled by setting the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property on the controller. Input modes that disable the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property will always run concurrently with all other input modes.</para>
        <para>This class itself implements the <see cref="T:yWorks.Controls.Input.IInputMode" /> interface so that hierarchies of instances of this class can easily be built. This class will request the input mutex if one of its child modes requests the mutex. Also if the instance itself gets <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.Enabled">disabled</see>, it will stop or cancel the current <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.MutexOwner">owner of the mutex</see>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.MultiplexingInputMode.MutexOwner" />
      <seealso cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)" />
    </member>
    <member name="P:yWorks.Controls.Input.MultiplexingInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MultiplexingInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MultiplexingInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.CreateInputModeEventArgs(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Helper method that yields a suitably configured <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> for this input mode.</para>
      </summary>
      <param name="context">
        <para>An input mode context that is available in the <see cref="T:yWorks.Controls.Input.InputModeEventArgs" />.</para>
        <para>Can be <c>null</c> in which case a new context for this instance is created automatically.</para>
      </param>
      <returns>
        <para>An input mode event argument that is configured for this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.Initialize">
      <summary>
        <para>Performs one-time initialization of this instance.</para>
      </summary>
      <remarks>
        <para>This method should not be invoked by subclasses. This will be done automatically upon first <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installation</see> of this mode.</para>
        <para>This code will be executed only once per instance. The <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.InputModeContext" /> property will be <c>null</c> when this code is executed. This method should not be used to install this mode into a specific canvas. Subclasses should always call <c>base.Initialize()</c> first.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.MultiplexingInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" />
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.Invalidate">
      <summary>
        <para>Convenience method for subclass implementations that invalidates the canvas this mode is currently installed in.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.#ctor">
      <summary>
        <para>Creates an instance with no initial modes.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MultiplexingInputMode.MutexOwner">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.Input.IInputMode" /> that currently owns the mutex.</para>
      </summary>
      <value>
        <para>The <see cref="T:yWorks.Controls.Input.IInputMode" /> that currently owns the mutex or <c>null</c>.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">
      <summary>
        <para>Adds the given <paramref name="mode" />.</para>
      </summary>
      <remarks>
        <para>The input modes will be ordered according to their <see cref="P:yWorks.Controls.Input.IInputMode.Priority" />: Input modes with lower priority will be <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see> earlier.</para>
        <para>Input modes will run exclusively if the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of their <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed controller</see> is set to <c>true</c>. Otherwise they can not and will not be deactivated if another <see cref="T:yWorks.Controls.Input.IInputMode" /> acquires the mutex.</para>
      </remarks>
      <param name="mode">
        <para>The input mode to add to this mode.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>If the same <paramref name="mode" /> has is already added to this instance.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.SubModePriorityChanged">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.IInputMode.Priority" /> of an <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">installed</see> sub mode has changed.</para>
      </summary>
      <remarks>
        <para>This implementation <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">uninstalls</see> all sub modes and then re-<see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installs</see> them according to their new priorities.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.Remove(yWorks.Controls.Input.IInputMode)">
      <summary>
        <para>Removes the given mode from this compound mode.</para>
      </summary>
      <param name="mode">
        <para>The mode to remove.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.GetSortedModes">
      <summary>
        <para>Returns a list of all modes managed by this instance in sorted order.</para>
      </summary>
      <returns>
        <para>A list of the modes.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.AdjustCursor">
      <summary>
        <para>Adjusts the cursor of the <see cref="T:yWorks.Controls.CanvasControl" /> according to the current input mutex owner or the first mode in the list whose <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> returns a non-null <see cref="P:yWorks.Controls.Input.ConcurrencyController.PreferredCursor" />.</para>
      </summary>
      <remarks>
        <para>This method will set <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.DefaultCursor" /> as the current cursor if no other <see cref="P:yWorks.Controls.Input.ConcurrencyController.PreferredCursor" /> has been specified.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MultiplexingInputMode.DefaultCursor">
      <summary>
        <para>Gets or sets the cursor to use whenever no child mode prefers a different cursor.</para>
      </summary>
      <remarks>
        <para>The default is <c>null</c></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.MultiplexingInputMode.AdjustCursor" />
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <param name="context" />
      <param name="controller" />
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.CreateChildInputModeContext">
      <summary>
        <para>Yields an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> for the child modes of this mode.</para>
      </summary>
      <remarks>
        <para>This method is called during <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installation</see> to create a new context for the child modes and can be used by client code to obtain a suitable context object. The <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.InputModeContext" /> property is already set, when this method is called. <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> calls for the created context will be resolved by this instance's <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.ChildInputModeContextLookup(System.Type)" /> method.</para>
      </remarks>
      <returns>
        <para>A new instance that delegates to the <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.InputModeContext">parent's context.</see></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.ChildInputModeContextLookup(System.Type)">
      <summary>
        <para>Callback method that will be used by the <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.CreateChildInputModeContext">child context's</see> <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method.</para>
      </summary>
      <param name="type">
        <para>The type argument passed to <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </param>
      <returns>
        <para>The result of the lookup query, or <c>null</c>.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.MultiplexingInputMode.CreateChildInputModeContext" />
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.TryStop">
      <summary>
        <para>Tries to stop all modes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.Cancel">
      <summary>
        <para>Cancels all modes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>This implementation sets the <see cref="P:yWorks.Controls.Input.ConcurrencyController.PreferredCursor" /> property to <c>null</c> and <see cref="M:yWorks.Controls.Input.ConcurrencyController.ReleaseMutex">releases</see> the mutex if the mutex is currently owned by this instance. Also, all concurrent child modes will be disabled.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>This implementation reenabled previously disabled concurrent child modes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MultiplexingInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="T:yWorks.Controls.Input.OverviewInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> that can be used for an overview <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>This mode will add navigation capabilities to the control it is installed in.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.OverviewInputMode.ClientCanvas" />
      <seealso cref="P:yWorks.Controls.Input.OverviewInputMode.HandleInputMode" />
      <seealso cref="P:yWorks.Controls.Input.OverviewInputMode.MoveInputMode" />
      <seealso cref="P:yWorks.Controls.Input.OverviewInputMode.KeyboardInputMode" />
      <seealso cref="P:yWorks.Controls.Input.OverviewInputMode.ClickInputMode" />
    </member>
    <member name="P:yWorks.Controls.Input.OverviewInputMode.AutoInvalidate">
      <summary>
        <para>Gets or sets whether the the canvas this mode is installed in should automatically be invalidated if the client canvas gets invalidated.</para>
      </summary>
      <remarks>
        <para>Automatic invalidation will be deferred to avoid too frequent updates of the overview.</para>
        <para>To manually update the overview when this property is <c>false</c>, call the <see cref="M:yWorks.Controls.CanvasControl.Invalidate" /> method on the <see cref="T:yWorks.Controls.GraphOverviewControl" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.OverviewInputMode.ViewportTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ComponentResourceKey" /> that should yield a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used by this mode render the viewport.</para>
      </summary>
      <remarks>
        <para>When explicitly setting a <see cref="P:yWorks.Controls.Input.OverviewInputMode.Template" />, this key will not be used. This is only a fallback if <see cref="P:yWorks.Controls.Input.OverviewInputMode.Template" /> is <c>null</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OverviewInputMode.#ctor">
      <summary>
        <para>Creates a new instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.OverviewInputMode.Initialize" />
    <member name="P:yWorks.Controls.Input.OverviewInputMode.HandleInputMode">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.Input.HandleInputMode" />.</para>
      </summary>
      <remarks>
        <para>This mode is responsible for handling the single handle that allows to resize the viewport rectangle.</para>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.OverviewInputMode.CreateHandleInputMode" /> will be called.</para>
        <para>By default this input mode has a priority of <c>10</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OverviewInputMode.CreateHandleInputMode">
      <summary>
        <para>Factory method for the HandleInputMode property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.OverviewInputMode.HandleInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of HandleInputMode</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.OverviewInputMode.MoveInputMode">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.Input.MoveInputMode" />.</para>
      </summary>
      <remarks>
        <para>This mode is responsible for moving the viewport rectangle.</para>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.OverviewInputMode.CreateMoveInputMode" /> will be called.</para>
        <para>By default this input mode has a priority of <c>20</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OverviewInputMode.CreateMoveInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.OverviewInputMode.MoveInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.OverviewInputMode.MoveInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of MoveInputMode</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.OverviewInputMode.ClickInputMode">
      <summary>
        <para>Gets the <see cref="P:yWorks.Controls.Input.OverviewInputMode.ClickInputMode" />.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.OverviewInputMode.CreateClickInputMode" /> will be called.</para>
        <para>By default this input mode has a priority of <c>0</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OverviewInputMode.CreateClickInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.OverviewInputMode.ClickInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.OverviewInputMode.ClickInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of ClickInputMode</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.OverviewInputMode.KeyboardInputMode">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.Input.KeyboardInputMode" />.</para>
      </summary>
      <remarks>
        <para>This mode handles all keyboard interaction gestures with the overview control.</para>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.OverviewInputMode.CreateKeyboardInputMode" /> will be called.</para>
        <para>By default this input mode has a priority of <c>0</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OverviewInputMode.CreateKeyboardInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.OverviewInputMode.KeyboardInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.OverviewInputMode.KeyboardInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="T:yWorks.Controls.Input.KeyboardInputMode" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.OverviewInputMode.AvailableCommands">
      <summary>
        <para>Gets the list of commands that are available in this instance.</para>
      </summary>
      <remarks>
        <para>Removing commands from this collection also removes the command bindings registered by this instance.</para>
        <para>Add supported commands to make them available in this instance.</para>
        <para>Supported commands are</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveLeft" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveRight" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveUp" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveDown" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.Zoom" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.IncreaseZoom" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.DecreaseZoom" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageDown" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageUp" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageLeft" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ScrollPageRight" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.FitContent" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.UpdateContentRect" />
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OverviewInputMode.ShouldInstallCommand(yWorks.Controls.ICommand)">
      <summary>
        <para>Callback method that is used by <see cref="M:yWorks.Controls.Input.OverviewInputMode.CreateKeyboardInputMode" /> to determine which of the built-in <see cref="T:yWorks.Controls.ICommand" />s to install.</para>
      </summary>
      <remarks>
        <para>This implementation unconditionally returns <c>true</c>, subclasses may override this method to adjust the behavior.</para>
      </remarks>
      <param name="command">
        <para>The command to install.</para>
      </param>
      <returns>
        <para>Whether to install this command.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.OverviewInputMode.ClientCanvas">
      <summary>
        <para>Gets or sets the canvas this canvas should use to navigate.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.OverviewInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="P:yWorks.Controls.Input.OverviewInputMode.Template">
      <summary>
        <para>Gets or sets the template that is used for the visualization of the marquee rectangle.</para>
      </summary>
      <value>
        <para>The template.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.OverviewInputMode.AutoMouseWheelZoom">
      <summary>
        <para>Gets or sets whether the mouse wheel can be used to perform zooming in the <see cref="P:yWorks.Controls.Input.OverviewInputMode.ClientCanvas" />.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OverviewInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.OverviewInputMode.Margins">
      <summary>
        <para>Gets and sets the insets in view coordinates that should be used by the <see cref="M:yWorks.Controls.Input.OverviewInputMode.UpdateVisibleArea" /> operation.</para>
      </summary>
      <remarks>
        <para>This influences the amount of visible whitespace in the view coordinate system around the graph after the <see cref="P:yWorks.Controls.CanvasControl.ContentRect">content rect</see> of the <see cref="P:yWorks.Controls.Input.OverviewInputMode.ClientCanvas" /> has changed. The default value is <c>(5,5,5,5)</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OverviewInputMode.UpdateVisibleArea">
      <summary>
        <para>Updates the <see cref="P:yWorks.Controls.CanvasControl.Zoom">zoom</see> and <see cref="P:yWorks.Controls.CanvasControl.ViewPoint">viewpoint</see> of the overview control.</para>
      </summary>
      <remarks>
        <para>This method is called when the <see cref="P:yWorks.Controls.CanvasControl.ContentRect">graph bounds</see> of the <see cref="P:yWorks.Controls.Input.OverviewInputMode.ClientCanvas"></see> have changed. The <see cref="P:yWorks.Controls.Input.OverviewInputMode.Margins">margins</see> should be respected.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.PopulateItemContextMenuEventArgs`1">
      <summary>
        <para>A specialized subclass of <see cref="T:yWorks.Controls.Input.PopulateMenuEventArgs" /> that carries the <see cref="P:yWorks.Controls.Input.PopulateItemContextMenuEventArgs`1.Item" /> for which the context menu should be populated.</para>
      </summary>
      <typeparam name="TModelItem">
        <para>The type of the <see cref="P:yWorks.Controls.Input.PopulateItemContextMenuEventArgs`1.Item">model item</see>.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.Input.PopulateItemContextMenuEventArgs`1.#ctor(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,System.Windows.Forms.ContextMenuStrip,yWorks.Controls.Input.EventSource,`0)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.PopulateItemContextMenuEventArgs`1" /> class.</para>
      </summary>
      <param name="context">
        <para>The context to populate the menu for.</para>
      </param>
      <param name="queryLocation">
        <para>The query location.</para>
      </param>
      <param name="menu">
        <para>The context menu.</para>
      </param>
      <param name="eventSource">
        <para>The for the event that triggered the context menu.</para>
      </param>
      <param name="item">
        <para>The item for which the context menu should be populated, may be <c>null</c>.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.PopulateItemContextMenuEventArgs`1.Item">
      <summary>
        <para>Gets the item for which the tool tip is queried.</para>
      </summary>
      <value>
        <para>The item, which may be <c>null</c>.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.Input.QueryItemToolTipEventArgs`1">
      <summary>
        <para>A specialized subclass of <see cref="T:yWorks.Controls.Input.ToolTipQueryEventArgs" /> that carries the <see cref="P:yWorks.Controls.Input.QueryItemToolTipEventArgs`1.Item" /> for which the tool tip is queried.</para>
      </summary>
      <typeparam name="TModelItem">
        <para>The type of the <see cref="P:yWorks.Controls.Input.QueryItemToolTipEventArgs`1.Item">model item</see>.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.Input.QueryItemToolTipEventArgs`1.#ctor(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,`0)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.QueryItemToolTipEventArgs`1" /> class.</para>
      </summary>
      <param name="context">
        <para>The context to yield the tool tip for.</para>
      </param>
      <param name="queryLocation">
        <para>The query location.</para>
      </param>
      <param name="item">
        <para>The item for which the tool tip is queried..</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.QueryItemToolTipEventArgs`1.Item">
      <summary>
        <para>Gets the item for which the tool tip is queried.</para>
      </summary>
      <value>
        <para>The item, which may be <c>null</c>.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.Input.RectangleReshapeHandleProvider">
      <summary>
        <para>A simple convenience implementation of an <see cref="T:yWorks.Controls.Input.IReshapeHandleProvider" /> that returns handles that modify a <see cref="T:yWorks.Geometry.IMutableRectangle" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.RectangleReshapeHandleProvider.Rectangle">
      <summary>
        <para>Gets the rectangle to read the current state from.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.RectangleReshapeHandleProvider.#ctor(yWorks.Geometry.IMutableRectangle,yWorks.Controls.Input.HandlePositions)">
      <summary>
        <para>Creates a default instance that provide handles for each of the positions given for the rectangle.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to create handles for.</para>
      </param>
      <param name="handlePositions">
        <para>A bitwise combination of all handle positions this instance should provide a handle for.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.RectangleReshapeHandleProvider.GetHandle(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.HandlePositions)">
      <summary>
        <para>Provides a <see cref="T:yWorks.Controls.Input.IHandle" /> that uses the rectangle instance to perform the actual reshaping.</para>
      </summary>
      <param name="context">
        <para>The context for which the handles are queried.</para>
      </param>
      <param name="position">
        <para>The position to provide an instance for.</para>
      </param>
      <returns>
        <para>A handle implementation.</para>
      </returns>
      <remarks>
        <para>This method may be called for each possible single position contained in the set as returned by <see cref="M:yWorks.Controls.Input.IReshapeHandleProvider.GetAvailableHandles(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.ReshapeHandleProviderBase">
      <summary>
        <para>Abstract base class implementation of the <see cref="T:yWorks.Controls.Input.IReshapeHandleProvider" /> interface that has properties to restrict the size and area of a reshapeable.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandleProviderBase.MinimumSize">
      <summary>
        <para>Gets or sets the minimum size allowed for the reshapeable.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="F:yWorks.Geometry.SizeD.Zero" />.</para>
      </remarks>
      <value>
        <para>The minimum size.</para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.RectangleHandle.MinimumSize" />
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandleProviderBase.MinimumEnclosedArea">
      <summary>
        <para>Gets or sets the minimum rectangular area that needs to be contained in the reshapeable.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="F:yWorks.Geometry.SizeD.Zero" />.</para>
      </remarks>
      <value>
        <para>The minimum size.</para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.RectangleHandle.MinimumEnclosedArea" />
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandleProviderBase.MaximumSize">
      <summary>
        <para>Gets or sets the maximum size allowed for the reshapeable.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="F:yWorks.Geometry.SizeD.Infinite" />.</para>
      </remarks>
      <value>
        <para>The maximum size.</para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.RectangleHandle.MaximumSize" />
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandleProviderBase.HandlePositions">
      <summary>
        <para>Gets or sets the bitwise combination of all handle positions this instance provides a handle for.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.ReshapeHandleProviderBase.GetAvailableHandles(yWorks.Controls.Input.IInputModeContext)" />
      <seealso cref="M:yWorks.Controls.Input.RectangleReshapeHandleProvider.GetHandle(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.HandlePositions)" />
    </member>
    <member name="M:yWorks.Controls.Input.ReshapeHandleProviderBase.GetAvailableHandles(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Returns the <see cref="P:yWorks.Controls.Input.ReshapeHandleProviderBase.HandlePositions" /> property.</para>
      </summary>
      <returns>
        <para>A bitwise combination of all handle positions this instance provides a handle for if queried in <see cref="M:yWorks.Controls.Input.RectangleReshapeHandleProvider.GetHandle(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.HandlePositions)" />.</para>
      </returns>
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.ReshapeHandleProviderBase.GetHandle(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.HandlePositions)">
      <summary>
        <para>Provides a <see cref="T:yWorks.Controls.Input.IHandle" /> that uses the rectangle and reshapeable instance bound to this instance to perform the actual reshaping.</para>
      </summary>
      <param name="context">
        <para>The context for which the handles are queried.</para>
      </param>
      <param name="position">
        <para>The position to provide an instance for.</para>
      </param>
      <returns>
        <para>A handle implementation.</para>
      </returns>
      <remarks>
        <para>This method may be called for each possible single position contained in the set as returned by <see cref="M:yWorks.Controls.Input.ReshapeHandleProviderBase.GetAvailableHandles(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.SelectionEventArgs`1">
      <summary>
        <para>Event arguments that are used when modifying a <see cref="T:yWorks.Controls.ISelectionModel`1" /></para>
      </summary>
      <typeparam name="T">
        <para>The type of the items in the <see cref="T:yWorks.Controls.ISelectionModel`1" />.</para>
      </typeparam>
    </member>
    <member name="P:yWorks.Controls.Input.SelectionEventArgs`1.Selection">
      <summary>
        <para>Gets the selection these event arguments refer to.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.SelectionEventArgs`1.#ctor(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.ISelectionModel{`0})">
      <summary>
        <para>Creates a new instance.</para>
      </summary>
      <param name="context">
        <para>The context the event with these event args is dispatched.</para>
      </param>
      <param name="selection">
        <para>The selection that is modified.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.SnapContext">
      <summary>
        <para>Manages interactive snapping of elements to other elements during drag operations like movements.</para>
      </summary>
      <remarks>
        <para>This class should be used by <see cref="T:yWorks.Controls.Input.IInputMode" /> implementations and similar code as follows:</para>
        <list type="bullet">
          <item>To initialize the operation <see cref="M:yWorks.Controls.Input.SnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> needs to be called.</item>
          <item>Method <see cref="M:yWorks.Controls.Input.SnapContext.DragInitialized" /> needs to be called after the mode has performed all of its own initialization.</item>
          <item>Then a series of zero or more invocations <see cref="M:yWorks.Controls.Input.SnapContext.HandleMove(yWorks.Geometry.PointD,System.Boolean)" /> needs to be called for each incremental movement of the user's input device.</item>
          <item>After <see cref="M:yWorks.Controls.Input.SnapContext.HandleMove(yWorks.Geometry.PointD,System.Boolean)" /> has been called, the mode should perform the move and report back to the instance by calling the <see cref="M:yWorks.Controls.Input.SnapContext.Dragged(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)" /> method.</item>
          <item>If the operation is canceled by the user <see cref="M:yWorks.Controls.Input.SnapContext.CancelDrag" /> should be called.</item>
          <item>If the operation is finalized the <see cref="M:yWorks.Controls.Input.SnapContext.DragFinished(yWorks.Geometry.PointD,System.Boolean)" /> method should be called.</item>
        </list>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.HandleInputMode.SnapContext" />
      <seealso cref="P:yWorks.Controls.Input.MoveInputMode.SnapContext" />
      <seealso cref="M:yWorks.Controls.Input.SnapContext.CreateSnapResultsModelManager(yWorks.Controls.CanvasControl)" />
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.SnapContext" /> class.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.SnapContext.CollectSnapResults">
      <summary>
        <para>Occurs while <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">moving</see> items and handles.</para>
      </summary>
      <remarks>
        <para>The moving model items must register for this event, preferably in the <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> method of the <see cref="T:yWorks.Controls.Input.IDragHandler" />.</para>
        <para>The event handler has to add <see cref="T:yWorks.Controls.Input.SnapResult" />s for the moving object to the list. The <see cref="T:yWorks.Controls.Input.IDragHandler" />s of the moved items have to take care themselves whether to add a handler to the list depending on the their settings.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.SnapContext.CleanedUp">
      <summary>
        <para>Occurs when this instance has been cleaned up.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.SnapContext.CleanUp" />
    </member>
    <member name="E:yWorks.Controls.Input.SnapContext.Initialized">
      <summary>
        <para>Occurs when this instance has been initialized.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.SnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="E:yWorks.Controls.Input.SnapContext.Initializing">
      <summary>
        <para>Occurs when this instance is about to be initialized.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.SnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Controls.Input.SnapContext.VisualizeSnapResults">
      <summary>
        <para>Gets or sets a value indicating whether to visualize the snap results.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the results should be visualized <c>false</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.SnapContext.CreateSnapResultsModelManager(yWorks.Controls.CanvasControl)" />
    </member>
    <member name="P:yWorks.Controls.Input.SnapContext.IsInitializing">
      <summary>
        <para>Gets or sets a value indicating whether this instance is currently initializing.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance is initializing; <c>false</c> otherwise.</para>
      </value>
      <seealso cref="E:yWorks.Controls.Input.SnapContext.Initialized" />
      <seealso cref="E:yWorks.Controls.Input.SnapContext.Initializing" />
      <seealso cref="P:yWorks.Controls.Input.SnapContext.IsInitialized" />
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.CleanUp">
      <summary>
        <para>Performs clean up procedures.</para>
      </summary>
      <remarks>
        <para>This is called in response to <see cref="M:yWorks.Controls.Input.SnapContext.CancelDrag" /> and <see cref="M:yWorks.Controls.Input.SnapContext.DragFinished(yWorks.Geometry.PointD,System.Boolean)" /> as well as initially during <see cref="M:yWorks.Controls.Input.SnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Called by <see cref="T:yWorks.Controls.Input.IInputMode" /> implementations when an interactive drag is started.</para>
      </summary>
      <param name="context">
        <para>The context in which the interactive drag is started.</para>
      </param>
      <param name="originalLocation">
        <para>The original location of the mouse.</para>
      </param>
      <remarks>
        <para>Updates <see cref="P:yWorks.Controls.Input.SnapContext.IsInitializing" />, <see cref="P:yWorks.Controls.Input.SnapContext.OriginalLocation" />, and <see cref="P:yWorks.Controls.Input.SnapContext.CurrentInputModeContext" /> and then triggers the <see cref="E:yWorks.Controls.Input.SnapContext.Initializing" /> event.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <para>If this context is already <see cref="P:yWorks.Controls.Input.SnapContext.IsInitialized">initialized</see>.</para>
      </exception>
    </member>
    <member name="P:yWorks.Controls.Input.SnapContext.CurrentInputModeContext">
      <summary>
        <para>Gets the current input mode context.</para>
      </summary>
      <value>
        <para>The current input mode context if this instance <see cref="P:yWorks.Controls.Input.SnapContext.IsInitialized" /> or <see cref="P:yWorks.Controls.Input.SnapContext.IsInitializing" />, otherwise <c>null</c>.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.OnCleanUp(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Raises the <see cref="M:yWorks.Controls.Input.SnapContext.CleanUp" /> event.</para>
      </summary>
      <param name="eventArgs">
        <para>The <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.CreateSnapResultsModelManager(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Helper method that creates the a <see cref="T:yWorks.Controls.CollectionModelManager`1" /> that can be used to present the current <see cref="T:yWorks.Controls.Input.SnapResult" />s in the provided <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <param name="canvas">
        <para>The control to initialize the <see cref="T:yWorks.Controls.CollectionModelManager`1" /> with.</para>
      </param>
      <returns>
        <para>The model manager that manages the visual representation of the <see cref="T:yWorks.Controls.Input.SnapResult" />s.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.CreateSnapResultCanvasObjectDescriptor">
      <summary>
        <para>Helper method used by <see cref="M:yWorks.Controls.Input.SnapContext.CreateSnapResultsModelManager(yWorks.Controls.CanvasControl)" /> to create the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> for the <see cref="T:yWorks.Controls.Input.SnapResult" /> type.</para>
      </summary>
      <returns>
        <para>An instance that can install <see cref="T:yWorks.Controls.Input.SnapResult" />s in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.DragInitialized">
      <summary>
        <para>Collects a list of snap lines.</para>
      </summary>
      <remarks>
        <para>Snap lines represent possible horizontal or vertical lines to which a moved item can "snap".</para>
        <para>This method is called at the start of <see cref="T:yWorks.Controls.Input.MoveInputMode" />'s or <see cref="T:yWorks.Controls.Input.HandleInputMode" />'s gesture after all items to be moved or reshaped have been added.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.OnInitialized(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.SnapContext.Initialized" /> event.</para>
      </summary>
      <param name="eventArgs">
        <para>The <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.OnInitializing(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.SnapContext.Initializing" /> event.</para>
      </summary>
      <param name="eventArgs">
        <para>The <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.HandleMove(yWorks.Geometry.PointD,System.Boolean)">
      <summary>
        <para>Handles a move.</para>
      </summary>
      <remarks>
        <para>This method returns the adjusted (mouse) coordinates. It also manages the collection of <see cref="T:yWorks.Controls.Input.SnapResult" />s. If snapping should be temporarily (for a mouse move) disabled, <paramref name="snappingDisabled" /> has to be set to <c>true</c>.</para>
      </remarks>
      <param name="newLocation">
        <para>The current mouse location.</para>
      </param>
      <param name="snappingDisabled">
        <para>If set to <c>true</c> snapping is temporarily disabled. This will remove the snap line visualizations and return a <see cref="T:yWorks.Controls.Input.SnapState" /> with the unchanged coordinates and the <see cref="P:yWorks.Controls.Input.SnapState.SnapType" /> <see cref="F:yWorks.Controls.Input.SnapTypes.NotSnapped" />.</para>
      </param>
      <returns>
        <para>The adjusted coordinates and how they have been adjusted. The unchanged coordinates if snapping has been temporarily disabled by setting <paramref name="snappingDisabled" /> to <c>true</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.SnapContext.SnapResults">
      <summary>
        <para>Gets the collection of <see cref="T:yWorks.Controls.Input.SnapResult" />s.</para>
      </summary>
      <remarks>
        <para>This collection is automatically updated during moving the mouse.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.ProcessSnapResults(System.Collections.Generic.List{yWorks.Controls.Input.SnapResult},yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Chooses the current <see cref="T:yWorks.Controls.Input.SnapResult" />s from a temporary list.</para>
      </summary>
      <remarks>
        <para>Chooses from a list of possible results the most important ones. Also maintains the collection of snap results.</para>
      </remarks>
      <param name="snapResults">
        <para>A temporary list of suggested <see cref="T:yWorks.Controls.Input.SnapResult" />s.</para>
      </param>
      <param name="originalLocation">
        <para>The point in world coordinates where the mouse move started.</para>
      </param>
      <param name="newLocation">
        <para>The current mouse location.</para>
      </param>
      <returns>
        <para>The adjusted coordinates and how they have been adjusted.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.OnCollectSnapResults(yWorks.Controls.Input.CollectSnapResultsEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.SnapContext.CollectSnapResults" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectSnapResultsEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.DragFinished(yWorks.Geometry.PointD,System.Boolean)">
      <summary>
        <para>Called when a drag has been successfully finished.</para>
      </summary>
      <remarks>
        <para>Clears all temporary lists and sets <see cref="P:yWorks.Controls.Input.SnapContext.IsInitialized" /> back to false. Also the <see cref="M:yWorks.Controls.Input.SnapContext.CleanUp" /> method is invoked and the <see cref="E:yWorks.Controls.Input.SnapContext.CleanedUp" /> event is triggered.</para>
      </remarks>
      <param name="newLocation">
        <para>The current mouse location.</para>
      </param>
      <param name="snappingDisabled">
        <para>If set to <c>true</c> snapping is temporarily disabled. This will remove the snap line visualizations and return a <see cref="T:yWorks.Controls.Input.SnapState" /> with the unchanged coordinates and the <see cref="F:yWorks.Controls.Input.SnapTypes.NotSnapped" /> <see cref="P:yWorks.Controls.Input.SnapState.SnapType" />.</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Controls.Input.SnapState" /> that specifies the adjusted coordinates and how they have been adjusted. The unchanged coordinates if snapping has been temporarily disabled by setting <paramref name="snappingDisabled" /> to <c>true</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.SnapContext.IsInitialized">
      <summary>
        <para>Gets whether the context is initialized.</para>
      </summary>
      <remarks>
        <para>The context is initialized between the calls to <see cref="M:yWorks.Controls.Input.SnapContext.DragInitialized" /> and <see cref="M:yWorks.Controls.Input.SnapContext.DragFinished(yWorks.Geometry.PointD,System.Boolean)" /> or <see cref="M:yWorks.Controls.Input.SnapContext.CancelDrag" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.SnapContext.SnapDistance">
      <summary>
        <para>Gets or sets the global snap distance, which is the maximum distance between the current mouse coordinates and the coordinates to which the mouse will snap.</para>
      </summary>
      <remarks>
        <para>The distance is interpreted in view coordinates.</para>
        <para>The default is 5.0d</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.CollectSnapResultsEventArgs.SnapDistance" />
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.CancelDrag">
      <summary>
        <para>Called when a drag has been canceled.</para>
      </summary>
      <remarks>
        <para>Clears all temporary lists and sets <see cref="P:yWorks.Controls.Input.SnapContext.IsInitialized" /> back to false, as well as performs <see cref="M:yWorks.Controls.Input.SnapContext.CleanUp" /> and finally triggers the <see cref="E:yWorks.Controls.Input.SnapContext.CleanedUp" /> event.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.SnapContext.OriginalLocation">
      <summary>
        <para>Gets the original location of the mouse at the time the gesture was initialized.</para>
      </summary>
      <value>
        <para>The original location.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.SnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Controls.Input.SnapContext.Enabled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Controls.Input.SnapContext" /> is enabled.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if enabled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.WrapContext(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Helper method that wraps the given <paramref name="context" /> so that a <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> query on the wrapped context for the <see cref="T:yWorks.Controls.Input.SnapContext" /> type yields this instance.</para>
      </summary>
      <param name="context">
        <para>The context to wrap and delegate all calls to.</para>
      </param>
      <returns>
        <para>A modified instance that yields this instance if it is queried for the <see cref="T:yWorks.Controls.Input.SnapContext" /> type.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.SnapContext.Dragged(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)">
      <summary>
        <para>This method needs to be called by the client <see cref="T:yWorks.Controls.Input.IInputMode" /> that <see cref="M:yWorks.Controls.Input.SnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">initialized</see> this instance after it has performed the actual move operation with the adjusted coordinates after a call to <see cref="M:yWorks.Controls.Input.SnapContext.HandleMove(yWorks.Geometry.PointD,System.Boolean)" />.</para>
      </summary>
      <remarks>
        <para>Most of the client code implementations will just call this method with the exact values returned by <see cref="M:yWorks.Controls.Input.SnapContext.HandleMove(yWorks.Geometry.PointD,System.Boolean)" />. This method does not need to be called if snapping has been temporarily disabled by calling <see cref="M:yWorks.Controls.Input.SnapContext.HandleMove(yWorks.Geometry.PointD,System.Boolean)" /> with its <c>snappingDisabled</c> parameter set to <c>true</c>.</para>
      </remarks>
      <param name="mouseLocation">
        <para>The actual mouse location.</para>
      </param>
      <param name="finalSnapState">
        <para>The final snap state that contains the location that has been used by the client code for the move and how it has been snapped.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.SnapResult">
      <summary>
        <para>This is the abstract base class used by the implementers of <see cref="T:yWorks.Controls.Input.SnapContext" /> to model the result of the mouse being snapped to a certain location.</para>
      </summary>
      <remarks>
        <para>It carries a <see cref="P:yWorks.Controls.Input.SnapResult.Weight" /> and can be used to obtain a <see cref="T:yWorks.Controls.IVisualCreator" /> that will be included in the view if the result is actually <see cref="M:yWorks.Controls.Input.SnapResult.IsSnapped(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)">snapped</see> after all other results with higher weight have been <see cref="M:yWorks.Controls.Input.SnapResult.Snap(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)">snapped</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.SnapResult.Weight">
      <summary>
        <para>Gets the weight of this result.</para>
      </summary>
      <remarks>
        <para>Higher weights represent more important results.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.SnapResult.Tag">
      <summary>
        <para>Gets the tag associated with this result.</para>
      </summary>
      <remarks>
        <para>If more than one result uses the same tag (not <c>null</c>), only the one with the highest <see cref="P:yWorks.Controls.Input.SnapResult.Weight" /> will be rendered.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.SnapResult.NullResult">
      <summary>
        <para>Gets a <see cref="T:yWorks.Controls.Input.SnapResult" /> representing that there is no snapping of the x or y coordinate.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.SnapResult.GetVisualCreator">
      <summary>
        <para>Returns a <see cref="T:yWorks.Controls.IVisualCreator" /> instance that can be used to create a <see cref="T:yWorks.Controls.IVisual" /> for this result.</para>
      </summary>
      <returns>
        <para>A visual creator which creates a <see cref="T:yWorks.Controls.IVisual" /> which depicts this snap result.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.SnapResult.Snap(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)">
      <summary>
        <para>Core method that performs the actual snapping.</para>
      </summary>
      <remarks>
        <para>This implementation does nothing.</para>
      </remarks>
      <param name="unsnappedLocation">
        <para>The location prior to the snapping.</para>
      </param>
      <param name="currentSnapState">
        <para>The currently snapped location and the state of the snapping. This instance can be modified by subclasses.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.SnapResult.IsSnapped(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)">
      <summary>
        <para>Checks whether this instance is still snapped given the final mouse location.</para>
      </summary>
      <remarks>
        <para>This implementation simply returns <c>false</c>.</para>
      </remarks>
      <param name="unsnappedLocation">
        <para>The unsnapped location.</para>
      </param>
      <param name="finalSnapState">
        <para>The final snap state that has been used by the client.</para>
      </param>
      <returns>
        <para>Whether the location are still snapped for this instance.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.SnapTypes">
      <summary>
        <para>A flaggable enumeration of the different types of snaps that is used by <see cref="T:yWorks.Controls.Input.SnapState" /> in <see cref="T:yWorks.Controls.Input.SnapResult" /> implementations.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.SnapResult.Snap(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)" />
      <seealso cref="T:yWorks.Controls.Input.SnapContext" />
    </member>
    <member name="F:yWorks.Controls.Input.SnapTypes.SnappedX">
      <summary>
        <para>Indicates that the location has been snapped to its x value.</para>
      </summary>
      <remarks>
        <para>Constant for use in <see cref="M:yWorks.Controls.Input.SnapResult.Snap(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)" /> and <see cref="M:yWorks.Controls.Input.SnapResult.IsSnapped(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)" />. The methods can take a bitwise combination of this field and <see cref="F:yWorks.Controls.Input.SnapTypes.SnappedY" />, <see cref="F:yWorks.Controls.Input.SnapTypes.SnappedXY" /> and <see cref="F:yWorks.Controls.Input.SnapTypes.NotSnapped" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.SnapTypes.SnappedY">
      <summary>
        <para>Indicates that the location has been snapped to its y value.</para>
      </summary>
      <remarks>
        <para>Constant for use in <see cref="M:yWorks.Controls.Input.SnapResult.Snap(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)" /> and <see cref="M:yWorks.Controls.Input.SnapResult.IsSnapped(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)" />. The methods can take a bitwise combination of this field and <see cref="F:yWorks.Controls.Input.SnapTypes.SnappedX" />, <see cref="F:yWorks.Controls.Input.SnapTypes.SnappedXY" /> and <see cref="F:yWorks.Controls.Input.SnapTypes.NotSnapped" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.SnapTypes.SnappedXY">
      <summary>
        <para>Indicates that the location has been snapped to its x and y values.</para>
      </summary>
      <remarks>
        <para>Constant for use in <see cref="M:yWorks.Controls.Input.SnapResult.Snap(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)" /> and <see cref="M:yWorks.Controls.Input.SnapResult.IsSnapped(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)" />. This is a bitwise combination of <see cref="F:yWorks.Controls.Input.SnapTypes.SnappedX" /> and <see cref="F:yWorks.Controls.Input.SnapTypes.SnappedY" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.SnapTypes.NotSnapped">
      <summary>
        <para>Indicates that the location has not been snapped at all.</para>
      </summary>
      <remarks>
        <para>Constant for use in <see cref="M:yWorks.Controls.Input.SnapResult.Snap(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)" /> and <see cref="M:yWorks.Controls.Input.SnapResult.IsSnapped(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.SnapState">
      <summary>
        <para>Describes the state of a snapping operation.</para>
      </summary>
      <remarks>
        <para>This class is used by <see cref="T:yWorks.Controls.Input.SnapContext" /> to <see cref="M:yWorks.Controls.Input.SnapContext.ProcessSnapResults(System.Collections.Generic.List{yWorks.Controls.Input.SnapResult},yWorks.Geometry.PointD,yWorks.Geometry.PointD)">process</see> <see cref="M:yWorks.Controls.Input.SnapResult.Snap(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapState)">snap results</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.SnapState.Location">
      <summary>
        <para>Gets the current location.</para>
      </summary>
      <value>
        <para>The location. The value can be adjusted using the <see cref="M:yWorks.Controls.Input.SnapState.SnapX(System.Double)" />, <see cref="M:yWorks.Controls.Input.SnapState.SnapY(System.Double)" />, and <see cref="M:yWorks.Controls.Input.SnapState.SnapTo(yWorks.Geometry.PointD)" /> methods.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.SnapState.SnapType">
      <summary>
        <para>Gets or sets the type of the snap.</para>
      </summary>
      <value>
        <para>The type of the snap.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.SnapState.#ctor(yWorks.Geometry.PointD,yWorks.Controls.Input.SnapTypes)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.SnapState" /> class.</para>
      </summary>
      <param name="location">
        <para>The initial location.</para>
      </param>
      <param name="snapType">
        <para>The current type of the snap.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.SnapState.ToString" />
    <member name="M:yWorks.Controls.Input.SnapState.SnapY(System.Double)">
      <summary>
        <para>Modifies the Y property of the <see cref="P:yWorks.Controls.Input.SnapState.Location" /> and adjusts the <see cref="P:yWorks.Controls.Input.SnapState.SnapType" /> accordingly.</para>
      </summary>
      <param name="newY">
        <para>The new Y.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.SnapState.SnapX(System.Double)">
      <summary>
        <para>Modifies the X property of the <see cref="P:yWorks.Controls.Input.SnapState.Location" /> and adjusts the <see cref="P:yWorks.Controls.Input.SnapState.SnapType" /> accordingly.</para>
      </summary>
      <param name="newX">
        <para>The new X.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.SnapState.SnapTo(yWorks.Geometry.PointD)">
      <summary>
        <para>Sets the <see cref="P:yWorks.Controls.Input.SnapState.Location" /> to the given point and adjusts the <see cref="P:yWorks.Controls.Input.SnapState.SnapType" /> accordingly.</para>
      </summary>
      <param name="newLocation">
        <para>The new location.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.TextEditorInputMode">
      <summary>
        <para>A simple <see cref="T:yWorks.Controls.Input.IInputMode" /> that displays a <see cref="T:System.Windows.Forms.TextBoxBase" /> instance in the <see cref="T:yWorks.Controls.CanvasControl" /> to let the user edit a text.</para>
      </summary>
      <remarks>
        <para>Hitting escape or enter will cancel or stop editing.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.TextEditorInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.TextEditorInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.TextEditorInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.TextEditorInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.TextEditorInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.TextEditorInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.TextEditorInputMode.TextEdited">
      <summary>
        <para>Occurs once the text has been edited.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.TextEditorInputMode.EditingCanceled">
      <summary>
        <para>Occurs if the editing has not been finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.TextEditorInputMode.EditingStarted">
      <summary>
        <para>Occurs when text editing is started.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.#ctor">
      <summary>
        <para>Creates a new instance using a default text box.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.#ctor(System.Windows.Forms.TextBoxBase)">
      <summary>
        <para>Creates a new instance using the given text box instance.</para>
      </summary>
      <param name="textBox">
        <para>The text box to use.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.AutoCommitOnFocusLost">
      <summary>
        <para>Gets or sets a property that determines whether the text edited should be committed if the focus gets lost or the editing should be canceled.</para>
      </summary>
      <remarks>
        <para>The default behavior is to cancel the editing process.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.AutoFocusCanvasOnEditorClosed">
      <summary>
        <para>Gets or sets a property that determines whether this mode should try to <see cref="M:System.Windows.Forms.Control.Select" /> or <see cref="M:System.Windows.Forms.Control.Focus" /> the <see cref="T:yWorks.Controls.GraphControl" /> once the editor is closed via a keyboard gesture.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.AutoStartEditing">
      <summary>
        <para>Gets or sets whether this mode should automatically fire up the editor once it gets installed.</para>
      </summary>
      <remarks>
        <para>If this mode is permanently installed, set this flag to <c>false</c> and set the <see cref="P:yWorks.Controls.Input.TextEditorInputMode.Editing" /> flag to <c>true</c> in order to start editing.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.LineBreakRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> to detect the key gesture for new line breaks.</para>
      </summary>
      <remarks>
        <para>When the provided <see cref="T:System.Windows.Forms.KeyEventArgs" /> are recognized, a new line break is inserted at the current caret position.</para>
      </remarks>
      <value>
        <para>The line break recognizer. The default recognizer checks for <see cref="F:System.Windows.Forms.Keys.Return" /> while <see cref="T:System.Windows.Forms.Control" /> is pressed.</para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.TextEditorInputMode.CancelRecognizer" />
      <seealso cref="P:yWorks.Controls.Input.TextEditorInputMode.StopRecognizer" />
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.CancelRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> to detect when editing the text shall be canceled.</para>
      </summary>
      <remarks>
        <para>When the provided <see cref="T:System.Windows.Forms.KeyEventArgs" /> are recognized, <see cref="M:yWorks.Controls.Input.TextEditorInputMode.Cancel" /> is called.</para>
      </remarks>
      <value>
        <para>The cancel recognizer. The default recognizer checks for <see cref="F:System.Windows.Forms.Keys.Escape" />.</para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.TextEditorInputMode.LineBreakRecognizer" />
      <seealso cref="P:yWorks.Controls.Input.TextEditorInputMode.StopRecognizer" />
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.StopRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> to detect when editing the text shall be stopped.</para>
      </summary>
      <remarks>
        <para>When the provided <see cref="T:System.Windows.Forms.KeyEventArgs" /> are recognized, <see cref="M:yWorks.Controls.Input.TextEditorInputMode.TryStop" /> is called.</para>
      </remarks>
      <value>
        <para>The stop recognizer. The default recognizer checks for <see cref="F:System.Windows.Forms.Keys.Return" /> while <see cref="T:System.Windows.Forms.Control" /> is not pressed.</para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.TextEditorInputMode.LineBreakRecognizer" />
      <seealso cref="P:yWorks.Controls.Input.TextEditorInputMode.CancelRecognizer" />
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.CreateTextBox">
      <summary>
        <para>Factory method that creates a default text box.</para>
      </summary>
      <returns>
        <para>A text box implementation.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.Editing">
      <summary>
        <para>Gets or sets the current editing state of the editor.</para>
      </summary>
      <remarks>
        <para>Setting a new value will trigger the <see cref="M:yWorks.Controls.Input.TextEditorInputMode.OnBeginEditing" /> and <see cref="M:yWorks.Controls.Input.TextEditorInputMode.OnCancelEditing" /> methods respectively.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.OnCancelEditing">
      <summary>
        <para>Called when editing gets canceled.</para>
      </summary>
      <remarks>
        <para>Removes the text box and releases the input mutex.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.OnEditingCanceled(yWorks.Controls.Input.TextEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TextEditorInputMode.EditingCanceled" /> event.</para>
      </summary>
      <param name="args">
        <para>The event argument</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.UninstallTextBox">
      <summary>
        <para>Removes the text box.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.OnBeginEditing">
      <summary>
        <para>Called when editing starts.</para>
      </summary>
      <remarks>
        <para>Requests the input mutex, and installs the text box.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.GetTextBoxBounds">
      <summary>
        <para>Returns the bounds of the <see cref="P:yWorks.Controls.Input.TextEditorInputMode.TextBox" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.EnsureVisible">
      <summary>
        <para>Adjusts the <see cref="P:yWorks.Controls.CanvasControl.Viewport" /> of the <see cref="T:yWorks.Controls.CanvasControl" /> so the <see cref="P:yWorks.Controls.Input.TextEditorInputMode.TextBox" /> is in the visible area.</para>
      </summary>
      <remarks>
        <para>Called once when the editing starts.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.OnEditingStarted(yWorks.Controls.Input.TextEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TextEditorInputMode.EditingStarted" /> event.</para>
      </summary>
      <param name="args">
        <para>The event argument.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.Clear">
      <summary>
        <para>Resets the contents of the text box.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.OnStopEditing">
      <summary>
        <para>Called when editing is stopped.</para>
      </summary>
      <remarks>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.TextEditorInputMode.TextEdited" /> event, removes the box and releases the input mutex.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.OnTextEdited(yWorks.Controls.Input.TextEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TextEditorInputMode.TextEdited" /> event.</para>
      </summary>
      <param name="args">
        <para>The event arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.TryStop">
      <summary>
        <para>Stops editing and returns <c>true</c>.</para>
      </summary>
      <returns>
        <para>
          <c>base.Stop()</c>
        </para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.Location">
      <summary>
        <para>Gets or sets the location of the text box in world coordinates.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.Anchor">
      <summary>
        <para>Gets or sets the anchor of the text box.</para>
      </summary>
      <remarks>
        <para>The anchor is the point inside the coordinate system of the text box that shall coincide with the <see cref="P:yWorks.Controls.Input.TextEditorInputMode.Location" /> in the view coordinate system. The X and Y values are expressed as relative width/height ratios.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TextEditorInputMode.TextBox">
      <summary>
        <para>Gets or sets the text box to use for displaying and editing.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="M:yWorks.Controls.Input.TextEditorInputMode.CreateTextBox" /> factory method, the first time this property is queried.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.TextEditorInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.InstallTextBox">
      <summary>
        <para>Installs the text box in the canvas and puts focus into it.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.AdjustPosition">
      <summary>
        <para>Adjusts the position of the text box in the <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.AdjustSize">
      <summary>
        <para>Adjusts the size of the text box in the <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.Cancel">
      <summary>
        <para>Cancels editing of the text box.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEditorInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.TextEventArgs">
      <summary>
        <para>Event arguments used by <see cref="T:yWorks.Controls.Input.TextEditorInputMode" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.TextEventArgs.Text">
      <summary>
        <para>Gets the text that was or will be edited.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TextEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext,System.String)">
      <summary>
        <para>Creates a new instance.</para>
      </summary>
      <param name="context">
        <para>The context in which this text event happened.</para>
      </param>
      <param name="text">
        <para>The text that was or will be edited.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.WaitInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> implementation that can be used to block user interaction.</para>
      </summary>
      <remarks>
        <para>Setting the <see cref="P:yWorks.Controls.Input.WaitInputMode.Waiting" /> property will try to cancel ongoing edits of the <see cref="P:yWorks.Controls.Input.ConcurrencyController.MutexOwner">mutex owner</see> and set the preferred cursor to <see cref="P:yWorks.Controls.Input.WaitInputMode.WaitCursor" />. This mode will try to add itself to the <see cref="M:yWorks.Controls.CanvasControl.Lookup(System.Type)">Lookup of the CanvasControl</see>, so that other clients can make use of its functionality.</para>
        <para>This mode uses an <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> controller by default.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.WaitInputMode.Waiting" />
    </member>
    <member name="P:yWorks.Controls.Input.WaitInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.WaitInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.WaitInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.WaitInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.WaitInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.WaitInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.#ctor">
      <summary>
        <para>Creates a new instance of this mode.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.WaitInputMode.Waiting">
      <summary>
        <para>Gets or sets the Waiting property.</para>
      </summary>
      <remarks>
        <para>Setting this property to <c>true</c> will <see cref="M:yWorks.Controls.Input.WaitInputMode.StartWaiting">start the waiting process.</see> Setting it to <c>false</c> will <see cref="M:yWorks.Controls.Input.WaitInputMode.EndWaiting">end the waiting</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.EndWaiting">
      <summary>
        <para>Called when waiting is finished.</para>
      </summary>
      <remarks>
        <para>This will reset the <see cref="P:yWorks.Controls.Input.ConcurrencyController.PreferredCursor" /> and <see cref="M:yWorks.Controls.Input.ConcurrencyController.ReleaseMutex">the mutex is released.</see></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.OnWaitingEnded(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.WaitInputMode.WaitingEnded" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.CanStartWaiting">
      <summary>
        <para>Returns if this mode can request the mutex when <see cref="P:yWorks.Controls.Input.WaitInputMode.Waiting" /> is set to <c>true</c>.</para>
      </summary>
      <returns>
        <para>if this mode can request the mutex when <see cref="P:yWorks.Controls.Input.WaitInputMode.Waiting" /> is set to <c>true</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.StartWaiting">
      <summary>
        <para>This will initiate the waiting process by trying to <see cref="M:yWorks.Controls.Input.ConcurrencyController.RequestMutex" />request the input mutex.</para>
      </summary>
      <remarks>
        <para>This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.PreferredCursor" /> to <see cref="P:yWorks.Controls.Input.WaitInputMode.WaitCursor" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.OnWaitingStarted(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.WaitInputMode.WaitingStarted" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.WaitInputMode.WaitingStarted">
      <summary>
        <para>Occurs when the waiting started.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.WaitInputMode.WaitingEnded">
      <summary>
        <para>Occurs when the waiting ended.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.WaitInputMode.WaitCursor">
      <summary>
        <para>Gets or sets the WaitCursor property.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.Cancel" />
    <member name="M:yWorks.Controls.Input.WaitInputMode.TryStop" />
    <member name="M:yWorks.Controls.Input.WaitInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.WaitInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.WaitInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.BridgeCrossingStyle">
      <summary>
        <para>Specifies constants that define the the style how bridges are drawn by <see cref="T:yWorks.Controls.BridgeManager" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingStyle.Gap">
      <summary>
        <para>A simple gap in the path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingStyle.Rectangle">
      <summary>
        <para>A rectangular bridge will be inserted in the path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingStyle.RectangleScaled">
      <summary>
        <para>A rectangular bridge with a fixed aspect ratio will be inserted in the path.</para>
      </summary>
      <remarks>
        <para>This bridge will be scaled for wider bridges so that its aspect ratio remains constant.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingStyle.TwoSides">
      <summary>
        <para>A triangular bridge will be inserted in the path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingStyle.TwoSidesScaled">
      <summary>
        <para>A triangular bridge with a fixed aspect ratio will be inserted in the path.</para>
      </summary>
      <remarks>
        <para>This bridge will be scaled for wider bridges so that its aspect ratio remains constant.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingStyle.Arc">
      <summary>
        <para>A bridge, consisting of two quarter circle arcs connected by a straight line, will be inserted in the path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingStyle.ArcScaled">
      <summary>
        <para>A semi-circle bridge will be inserted in the path.</para>
      </summary>
      <remarks>
        <para>This bridge will be scaled for wider bridges so that its aspect ratio remains constant.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingStyle.Custom">
      <summary>
        <para>Inserts a custom bridge into the path.</para>
      </summary>
      <remarks>
        <para>Custom bridges require an appropriate implementation of the <see cref="T:yWorks.Controls.IBridgeCreator" /> interface and <see cref="M:yWorks.Controls.IBridgeCreator.CreateCustomBridge(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)" /> method.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.BridgeOrientationStyle">
      <summary>
        <para>Specifies constants that define the direction in which bridges are drawn.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeOrientationStyle.FlowRight">
      <summary>
        <para>The brige is drawn to the right of the flow of the path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeOrientationStyle.FlowLeft">
      <summary>
        <para>The brige is drawn to the left of the flow of the path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeOrientationStyle.Positive">
      <summary>
        <para>The brige is drawn in the direction of the positive axes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeOrientationStyle.Negative">
      <summary>
        <para>The brige is drawn in the direction of the negative axes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeOrientationStyle.Left">
      <summary>
        <para>The bridge points to the right.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeOrientationStyle.Right">
      <summary>
        <para>The bridge points to the left.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeOrientationStyle.Up">
      <summary>
        <para>The bridge points upwards.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeOrientationStyle.Down">
      <summary>
        <para>The bridge points downwards.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.BridgeCrossingPolicy">
      <summary>
        <para>Enumeration used by <see cref="T:yWorks.Controls.BridgeManager" /> that determines how crossings between obstacles and paths are determined.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingPolicy.HorizontalBridgesVertical">
      <summary>
        <para>Makes horizontal segments bridge over vertical obstacles.</para>
      </summary>
      <remarks>
        <para>Horizontal segments do not cross each other, just as vertical ones will not cross each other. Horizontal segments are segments with a slope between 1 and -1. All others are vertical segments. For non-parallel intersecting pairs of segments there does not need to be a crossing unless only one of them is vertical.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingPolicy.VerticalBridgesHorizontal">
      <summary>
        <para>Makes vertical segments bridge over horizontal obstacles.</para>
      </summary>
      <remarks>
        <para>Horizontal segments do not cross each other, just as vertical ones will not cross each other. Horizontal segments are segments with a slope between 1 and -1. All others are vertical segments. For non-parallel intersecting pairs of segments there does not need to be a crossing unless only one of them is horizontal.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingPolicy.MoreHorizontalBridgesLessHorizontal">
      <summary>
        <para>Makes more horizontal edges bridge over edges which are less horizontal.</para>
      </summary>
      <remarks>
        <para>The smaller the absolute slope of an edge, the more horizontal it is. For each non-parallel intersecting pair of segments, there will be a crossing.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.BridgeCrossingPolicy.MoreVerticalBridgesLessVertical">
      <summary>
        <para>Makes more vertical edges bridge over edges which are less vertical.</para>
      </summary>
      <remarks>
        <para>The larger the absolute slope of an edge, the more vertical it is. For each non-parallel intersecting pair of segments, there will be a crossing.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.BridgeManager">
      <summary>
        <para>Helper class that calculates visual hints in a path where said path crosses an obstacle.</para>
      </summary>
      <remarks>
        <para>Most notably this feature is used to render crossings of <see cref="T:yWorks.Graph.IEdge" />s with other edges.</para>
        <para>To set up bridges in a <see cref="T:yWorks.Controls.GraphControl" /> at the least the following is necessary:</para>
        <para>Furthermore, an edge style that supports bridges is necessary; <see cref="T:yWorks.Graph.Styles.PolylineEdgeStyle" /> is a good choice. Various other properties can be set to change the defaults, e.g. <see cref="T:yWorks.Controls.BridgeCrossingStyle">how bridges appear</see>, or <see cref="T:yWorks.Controls.BridgeOrientationStyle">which way bridges point</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.BridgeManager.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.BridgeManager" /> class.</para>
      </summary>
      <remarks>
        <para>Initially the <see cref="P:yWorks.Controls.BridgeManager.DefaultBridgeCreator" /> will be set to an instance that will delegate to the set of <c>Default</c> properties in this class and the <see cref="M:yWorks.Controls.BridgeManager.InsertDefaultCustomBridge(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)" /> method respectively.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.BridgeManager.DefaultBridgeCreator">
      <summary>
        <para>Gets or sets the default implementation of the <see cref="T:yWorks.Controls.IBridgeCreator" /> that will be used if <see cref="M:yWorks.Controls.BridgeManager.AddBridges(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Controls.IBridgeCreator)" /> is invoked with a <c>null</c> callback argument.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.BridgeManager.DefaultBridgeCrossingStyle" />
      <seealso cref="P:yWorks.Controls.BridgeManager.DefaultBridgeWidth" />
      <seealso cref="P:yWorks.Controls.BridgeManager.DefaultBridgeHeight" />
      <seealso cref="M:yWorks.Controls.BridgeManager.InsertDefaultCustomBridge(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)" />
    </member>
    <member name="P:yWorks.Controls.BridgeManager.ConsiderCurves">
      <summary>
        <para>Gets or sets a value that determines whether curves (<see cref="M:yWorks.Geometry.GeneralPath.CubicTo(yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">cubic</see> and <see cref="M:yWorks.Geometry.GeneralPath.QuadTo(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">quadratic</see>) should be considered as obstacles.</para>
      </summary>
      <remarks>
        <para>This can be a costly operation so the default is <c>false</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.BridgeManager.ZoomThreshold">
      <summary>
        <para>Gets or sets a threshold value that determines below which zoom level, there should be no more bridge calculation.</para>
      </summary>
      <remarks>
        <para>Since the calculation of the bridges is a costly operation if there are many items visible and bridges are not clearly visible at low zoom levels, it is convenient to disable the calculation of bridges for these zoom levels to speed up the rendering process. The default value is <c>0.3d</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.BridgeManager.BridgeCrossingPolicy">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.BridgeCrossingPolicy" /> mode that is used by this instance.</para>
      </summary>
      <remarks>
        <para>By default the <see cref="F:yWorks.Controls.BridgeCrossingPolicy.HorizontalBridgesVertical" /> mode is set.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.BridgeManager.CanvasControl">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.BridgeManager.CanvasControl" /> that should be managed by this instance.</para>
      </summary>
      <remarks>
        <para>This method will <see cref="M:yWorks.Controls.BridgeManager.Install(yWorks.Controls.CanvasControl)" /> a <see cref="E:yWorks.Controls.CanvasControl.PrepareRenderContext">preparation stage</see> for the <see cref="T:yWorks.Controls.IRenderContext" /> in the provided <see cref="P:yWorks.Controls.BridgeManager.CanvasControl" /> via the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> mechanism.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.BridgeManager.DefaultBridgeCrossingStyle">
      <summary>
        <para>Gets or sets the default <see cref="T:yWorks.Controls.BridgeCrossingStyle" /> that will be used by the default implementation of the <see cref="T:yWorks.Controls.IBridgeCreator" /> that is initially assigned to the <see cref="P:yWorks.Controls.BridgeManager.DefaultBridgeCreator" /> property.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="F:yWorks.Controls.BridgeCrossingStyle.Arc" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.IBridgeCreator.GetCrossingStyle(yWorks.Controls.IRenderContext)" />
    </member>
    <member name="P:yWorks.Controls.BridgeManager.DefaultBridgeWidth">
      <summary>
        <para>Gets or sets the default width of a bridge that will be used by the default implementation of the <see cref="T:yWorks.Controls.IBridgeCreator" /> that is initially assigned to the <see cref="P:yWorks.Controls.BridgeManager.DefaultBridgeCreator" /> property.</para>
      </summary>
      <remarks>
        <para>The default value is <c>10.0d</c>. Setting this value will adjust the <see cref="P:yWorks.Controls.BridgeManager.ClipMargin" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.IBridgeCreator.GetBridgeWidth(yWorks.Controls.IRenderContext)" />
    </member>
    <member name="P:yWorks.Controls.BridgeManager.ClipMargin">
      <summary>
        <para>Gets or sets the margin by which the <see cref="P:yWorks.Controls.IRenderContext.Clip" /> should be enlarged to accommodate for clipped away lines being taken into account for bridge calculation.</para>
      </summary>
      <remarks>
        <para>This value should be set to at least half the value of <see cref="M:yWorks.Controls.IBridgeCreator.GetBridgeWidth(yWorks.Controls.IRenderContext)">the width of the bridges</see> used in this context. This is because obstacles might otherwise be clipped from the view and not taken into account for the calculation of the bridges. By default this value will be 2 more than half of the <see cref="P:yWorks.Controls.BridgeManager.DefaultBridgeWidth" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.BridgeManager.DefaultBridgeHeight">
      <summary>
        <para>Gets or sets the default height of a bridge that will be used by the default implementation of the <see cref="T:yWorks.Controls.IBridgeCreator" /> that is initially assigned to the <see cref="P:yWorks.Controls.BridgeManager.DefaultBridgeCreator" /> property.</para>
      </summary>
      <remarks>
        <para>The default value is <c>5.0d</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.IBridgeCreator.GetBridgeHeight(yWorks.Controls.IRenderContext)" />
    </member>
    <member name="P:yWorks.Controls.BridgeManager.DefaultBridgeOrientationStyle">
      <summary>
        <para>Gets or sets the default <see cref="T:yWorks.Controls.BridgeOrientationStyle" /> for bridges that will be used by the default implementation of the <see cref="T:yWorks.Controls.IBridgeCreator" /> that is initially assigned to the <see cref="P:yWorks.Controls.BridgeManager.DefaultBridgeCreator" /> property.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.BridgeOrientationStyle.Up" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.IBridgeCreator.GetOrientationStyle(yWorks.Controls.IRenderContext)" />
    </member>
    <member name="M:yWorks.Controls.BridgeManager.Dispose">
      <summary>
        <para>Disposes of this instance by resetting the <see cref="P:yWorks.Controls.BridgeManager.CanvasControl" /> property to <c>null</c>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.BridgeManager.AddObstacleProvider(yWorks.Controls.IObstacleProvider)">
      <summary>
        <para>Adds another <see cref="T:yWorks.Controls.IObstacleProvider" /> to query for obstacles.</para>
      </summary>
      <remarks>
        <para>The <see cref="M:yWorks.Controls.IObstacleProvider.GetObstacles(yWorks.Controls.IRenderContext)" /> method will be invoked during construction of the obstacles.</para>
      </remarks>
      <param name="provider">
        <para>The provider instance to use for later queries.</para>
      </param>
      <seealso cref="M:yWorks.Controls.BridgeManager.RegisterObstacles(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Controls.BridgeManager.RemoveObstacleProvider(yWorks.Controls.IObstacleProvider)" />
    </member>
    <member name="M:yWorks.Controls.BridgeManager.RemoveObstacleProvider(yWorks.Controls.IObstacleProvider)">
      <summary>
        <para>Removes a previously <see cref="M:yWorks.Controls.BridgeManager.AddObstacleProvider(yWorks.Controls.IObstacleProvider)">added</see> <see cref="T:yWorks.Controls.IObstacleProvider" /> from the list of registered providers.</para>
      </summary>
      <param name="provider">
        <para>The provider instance to remove from this instance.</para>
      </param>
      <seealso cref="M:yWorks.Controls.BridgeManager.AddObstacleProvider(yWorks.Controls.IObstacleProvider)" />
    </member>
    <member name="M:yWorks.Controls.BridgeManager.AddBridges(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Controls.IBridgeCreator)">
      <summary>
        <para>Core method that will add bridges to a <see cref="T:yWorks.Geometry.GeneralPath" /> using the <see cref="T:yWorks.Controls.IBridgeCreator" /> callback to determine the type of the bridges.</para>
      </summary>
      <remarks>
        <para>This method may return <paramref name="path" /> itself if no crossings have been determined. Otherwise it will return a new path instance that has the bridges added at the corresponding places.</para>
      </remarks>
      <param name="context">
        <para>The context to use.</para>
      </param>
      <param name="path">
        <para>The path to calculate the bridged variant for.</para>
      </param>
      <param name="callback">
        <para>The callback or <c>null</c> that determines the appearance of the bridges.</para>
      </param>
      <returns>
        <para>The path that might have been augmented by the bridges.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.BridgeManager.RegisterObstacles(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Called to initialize the context with the obstacles.</para>
      </summary>
      <param name="context">
        <para>The context that will be used to store the obstacles with.</para>
      </param>
      <seealso cref="M:yWorks.Controls.BridgeManager.RegisterObstacle(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath)" />
      <seealso cref="M:yWorks.Controls.BridgeManager.RegisterObstacleLine(yWorks.Controls.IRenderContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.BridgeManager.RegisterObstacle(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath)">
      <summary>
        <para>Convenience method that can be called to dynamically register an obstacle path with the context during the rendering.</para>
      </summary>
      <remarks>
        <para>Normally all obstacles will be registered initially by method <see cref="M:yWorks.Controls.BridgeManager.RegisterObstacles(yWorks.Controls.IRenderContext)" />. This method can be called during the rendering phase to register additional obstacles at a later point in time.</para>
      </remarks>
      <param name="context">
        <para>The context to register the obstacles with.</para>
      </param>
      <param name="path">
        <para>The path that describes the obstacles.</para>
      </param>
      <seealso cref="M:yWorks.Controls.BridgeManager.RegisterObstacleLine(yWorks.Controls.IRenderContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.BridgeManager.RegisterObstacleLine(yWorks.Controls.IRenderContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Convenience method that can be called to dynamically register a single obstacle line with the context during the rendering.</para>
      </summary>
      <param name="context">
        <para>The context to register the obstacles with.</para>
      </param>
      <param name="p1">
        <para>The coordinates of the first point of the line.</para>
      </param>
      <param name="p2">
        <para>The coordinates of the second point of the line.</para>
      </param>
      <remarks>
        <para>Normally all obstacles will be registered initially by method <see cref="M:yWorks.Controls.BridgeManager.RegisterObstacles(yWorks.Controls.IRenderContext)" />. This method can be called during the rendering phase to register additional obstacles at a later point in time.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.BridgeManager.RegisterObstacleLine(yWorks.Controls.IRenderContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.BridgeManager.RegisterObstacleQuadCurve(yWorks.Controls.IRenderContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Convenience method that can be called to dynamically register a single obstacle quadratic curve with the context during the rendering.</para>
      </summary>
      <param name="context">
        <para>The context to register the obstacles with.</para>
      </param>
      <param name="p1">
        <para>The coordinates of the starting point of the line.</para>
      </param>
      <param name="cp">
        <para>The coordinates of the control point of the curve.</para>
      </param>
      <param name="p2">
        <para>The coordinates of the ending point of the line.</para>
      </param>
      <remarks>
        <para>Normally all obstacles will be registered initially by method <see cref="M:yWorks.Controls.BridgeManager.RegisterObstacles(yWorks.Controls.IRenderContext)" />. This method can be called during the rendering phase to register additional obstacles at a later point in time.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.BridgeManager.RegisterObstacleLine(yWorks.Controls.IRenderContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.BridgeManager.RegisterObstacleCubicCurve(yWorks.Controls.IRenderContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Convenience method that can be called to dynamically register a single obstacle cubic curve with the context during the rendering.</para>
      </summary>
      <param name="context">
        <para>The context to register the obstacles with.</para>
      </param>
      <param name="p1">
        <para>The coordinates of the starting point of the line.</para>
      </param>
      <param name="cp1">
        <para>The coordinates of the first control point of the curve.</para>
      </param>
      <param name="cp2">
        <para>The coordinates of the second control point of the curve.</para>
      </param>
      <param name="p2">
        <para>The coordinates of the ending point of the line.</para>
      </param>
      <remarks>
        <para>Normally all obstacles will be registered initially by method <see cref="M:yWorks.Controls.BridgeManager.RegisterObstacles(yWorks.Controls.IRenderContext)" />. This method can be called during the rendering phase to register additional obstacles at a later point in time.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.BridgeManager.RegisterObstacleLine(yWorks.Controls.IRenderContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.BridgeManager.GetObstacleHash(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Gets a hash code that describes the current state of the obstacles.</para>
      </summary>
      <remarks>
        <para>This method can be used to get a concise, digest snapshot of the current obstacle locations. Storing that result and comparing it to another snapshot later allows to determine quickly whether obstacles have changed since the last call. This is helpful, e.g. in implementations of <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> that support bridges to not recreate the edge path (including bridges) in <see cref="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" /> if no obstacles changed.</para>
      </remarks>
      <param name="context">
        <para>The context to inspect.</para>
      </param>
      <returns>
        <para>A hash of the state of the obstacles.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.BridgeManager.Uninstall(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Reverts the <see cref="M:yWorks.Controls.BridgeManager.Install(yWorks.Controls.CanvasControl)" /> method.</para>
      </summary>
      <param name="canvas">
        <para>The <see cref="P:yWorks.Controls.BridgeManager.CanvasControl" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.BridgeManager.Install(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Installs this manager for the specified <see cref="P:yWorks.Controls.BridgeManager.CanvasControl" />.</para>
      </summary>
      <param name="canvas">
        <para>The <see cref="P:yWorks.Controls.BridgeManager.CanvasControl" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.BridgeManager.InsertDefaultCustomBridge(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Implementation that will be called by the default value of the <see cref="P:yWorks.Controls.BridgeManager.DefaultBridgeCreator" /> to satisfy requests to <see cref="M:yWorks.Controls.IBridgeCreator.CreateCustomBridge(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)" />.</para>
      </summary>
      <remarks>
        <para>This implementation will insert a gap style bridge by first creating a <see cref="M:yWorks.Geometry.GeneralPath.LineTo(yWorks.Geometry.PointD)">line</see> to <paramref name="start" /> and then <see cref="M:yWorks.Geometry.GeneralPath.MoveTo(yWorks.Geometry.PointD)">moving</see> to <paramref name="end" />.</para>
      </remarks>
      <param name="context">
        <para>The context for the call.</para>
      </param>
      <param name="path">
        <para>The path to append the next segment to.</para>
      </param>
      <param name="start">
        <para>The coordinates of the starting point of the bridge.</para>
      </param>
      <param name="end">
        <para>The coordinates of the ending point of the bridge.</para>
      </param>
      <param name="gapLength">
        <para>The distance between the starting point and the end point.</para>
      </param>
      <seealso cref="M:yWorks.Controls.IBridgeCreator.CreateCustomBridge(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)" />
    </member>
    <member name="T:yWorks.Controls.IBridgeCreator">
      <summary>
        <para>Allows to add bridge visualizations to a <see cref="T:yWorks.Geometry.GeneralPath" />.</para>
      </summary>
      <remarks>
        <para>An implementation of this interface is used by <see cref="T:yWorks.Controls.BridgeManager" /> to <see cref="M:yWorks.Controls.BridgeManager.AddBridges(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Controls.IBridgeCreator)">insert bridges</see> into an edge path.</para>
        <para>A custom implementation of this interface is necessary if a <see cref="F:yWorks.Controls.BridgeCrossingStyle.Custom">custom bridge drawing style</see> is used.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.BridgeManager" />
    </member>
    <member name="M:yWorks.Controls.IBridgeCreator.GetCrossingStyle(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.BridgeCrossingStyle" /> to use in the given <see cref="T:yWorks.Controls.IRenderContext" />.</para>
      </summary>
      <param name="context">
        <para>The context in which the crossing will be used.</para>
      </param>
      <returns>
        <para>The style to use, or <see cref="F:yWorks.Controls.BridgeCrossingStyle.Custom" /> in order to let <see cref="T:yWorks.Controls.BridgeManager" /> call <see cref="M:yWorks.Controls.IBridgeCreator.CreateCustomBridge(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.IBridgeCreator.GetOrientationStyle(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.BridgeOrientationStyle" /> to use in the given <see cref="T:yWorks.Controls.IRenderContext" />.</para>
      </summary>
      <param name="context">
        <para>The context in which the style will be used..</para>
      </param>
      <returns>
        <para>The style to use. Any value can be returned and will be ignored if the <see cref="M:yWorks.Controls.IBridgeCreator.GetCrossingStyle(yWorks.Controls.IRenderContext)">crossing style</see> is set to <see cref="F:yWorks.Controls.BridgeCrossingStyle.Custom" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.IBridgeCreator.GetBridgeWidth(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Gets the width of the bridge for the given <see cref="T:yWorks.Controls.IRenderContext" />.</para>
      </summary>
      <remarks>
        <para>The width is the preferred length of the segment that will be removed from the original segment if it crosses an obstacle. That bridge will be made larger if multiple obstacle bridges would otherwise overlap. The bridge will be automatically made smaller if it happens to be near the end of a segment and would otherwise extend beyond the end of the segment.</para>
      </remarks>
      <param name="context">
        <para>The context where the bridge will be created for.</para>
      </param>
      <returns>
        <para>The positive preferred width of the bridge.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.IBridgeCreator.GetBridgeHeight(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Gets the height of the bridge for the given <see cref="T:yWorks.Controls.IRenderContext" />.</para>
      </summary>
      <remarks>
        <para>The height is the default height that will be used for drawing the non-<see cref="F:yWorks.Controls.BridgeCrossingStyle.Custom">custom</see> <see cref="T:yWorks.Controls.BridgeCrossingStyle" />s.</para>
      </remarks>
      <param name="context">
        <para>The context where the bridge will be created for.</para>
      </param>
      <returns>
        <para>The non-negative preferred basic unscaled height of the bridge.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.IBridgeCreator.CreateCustomBridge(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Callback that will be used by the <see cref="T:yWorks.Controls.BridgeManager" /> if the <see cref="M:yWorks.Controls.IBridgeCreator.GetCrossingStyle(yWorks.Controls.IRenderContext)" /> method yields <see cref="F:yWorks.Controls.BridgeCrossingStyle.Custom" /> to actually insert a bridge into the given <see cref="T:yWorks.Geometry.GeneralPath" />.</para>
      </summary>
      <remarks>
        <para>When this method is called the <see cref="T:yWorks.Geometry.GeneralPath" />'s <see cref="P:yWorks.Geometry.GeneralPath.LastCoordinate">last</see> coordinates are not yet at <paramref name="start" />. So most implementation should first <see cref="M:yWorks.Geometry.GeneralPath.MoveTo(yWorks.Geometry.PointD)" /> that location. Also at the end of the call, implementation should make sure that the GeneralPath's end is at <paramref name="end" />. The <paramref name="gapLength" /> is provided for convenience so that the distance between <c>startPoint</c> and <c>endPoint</c> does not need to be calculated if it is needed for the drawing.</para>
      </remarks>
      <param name="context">
        <para>The context for the call.</para>
      </param>
      <param name="path">
        <para>The path to append the bridge segment to.</para>
      </param>
      <param name="start">
        <para>The coordinates of the starting point of the bridge.</para>
      </param>
      <param name="end">
        <para>The coordinates of the ending point of the bridge.</para>
      </param>
      <param name="gapLength">
        <para>The distance between the starting point and the end point.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.IObstacleProvider">
      <summary>
        <para>Implementations of this interface can provide a path that is used to determine bridges by <see cref="T:yWorks.Controls.BridgeManager" />.</para>
      </summary>
      <remarks>
        <para>Typically the <see cref="T:yWorks.Graph.ILookup" /> implementation of styles will return an implementation of this interface.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.IObstacleProvider.GetObstacles(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Returns a path representing obstacles that would need bridges.</para>
      </summary>
      <remarks>
        <para>For performance reasons the implementation should only return a non-<c>null</c> <see cref="T:yWorks.Geometry.GeneralPath" /> if it might be <see cref="M:yWorks.Controls.IVisibilityTestable.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">visible</see> in the provided <see cref="P:yWorks.Controls.IRenderContext.Clip" />.</para>
      </remarks>
      <param name="context">
        <para>The context for which the obstacles are queried.</para>
      </param>
      <returns>
        <para>A path that describes the obstacles or <c>null</c> if there are no obstacles for the given context.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.CollectionModelManager`1">
      <summary>
        <para>An <see cref="T:yWorks.Controls.ItemModelManager`1" /> that automatically installs and removes visual representations of items in a <see cref="T:yWorks.Utils.IObservableCollection`1" /> into or from the canvas.</para>
      </summary>
      <typeparam name="T">
        <para>The type of items in the observable collection.</para>
      </typeparam>
    </member>
    <member name="P:yWorks.Controls.CollectionModelManager`1.Enabled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Controls.CollectionModelManager`1" /> is enabled.</para>
      </summary>
      <remarks>
        <para>If the manager is disabled, it will not install the <see cref="T:yWorks.Controls.ICanvasObject" />s into the associated <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if enabled; otherwise, <c>false</c>.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.CollectionModelManager`1.OnDisabled">
      <summary>
        <para>Called when this mode gets <see cref="P:yWorks.Controls.CollectionModelManager`1.Enabled">disabled</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CollectionModelManager`1.OnEnabled">
      <summary>
        <para>Called when this mode gets <see cref="P:yWorks.Controls.CollectionModelManager`1.Enabled">enabled</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CollectionModelManager`1.#ctor(yWorks.Utils.IObservableCollection{`0})">
      <summary>
        <para>Creates a new instance using the given <paramref name="model" />.</para>
      </summary>
      <param name="model">
        <para>The model to manage.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CollectionModelManager`1.#ctor">
      <summary>
        <para>Creates a new instance.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.CollectionModelManager`1.Model" />
    </member>
    <member name="P:yWorks.Controls.CollectionModelManager`1.Model">
      <summary>
        <para>Gets or sets the model of the items to display in the canvas.</para>
      </summary>
      <remarks>
        <para>Setting the model will automatically remove the items installed for a previously installed model. Also the items contained in the new model will immediately be queried and installed into the canvas.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.CollectionModelManager`1.AddItem(`0)">
      <param name="item" />
    </member>
    <member name="M:yWorks.Controls.CollectionModelManager`1.RemoveItem(`0)">
      <param name="item" />
    </member>
    <member name="M:yWorks.Controls.CollectionModelManager`1.Update(`0)">
      <param name="item" />
    </member>
    <member name="M:yWorks.Controls.CollectionModelManager`1.GetItem(yWorks.Controls.ICanvasObject)">
      <param name="canvasObject" />
    </member>
    <member name="T:yWorks.Controls.ItemModelManager`1">
      <summary>
        <para>Installs and removes visual representations of items into or from the canvas.</para>
      </summary>
      <typeparam name="T">
        <para>The type of managed items.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.GetCanvasObject(`0)">
      <summary>
        <para>Retrieves the canvas object that has been registered for the given item or <c>null</c>.</para>
      </summary>
      <param name="item">
        <para>The item to retrieve the canvas object for.</para>
      </param>
      <returns>
        <para>A canvas object instance or <c>null</c>.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.ItemModelManager`1.Install(`0)" />
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.ItemAddedHandler(System.Object,yWorks.Utils.ItemEventArgs{`0})">
      <summary>
        <para>Event handler for item creation events that adds the item to this manager.</para>
      </summary>
      <remarks>
        <para>This method is intended to be used to delegate item creation events from observable collections:</para>
        <para>This method calls <see cref="M:yWorks.Controls.ItemModelManager`1.AddItem(`0)" /> with <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" />.</para>
      </remarks>
      <param name="source">
        <para>The instance that raised the event.</para>
      </param>
      <param name="args">
        <para>The event arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.AddItem(`0)">
      <summary>
        <para>Registers and <see cref="M:yWorks.Controls.ItemModelManager`1.Install(`0)">installs</see> the given <paramref name="item" /> into the canvas.</para>
      </summary>
      <param name="item">
        <para>The item to install.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.AddItems(System.Collections.Generic.IEnumerable{`0})">
      <summary>
        <para>
          <see cref="M:yWorks.Controls.ItemModelManager`1.AddItem(`0)">Adds</see> all items to the canvas.</para>
      </summary>
      <remarks>
        <para>This is useful to initialize this manager with an existing collection of items.</para>
      </remarks>
      <param name="items">
        <para>The items to add.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.ItemRemovedHandler(System.Object,yWorks.Utils.ItemEventArgs{`0})">
      <summary>
        <para>Event handler for item removal events that removes the item from this manager.</para>
      </summary>
      <remarks>
        <para>This method is intended to be used to delegate item removal events from observable collections:</para>
        <para>This method calls <see cref="M:yWorks.Controls.ItemModelManager`1.RemoveItem(`0)" /> with <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" />.</para>
      </remarks>
      <param name="source">
        <para>The instance that raised the event.</para>
      </param>
      <param name="args">
        <para>The event arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.RemoveItem(`0)">
      <summary>
        <para>Deregisters and uninstalls the given <paramref name="item" /> from the canvas.</para>
      </summary>
      <param name="item">
        <para>The item to uninstall.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.RemoveItems(System.Collections.Generic.IEnumerable{`0})">
      <summary>
        <para>
          <see cref="M:yWorks.Controls.ItemModelManager`1.RemoveItem(`0)">Removes</see> all items from the canvas.</para>
      </summary>
      <remarks>
        <para>This method can be used to clean up this manager before disposing it.</para>
      </remarks>
      <param name="items">
        <para>The items to remove.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.ItemChangedHandler(System.Object,yWorks.Utils.ItemEventArgs{`0})">
      <summary>
        <para>Event handler for item change events that updates the visual representation for that item.</para>
      </summary>
      <remarks>
        <para>This method is intended to be used to delegate item change events from observable collections:</para>
        <para>This is necessary if the group the canvas object should be added to might change after the item change. This might happen, e.g. after changing an edge's port in a grouped graph.</para>
      </remarks>
      <param name="source">
        <para>The event source.</para>
      </param>
      <param name="args">
        <para>The item event args which indicate the change.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.Update(`0)">
      <summary>
        <para>This method may be called to update the visual representation of the given item in the canvas.</para>
      </summary>
      <remarks>
        <para>If no visual representation is registered, yet, <see cref="M:yWorks.Controls.ItemModelManager`1.Install(`0)" /> will be called.</para>
      </remarks>
      <param name="item">
        <para>The item to update.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.GetItem(yWorks.Controls.ICanvasObject)">
      <summary>
        <para>Tries to find the item managed by this instance that is associated with the given canvas object.</para>
      </summary>
      <param name="canvasObject">
        <para>The canvas object to query the corresponding model item for.</para>
      </param>
      <returns>
        <para>The item or <c>null</c> if no such item could be found.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.ItemModelManager`1.Comparer">
      <summary>
        <para>Gets or sets an <see cref="T:System.Collections.Generic.IComparer`1" /> that compares the items so that they are put into the correct order in the canvas tree.</para>
      </summary>
      <remarks>
        <para>If this instance is set to <c>null</c> this feature is effectively turned off.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.ItemModelManager`1.Descriptor">
      <summary>
        <para>Gets or sets the canvas object descriptor used by <see cref="M:yWorks.Controls.ItemModelManager`1.Install(`0)" /> when an item is <see cref="M:yWorks.Controls.ICanvasObjectGroup.AddChild(System.Object,yWorks.Controls.ICanvasObjectDescriptor)">added</see> to an canvas object group.</para>
      </summary>
      <remarks>
        <para>Setting the descriptor to <c>null</c> will prevent this manager from installing new items.</para>
      </remarks>
      <value>
        <para>The canvas object descriptor used by <see cref="M:yWorks.Controls.ItemModelManager`1.Install(`0)" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.ItemModelManager`1.CanvasObjectGroup">
      <summary>
        <para>Gets or sets the canvas object group used by <see cref="M:yWorks.Controls.ItemModelManager`1.Install(`0)" />.</para>
      </summary>
      <remarks>
        <para>Setting this property to <c>null</c> will prevent this manager from installing new items.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.GetDescriptor(`0)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> used to <see cref="M:yWorks.Controls.ItemModelManager`1.Install(`0)" /> the <paramref name="item" /> in the canvas.</para>
      </summary>
      <remarks>
        <para>The default implementation simply returns the value of <see cref="P:yWorks.Controls.ItemModelManager`1.Descriptor" />.</para>
      </remarks>
      <param name="item">
        <para>The item to get the descriptor for.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> used to <see cref="M:yWorks.Controls.ItemModelManager`1.Install(`0)" /> an item in the canvas.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.GetCanvasObjectGroup(`0)">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> used to <see cref="M:yWorks.Controls.ItemModelManager`1.Install(`0)" /> the <paramref name="item" /> in the canvas.</para>
      </summary>
      <remarks>
        <para>The default implementation simply returns the value of <see cref="P:yWorks.Controls.ItemModelManager`1.CanvasObjectGroup" />.</para>
      </remarks>
      <param name="item">
        <para>The item to get the group for.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> used to <see cref="M:yWorks.Controls.ItemModelManager`1.Install(`0)" /> an item in the canvas.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ItemModelManager`1.Install(`0)">
      <summary>
        <para>Installs a member of the collection into the canvas using the <see cref="P:yWorks.Controls.ItemModelManager`1.Descriptor" />.</para>
      </summary>
      <param name="item">
        <para>The member to install.</para>
      </param>
      <returns>
        <para>The canvas object that has been returned by the installer.</para>
      </returns>
    </member>
    <member name="T:yWorks.Utils.DefaultObservableCollection`1">
      <summary>
        <para>A simple default implementation of an <see cref="T:yWorks.Utils.IObservableCollection`1" /> that is backed by an ordinary <see cref="T:System.Collections.Generic.ICollection`1" /></para>
      </summary>
      <typeparam name="T">
        <para>The type of the elements contained in this collection.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.Add(`0)">
      <summary>
        <para>Adds the item the the collection and triggers the <see cref="E:yWorks.Utils.DefaultObservableCollection`1.ItemAdded" /> event.</para>
      </summary>
      <remarks>
        <para>This implementation calls the <see cref="M:yWorks.Utils.DefaultObservableCollection`1.OnItemAdded(`0)" /> method.</para>
      </remarks>
      <param name="item">
        <para>The item to add to the collection.</para>
      </param>
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.Clear">
      <summary>
        <para>Clears this collection, triggering an <see cref="E:yWorks.Utils.DefaultObservableCollection`1.ItemRemoved" /> event for each element removed.</para>
      </summary>
      <seealso cref="M:yWorks.Utils.DefaultObservableCollection`1.OnItemRemoved(`0)" />
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.Contains(`0)">
      <summary>
        <para>Checks for containment of the item in this collection.</para>
      </summary>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether the item is contained in this collection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.CopyTo(`0[],System.Int32)">
      <summary>
        <para>Copies the items to the given array.</para>
      </summary>
      <param name="array" />
      <param name="arrayIndex" />
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.Remove(`0)">
      <summary>
        <para>Tries to remove the item from the collection and triggers the <see cref="E:yWorks.Utils.DefaultObservableCollection`1.ItemRemoved" /> event.</para>
      </summary>
      <param name="item">
        <para>The item to remove.</para>
      </param>
      <returns>
        <para>Whether the item has been removed.</para>
      </returns>
      <seealso cref="M:yWorks.Utils.DefaultObservableCollection`1.OnItemRemoved(`0)" />
    </member>
    <member name="P:yWorks.Utils.DefaultObservableCollection`1.Count">
      <summary>
        <para>Gets the number of elements in this collection.</para>
      </summary>
    </member>
    <member name="P:yWorks.Utils.DefaultObservableCollection`1.IsReadOnly">
      <summary>
        <para>Gets whether this collection is read only.</para>
      </summary>
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.GetEnumerator">
      <summary>
        <para>Returns an enumerator over the elements in this collection.</para>
      </summary>
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.#ctor">
      <summary>
        <para>Creates a new instance using a <see cref="T:System.Collections.Generic.List`1" /> as the backing store.</para>
      </summary>
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
      <summary>
        <para>Creates a new instance using a provided collection as the backing store.</para>
      </summary>
      <param name="items" />
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.GetItems">
      <summary>
        <para>Returns the collection used internally as the backing store.</para>
      </summary>
      <remarks>
        <para>Normally code should not use this method to gain access to the collection in order to modify it.</para>
      </remarks>
      <returns>
        <para>The backing store of this observable collection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.PublishItemChanged(`0)">
      <summary>
        <para>Method that may be called by client code to trigger an <see cref="E:yWorks.Utils.DefaultObservableCollection`1.ItemChanged" /> event.</para>
      </summary>
      <param name="item">
        <para>The item to trigger the change event for.</para>
      </param>
      <seealso cref="M:yWorks.Utils.DefaultObservableCollection`1.OnItemChanged(`0)" />
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.OnItemChanged(`0)">
      <summary>
        <para>Callback method that will trigger the <see cref="E:yWorks.Utils.DefaultObservableCollection`1.ItemChanged" /> event.</para>
      </summary>
      <param name="item">
        <para>The item that has changed.</para>
      </param>
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.OnItemRemoved(`0)">
      <summary>
        <para>Callback method that will trigger the <see cref="E:yWorks.Utils.DefaultObservableCollection`1.ItemRemoved" /> event.</para>
      </summary>
      <param name="item">
        <para>The item that has just been removed from the collection.</para>
      </param>
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.OnItemAdded(`0)">
      <summary>
        <para>Callback method that will trigger the <see cref="E:yWorks.Utils.DefaultObservableCollection`1.ItemAdded" /> event.</para>
      </summary>
      <param name="item">
        <para>The item that has just been added to the collection.</para>
      </param>
    </member>
    <member name="E:yWorks.Utils.DefaultObservableCollection`1.ItemAdded">
      <summary>
        <para>Occurs when an item has been added to this collection.</para>
      </summary>
    </member>
    <member name="E:yWorks.Utils.DefaultObservableCollection`1.ItemRemoved">
      <summary>
        <para>Occurs when an item has been removed from this collection.</para>
      </summary>
    </member>
    <member name="E:yWorks.Utils.DefaultObservableCollection`1.ItemChanged">
      <summary>
        <para>Occurs when an item has been changed inside this collection.</para>
      </summary>
    </member>
    <member name="M:yWorks.Utils.DefaultObservableCollection`1.ToString" />
    <member name="T:yWorks.Controls.DefaultSelectionModel`1">
      <summary>
        <para>Default implementation of an <see cref="T:yWorks.Controls.ISelectionModel`1" /> that is based on an observable collection to hold the selected elements.</para>
      </summary>
      <remarks>
        <para>This selection model has a domain that's controlled with a <see cref="P:yWorks.Controls.DefaultSelectionModel`1.IsInDomain">predicate</see> which encompasses the items that can be selected. If that domain changes it is important to delegate item removal events from the domain model to this selection model to ensure that items that have been removed are deselected as well. A <see cref="M:yWorks.Controls.DefaultSelectionModel`1.ItemRemovedFromDomainHandler(System.Object,yWorks.Utils.ItemEventArgs{`0})">convenience event handler</see> exists for that purpose.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the items to be selected.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.DefaultSelectionModel`1.#ctor">
      <summary>
        <para>Creates a default selection model implementation that uses a <see cref="T:yWorks.Utils.DefaultObservableCollection`1" /> to hold the selection.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.DefaultSelectionModel`1.IsInDomain">
      <summary>
        <para>Gets or sets the predicate which determines whether the queried item should be considered for this selection model.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.DefaultSelectionModel`1.ItemRemovedFromDomainHandler(System.Object,yWorks.Utils.ItemEventArgs{`0})">
      <summary>
        <para>Event handler for domain item removal events that removes the item from this model.</para>
      </summary>
      <remarks>
        <para>This method is intended to be used to delegate item removal events from the respective domain collection:</para>
        <para>This method calls <see cref="M:yWorks.Controls.DefaultSelectionModel`1.RemoveDomainItem(`0)" /> with <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" />.</para>
      </remarks>
      <param name="source">
        <para>The instance that raised the event.</para>
      </param>
      <param name="evt">
        <para>The event arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.DefaultSelectionModel`1.RemoveDomainItem(`0)">
      <summary>
        <para>Removes the given <paramref name="item" /> from the selection in response to the item being removed from the domain.</para>
      </summary>
      <param name="item">
        <para>The item to remove from the considered items.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.DefaultSelectionModel`1.Selection">
      <summary>
        <para>Gets an observable collection view over the selected items.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.DefaultSelectionModel`1.IsSelected(`0)">
      <summary>
        <para>Determines whether an item is selected by checking for the containment in the <see cref="P:yWorks.Controls.DefaultSelectionModel`1.Selection" />.</para>
      </summary>
      <param name="item">
        <para>The item to check</para>
      </param>
      <returns>
        <para>Whether the item is selected.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.DefaultSelectionModel`1.SetSelected(`0,System.Boolean)">
      <summary>
        <para>Sets the selection state of the item.</para>
      </summary>
      <param name="item" />
      <param name="selected" />
    </member>
    <member name="M:yWorks.Controls.DefaultSelectionModel`1.OnItemSelectionChanged(`0,System.Boolean)">
      <summary>
        <para>Called when an item gets selected or deselected.</para>
      </summary>
      <remarks>
        <para>Triggers the <see cref="E:yWorks.Controls.DefaultSelectionModel`1.ItemSelectionChanged" /> event.</para>
      </remarks>
      <param name="o">
        <para>The item.</para>
      </param>
      <param name="selected">
        <para>Whether or not the item is selected after the change.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.DefaultSelectionModel`1.Clear" />
    <member name="M:yWorks.Controls.DefaultSelectionModel`1.GetEnumerator" />
    <member name="T:yWorks.Graph.DictionaryMapper`2">
      <summary>
        <para>An <see cref="T:yWorks.Graph.IMapper`2" /> implementation backed by a <see cref="T:System.Collections.Generic.IDictionary`2" />.</para>
      </summary>
      <remarks>
        <para>A <see cref="P:yWorks.Graph.DictionaryMapper`2.DefaultValue" /> can be set that is returned for keys that don't have an explicit value set.</para>
        <para>It is legal to use <c>null</c> as key (provided <typeparamref name="K" /> is a reference or nullable type), which can be assigned a value just like other keys.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.DictionaryMapper`2.Entries">
      <summary>
        <para>Gets an enumerable over all entries in this (dictionary based) mapper.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.DictionaryMapper`2.DefaultValue">
      <summary>
        <para>Gets or sets the default value to return if no specific value has been set for a given key.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.DictionaryMapper`2.#ctor">
      <summary>
        <para>Creates an instance using a <see cref="T:System.Collections.Generic.Dictionary`2" /> as the backing store.</para>
      </summary>
      <remarks>
        <para>The value for the null item is stored separately.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.DictionaryMapper`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <summary>
        <para>Creates an instance using the provided <see cref="T:System.Collections.Generic.Dictionary`2" /> as the backing store.</para>
      </summary>
      <remarks>
        <para>The value for the null item is stored separately.</para>
      </remarks>
      <param name="dictionary" />
    </member>
    <member name="M:yWorks.Graph.DictionaryMapper`2.Clear">
      <summary>
        <para>Calls <see cref="M:System.Collections.Generic.Dictionary`2.Clear" /> on the backing implementation.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.DictionaryMapper`2.RemoveValue(`0)">
      <param name="key" />
    </member>
    <member name="T:yWorks.Graph.WeakDictionaryMapper`2">
      <summary>
        <para>An <see cref="T:yWorks.Graph.IMapper`2" /> implementation backed by a <see cref="T:System.Collections.Generic.IDictionary`2" /> that uses <see cref="T:System.WeakReference" />s for the keys.</para>
      </summary>
      <remarks>
        <para>A <see cref="P:yWorks.Graph.WeakDictionaryMapper`2.DefaultValue" /> can be set that is returned for values that don't have an explicit value set.</para>
        <para>It is legal to use <c>null</c> as key (provided <typeparamref name="K" /> is a reference or nullable type), which can be assigned a value just like other keys.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.WeakDictionaryMapper`2.DefaultValue">
      <summary>
        <para>Gets or sets the default value to return if no specific value has been set for a given key.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.WeakDictionaryMapper`2.#ctor">
      <summary>
        <para>Creates an instance using a <see cref="T:System.Collections.Generic.Dictionary`2" /> as the backing store.</para>
      </summary>
      <remarks>
        <para>The value for the null item is stored separately.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.WeakDictionaryMapper`2.Empty">
      <summary>
        <para>Gets a value indicating whether this mapping currently has any values set.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.WeakDictionaryMapper`2.Clear">
      <summary>
        <para>Removes all entries from the mapping.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.WeakDictionaryMapper`2.RemoveValue(`0)">
      <param name="key" />
    </member>
    <member name="T:yWorks.Controls.ShowFocusPolicy">
      <summary>
        <para>The enumeration that describes the possible different policies for displaying the focus of items managed by the <see cref="T:yWorks.Controls.FocusIndicatorManager`1" /></para>
      </summary>
      <seealso cref="T:yWorks.Controls.FocusIndicatorManager`1" />
    </member>
    <member name="F:yWorks.Controls.ShowFocusPolicy.Always">
      <summary>
        <para>Indicates that irrespectively of the keyboard focus, the focus should always be rendered for the <see cref="P:yWorks.Controls.FocusIndicatorManager`1.FocusedItem" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.ShowFocusPolicy.WhenFocused">
      <summary>
        <para>Indicates that depending on the value of <see cref="P:yWorks.Controls.FocusIndicatorManager`1.Focused" />the focus should only be rendered if this property is set to <c>true</c>.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.FocusIndicatorManager`1">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ModelManager`1" /> implementation that manages the visual decoration of the focused element in a canvas.</para>
      </summary>
      <remarks>
        <para>For the item that should be focused this class uses the <see cref="T:yWorks.Graph.ILookup" /> mechanism of the item to lookup an <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> implementation which will do the actual installation of the decoration in the canvas.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the items.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.FocusIndicatorManager`1.OnDisabled" />
    <member name="M:yWorks.Controls.FocusIndicatorManager`1.OnEnabled" />
    <member name="M:yWorks.Controls.FocusIndicatorManager`1.Add(`0)">
      <summary>
        <para>Overridden to do nothing.</para>
      </summary>
      <param name="item" />
    </member>
    <member name="M:yWorks.Controls.FocusIndicatorManager`1.Remove(`0)">
      <summary>
        <para>Overridden to do nothing.</para>
      </summary>
      <param name="item" />
    </member>
    <member name="M:yWorks.Controls.FocusIndicatorManager`1.#ctor(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Creates an instance that for all focused items in the model dynamically installs a decoration.</para>
      </summary>
      <param name="canvas">
        <para>The canvas to add the focus marks to.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.FocusIndicatorManager`1.PropertyChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Controls.FocusIndicatorManager`1.FocusedItem" /> property has been changed.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.FocusIndicatorManager`1.FocusedItem">
      <summary>
        <para>Gets or sets the focused item, updates the canvas and fires the corresponding property change event.</para>
      </summary>
      <value>
        <para>The focused item, which can be <c>null</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.FocusIndicatorManager`1.ShowFocusPolicy">
      <summary>
        <para>Gets or sets the show focus policy.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.ShowFocusPolicy.WhenFocused" />.</para>
      </remarks>
      <value>
        <para>The show focus policy. Changing this property influences the visibility of the rendering depending on the current value of <see cref="P:yWorks.Controls.FocusIndicatorManager`1.Focused" /> attribute.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.FocusIndicatorManager`1.Focused">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="T:yWorks.Controls.CanvasControl">container</see> this manager is installed in currently is <see cref="P:System.Windows.Forms.Control.Focused" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the container is currently focused; <c>false</c> otherwise. Depending on the <see cref="P:yWorks.Controls.FocusIndicatorManager`1.ShowFocusPolicy" />, this will influence the visibility of the rendering.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.FocusIndicatorManager`1.OnFocusedChanged">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.FocusIndicatorManager`1.Focused" /> property has changed.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.FocusIndicatorManager`1.Focused" />
    </member>
    <member name="M:yWorks.Controls.FocusIndicatorManager`1.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
      <summary>
        <para>Callback method that is triggered when the focused item has changed.</para>
      </summary>
      <remarks>
        <para>This method raises the <see cref="E:yWorks.Controls.FocusIndicatorManager`1.PropertyChanged" /> event. Subclasses overriding this method should make sure to invoke the super class implementation.</para>
      </remarks>
      <param name="args">
        <para>a description of the event</para>
      </param>
      <seealso cref="P:yWorks.Controls.FocusIndicatorManager`1.FocusedItem" />
      <seealso cref="E:yWorks.Controls.FocusIndicatorManager`1.PropertyChanged" />
    </member>
    <member name="M:yWorks.Controls.FocusIndicatorManager`1.GetInstaller(`0)">
      <summary>
        <para>Callback used by <see cref="M:yWorks.Controls.ModelManager`1.Install(`0)" /> to retrieve the installer for a given item.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the item to retrieve an <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> instance.</para>
      </remarks>
      <param name="item">
        <para>The item to find an installer for.</para>
      </param>
      <returns>
        <para>An installer or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.FocusIndicatorManager`1.GetCanvasObjectGroup(`0)">
      <summary>
        <para>Callback used by <see cref="M:yWorks.Controls.ModelManager`1.Install(`0)" /> to retrieve the installer for a given item.</para>
      </summary>
      <remarks>
        <para>This implementation always returns the <see cref="P:yWorks.Controls.CanvasControl.FocusGroup" /> of the <see cref="P:yWorks.Controls.ModelManager`1.Canvas" /> of this instance.</para>
      </remarks>
      <param name="item">
        <para>The item to find a canvas object group for.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> or <c>null</c></para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.HighlightIndicatorManager`1">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ModelManager`1" /> implementation that manages the visual decorations of highlighted elements in a canvas.</para>
      </summary>
      <remarks>
        <para>For each item that should be highlighted this class uses the <see cref="T:yWorks.Graph.ILookup" /> mechanism of the items to lookup an <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> implementation which will do the actual installation of the decoration in the canvas.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the items.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.HighlightIndicatorManager`1.OnDisabled" />
    <member name="M:yWorks.Controls.HighlightIndicatorManager`1.OnEnabled" />
    <member name="M:yWorks.Controls.HighlightIndicatorManager`1.#ctor(yWorks.Controls.CanvasControl,yWorks.Controls.ISelectionModel{`0})">
      <summary>
        <para>Creates an instance that for all selected items in the model dynamically installs a selection paint decoration.</para>
      </summary>
      <param name="canvas">
        <para>The canvas to add the selection marks to.</para>
      </param>
      <param name="selectionModel">
        <para>The model that determines which items are highlighted.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.HighlightIndicatorManager`1.SelectionModel">
      <summary>
        <para>Gets or sets the selection model that determines which items are highlighted.</para>
      </summary>
      <remarks>
        <para>May be <c>null</c>, in which case no elements are considered highlighted.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.HighlightIndicatorManager`1.ClearHighlights">
      <summary>
        <para>Removes all highlights.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.HighlightIndicatorManager`1.AddHighlight(`0)">
      <summary>
        <para>Adds another highlight.</para>
      </summary>
      <param name="item">
        <para>The item to highlight.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.HighlightIndicatorManager`1.RemoveHighlight(`0)">
      <summary>
        <para>Removes an item from the current highlight selection.</para>
      </summary>
      <param name="item">
        <para>The item whose highlight decorator will be removed.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.HighlightIndicatorManager`1.GetInstaller(`0)">
      <summary>
        <para>Callback used by <see cref="M:yWorks.Controls.ModelManager`1.Install(`0)" /> to retrieve the installer for a given item.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the item to retrieve an <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> instance.</para>
      </remarks>
      <param name="item">
        <para>The item to find an installer for.</para>
      </param>
      <returns>
        <para>An installer or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.HighlightIndicatorManager`1.GetCanvasObjectGroup(`0)">
      <summary>
        <para>Callback used by <see cref="M:yWorks.Controls.ModelManager`1.Install(`0)" /> to retrieve the installer for a given item.</para>
      </summary>
      <remarks>
        <para>This implementation always returns the <see cref="P:yWorks.Controls.CanvasControl.HighlightGroup" /> of the <see cref="P:yWorks.Controls.ModelManager`1.Canvas" /> of this instance.</para>
      </remarks>
      <param name="item">
        <para>The item to find a canvas object group for.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> or <c>null</c></para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.ICanvasObjectInstaller">
      <summary>
        <para>Installs visual representations of items in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>This interface is most prominently used by <see cref="T:yWorks.Controls.ModelManager`1" /> and its descendants to manage visuals in the canvas.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.ICanvasObjectInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">
      <summary>
        <para>This the main method of the interface that performs the installation of an item's visual representation in the <see cref="T:yWorks.Controls.CanvasControl">canvas</see> by adding <see cref="T:yWorks.Controls.ICanvasObject" />s.</para>
      </summary>
      <param name="context">
        <para>The context that contains the information required to install the visual representation.</para>
      </param>
      <param name="group">
        <para>The canvas object group to add the newly generated <see cref="T:yWorks.Controls.ICanvasObject" /> to.</para>
      </param>
      <param name="item">
        <para>The item to install.</para>
      </param>
      <returns>
        <para>The newly generated <see cref="T:yWorks.Controls.ICanvasObject" /> for the item's visual representation. <c>null</c> if nothing was installed.</para>
      </returns>
    </member>
    <member name="T:yWorks.Utils.IObservableCollection`1">
      <summary>
        <para>The interface for a collection that will notify registered event handlers of changes to its contents.</para>
      </summary>
      <typeparam name="T">
        <para>The type of the items in the collection.</para>
      </typeparam>
      <seealso cref="T:yWorks.Utils.DefaultObservableCollection`1" />
    </member>
    <member name="E:yWorks.Utils.IObservableCollection`1.ItemAdded">
      <summary>
        <para>Occurs when an item has been added to this collection.</para>
      </summary>
    </member>
    <member name="E:yWorks.Utils.IObservableCollection`1.ItemRemoved">
      <summary>
        <para>Occurs when an item has been removed from this collection.</para>
      </summary>
    </member>
    <member name="E:yWorks.Utils.IObservableCollection`1.ItemChanged">
      <summary>
        <para>Occurs when an item in this collection has changed significantly.</para>
      </summary>
      <remarks>
        <para>It is up to the implementation whether and when to trigger this event.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Utils.IListEnumerable`1">
      <summary>
        <para>An extension to the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface that allows for indexed access and retrieval of the element count.</para>
      </summary>
      <remarks>
        <para>This interface is like a rudimentary read-only <see cref="T:System.Collections.Generic.IList`1" /></para>
      </remarks>
      <typeparam name="T">
        <para>The type of the contained elements.</para>
      </typeparam>
    </member>
    <member name="P:yWorks.Utils.IListEnumerable`1.Count">
      <summary>
        <para>Gets the number of elements in this collection.</para>
      </summary>
    </member>
    <member name="P:yWorks.Utils.IListEnumerable`1.Item(System.Int32)">
      <summary>
        <para>Gets the <paramref name="i" />-th element in the collection.</para>
      </summary>
      <param name="i">
        <para>the zero-based index of the item in this collection</para>
      </param>
      <returns>
        <para>the item for the given index</para>
      </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>
          <paramref name="i" /> is not a valid index in the <see cref="T:yWorks.Utils.IListEnumerable`1" />.</para>
      </exception>
    </member>
    <member name="T:yWorks.Utils.ListEnumerable`1">
      <summary>
        <para>Wraps a simple <see cref="T:System.Collections.Generic.IEnumerable`1" /> into a <see cref="T:yWorks.Utils.IListEnumerable`1" />.</para>
      </summary>
      <remarks>
        <para>This implementation is optimized for <see cref="T:System.Collections.Generic.IList`1" /> and <see cref="T:System.Collections.Generic.ICollection`1" />, as well as <see cref="T:System.Array" /> <see cref="T:System.Collections.Generic.IEnumerable`1" />s.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the enumerable.</para>
      </typeparam>
    </member>
    <member name="F:yWorks.Utils.ListEnumerable`1.Empty">
      <summary>
        <para>An empty, immutable instance of <see cref="T:yWorks.Utils.IListEnumerable`1" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Utils.ListEnumerable`1.#ctor">
      <summary>
        <para>Creates a new instance with a backing <see cref="T:System.Collections.Generic.List`1" /> as the backing store.</para>
      </summary>
    </member>
    <member name="P:yWorks.Utils.ListEnumerable`1.BackingEnumerable">
      <summary>
        <para>Gets the backing enumerable.</para>
      </summary>
      <value>
        <para>The backing enumerable.</para>
      </value>
    </member>
    <member name="M:yWorks.Utils.ListEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
        <para>Creates a new instance using the given backing enumerable.</para>
      </summary>
      <param name="backingEnumerable">
        <para>The enumerable to back this instance.</para>
      </param>
    </member>
    <member name="M:yWorks.Utils.ListEnumerable`1.GetEnumerator" />
    <member name="T:yWorks.Utils.ItemEventArgs`1">
      <summary>
        <para>Event argument class used by <see cref="T:yWorks.Utils.IObservableCollection`1" /> and similar that holds a specific item that is related to the event.</para>
      </summary>
      <typeparam name="T">
        <para>The type of the item contained in the event.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Utils.ItemEventArgs`1.#ctor(`0)">
      <summary>
        <para>Creates a new event argument for the given item.</para>
      </summary>
      <param name="item">
        <para>The item which is the subject of the event.</para>
      </param>
    </member>
    <member name="P:yWorks.Utils.ItemEventArgs`1.Item">
      <summary>
        <para>Gets the item that is the subject of the event.</para>
      </summary>
    </member>
    <member name="T:yWorks.Utils.ListEnumerableExtensions">
      <summary>
        <para>Contains <c>static</c> extension methods for the <see cref="T:yWorks.Utils.IListEnumerable`1" /> interface.</para>
      </summary>
    </member>
    <member name="M:yWorks.Utils.ListEnumerableExtensions.Last``1(yWorks.Utils.IListEnumerable{``0})">
      <summary>
        <para>Returns the last item in the list.</para>
      </summary>
      <param name="list">
        <para>The list.</para>
      </param>
      <returns>
        <para>The last item in the list.</para>
      </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>If there are no items in the list.</para>
      </exception>
    </member>
    <member name="M:yWorks.Utils.ListEnumerableExtensions.First``1(yWorks.Utils.IListEnumerable{``0})">
      <summary>
        <para>Returns the first item in the list.</para>
      </summary>
      <param name="list">
        <para>The list.</para>
      </param>
      <returns>
        <para>The first item in the list.</para>
      </returns>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>If there are no items in the list.</para>
      </exception>
    </member>
    <member name="T:yWorks.Graph.IMapper`2">
      <summary>
        <para>An interface for simple typed dictionary-like implementations.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Graph.IMapper`2" />s are most prominently used when interfacing with <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> and <see cref="T:yWorks.GraphML.GraphMLIOHandler">GraphML</see>. <see cref="T:yWorks.Graph.IGraph" /> also provides the <see cref="P:yWorks.Graph.IGraph.MapperRegistry" /> to add additional information to a graph.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Mappers" />
      <seealso cref="T:yWorks.Graph.DictionaryMapper`2" />
      <typeparam name="K">
        <para>The type of element this interface accepts as keys for the mapping.</para>
      </typeparam>
      <typeparam name="V">
        <para>The type of element this interface accepts as values for the mapping.</para>
      </typeparam>
    </member>
    <member name="P:yWorks.Graph.IMapper`2.Item(`0)">
      <summary>
        <para>Gets or sets the value for a given key in the mapping.</para>
      </summary>
      <remarks>
        <para>Setting a value for an already existing key overwrites the previous value.</para>
        <para>It depends on the specific implementation of the mapper whether a mapping can be removed. If an implementation provides a way to remove a mapping, that should be preferred over setting a <c>null</c> value. For example, <see cref="T:yWorks.Graph.DictionaryMapper`2" /> provides the <see cref="M:yWorks.Graph.DictionaryMapper`2.RemoveValue(`0)" /> method.</para>
      </remarks>
      <param name="key">
        <para>The key of the mapping.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.MapperDelegate`2">
      <summary>
        <para>A delegate that mimics <see cref="T:yWorks.Graph.IMapper`2" />'s indexer read-access.</para>
      </summary>
      <typeparam name="K">
        <para>The type of element this delegate accepts as keys for the mapping.</para>
      </typeparam>
      <typeparam name="V">
        <para>The type of element this delegate returns as values for the mapping.</para>
      </typeparam>
      <param name="key">
        <para>The key of the mapping.</para>
      </param>
      <returns>
        <para>The value or a suitable default that is associated with <paramref name="key" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Mappers">
      <summary>
        <para>Provides factory methods for specialized <see cref="T:yWorks.Graph.IMapper`2" /> implementations.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Mappers.FromDelegate``2(yWorks.Graph.MapperDelegate{``0,``1})">
      <summary>
        <para>Create an implementation of <see cref="T:yWorks.Graph.IMapper`2" /> that delegates <see cref="T:yWorks.Graph.IMapper`2" /> indexer getter calls to the provided handler.</para>
      </summary>
      <remarks>
        <para>The implementation returned silently ignores calls to the <see cref="T:yWorks.Graph.IMapper`2" /> indexer setter.</para>
      </remarks>
      <typeparam name="K">
        <para>The type of the key to use.</para>
      </typeparam>
      <typeparam name="V">
        <para>The type of the value to use.</para>
      </typeparam>
      <param name="getter">
        <para>The delegate to delegate <see cref="T:yWorks.Graph.IMapper`2" /> indexer getter calls to.</para>
      </param>
      <returns>
        <para>An implementation that delegates to <paramref name="getter" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Mappers.FromConstant``2(``1)">
      <summary>
        <para>Creates a constant mapper that will always return the <paramref name="constant" />.</para>
      </summary>
      <typeparam name="K">
        <para>The type of the key to use.</para>
      </typeparam>
      <typeparam name="V">
        <para>The type of the value to use.</para>
      </typeparam>
      <param name="constant">
        <para>The constant to return in <see cref="T:yWorks.Graph.IMapper`2" />'s indexer.</para>
      </param>
      <returns>
        <para>A new instance that will always return the same constant.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.IModelItem">
      <summary>
        <para>Base interface for items that can be used in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>Most prominently this is the interface all graph elements used in <see cref="T:yWorks.Graph.IGraph" /> implement.</para>
        <para>It adds no functionality over the <see cref="T:yWorks.Graph.ILookup" /> and <see cref="T:yWorks.Graph.ITagOwner" /> interfaces it inherits.</para>
        <para>To add custom visuals to a <see cref="T:yWorks.Controls.CanvasControl" /> it is not necessary to implement this interface. Instead, any object can be <see cref="M:yWorks.Controls.ICanvasObjectGroup.AddChild(System.Object,yWorks.Controls.ICanvasObjectDescriptor)">added directly to the canvas</see>, provided there is a suitable <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> implementation for rendering it.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.ISelectionIndicatorInstaller">
      <summary>
        <para>An interface for objects that can install a visual representation of a selection decoration of an item in the model displayed in a canvas.</para>
      </summary>
      <remarks>
        <para>This interface is a tagging sub interface of the <see cref="T:yWorks.Controls.ICanvasObjectInstaller" />. This interface is used for <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> operations.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.SelectionIndicatorManager`1" />
      <seealso cref="T:yWorks.Controls.IHighlightIndicatorInstaller" />
    </member>
    <member name="T:yWorks.Controls.ISelectionModel`1">
      <summary>
        <para>An interface that models the selection state of a set of items.</para>
      </summary>
      <remarks>
        <para>This interface extends the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface for convenient enumeration of the selected items. Use the <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" /> to get all selected items.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of items contained in the selection's domain.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.ISelectionModel`1.IsSelected(`0)">
      <summary>
        <para>Determines whether an item is currently selected.</para>
      </summary>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether it is currently selected.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ISelectionModel`1.SetSelected(`0,System.Boolean)">
      <summary>
        <para>Sets the selection state of an item.</para>
      </summary>
      <remarks>
        <para>If the state changes, this will trigger the <see cref="E:yWorks.Controls.ISelectionModel`1.ItemSelectionChanged" /> event.</para>
      </remarks>
      <param name="item">
        <para>The item to set the selection state for.</para>
      </param>
      <param name="selected">
        <para>Whether to select the object.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.ISelectionModel`1.Count">
      <summary>
        <para>Gets the number of selected items.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.ISelectionModel`1.ItemSelectionChanged">
      <summary>
        <para>Occurs when an item changed its selection state from selected to unselected or vice versa.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.ISelectionModel`1.SetSelected(`0,System.Boolean)" />
    </member>
    <member name="M:yWorks.Controls.ISelectionModel`1.Clear">
      <summary>
        <para>Clears the selection.</para>
      </summary>
      <remarks>
        <para>This is a convenience method that will set the selection state of all elements to unselected.</para>
      </remarks>
      <seealso cref="E:yWorks.Controls.ISelectionModel`1.ItemSelectionChanged" />
    </member>
    <member name="T:yWorks.Controls.ItemSelectionChangedEventArgs`1">
      <summary>
        <para>Provides data for the <see cref="E:yWorks.Controls.ISelectionModel`1.ItemSelectionChanged" /> event.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ItemSelectionChangedEventArgs`1.#ctor(`0,System.Boolean)">
      <summary>
        <para>Initializes a new event argument instance for the given item and its selection state.</para>
      </summary>
      <param name="item">
        <para>The item whose <see cref="M:yWorks.Controls.ISelectionModel`1.IsSelected(`0)">selection state</see> has changed.</para>
      </param>
      <param name="selected">
        <para>The value indicating whether the item is selected after the change.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.ItemSelectionChangedEventArgs`1.ItemSelected">
      <summary>
        <para>Gets a value indicating whether the item is selected after the change.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.ModelManager`1">
      <summary>
        <para>Manages the visual representations of items in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <typeparam name="T">
        <para>The type of items this instance deals with.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.ModelManager`1.#ctor(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Creates a new instance that will manage the items for the given canvas.</para>
      </summary>
      <param name="canvas">
        <para>The canvas to manage.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.ModelManager`1.Canvas">
      <summary>
        <para>Gets the canvas instance this instance is managing.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ModelManager`1.Enabled">
      <summary>
        <para>Gets or sets whether this <see cref="T:yWorks.Controls.ModelManager`1" /> is enabled.</para>
      </summary>
      <remarks>
        <para>If the manager is disabled, it will not install the <see cref="T:yWorks.Controls.ICanvasObject" />s into the associated <see cref="T:yWorks.Controls.CanvasControl" />.</para>
        <para>The default is <c>true</c>, i.e. this manager is enabled by default.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if enabled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.ModelManager`1.OnEnabled">
      <summary>
        <para>Called when this mode gets <see cref="P:yWorks.Controls.ModelManager`1.Enabled">enabled</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ModelManager`1.OnDisabled">
      <summary>
        <para>Called when this mode gets <see cref="P:yWorks.Controls.ModelManager`1.Enabled">disabled</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ModelManager`1.GetInstaller(`0)">
      <summary>
        <para>Callback used by <see cref="M:yWorks.Controls.ModelManager`1.Install(`0)" /> to retrieve the installer for a given item.</para>
      </summary>
      <remarks>
        <para>Implementations may use the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the item.</para>
        <para>Returning <c>null</c> will cause <see cref="M:yWorks.Controls.ModelManager`1.Install(`0)" /> not to install anything.</para>
      </remarks>
      <param name="item">
        <para>The item to find an installer for.</para>
      </param>
      <returns>
        <para>An installer or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ModelManager`1.GetCanvasObjectGroup(`0)">
      <summary>
        <para>Callback used by <see cref="M:yWorks.Controls.ModelManager`1.Install(`0)" /> to retrieve the canvas object group for a given item.</para>
      </summary>
      <remarks>
        <para>Returning <c>null</c> will cause <see cref="M:yWorks.Controls.ModelManager`1.Install(`0)" /> not to install anything.</para>
      </remarks>
      <param name="item">
        <para>The item to find a canvas object group for.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ModelManager`1.Add(`0)">
      <summary>
        <para>Installs an itemm and adds it to this managers set of managed items.</para>
      </summary>
      <remarks>
        <para>If <see cref="P:yWorks.Controls.ModelManager`1.Enabled" /> is set to false the item will not be installed.</para>
      </remarks>
      <param name="item">
        <para>The item to add.</para>
      </param>
      <returns>
        <para>The newly created canvas object or <c>null</c> if nothing was installed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ModelManager`1.Remove(`0)">
      <summary>
        <para>Uninstalls the provided item and removes it from this managers set of managed items.</para>
      </summary>
      <param name="item">
        <para>The item to remove.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ModelManager`1.Install(`0)">
      <summary>
        <para>Installs a member of the collection into the canvas using the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> which is returned by <see cref="M:yWorks.Controls.ModelManager`1.GetInstaller(`0)" />.</para>
      </summary>
      <param name="item">
        <para>The member to install.</para>
      </param>
      <returns>
        <para>The canvas object that has been returned by the installer.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ModelManager`1.UnInstall(yWorks.Controls.ICanvasObject)">
      <summary>
        <para>Simple implementation that removes the given <see cref="T:yWorks.Controls.ICanvasObject" />.</para>
      </summary>
      <param name="canvasObject">
        <para>The canvas objects that have been associated with the descriptor.</para>
      </param>
      <seealso cref="M:yWorks.Controls.ICanvasObject.Remove" />
    </member>
    <member name="T:yWorks.Controls.SelectionIndicatorManager`1">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ModelManager`1" /> implementation that manages the visual decorations of selected elements in a canvas.</para>
      </summary>
      <remarks>
        <para>For each item in the <see cref="P:yWorks.Controls.SelectionIndicatorManager`1.Model" /> that is marked as selected by the <see cref="P:yWorks.Controls.SelectionIndicatorManager`1.SelectionModel" /> this class uses the <see cref="T:yWorks.Graph.ILookup" /> mechanism of the items to lookup an <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> implementation which will do the actual installation of the decoration in the canvas.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the items in the collection and selection model.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.SelectionIndicatorManager`1.OnDisabled" />
    <member name="M:yWorks.Controls.SelectionIndicatorManager`1.OnEnabled" />
    <member name="M:yWorks.Controls.SelectionIndicatorManager`1.#ctor(yWorks.Controls.CanvasControl,yWorks.Utils.IObservableCollection{`0},yWorks.Controls.ISelectionModel{`0})">
      <summary>
        <para>Creates an instance that for all selected items in the model dynamically installs a selection paint decoration.</para>
      </summary>
      <param name="canvas">
        <para>The canvas to add the selection marks to.</para>
      </param>
      <param name="model">
        <para>The model that holds the domain.</para>
      </param>
      <param name="selectionModel">
        <para>The model that determines which items are selected.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.SelectionIndicatorManager`1.SelectionModel">
      <summary>
        <para>Gets or sets the selection model that determines which items are selected.</para>
      </summary>
      <remarks>
        <para>May be <c>null</c>, in which case no elements are considered selected.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.SelectionIndicatorManager`1.Model">
      <summary>
        <para>Gets or sets the model that describes the domain for the selection.</para>
      </summary>
      <remarks>
        <para>Only item contained in this model can be rendered as selected.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.SelectionIndicatorManager`1.RemoveSelection(`0)">
      <summary>
        <para>Removes an item from the current selection.</para>
      </summary>
      <param name="item">
        <para>The item whose selection decorator will be removed.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.SelectionIndicatorManager`1.AddSelection(`0)">
      <summary>
        <para>Adds an item to the current selection.</para>
      </summary>
      <param name="item">
        <para>The item whose selection decorator will added.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.SelectionIndicatorManager`1.GetInstaller(`0)">
      <summary>
        <para>Callback used by <see cref="M:yWorks.Controls.ModelManager`1.Install(`0)" /> to retrieve the installer for a given item.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the item to retrieve an <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> instance.</para>
      </remarks>
      <param name="item">
        <para>The item to find an installer for.</para>
      </param>
      <returns>
        <para>An installer or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.SelectionIndicatorManager`1.GetCanvasObjectGroup(`0)">
      <summary>
        <para>Callback used by <see cref="M:yWorks.Controls.ModelManager`1.Install(`0)" /> to retrieve the installer for a given item.</para>
      </summary>
      <remarks>
        <para>This implementation always returns the <see cref="P:yWorks.Controls.CanvasControl.SelectionGroup" /> of the <see cref="P:yWorks.Controls.ModelManager`1.Canvas" /> of this instance.</para>
      </remarks>
      <param name="item">
        <para>The item to find a canvas object group for.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> or <c>null</c></para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.RenderContext">
      <summary>
        <para>A simple default implementation of <see cref="T:yWorks.Controls.IRenderContext" /> that can be used for custom <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)">IVisualCreator.CreateVisual</see>, <see cref="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">IVisualCreator.UpdateVisual</see>, and <see cref="M:yWorks.Controls.IVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">IVisual.Paint</see> invocations.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.RenderContext.#ctor(System.Drawing.Graphics,yWorks.Controls.CanvasControl)">
      <summary>
        <para>Creates an instance using a graphics instance and a <see cref="P:yWorks.Controls.RenderContext.CanvasControl" /></para>
      </summary>
      <param name="graphics" />
      <param name="canvas" />
    </member>
    <member name="P:yWorks.Controls.RenderContext.WorldTransform">
      <summary>
        <para>The transform that can be applied to the graphics context in order to paint into the world coordinate system.</para>
      </summary>
      <remarks>
        <para>This provides direct access to the instance. Client code should not modify the returned instance unless they know what they are doing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.RenderContext.ToViewCoordinates(yWorks.Geometry.PointD,System.Boolean)">
      <param name="worldLocation" />
      <param name="roundToPixels" />
    </member>
    <member name="P:yWorks.Controls.RenderContext.ViewTransform">
      <summary>
        <para>A transform that can be applied to the graphics context in order to paint in the view coordinate system.</para>
      </summary>
      <remarks>
        <para>This provides direct access to the instance. Client code should not modify the returned instance unless they know what they are doing. Setting the graphics'<see cref="P:System.Drawing.Graphics.Transform" /> property to this property will make the graphics context paint in the view coordinate system.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.RenderContext.Transform">
      <summary>
        <para>The transform that is used to convert between the <see cref="P:yWorks.Controls.RenderContext.ViewTransform" /> and the resulting <see cref="P:yWorks.Controls.RenderContext.WorldTransform" />.</para>
      </summary>
      <value />
      <remarks>
        <para>Coordinates transformed using this matrix can be drawn into a graphics context that has the <see cref="P:yWorks.Controls.RenderContext.ViewTransform" /> applied but appear to be drawn into the <see cref="P:yWorks.Controls.RenderContext.WorldTransform">world coordinate system.</see> <c>ViewTransform * Transform = WorldTransform</c> This provides direct access to the instance. Client code should not modify the returned instance unless they know what they are doing.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.RenderContext.ToViewCoordinates(yWorks.Geometry.PointD,System.Boolean)" />
    </member>
    <member name="M:yWorks.Controls.RenderContext.Lookup(System.Type)">
      <summary>
        <para>Yields the <see cref="P:yWorks.Controls.RenderContext.CanvasControl" /> if it is assignable to <paramref name="type" />.</para>
      </summary>
      <param name="type">
        <para>The type that is queried.</para>
      </param>
      <returns>
        <para>The result or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.VisualGroup">
      <summary>
        <para>A container that can hold a number of child <see cref="T:yWorks.Controls.IVisual" />s.</para>
      </summary>
      <remarks>
        <para>Use this container if you need to return a container instance from within a <see cref="T:yWorks.Controls.IVisualCreator" /> implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.VisualGroup.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.VisualGroup" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.VisualGroup.Transform">
      <summary>
        <para>Gets or sets a transform that is applied to the children of the container.</para>
      </summary>
      <value>
        <para>The transform.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.VisualGroup.Add(yWorks.Controls.IVisual)">
      <summary>
        <para>Adds another <see cref="T:yWorks.Controls.IVisual" /> to the children collection of this instance.</para>
      </summary>
      <param name="child">
        <para>The child to add.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.VisualGroup.Remove(yWorks.Controls.IVisual)">
      <summary>
        <para>Removes a previously added <see cref="T:yWorks.Controls.IVisual" /> from the children collection of this instance.</para>
      </summary>
      <param name="child">
        <para>The child to remove.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.VisualGroup.Children">
      <summary>
        <para>Gets the list of children with read and write access.</para>
      </summary>
      <value>
        <para>The children.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.VisualGroup.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="T:yWorks.Controls.Input.ConstrainedPositionHandler">
      <summary>
        <para>A convenience implementation of the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> interface that can be used to constrain the position of an item.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ConstrainedDragHandler`1" />
      <seealso cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.ConstrainNewLocation(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedPositionHandler.#ctor(yWorks.Controls.Input.IPositionHandler)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.ConstrainedPositionHandler" /> class that delegates to the <paramref name="wrappedHandler" />.</para>
      </summary>
      <param name="wrappedHandler">
        <para>The handler to wrap.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.ConstrainedHandle">
      <summary>
        <para>A convenience implementation of the <see cref="T:yWorks.Controls.Input.IHandle" /> interface that can be used to constrain the handle of an item.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ConstrainedDragHandler`1" />
      <seealso cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.ConstrainNewLocation(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedHandle.#ctor(yWorks.Controls.Input.IHandle)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.ConstrainedHandle" /> class that delegates to the <paramref name="wrappedHandle" />.</para>
      </summary>
      <param name="wrappedHandle">
        <para>The handle to wrap.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.ConstrainedHandle.Type">
      <summary>
        <para>Gets the <see cref="P:yWorks.Controls.Input.ConstrainedDragHandler`1.WrappedHandler" />'s <see cref="P:yWorks.Controls.Input.IHandle.Type" /> property.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ConstrainedHandle.Cursor">
      <summary>
        <para>Gets the <see cref="P:yWorks.Controls.Input.ConstrainedDragHandler`1.WrappedHandler" />'s <see cref="P:yWorks.Controls.Input.IHandle.Cursor" /> property.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.ConstrainedReshapeHandler">
      <summary>
        <para>A utility implementation of the <see cref="T:yWorks.Controls.Input.IReshapeHandler" /> interface that can be used to constrain the reshaping of an existing instance conveniently.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ConstrainedHandle" />
      <seealso cref="T:yWorks.Controls.Input.ConstrainedPositionHandler" />
      <seealso cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.ConstrainNewBounds(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedReshapeHandler.#ctor(yWorks.Controls.Input.IReshapeHandler)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.ConstrainedReshapeHandler" /> class that delegates to the <paramref name="wrappedHandler" />.</para>
      </summary>
      <param name="wrappedHandler">
        <para>The handler to wrap.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.ConstrainedReshapeHandler.WrappedHandler">
      <summary>
        <para>Gets the wrapped handler to which calls will be ultimately delegated.</para>
      </summary>
      <value>
        <para>The wrapped handler.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ConstrainedReshapeHandler.Bounds">
      <summary>
        <para>Gets the <see cref="P:yWorks.Controls.Input.ConstrainedReshapeHandler.WrappedHandler" />'s <see cref="P:yWorks.Controls.Input.IReshapeHandler.Bounds" /> property.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Initializes the reshape operation and subsequently calls <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.OnInitialized(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /></para>
      </summary>
      <param name="context">
        <para>The context in which the drag will be performed.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Handles the reshape operation and subsequently calls <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.OnReshaped(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /></para>
      </summary>
      <param name="context">
        <para>The context in which the reshape will be performed.</para>
      </param>
      <param name="originalBounds">
        <para>The value of the <see cref="P:yWorks.Controls.Input.ConstrainedReshapeHandler.Bounds" /> property at the time of <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
      <param name="newBounds">
        <para>The coordinates in the world coordinate system that the client wants to reshape the item to. Depending on the implementation the <see cref="P:yWorks.Controls.Input.ConstrainedReshapeHandler.Bounds" /> may or may not be modified to reflect the new value.</para>
      </param>
      <remarks>
        <para>This method will use the <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.ConstrainNewBounds(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /> callback to let subclasses constrain the reshaping.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedReshapeHandler.ConstrainNewBounds(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Callback that needs to implement the constraints for the new bounds.</para>
      </summary>
      <param name="context">
        <para>The context in which the reshape will be performed.</para>
      </param>
      <param name="originalBounds">
        <para>The value of the <see cref="P:yWorks.Controls.Input.ConstrainedReshapeHandler.Bounds" /> property at the time of <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
      <param name="newBounds">
        <para>The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the implementation the <see cref="P:yWorks.Controls.Input.ConstrainedReshapeHandler.Bounds" /> may or may not be modified to reflect the new value.</para>
      </param>
      <returns>
        <para>The constrained value of <paramref name="newBounds" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedReshapeHandler.CancelReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Cancels the move operation and calls <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.OnCanceled(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /></para>
      </summary>
      <param name="context">
        <para>The context to retrieve information about the drag from.</para>
      </param>
      <param name="originalBounds">
        <para>The value of the coordinate of the <see cref="P:yWorks.Controls.Input.ConstrainedReshapeHandler.Bounds" /> property at the time of <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedReshapeHandler.OnReshaped(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Called when the <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /> operation has been performed.</para>
      </summary>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="originalBounds">
        <para>The original Bounds.</para>
      </param>
      <param name="newBounds">
        <para>The new Bounds.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedReshapeHandler.OnInitialized(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Called when the <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" /> method has been called.</para>
      </summary>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="originalBounds">
        <para>The original bounds.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedReshapeHandler.OnCanceled(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Called when the <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.CancelReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /> method has been called.</para>
      </summary>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="originalBounds">
        <para>The original bounds.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedReshapeHandler.OnFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Called when the <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.ReshapeFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /> method has been called.</para>
      </summary>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="originalBounds">
        <para>The original bounds.</para>
      </param>
      <param name="newBounds">
        <para>The new bounds.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedReshapeHandler.ReshapeFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Handles the finish operation and invokes <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.OnFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /></para>
      </summary>
      <param name="context">
        <para>The context to retrieve information about the drag from.</para>
      </param>
      <param name="originalBounds">
        <para>The value of the <see cref="P:yWorks.Controls.Input.ConstrainedReshapeHandler.Bounds" /> property at the time of <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
      <param name="newBounds">
        <para>The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the implementation the <see cref="P:yWorks.Controls.Input.ConstrainedReshapeHandler.Bounds" /> may or may not be modified to reflect the new value. This is the same value as delivered in the last invocation of <see cref="M:yWorks.Controls.Input.ConstrainedReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /></para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.ConstrainedDragHandler`1">
      <summary>
        <para>A utility implementation of the <see cref="T:yWorks.Controls.Input.IDragHandler" /> interface that can be used to constrain the movement of an existing instance.</para>
      </summary>
      <typeparam name="TWrapped">
        <para>The exact type of the wrapped implementation.</para>
      </typeparam>
      <seealso cref="T:yWorks.Controls.Input.ConstrainedHandle" />
      <seealso cref="T:yWorks.Controls.Input.ConstrainedPositionHandler" />
      <seealso cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.ConstrainNewLocation(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedDragHandler`1.#ctor(`0)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.ConstrainedDragHandler`1" /> class that delegates to the <paramref name="wrappedHandler" />.</para>
      </summary>
      <param name="wrappedHandler">
        <para>The handler to wrap.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.ConstrainedDragHandler`1.WrappedHandler">
      <summary>
        <para>Gets the wrapped handler to which calls will be ultimately delegated.</para>
      </summary>
      <value>
        <para>The wrappe handler.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ConstrainedDragHandler`1.Location">
      <summary>
        <para>Gets the <see cref="P:yWorks.Controls.Input.ConstrainedDragHandler`1.WrappedHandler" />'s <see cref="P:yWorks.Controls.Input.IDragHandler.Location" /> property.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedDragHandler`1.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Initializes the drag operation and subsequently calls <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.OnInitialized(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /></para>
      </summary>
      <param name="context">
        <para>The context in which the drag will be performed.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedDragHandler`1.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Handles the move operation and subsequently calls <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.OnMoved(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /></para>
      </summary>
      <param name="context">
        <para>The context in which the drag will be performed.</para>
      </param>
      <param name="originalLocation">
        <para>The value of the <see cref="P:yWorks.Controls.Input.ConstrainedDragHandler`1.Location" /> property at the time of <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
      <param name="newLocation">
        <para>The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the implementation the <see cref="P:yWorks.Controls.Input.ConstrainedDragHandler`1.Location" /> may or may not be modified to reflect the new value.</para>
      </param>
      <remarks>
        <para>This method will use the <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.ConstrainNewLocation(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> callback to let subclasses constrain the movement.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedDragHandler`1.ConstrainNewLocation(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Callback that needs to implement the constraints for the new location.</para>
      </summary>
      <param name="context">
        <para>The context in which the drag will be performed.</para>
      </param>
      <param name="originalLocation">
        <para>The value of the <see cref="P:yWorks.Controls.Input.ConstrainedDragHandler`1.Location" /> property at the time of <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
      <param name="newLocation">
        <para>The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the implementation the <see cref="P:yWorks.Controls.Input.ConstrainedDragHandler`1.Location" /> may or may not be modified to reflect the new value.</para>
      </param>
      <returns>
        <para>The constrained value of <paramref name="newLocation" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedDragHandler`1.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Cancels the move operation and calls <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.OnCanceled(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /></para>
      </summary>
      <param name="context">
        <para>The context to retrieve information about the drag from.</para>
      </param>
      <param name="originalLocation">
        <para>The value of the coordinate of the <see cref="P:yWorks.Controls.Input.ConstrainedDragHandler`1.Location" /> property at the time of <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedDragHandler`1.OnMoved(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Called when the <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> operation has been performed.</para>
      </summary>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="originalLocation">
        <para>The original location.</para>
      </param>
      <param name="newLocation">
        <para>The new location.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedDragHandler`1.OnInitialized(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Called when the <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> method has been called.</para>
      </summary>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="originalLocation">
        <para>The original location.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedDragHandler`1.OnCanceled(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Called when the <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> method has been called.</para>
      </summary>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="originalLocation">
        <para>The original location.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedDragHandler`1.OnFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Called when the <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> method has been called.</para>
      </summary>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="originalLocation">
        <para>The original location.</para>
      </param>
      <param name="newLocation">
        <para>The new location.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ConstrainedDragHandler`1.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Handles the finish operation and invokes <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.OnFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /></para>
      </summary>
      <param name="context">
        <para>The context to retrieve information about the drag from.</para>
      </param>
      <param name="originalLocation">
        <para>The value of the <see cref="P:yWorks.Controls.Input.ConstrainedDragHandler`1.Location" /> property at the time of <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
      <param name="newLocation">
        <para>The coordinates in the world coordinate system that the client wants the handle to be at. Depending on the implementation the <see cref="P:yWorks.Controls.Input.ConstrainedDragHandler`1.Location" /> may or may not be modified to reflect the new value. This is the same value as delivered in the last invocation of <see cref="M:yWorks.Controls.Input.ConstrainedDragHandler`1.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /></para>
      </param>
    </member>
    <member name="T:yWorks.Controls.BoundsProviders">
      <summary>
        <para>Simple default implementation of <see cref="T:yWorks.Controls.IBoundsProvider" /> that returns a constant rectangle instance.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BoundsProviders.Empty">
      <summary>
        <para>An implementation that returns an <see cref="T:yWorks.Controls.IBoundsProvider" /> that yields an "Empty" bounds.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.BoundsProviders.Unbounded">
      <summary>
        <para>An implementation that returns an <see cref="T:yWorks.Controls.IBoundsProvider" /> that yields <see cref="F:yWorks.Geometry.RectD.Infinite">"infinite"</see> bounds.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.BoundsProviders.FromRectangle(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Creates an instance that returns the given model as the bounds.</para>
      </summary>
      <param name="bounds">
        <para>the rectangle</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.VisibilityTestables">
      <summary>
        <para>Utility class that provides simple implementations of <see cref="T:yWorks.Controls.IVisibilityTestable" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.VisibilityTestables.Always">
      <summary>
        <para>An implementation of a <see cref="T:yWorks.Controls.IVisibilityTestable" /> that always yields <c>true</c>.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.VisibilityTestables.Never">
      <summary>
        <para>An implementation of a <see cref="T:yWorks.Controls.IVisibilityTestable" /> that always yields <c>false</c>.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.HitTestableHandler">
      <summary>
        <para>A delegate version of the <see cref="T:yWorks.Controls.Input.IHitTestable" /> interface.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.IHitTestable" />
      <seealso cref="M:yWorks.Controls.Input.HitTestables.Create(yWorks.Controls.Input.HitTestableHandler)" />
    </member>
    <member name="T:yWorks.Controls.Input.HitTestables">
      <summary>
        <para>A utility class that provides simple <see cref="T:yWorks.Controls.Input.IHitTestable" /> implementations.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.HitTestables.Create(yWorks.Controls.Input.HitTestableHandler)">
      <summary>
        <para>Wrap a handler into an interface.</para>
      </summary>
      <param name="handler" />
    </member>
    <member name="F:yWorks.Controls.Input.HitTestables.Never">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IHitTestable" /> that always returns false.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.HitTestables.Always">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IHitTestable" /> that always returns true.</para>
      </summary>
    </member>
    <member name="T:yWorks.Geometry.PathType">
      <summary>
        <para>An enumeration of all possible types that make up a <see cref="T:yWorks.Geometry.GeneralPath" /></para>
      </summary>
    </member>
    <member name="F:yWorks.Geometry.PathType.MoveTo">
      <summary>
        <para>The type that is used to move the pen to the next position.</para>
      </summary>
      <remarks>
        <para>This type uses one coordinate pair.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Geometry.PathType.LineTo">
      <summary>
        <para>The type that is used to add a line from the current position to the next position.</para>
      </summary>
      <remarks>
        <para>This type uses one coordinate pair.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Geometry.PathType.QuadTo">
      <summary>
        <para>The type that is used to add a quadratic Bézier curve from the current position to the next position using one control point.</para>
      </summary>
      <remarks>
        <para>This type uses two coordinate pairs.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Geometry.PathType.CubicTo">
      <summary>
        <para>The type that is used to add a cubic Bézier curve from the current position to the next position using two intermediate control points.</para>
      </summary>
      <remarks>
        <para>This type uses three coordinate pairs.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Geometry.PathType.Close">
      <summary>
        <para>The type that is used to add a line from the current position to the last <see cref="F:yWorks.Geometry.PathType.MoveTo" /> position.</para>
      </summary>
      <remarks>
        <para>This type uses no coordinate pair.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Geometry.GeneralPath">
      <summary>
        <para>Models a path that consists of lines and Bézier curves.</para>
      </summary>
      <remarks>
        <para>This class uses double precision coordinates to model a virtual pen that can be moved across the world coordinate system and which can be used to draw lines and Bézier curves. This class provides many geometric utility methods, such as calculating the bounds, hit tests, containment tests, curve flattening, path transformation, path modification, and path iteration.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Geometry.GeneralPath.PathCursor">
      <summary>
        <para>A class that is used by <see cref="T:yWorks.Geometry.GeneralPath" /> to iterate over the elements the path is made up of.</para>
      </summary>
      <seealso cref="M:yWorks.Geometry.GeneralPath.CreateCursor" />
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.PathCursor.MoveNext">
      <summary>
        <para>Advances the cursor to the next position if possible.</para>
      </summary>
      <returns>
        <para>Whether the cursor has been moved successfully. <c>false</c> if the cursor has been moved beyond the end of the path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.PathCursor.Reset">
      <summary>
        <para>Reset the cursor to point to the beginning of the path.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.PathCursor.ToLast">
      <summary>
        <para>Resets the cursor to point to the last element in the path.</para>
      </summary>
      <returns>
        <para>Whether the cursor has been moved successfully.</para>
      </returns>
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.PathCursor.Index">
      <summary>
        <para>Gets the current position of the cursor.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.PathCursor.MovePrevious">
      <summary>
        <para>Moves the cursor to the previous position in the path.</para>
      </summary>
      <returns>
        <para>Whether the move was successful.</para>
      </returns>
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.PathCursor.PathType">
      <summary>
        <para>Gets the type of the path at the position of the cursor.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.PathCursor.GetCurrent(System.Double[])">
      <summary>
        <para>Places the coordinates for the current type into the given array.</para>
      </summary>
      <remarks>
        <para>The array needs to have a length of at least 6, since <see cref="F:yWorks.Geometry.PathType.CubicTo" /> needs six coordinates. If the path has been flattened a length of two suffices.</para>
      </remarks>
      <returns>
        <para>The current type of the path element.</para>
      </returns>
      <seealso cref="M:yWorks.Geometry.GeneralPath.PathCursor.GetCurrentEndPoint(System.Double[])" />
      <param name="coordinates" />
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.PathCursor.CurrentEndPointX">
      <summary>
        <para>Gets the current x coordinate of the last path element.</para>
      </summary>
      <value>
        <para>The x coordinate or <c>0</c> if the element is of type <see cref="F:yWorks.Geometry.PathType.Close" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.PathCursor.CurrentEndPoint">
      <summary>
        <para>Gets the current end point of the last path element.</para>
      </summary>
      <value>
        <para>The current end point.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.PathCursor.CurrentEndPointY">
      <summary>
        <para>Gets the current y coordinate of the last path element.</para>
      </summary>
      <value>
        <para>The y coordinate or <c>0</c> if the element is of type <see cref="F:yWorks.Geometry.PathType.Close" />.</para>
      </value>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.PathCursor.GetCurrentEndPoint(System.Double[])">
      <summary>
        <para>Places the current end coordinates of the last path element into the array.</para>
      </summary>
      <param name="coordinates">
        <para>An array with length at least 2.</para>
      </param>
      <returns>
        <para>The type of the current element.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.#ctor(System.Int32)">
      <summary>
        <para>Creates a new instance with given initial capacity.</para>
      </summary>
      <param name="capacity">
        <para>The number of elements for which storage will be allocated initially.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.IsEquivalentTo(yWorks.Geometry.GeneralPath)">
      <summary>
        <para>Determines whether a given <see cref="T:yWorks.Geometry.GeneralPath" /> instance can be considered equivalent to this one, that is, both represent the same path with the same sub-path types and coordinates.</para>
      </summary>
      <param name="path">
        <para>The other <see cref="T:yWorks.Geometry.GeneralPath" /> instance to compare.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if <paramref name="path" /> and this instance have the same sub-path types and coordinates, <c>false</c> if not.</para>
      </returns>
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.LastX">
      <summary>
        <para>Gets the last x coordinate of the last path element.</para>
      </summary>
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.LastCoordinate">
      <summary>
        <para>Gets the last coordinates of the last path element.</para>
      </summary>
      <value>
        <para>The last coordinate.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.LastY">
      <summary>
        <para>Gets the last y coordinate of the last path element.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.FindRayIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Finds the first intersection of a ray with this <see cref="T:yWorks.Geometry.GeneralPath" /> using a given epsilon for flattening Bézier curves contained in the path.</para>
      </summary>
      <remarks>
        <para>The ray is treated like an infinite line starting at the given anchor point and continuing in the direction of rayX, rayY. The ray vector does not need to be normalized. The value returned will be the smallest positive value such that the point depicted by <c>(anchorX + result * rayX, anchorY + result * rayY)</c> is an intersection point between the ray and the path.</para>
      </remarks>
      <param name="anchor">
        <para>The coordinates of the anchor point of the ray.</para>
      </param>
      <param name="direction">
        <para>The coordinates of the direction vector of the ray.</para>
      </param>
      <returns>
        <para>The factor to calculate the intersection point or <c>double.PositiveInfinity</c>.</para>
      </returns>
      <param name="eps">
        <para>The epsilon value that is used for the accuracy with which the implementation should test Bézier curves within the path for intersections.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Render(System.Drawing.Graphics,System.Drawing.Brush,System.Drawing.Pen)">
      <summary>
        <para>Both fills and draws a path to the graphics context.</para>
      </summary>
      <param name="g">
        <para>The graphics context to draw to.</para>
      </param>
      <param name="brush">
        <para>The brush to use for filling.</para>
      </param>
      <param name="pen">
        <para>The pen to use for drawing.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Render(System.Drawing.Graphics,System.Drawing.Drawing2D.Matrix,System.Drawing.Brush,System.Drawing.Pen)">
      <summary>
        <para>Both fills and draws a path to the graphics context using the transformation matrix.</para>
      </summary>
      <param name="g">
        <para>The graphics context to draw to.</para>
      </param>
      <param name="brush">
        <para>The brush to use for filling.</para>
      </param>
      <param name="pen">
        <para>The pen to use for drawing.</para>
      </param>
      <param name="matrix">
        <para>The transformation to apply to the path before drawing.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Render(System.Drawing.Graphics,yWorks.Geometry.Matrix2D,System.Drawing.Brush,System.Drawing.Pen)">
      <summary>
        <para>Both fills and draws a path to the graphics context using the transformation matrix.</para>
      </summary>
      <param name="g">
        <para>The graphics context to draw to.</para>
      </param>
      <param name="brush">
        <para>The brush to use for filling.</para>
      </param>
      <param name="pen">
        <para>The pen to use for drawing.</para>
      </param>
      <param name="matrix">
        <para>The transformation to apply to the path before drawing.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Fill(System.Drawing.Graphics,System.Drawing.Brush)">
      <summary>
        <para>Fills a path to the graphics context.</para>
      </summary>
      <param name="g">
        <para>The graphics context to draw to.</para>
      </param>
      <param name="brush">
        <para>The brush to use for filling.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Fill(System.Drawing.Graphics,System.Drawing.Drawing2D.Matrix,System.Drawing.Brush)">
      <summary>
        <para>Fills a path to the graphics context.</para>
      </summary>
      <param name="g">
        <para>The graphics context to draw to.</para>
      </param>
      <param name="brush">
        <para>The brush to use for filling.</para>
      </param>
      <param name="matrix">
        <para>The transformation to apply to the path before filling.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Fill(System.Drawing.Graphics,yWorks.Geometry.Matrix2D,System.Drawing.Brush)">
      <summary>
        <para>Fills a path to the graphics context.</para>
      </summary>
      <param name="g">
        <para>The graphics context to draw to.</para>
      </param>
      <param name="brush">
        <para>The brush to use for filling.</para>
      </param>
      <param name="matrix">
        <para>The transformation to apply to the path before filling.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Draw(System.Drawing.Graphics,System.Drawing.Pen)">
      <summary>
        <para>Draws a path to the graphics context.</para>
      </summary>
      <param name="g">
        <para>The graphics context to draw to.</para>
      </param>
      <param name="pen">
        <para>The pen to use for drawing.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Draw(System.Drawing.Graphics,System.Drawing.Drawing2D.Matrix,System.Drawing.Pen)">
      <summary>
        <para>Draws a path to the graphics context.</para>
      </summary>
      <param name="g">
        <para>The graphics context to draw to.</para>
      </param>
      <param name="pen">
        <para>The pen to use for drawing.</para>
      </param>
      <param name="matrix">
        <para>The transformation to apply to the path before filling.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Draw(System.Drawing.Graphics,yWorks.Geometry.Matrix2D,System.Drawing.Pen)">
      <summary>
        <para>Draws a path to the graphics context.</para>
      </summary>
      <param name="g">
        <para>The graphics context to draw to.</para>
      </param>
      <param name="pen">
        <para>The pen to use for drawing.</para>
      </param>
      <param name="matrix">
        <para>The transformation to apply to the path before filling.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.FindLineIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Finds an intersection point between a line and this <see cref="T:yWorks.Geometry.GeneralPath" />.</para>
      </summary>
      <remarks>
        <para>The value returned will be the smallest positive value smaller than 1 such that the point depicted by <c>start + result * (end - start)</c> is an intersection point between the line and the path.</para>
      </remarks>
      <param name="start">
        <para>The coordinates of the first point of the line.</para>
      </param>
      <param name="end">
        <para>The coordinates of the second point of the line.</para>
      </param>
      <param name="eps">
        <para>The value to use for interpolating Bézier curves.</para>
      </param>
      <returns>
        <para>The factor to calculate the intersection point or <c>double.PositiveInfinity</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.IsEmpty">
      <summary>
        <para>Gets a value indicating whether this path contains elements other than an initial MoveTo.</para>
      </summary>
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.IsVisible">
      <summary>
        <para>Gets a value indicating whether the path contains visible parts.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.MoveTo(System.Double,System.Double)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.MoveTo" /> operation to the path elements.</para>
      </summary>
      <remarks>
        <para>This moves the pen to a new position without drawing a line.</para>
      </remarks>
      <param name="x">
        <para>The next x coordinate.</para>
      </param>
      <param name="y">
        <para>The next y coordinate.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.MoveTo(yWorks.Geometry.IPoint)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.MoveTo" /> operation to the path elements.</para>
      </summary>
      <remarks>
        <para>This moves the pen to a new position without drawing a line.</para>
      </remarks>
      <param name="point">
        <para>The next coordinate.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.MoveTo(yWorks.Geometry.PointD)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.MoveTo" /> operation to the path elements.</para>
      </summary>
      <remarks>
        <para>This moves the pen to a new position without drawing a line.</para>
      </remarks>
      <param name="point">
        <para>The next coordinate.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.AppendRectangle(yWorks.Geometry.IRectangle,System.Boolean)">
      <summary>
        <para>Appends a rectangle to this path instance.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to get the coordinates from.</para>
      </param>
      <param name="connect">
        <para>Whether to use a <see cref="M:yWorks.Geometry.GeneralPath.LineTo(yWorks.Geometry.IPoint)" /> to the upper left corner.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.AppendOrientedRectangle(yWorks.Geometry.IOrientedRectangle,System.Boolean)">
      <summary>
        <para>Appends an <see cref="T:yWorks.Geometry.IOrientedRectangle" /> to this path instance.</para>
      </summary>
      <param name="rectangle">
        <para>The <see cref="T:yWorks.Geometry.IOrientedRectangle" /> to get the coordinates from.</para>
      </param>
      <param name="connect">
        <para>Whether to use a <see cref="M:yWorks.Geometry.GeneralPath.LineTo(yWorks.Geometry.IPoint)" /> to the anchor corner.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Append(yWorks.Geometry.GeneralPath,System.Boolean)">
      <summary>
        <para>Appends the contents of the given path to this path.</para>
      </summary>
      <remarks>
        <para>If <paramref name="connect" /> is <c>true</c>, an initial <see cref="F:yWorks.Geometry.PathType.MoveTo" /> in <paramref name="other" /> will be transformed into a <see cref="F:yWorks.Geometry.PathType.LineTo" />.</para>
      </remarks>
      <param name="other">
        <para>The path to append to this path.</para>
      </param>
      <param name="connect">
        <para>Whether to connect the path to the end of this path.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Prepend(yWorks.Geometry.GeneralPath,System.Boolean)">
      <summary>
        <para>Adds the contents of the given path to the beginning of this path.</para>
      </summary>
      <remarks>
        <para>If <paramref name="connect" /> is <c>true</c>, the initial <see cref="F:yWorks.Geometry.PathType.MoveTo" /> in <c>this</c> will be transformed into a <see cref="F:yWorks.Geometry.PathType.LineTo" />.</para>
      </remarks>
      <param name="other">
        <para>The path to append to this path.</para>
      </param>
      <param name="connect">
        <para>Whether to connect the path to the end of this path.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Append(System.Drawing.Drawing2D.GraphicsPath,System.Boolean)">
      <summary>
        <para>Appends the contents of the given path to this path.</para>
      </summary>
      <remarks>
        <para>If <paramref name="connect" /> is <c>true</c>, an initial move operation in <paramref name="path" /> will be transformed into a <see cref="F:yWorks.Geometry.PathType.LineTo" />.</para>
      </remarks>
      <param name="path">
        <para>The path to append to this path.</para>
      </param>
      <param name="connect">
        <para>Whether to connect the path to the end of this path.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Append(yWorks.Geometry.GeneralPath,System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Appends parts of the contents of the given path to this path.</para>
      </summary>
      <remarks>
        <para>If <paramref name="connect" /> is <c>true</c>, an initial <see cref="F:yWorks.Geometry.PathType.MoveTo" /> in <paramref name="other" /> will be transformed into a <see cref="F:yWorks.Geometry.PathType.LineTo" />.</para>
      </remarks>
      <param name="other">
        <para>The path to append to this path.</para>
      </param>
      <param name="connect">
        <para>Whether to connect the path to the end of this path.</para>
      </param>
      <param name="beginIndex">
        <para>The first element to be copied from <paramref name="other" />, inclusively.</para>
      </param>
      <param name="endIndex">
        <para>The last element to be copied from <paramref name="other" />, exclusively.</para>
      </param>
    </member>
    <member name="P:yWorks.Geometry.GeneralPath.Count">
      <summary>
        <para>Gets the number of <see cref="T:yWorks.Geometry.PathType" /> operations stored in this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.LineTo(System.Double,System.Double)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.LineTo" /> operation to the path elements.</para>
      </summary>
      <remarks>
        <para>This draws a line from the current end point to the given position.</para>
      </remarks>
      <param name="x">
        <para>The x coordinate of the line's end point.</para>
      </param>
      <param name="y">
        <para>The y coordinate of the line's end point.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.LineTo(yWorks.Geometry.IPoint)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.LineTo" /> operation to the path elements.</para>
      </summary>
      <remarks>
        <para>This draws a line from the current end point to the given position.</para>
      </remarks>
      <param name="point">
        <para>The coordinates of the line's end point.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.LineTo(yWorks.Geometry.PointD)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.LineTo" /> operation to the path elements.</para>
      </summary>
      <remarks>
        <para>This draws a line from the current end point to the given position.</para>
      </remarks>
      <param name="point">
        <para>The coordinates of the line's end point.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.QuadTo(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.QuadTo">quadratic Bézier curve</see> to the path elements.</para>
      </summary>
      <remarks>
        <para>This draws a quadratic Bézier curve from the current end point to the given position using the given control point.</para>
      </remarks>
      <param name="cx">
        <para>The x coordinate of the Bézier control point.</para>
      </param>
      <param name="cy">
        <para>The y coordinate of the Bézier control point.</para>
      </param>
      <param name="x">
        <para>The x coordinate of the curve's end point.</para>
      </param>
      <param name="y">
        <para>The y coordinate of the curve's end point.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.QuadTo(yWorks.Geometry.IPoint,yWorks.Geometry.IPoint)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.QuadTo">quadratic Bézier curve</see> to the path elements.</para>
      </summary>
      <remarks>
        <para>This draws a quadratic Bézier curve from the current end point to the given position using the given control point.</para>
      </remarks>
      <param name="center">
        <para>The coordinates of the Bézier control point.</para>
      </param>
      <param name="point">
        <para>The coordinates of the curve's end point.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.QuadTo(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.QuadTo">quadratic Bézier curve</see> to the path elements.</para>
      </summary>
      <remarks>
        <para>This draws a quadratic Bézier curve from the current end point to the given position using the given control point.</para>
      </remarks>
      <param name="center">
        <para>The coordinates of the Bézier control point.</para>
      </param>
      <param name="point">
        <para>The coordinates of the curve's end point.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Flatten(System.Double)">
      <summary>
        <para>Creates a new path from this instance flattening all Bézier curves using the given epsilon.</para>
      </summary>
      <remarks>
        <para>This will create a path that consists of <see cref="F:yWorks.Geometry.PathType.MoveTo" />, <see cref="F:yWorks.Geometry.PathType.LineTo" />, and <see cref="F:yWorks.Geometry.PathType.Close" /> operations only.</para>
      </remarks>
      <param name="eps">
        <para>The maximum value the flattened path may diverge from the original path for the Bézier curve line interpolations.</para>
      </param>
      <returns>
        <para>A new path that does not contain Bézier curves.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CubicTo(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.CubicTo">cubic Bézier curve</see> to the path elements.</para>
      </summary>
      <remarks>
        <para>This draws a cubic Bézier curve from the current end point to the given position using the two given control points.</para>
      </remarks>
      <param name="c1x">
        <para>The x coordinate of the first Bézier control point.</para>
      </param>
      <param name="c1y">
        <para>The y coordinate of the first Bézier control point.</para>
      </param>
      <param name="c2x">
        <para>The x coordinate of the second Bézier control point.</para>
      </param>
      <param name="c2y">
        <para>The y coordinate of the second Bézier control point.</para>
      </param>
      <param name="x">
        <para>The x coordinate of the curve's end point.</para>
      </param>
      <param name="y">
        <para>The y coordinate of the curve's end point.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CubicTo(yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.CubicTo">cubic Bézier curve</see> to the path elements.</para>
      </summary>
      <remarks>
        <para>This draws a cubic Bézier curve from the current end point to the given position using the two given control points.</para>
      </remarks>
      <param name="c1">
        <para>The coordinates of the first Bézier control point.</para>
      </param>
      <param name="c2">
        <para>The coordinates of the second Bézier control point.</para>
      </param>
      <param name="end">
        <para>The coordinates of the curve's end point.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CubicTo(yWorks.Geometry.IPoint,yWorks.Geometry.IPoint,yWorks.Geometry.IPoint)">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.CubicTo">cubic Bézier curve</see> to the path elements.</para>
      </summary>
      <remarks>
        <para>This draws a cubic Bézier curve from the current end point to the given position using the two given control points.</para>
      </remarks>
      <param name="c1">
        <para>The coordinates of the first Bézier control point.</para>
      </param>
      <param name="c2">
        <para>The coordinates of the second Bézier control point.</para>
      </param>
      <param name="end">
        <para>The coordinates of the curve's end point.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Close">
      <summary>
        <para>Appends a <see cref="F:yWorks.Geometry.PathType.Close" /> operation to the path elements, creating a line to the last <see cref="F:yWorks.Geometry.PathType.MoveTo" /> position.</para>
      </summary>
      <remarks>
        <para>This draws a line from the current end point to the last <see cref="M:yWorks.Geometry.GeneralPath.MoveTo(System.Double,System.Double)" /> position, closing the current sub path.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CreateCursor">
      <summary>
        <para>Creates a cursor for iterating over the elements of this path.</para>
      </summary>
      <remarks>
        <para>The cursor is fail-fast, i.e. if the path's structure is modified after the construction of the cursor any cursor operation will fail.</para>
      </remarks>
      <returns>
        <para>A cursor to iterate over this path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Clear">
      <summary>
        <para>Resets this path to be an empty path.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CreatePath(System.Drawing.Drawing2D.Matrix)">
      <summary>
        <para>Creates a GraphicsPath from the current path.</para>
      </summary>
      <param name="transform">
        <para>The transform to apply to the path.</para>
      </param>
      <returns>
        <para>A GraphicsPath instance that can be used to render this path to a Graphics context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CreatePath(yWorks.Geometry.Matrix2D)">
      <summary>
        <para>Creates a GraphicsPath from the current path using the given transform.</para>
      </summary>
      <param name="transform" />
      <returns>
        <para>A GraphicsPath instance that can be used to render this path to a Graphics context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CreateRegion">
      <summary>
        <para>Creates a Region from the current path using.</para>
      </summary>
      <returns>
        <para>A Region instance that can has been created using this path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.AppendTo(System.Drawing.Drawing2D.GraphicsPath,System.Drawing.Drawing2D.Matrix)">
      <summary>
        <para>Appends this path to the given GraphicsPath applying the given transform.</para>
      </summary>
      <param name="transform">
        <para>The transform to apply to the elements of this path before appending them.</para>
      </param>
      <param name="path">
        <para>The path to append this path to.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.GetPoint(System.Double)">
      <summary>
        <para>Gets a point on this path instance at the given ratio.</para>
      </summary>
      <remarks>
        <para>Note that this implementation still treats Bézier curves as linear segments.</para>
      </remarks>
      <param name="ratio">
        <para>A value between 0 and 1 inclusively that indicates a ratio from the beginning to the end of this path.</para>
      </param>
      <returns>
        <para>The coordinates of the point.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.GetTangent(System.Double)">
      <summary>
        <para>Gets the tangent on this path instance at the given ratio.</para>
      </summary>
      <remarks>
        <para>Note that this implementation still treats Bézier curves as linear segments.</para>
      </remarks>
      <param name="ratio">
        <para>A value between 0 and 1 inclusively that indicates a ratio from the beginning to the end of this path.</para>
      </param>
      <returns>
        <para>The tangent, if any exists; <c>null</c> otherwise. The tangent vector may not be normalized.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.GetTangent(System.Int32,System.Double)">
      <summary>
        <para>Gets the tangent on this path instance at the segment and segment ratio.</para>
      </summary>
      <remarks>
        <para>Note that this implementation still treats Bézier curves as linear segments.</para>
      </remarks>
      <param name="ratio">
        <para>A value between 0 and 1 inclusively that indicates a ratio from the beginning to the end of the segment at segmentIndex for this path.</para>
      </param>
      <param name="segmentIndex">
        <para>The segment index to determine a point at.</para>
      </param>
      <returns>
        <para>The tangent, if any exists; <c>null</c> otherwise. The tangent vector may not be normalized.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.GetSegmentCount">
      <summary>
        <para>Gets the number of segments in this path, that is the number of <see cref="F:yWorks.Geometry.PathType.LineTo" /> and <see cref="F:yWorks.Geometry.PathType.Close" /> operations.</para>
      </summary>
      <returns>
        <para>The number of segments.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.GetLength">
      <summary>
        <para>Returns the geometric length of this path.</para>
      </summary>
      <remarks>
        <para>Note that Bézier curves are still treated as line segments.</para>
      </remarks>
      <returns>
        <para>The length of this path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.GetBounds(System.Double)">
      <summary>
        <para>Gets the bounds of a flattened version the path.</para>
      </summary>
      <param name="eps">
        <para>The epsilon to use for the flattening operation.</para>
      </param>
      <returns>
        <para>The bounds of the flattened path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.GetBounds">
      <summary>
        <para>Calculates the bounds of this path and returns it.</para>
      </summary>
      <remarks>
        <para>This will not yield tight bounds if the path contains Bézier curves. The bounds are calculated using the union of all points and control points contained in this path.</para>
      </remarks>
      <returns>
        <para>A rectangle that describes the geometric bounds of this path.</para>
      </returns>
      <seealso cref="M:yWorks.Geometry.GeneralPath.GetBounds(System.Double)" />
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.AreaContains(yWorks.Geometry.PointD)">
      <summary>
        <para>Checks whether the point lies inside the area that is described by this path instance.</para>
      </summary>
      <remarks>
        <para>Note that this will only work as expected for closed paths.</para>
      </remarks>
      <param name="point">
        <para>The coordinates of the point to test.</para>
      </param>
      <returns>
        <para>Whether the point lies within the area described by this path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.AreaContains(yWorks.Geometry.IPoint)">
      <summary>
        <para>Checks whether the point lies inside the area that is described by this path instance.</para>
      </summary>
      <remarks>
        <para>Note that this will only work as expected for closed paths.</para>
      </remarks>
      <param name="point">
        <para>The coordinates of the point to test.</para>
      </param>
      <returns>
        <para>Whether the point lies within the area described by this path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.AreaContains(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Checks whether the point lies inside the area that is described by this path instance.</para>
      </summary>
      <remarks>
        <para>Note that this will only work as expected for closed paths. The epsilon is used for internally flattening Bézier curves.</para>
      </remarks>
      <param name="point">
        <para>The coordinates of the point to test.</para>
      </param>
      <param name="eps">
        <para>The value to use for flattening Bézier curves during the test.</para>
      </param>
      <returns>
        <para>Whether the point lies within the area described by this path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.PathContains(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Tests whether the line of the path is hit at the given point using an epsilon for fuzzy hit testing.</para>
      </summary>
      <param name="point">
        <para>The p coordinates of the point to test.</para>
      </param>
      <param name="eps">
        <para>The allowed distance from the point to the path that is considered a hit.</para>
      </param>
      <returns>
        <para>Whether the point hits the path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CropAfter(yWorks.Geometry.GeneralPath.PathCursor)">
      <summary>
        <para>Crops the path after the position indicated by the cursor.</para>
      </summary>
      <remarks>
        <para>This will remove all path operations that follow the position indicated by the cursor.</para>
      </remarks>
      <param name="cursor">
        <para>The cursor that depicts a position in this path.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Compress">
      <summary>
        <para>Compresses the internal data structures so that the amount of memory used by this instance is minimal with respect to the information stored in it.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CropBefore(yWorks.Geometry.GeneralPath.PathCursor)">
      <summary>
        <para>Crops the path before the position indicated by the cursor.</para>
      </summary>
      <remarks>
        <para>This will remove all path operations that precede the position indicated by the cursor.</para>
      </remarks>
      <param name="cursor">
        <para>The cursor that depicts a position in this path.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Intersects(yWorks.Geometry.RectD,System.Double)">
      <summary>
        <para>Checks whether this path intersects the given rectangle.</para>
      </summary>
      <remarks>
        <para>This will yield false if the rectangle is fully contained within the area of the path.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to test.</para>
      </param>
      <param name="eps">
        <para>The epsilon to use for fuzzy testing.</para>
      </param>
      <returns>
        <para>Whether the path described by this instance intersects the rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.MayIntersectClip(yWorks.Geometry.RectD,System.Double)">
      <summary>
        <para>Performs a quick test to decide whether this path might intersect the clipping rectangle, provided the path would be painted using stroke of the given width.</para>
      </summary>
      <remarks>
        <para>This method will return false if the clip is entirely inside the area of this path.</para>
      </remarks>
      <param name="clip">
        <para>The clip to check for intersection.</para>
      </param>
      <param name="width">
        <para>The width of the stroke.</para>
      </param>
      <returns>
        <para>
          <c>false</c> if it is guaranteed that this instance would not intersect the given clip.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CreateGeneralPath(System.Drawing.Drawing2D.Matrix)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Geometry.GeneralPath" /> that is a copy of this path with all geometry transformed using the supplied matrix.</para>
      </summary>
      <param name="transform">
        <para>The matrix to multiply the geometry with.</para>
      </param>
      <returns>
        <para>A new path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CreateGeneralPath(yWorks.Geometry.Matrix2D)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Geometry.GeneralPath" /> that is a copy of this path with all geometry transformed using the supplied matrix.</para>
      </summary>
      <param name="transform">
        <para>The matrix to multiply the geometry with.</para>
      </param>
      <returns>
        <para>A new path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Transform(yWorks.Geometry.Matrix2D)">
      <summary>
        <para>Transforms this <see cref="T:yWorks.Geometry.GeneralPath" /> in place using the given transform.</para>
      </summary>
      <param name="transform">
        <para>The matrix to multiply the geometry with.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.AppendEllipse(yWorks.Geometry.IRectangle,System.Boolean)">
      <summary>
        <para>Appends an ellipse using the given bounding box to this instance.</para>
      </summary>
      <param name="bounds">
        <para>The bounds of the ellipse.</para>
      </param>
      <param name="connect">
        <para>Whether to initially <see cref="M:yWorks.Geometry.GeneralPath.LineTo(yWorks.Geometry.IPoint)" /> the ellipses lowest point.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.Clone">
      <summary>
        <para>Creates a clone of this instance, copying the path information to the new instance.</para>
      </summary>
      <returns>
        <para>An exact clone of this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeneralPath.CreateSmoothedPath(System.Double)">
      <summary>
        <para>Creates a new path based on this one where corners are smoothed with a quadratic Bézier arc starting at <paramref name="smoothingLength" /> away from the corner.</para>
      </summary>
      <param name="smoothingLength">
        <para>Distance from the corner where the arc begins.</para>
      </param>
      <returns>
        <para>A new path, with its corners smoothed.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.GridVisualCreator">
      <summary>
        <para>Renders a grid using various different <see cref="P:yWorks.Controls.GridVisualCreator.GridStyle">styles</see>.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.GridInfo" />
      <seealso cref="P:yWorks.Controls.GridVisualCreator.GridStyle" />
    </member>
    <member name="P:yWorks.Controls.GridVisualCreator.GridStyle">
      <summary>
        <para>Gets or sets the grid style that this implementation uses.</para>
      </summary>
      <value>
        <para>The grid style.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.GridVisualCreator.GridInfo">
      <summary>
        <para>Gets or sets the grid info that describes the geometry of the grid.</para>
      </summary>
      <value>
        <para>The grid info.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.GridVisualCreator.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.GridVisualCreator" /> class.</para>
      </summary>
      <remarks>
        <para>The spacing is initialized to 25 units.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GridVisualCreator.#ctor(System.Double,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.GridVisualCreator" /> class.</para>
      </summary>
      <remarks>
        <para>This initializes the <see cref="P:yWorks.Controls.GridVisualCreator.GridInfo" /> field using the given values.</para>
      </remarks>
      <param name="horizontalSpacing">
        <para>The x spacing.</para>
      </param>
      <param name="verticalSpacing">
        <para>The y spacing.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GridVisualCreator.#ctor(yWorks.Controls.GridInfo)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.GridVisualCreator" /> class.</para>
      </summary>
      <param name="gridInfo">
        <para>The grid info.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.GridVisualCreator.Visible">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Controls.GridVisualCreator" /> is visible.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if visible; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.GridVisualCreator.Pen">
      <summary>
        <para>Gets or sets the pen to use for painting the grid points.</para>
      </summary>
      <remarks>
        <para>If <see cref="P:yWorks.Controls.GridVisualCreator.GridStyle" /> is either <see cref="F:yWorks.Controls.GridStyle.Crosses" /> or <see cref="F:yWorks.Controls.GridStyle.Lines" />, this pen will be used for the main grid lines (i.e. those using even grid coordinates). Default value is <see cref="P:System.Drawing.Pens.Black" />.</para>
      </remarks>
      <value>
        <para>The pen.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.GridVisualCreator.AlternatePen">
      <summary>
        <para>Gets or sets the pen to use for painting the alternate grid lines or crosses.</para>
      </summary>
      <remarks>
        <para>This property is only used if <see cref="P:yWorks.Controls.GridVisualCreator.GridStyle" /> is either <see cref="F:yWorks.Controls.GridStyle.Crosses" /> or <see cref="F:yWorks.Controls.GridStyle.Lines" />. In this case, this pen will be used for the alternate grid lines (i.e. those using odd grid coordinates). Default value is <see cref="P:System.Drawing.Pens.LightGray" />.</para>
      </remarks>
      <value>
        <para>The pen.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.GridVisualCreator.VisibilityThreshold">
      <summary>
        <para>Gets or sets the visibility threshold.</para>
      </summary>
      <remarks>
        <para>This indicates the minimum distance in the view coordinate system between two grid points. If the distance becomes smaller, the grid will not be rendered.</para>
      </remarks>
      <value>
        <para>The visibility threshold.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.GridVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.GridVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="T:yWorks.Controls.GridStyle">
      <summary>
        <para>The different possible styles supported by <see cref="T:yWorks.Controls.GridVisualCreator" />'s <see cref="T:yWorks.Controls.GridStyle" /> property.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.GridStyle.Dots">
      <summary>
        <para>For each grid point, there is a small dot rendered.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.GridStyle.Crosses">
      <summary>
        <para>For each grid point, there is a small cross rendered.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.GridStyle.Lines">
      <summary>
        <para>Draws horizontal and vertical lines through the grid points.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.IBoundsProvider">
      <summary>
        <para>Interface that is implemented for elements that can provide painting bounds in the world coordinate system.</para>
      </summary>
      <remarks>
        <para>This information can be used by the rendering engine to increase rendering performance significantly.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.CanvasControl" />
      <seealso cref="T:yWorks.Controls.ICanvasObjectDescriptor" />
      <seealso cref="T:yWorks.Controls.ICanvasObject" />
      <seealso cref="T:yWorks.Controls.BoundsProviders" />
    </member>
    <member name="M:yWorks.Controls.IBoundsProvider.GetBounds(yWorks.Controls.ICanvasContext)">
      <summary>
        <para>Returns a tight rectangular area where the whole rendering would fit into.</para>
      </summary>
      <remarks>
        <para>If calculating the bounds is too expensive or the painting is not bound to a certain area, this method may return <see cref="F:yWorks.Geometry.RectD.Infinite" />. If nothing is painted, this method should return an empty rectangle, where either or both the width and height is non-positive or <see cref="F:yWorks.Geometry.RectD.Empty" />.</para>
      </remarks>
      <param name="context">
        <para>the context to calculate the bounds for</para>
      </param>
      <returns>
        <para>the bounds or <see cref="F:yWorks.Geometry.RectD.Empty" /> to indicate an unbound area</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.IVisibilityTestable">
      <summary>
        <para>Interface that is implemented for elements that can determine whether they might be visible in a given clipping rectangle.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.CanvasControl" />
      <seealso cref="T:yWorks.Controls.ICanvasObjectDescriptor" />
      <seealso cref="T:yWorks.Controls.ICanvasObject" />
      <seealso cref="T:yWorks.Controls.VisibilityTestables" />
    </member>
    <member name="M:yWorks.Controls.IVisibilityTestable.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Determines whether an element might intersect the visible region for a given context.</para>
      </summary>
      <remarks>
        <para>Conservative implementations can always return <c>true</c>.</para>
      </remarks>
      <param name="context">
        <para>The context to determine the visibility for.</para>
      </param>
      <param name="rectangle">
        <para>The visible region clip.</para>
      </param>
      <returns>
        <para>
          <c>false</c> if and only if it is safe not to paint the element because it would not affect the given clipping region.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.IHitTestable">
      <summary>
        <para>Interface that is implemented for elements that can be hit or picked in a coordinate system.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.CanvasControl" />
      <seealso cref="T:yWorks.Controls.ICanvasObjectDescriptor" />
      <seealso cref="T:yWorks.Controls.ICanvasObject" />
    </member>
    <member name="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Determines if something has been hit at the given coordinates in the world coordinate system.</para>
      </summary>
      <remarks>
        <para>Implementations should inspect the <see cref="P:yWorks.Controls.ICanvasContext.HitTestRadius" /> and take the value into account when performing hit tests. This allows the user to hit elements even if the zoom level is very small and allows for accurate hit tests at greater zoom levels.</para>
      </remarks>
      <param name="context">
        <para>the context the hit test is performed in</para>
      </param>
      <param name="location">
        <para>the coordinates in world coordinate system</para>
      </param>
      <returns>
        <para>whether something has been hit</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.IMarqueeTestable">
      <summary>
        <para>Interface that is used to test whether a rendered item is deemed to be inside a rectangular marquee selection.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.IMarqueeTestable.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>This callback returns <c>true</c> if the corresponding item is considered to intersect the given rectangular box.</para>
      </summary>
      <remarks>
        <para>This method may return <c>false</c> if the item cannot be selected using a selection marquee or optionally if the item is only partially contained within the box.</para>
        <para>Implementations should respect the <see cref="P:yWorks.Controls.ICanvasContext.HitTestRadius" /> if marquee selections should behave differently on different zoom levels.</para>
      </remarks>
      <param name="context">
        <para>the current input mode context</para>
      </param>
      <param name="rectangle">
        <para>the box describing the marquee's bounds</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the item is considered to be captured by the marquee</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.MarqueeTestables">
      <summary>
        <para>A utility class that provides two simple <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> implementations.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.MarqueeTestables.Always" />
      <seealso cref="F:yWorks.Controls.Input.MarqueeTestables.Never" />
    </member>
    <member name="F:yWorks.Controls.Input.MarqueeTestables.Always">
      <summary>
        <para>An implementation that always yields <c>true</c>.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MarqueeTestables.Never">
      <summary>
        <para>An implementation that always yields <c>false</c>.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.IRenderContext">
      <summary>
        <para>Describes the current context for rendering routines.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.IVisualCreator" />
      <seealso cref="T:yWorks.Controls.IVisual" />
    </member>
    <member name="P:yWorks.Controls.IRenderContext.Graphics">
      <summary>
        <para>Gets the current graphics context.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.IRenderContext.Clip">
      <summary>
        <para>Gets the clipping rectangle in world coordinates.</para>
      </summary>
      <remarks>
        <para>Painting outside of this clip may be skipped altogether.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.IRenderContext.ViewTransform">
      <summary>
        <para>A transform that can be applied to the graphics context in order to paint in the view coordinate system.</para>
      </summary>
      <remarks>
        <para>Setting the <see cref="P:System.Drawing.Graphics.Transform" /> property to this property will make the graphics context paint in the view coordinate system.</para>
      </remarks>
      <value>
        <para>The transform to display elements in the view coordinate system.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.IRenderContext.WorldTransform">
      <summary>
        <para>The transform that can be applied to the graphics context in order to paint into the world coordinate system.</para>
      </summary>
      <remarks>
        <para>Setting the <see cref="P:System.Drawing.Graphics.Transform" /> property to this property will make the graphics context paint in the world coordinate system.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.IRenderContext.Transform">
      <summary>
        <para>The transform that is used to convert between the <see cref="P:yWorks.Controls.IRenderContext.ViewTransform" /> and the resulting <see cref="P:yWorks.Controls.IRenderContext.WorldTransform" />.</para>
      </summary>
      <remarks>
        <para>Coordinates transformed using this matrix can be drawn into a graphics context that has the <see cref="P:yWorks.Controls.IRenderContext.ViewTransform" /> applied but appear to be drawn into the <see cref="P:yWorks.Controls.IRenderContext.WorldTransform">world coordinate system.</see> <c>ViewTransform * Transform = WorldTransform</c></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.IRenderContext.ToViewCoordinates(yWorks.Geometry.PointD,System.Boolean)" />
    </member>
    <member name="M:yWorks.Controls.IRenderContext.ToViewCoordinates(yWorks.Geometry.PointD,System.Boolean)">
      <summary>
        <para>Converts the given set of world coordinates to a coordinate pair that can be used to paint within the <see cref="P:yWorks.Controls.IRenderContext.ViewTransform" />.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.IRenderContext.ViewTransform" />
      <param name="worldPoint">
        <para>The coordinates in the world coordinate system.</para>
      </param>
      <param name="roundToPixels">
        <para>A value indicating whether the result should be rounded to integral display pixel values.</para>
      </param>
      <returns>
        <para>The coordinates in the view coordinate system.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.IVisualCreator">
      <summary>
        <para>Factory interface which is used by implementations that know how to create <see cref="T:yWorks.Controls.IVisual" />s for rendering into a given <see cref="T:yWorks.Controls.IRenderContext" />.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.CanvasControl" />
      <seealso cref="T:yWorks.Controls.ICanvasObjectDescriptor" />
      <seealso cref="T:yWorks.Controls.ICanvasObject" />
    </member>
    <member name="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)">
      <summary>
        <para>This method is called by the framework to create a <see cref="T:yWorks.Controls.IVisual" /> that will be included into the <see cref="T:yWorks.Controls.IRenderContext" />.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Controls.CanvasControl" /> uses this interface through the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> to populate the visual canvas object tree.</para>
      </remarks>
      <param name="context">
        <para>The context that describes where the visual will be used.</para>
      </param>
      <returns>
        <para>The visual to include in the canvas object visual tree. This may be <c>null</c>.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <summary>
        <para>This method updates or replaces a previously created <see cref="T:yWorks.Controls.IVisual" /> for inclusion in the <see cref="T:yWorks.Controls.IRenderContext" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Controls.CanvasControl" /> uses this method to give implementations a chance to update an existing <see cref="T:yWorks.Controls.IVisual" /> that has previously been created by the same instance during a call to <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" />. Implementation may update the <paramref name="oldVisual" /> and return that same reference, or create a new visual and return the new instance or <c>null</c>.</para>
      </remarks>
      <param name="context">
        <para>The context that describes where the visual will be used in.</para>
      </param>
      <param name="oldVisual">
        <para>The visual instance that had been returned the last time the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> method was called on this instance.</para>
      </param>
      <returns>
        <para>
          <paramref name="oldVisual" />, if this instance modified the visual, or a new visual that should replace the existing one in the canvas object visual tree.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="T:yWorks.Controls.ICanvasObjectDescriptor" />
      <seealso cref="T:yWorks.Controls.CanvasControl" />
    </member>
    <member name="T:yWorks.Controls.VoidVisualCreator">
      <summary>
        <para>A void/null implementation of the <see cref="T:yWorks.Controls.IVisualCreator" /> interface that does nothing.</para>
      </summary>
      <remarks>
        <para>Use <see cref="F:yWorks.Controls.VoidVisualCreator.Instance" /> for methods that require non-<c>null</c> <see cref="T:yWorks.Controls.IVisualCreator" /> implementations if you want to have no visualization.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.VoidVisualCreator.Instance">
      <summary>
        <para>An immutable and shareable convenience instance of the <see cref="T:yWorks.Controls.VoidVisualCreator" /> class.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.VoidVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Returns <c>null</c>.</para>
      </summary>
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.VoidVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <summary>
        <para>Returns <c>null</c>.</para>
      </summary>
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="T:yWorks.Controls.IVisual">
      <summary>
        <para>Simple interface which is used by implementations that know how to render something into a given <see cref="T:System.Drawing.Graphics" /> context using a specific <see cref="T:yWorks.Controls.IRenderContext" />.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.CanvasControl" />
      <seealso cref="T:yWorks.Controls.ICanvasObjectDescriptor" />
      <seealso cref="T:yWorks.Controls.ICanvasObject" />
    </member>
    <member name="M:yWorks.Controls.IVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <summary>
        <para>Performs the actual painting into the given graphics context.</para>
      </summary>
      <remarks>
        <para>Implementations may not leave the state of the graphics context altered, specifically they must revert all changes applied to the graphics context's transform.</para>
      </remarks>
      <param name="g">
        <para>The context to paint into.</para>
      </param>
      <param name="context">
        <para>The render context that can be used to obtain information about the coordinate systems.</para>
      </param>
    </member>
    <member name="T:yWorks.Markup.Common.GeneralPathExtension" />
    <member name="M:yWorks.Markup.Common.GeneralPathExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.GeneralPathExtension.#ctor(yWorks.Geometry.GeneralPath)">
      <param name="path" />
    </member>
    <member name="M:yWorks.Markup.Common.GeneralPathExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="M:yWorks.Markup.Common.GeneralPathExtension.AddChild(System.Object)">
      <summary>
        <para>Adds a child object.</para>
      </summary>
      <param name="value">
        <para>The child object to add.</para>
      </param>
    </member>
    <member name="P:yWorks.Markup.Common.GeneralPathExtension.Items">
      <summary>
        <para>Gets the items that make up the <see cref="T:yWorks.Geometry.GeneralPath" /></para>
      </summary>
      <seealso cref="T:yWorks.Markup.Common.MoveTo" />
      <seealso cref="T:yWorks.Markup.Common.LineTo" />
      <seealso cref="T:yWorks.Markup.Common.Close" />
      <seealso cref="T:yWorks.Markup.Common.QuadTo" />
      <seealso cref="T:yWorks.Markup.Common.CubicTo" />
    </member>
    <member name="M:yWorks.Markup.Common.GeneralPathExtension.AddText(System.String)">
      <summary>
        <para>Adds the text content of a node to the object.</para>
      </summary>
      <remarks>
        <para>This implementation does nothing</para>
      </remarks>
      <param name="text">
        <para>The text to add to the object.</para>
      </param>
    </member>
    <member name="T:yWorks.Markup.Common.MoveTo" />
    <member name="M:yWorks.Markup.Common.MoveTo.#ctor" />
    <member name="P:yWorks.Markup.Common.MoveTo.Point" />
    <member name="T:yWorks.Markup.Common.LineTo" />
    <member name="M:yWorks.Markup.Common.LineTo.#ctor" />
    <member name="P:yWorks.Markup.Common.LineTo.Point" />
    <member name="T:yWorks.Markup.Common.CubicTo" />
    <member name="M:yWorks.Markup.Common.CubicTo.#ctor" />
    <member name="P:yWorks.Markup.Common.CubicTo.Point" />
    <member name="P:yWorks.Markup.Common.CubicTo.ControlPoint2" />
    <member name="P:yWorks.Markup.Common.CubicTo.ControlPoint1" />
    <member name="T:yWorks.Markup.Common.QuadTo" />
    <member name="M:yWorks.Markup.Common.QuadTo.#ctor" />
    <member name="P:yWorks.Markup.Common.QuadTo.Point" />
    <member name="P:yWorks.Markup.Common.QuadTo.ControlPoint" />
    <member name="T:yWorks.Markup.Common.Close" />
    <member name="T:yWorks.Controls.OrientedRectangleIndicatorInstaller">
      <summary>
        <para>An abstract base class for the <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" />, <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> and <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> implementations that draws an oriented rectangle using a <see cref="P:yWorks.Controls.OrientedRectangleIndicatorInstaller.Template" />.</para>
      </summary>
      <remarks>
        <para>In the <see cref="M:yWorks.Controls.ICanvasObjectInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)" /> method, this implementation will add either a fixed <see cref="T:yWorks.Geometry.IOrientedRectangle" /> instance that is passed in the constructor as a parameter or the return value of the method <see cref="M:yWorks.Controls.OrientedRectangleIndicatorInstaller.GetRectangle(System.Object)" /> if the former does not exist (i.e. the parameterless constructor was used to instantiate this class).</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.OrientedRectangleIndicatorInstaller.SelectionTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> for drawing the selection indicator.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.OrientedRectangleIndicatorInstaller.FocusTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> for drawing the focus indicator.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.OrientedRectangleIndicatorInstaller.HighlightTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> for drawing the highlight indicator.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.OrientedRectangleIndicatorInstaller.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.OrientedRectangleIndicatorInstaller" /> class without fixed bounds.</para>
      </summary>
      <remarks>
        <para>The object that is created through this constructor relies on the value returned by the <see cref="M:yWorks.Controls.OrientedRectangleIndicatorInstaller.GetRectangle(System.Object)" /> method to <see cref="M:yWorks.Controls.ICanvasObjectGroup.AddChild(System.Object,yWorks.Controls.ICanvasObjectDescriptor)">add</see> to the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> in the <see cref="M:yWorks.Controls.ICanvasObjectInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)" /> method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.OrientedRectangleIndicatorInstaller.#ctor(yWorks.Geometry.IOrientedRectangle,yWorks.Controls.ResourceKey)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.OrientedRectangleIndicatorInstaller" /> class with fixed bounds and a <see cref="T:yWorks.Controls.ResourceKey" />.</para>
      </summary>
      <remarks>
        <para>The given <see cref="T:yWorks.Geometry.IOrientedRectangle" /> is used for all items as object that is added to the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> in the <see cref="M:yWorks.Controls.ICanvasObjectInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)" /> method.</para>
        <para>If the <see cref="P:yWorks.Controls.OrientedRectangleIndicatorInstaller.Template" /> property is not set, the <paramref name="templateKey" /> is used to lookup a <see cref="T:yWorks.Controls.TemplateVisual" /> in the resources of the <see cref="T:yWorks.Controls.CanvasControl" />. If there is none, a default templated is used.</para>
      </remarks>
      <param name="fixedBounds" />
      <param name="templateKey" />
    </member>
    <member name="M:yWorks.Controls.OrientedRectangleIndicatorInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">
      <param name="context" />
      <param name="group" />
      <param name="item" />
    </member>
    <member name="P:yWorks.Controls.OrientedRectangleIndicatorInstaller.Template">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.TemplateVisual" /> to use for this indicator.</para>
      </summary>
      <remarks>
        <para>If this property is not set, the <see cref="T:yWorks.Controls.ResourceKey" /> passed in the constructor is used to lookup a <see cref="T:yWorks.Controls.TemplateVisual" /> in the resources of the <see cref="T:yWorks.Controls.CanvasControl" />. If there is none, a default templated is used.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.OrientedRectangleIndicatorInstaller.GetRectangle(System.Object)">
      <summary>
        <para>Factory method that returns an <see cref="T:yWorks.Geometry.IOrientedRectangle" /> for a given user object.</para>
      </summary>
      <remarks>
        <para>This method is called for the object to <see cref="M:yWorks.Controls.ICanvasObjectGroup.AddChild(System.Object,yWorks.Controls.ICanvasObjectDescriptor)">add</see> to the <see cref="T:yWorks.Controls.ICanvasObjectGroup" />, if there are no fixed bounds set on this instance (i.e. the parameterless constructor was used to instantiate this class).</para>
        <para>This implementation returns null for every given object.</para>
      </remarks>
      <returns>
        <para>An <see cref="T:yWorks.Geometry.IOrientedRectangle" /> for the given item that is <see cref="M:yWorks.Controls.ICanvasObjectGroup.AddChild(System.Object,yWorks.Controls.ICanvasObjectDescriptor)">added</see> to the <see cref="T:yWorks.Controls.ICanvasObjectGroup" />.</para>
      </returns>
      <param name="item" />
    </member>
    <member name="T:yWorks.Controls.PointSelectionIndicatorInstaller">
      <summary>
        <para>A simple <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> implementation that draws an ellipse centered at a given point in world coordinate space.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.PointSelectionIndicatorInstaller.#ctor(yWorks.Geometry.IPoint)">
      <summary>
        <para>Creates a selection paintable that indicates a point.</para>
      </summary>
      <param name="point">
        <para>The point to use for the center of the painting.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.PointSelectionIndicatorInstaller.Pen">
      <summary>
        <para>Gets or sets the <see cref="T:System.Drawing.Pen" /> to use for drawing the point in the view coordinate system.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.PointSelectionIndicatorInstaller.Brush">
      <summary>
        <para>Gets or sets the <see cref="T:System.Drawing.Brush" /> to use for filling the point's ellipse in the view coordinate system.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.PointSelectionIndicatorInstaller.GetCenterPoint(System.Object)">
      <summary>
        <para>Factory method that retrieves the center for a given user object.</para>
      </summary>
      <remarks>
        <para>This implementation simply returns the value provided to the constructor.</para>
      </remarks>
      <param name="userObject" />
    </member>
    <member name="M:yWorks.Controls.PointSelectionIndicatorInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">
      <param name="context" />
      <param name="group" />
      <param name="item" />
    </member>
    <member name="T:yWorks.Controls.Input.RectangleHandle">
      <summary>
        <para>A more sophisticated <see cref="T:yWorks.Controls.Input.IHandle" /> implementation that modifies a rectangle.</para>
      </summary>
      <remarks>
        <para>Implementations of this class work on a mutable rectangle instance for handling drags of the handle. A separate point implementation is used for specifying the position of the handle. As a convenience this class also implements the <see cref="T:yWorks.Geometry.IMutablePoint" /> interface which modifies the handle's position.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.RectangleHandle.Position">
      <summary>
        <para>Gets the position of the handle.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.RectangleHandle.Rectangle">
      <summary>
        <para>Gets the rectangle instance to modify.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.RectangleHandle.MinimumSize">
      <summary>
        <para>Gets or sets the minimum size allowed for the reshapeable.</para>
      </summary>
      <remarks>
        <para>The value is stored by reference. The default is <see cref="F:yWorks.Geometry.SizeD.Zero" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.RectangleHandle.MinimumEnclosedArea">
      <summary>
        <para>Gets or sets the minimum enclosed area that needs to be encompassed by this reshapeable.</para>
      </summary>
      <remarks>
        <para>The value is stored by reference. The default is <see cref="F:yWorks.Geometry.SizeD.Zero" />, which does not restrict the area at all.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.RectangleHandle.MaximumSize">
      <summary>
        <para>Gets or sets the maximum size allowed for the reshapeable.</para>
      </summary>
      <remarks>
        <para>The value is stored by reference. The default is <see cref="F:yWorks.Geometry.SizeD.Infinite" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.RectangleHandle.#ctor(yWorks.Controls.Input.HandlePositions,yWorks.Geometry.IMutableRectangle)">
      <summary>
        <para>Subclass constructor that creates a handle for the given position using the location instance as the <see cref="P:yWorks.Controls.Input.IDragHandler.Location" /> for the handle.</para>
      </summary>
      <remarks>
        <para>The instance modifies the instances using the reshapeable interface and reads the current state using the rect. The handle will automatically trim changes of the rectangle to the specified minimum and maximum size.</para>
      </remarks>
      <param name="position">
        <para>The position of the handle.</para>
      </param>
      <param name="rectangle">
        <para>The rectangle to change.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.RectangleHandle.Location">
      <summary>
        <para>Gets a view of the center of the handle.</para>
      </summary>
      <value />
      <remarks>
        <para>The point describes the current world coordinate of the element that can be modified by this handle.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.RectangleHandle.Type">
      <summary>
        <para>Gets or sets the type of the handle that can be used by the rendering engine to render types differently.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.RectangleHandle.Cursor">
      <summary>
        <para>Gets or sets the cursor to display when the mouse hovers over or drags this handle.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.RectangleHandle.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>This implementation does nothing.</para>
      </summary>
      <param name="context" />
    </member>
    <member name="P:yWorks.Controls.Input.RectangleHandle.X">
      <summary>
        <para>Gets or sets the x coordinate.</para>
      </summary>
      <remarks>
        <para>The setter delegates to <see cref="M:yWorks.Controls.Input.RectangleHandle.MoveBy(yWorks.Geometry.PointD)" /></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.RectangleHandle.Y">
      <summary>
        <para>Gets or sets the y coordinate.</para>
      </summary>
      <remarks>
        <para>The setter delegates to <see cref="M:yWorks.Controls.Input.RectangleHandle.MoveBy(yWorks.Geometry.PointD)" /></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.RectangleHandle.MoveBy(yWorks.Geometry.PointD)">
      <summary>
        <para>Delegates the work to the reshapeable.</para>
      </summary>
      <param name="delta" />
    </member>
    <member name="M:yWorks.Controls.Input.RectangleHandle.Set(System.Double,System.Double)">
      <summary>
        <para>Delegates to <see cref="M:yWorks.Controls.Input.RectangleHandle.MoveBy(yWorks.Geometry.PointD)" />.</para>
      </summary>
      <param name="x" />
      <param name="y" />
    </member>
    <member name="M:yWorks.Controls.Input.RectangleHandle.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Delegates to <see cref="M:yWorks.Controls.Input.RectangleHandle.Set(System.Double,System.Double)" />.</para>
      </summary>
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.RectangleHandle.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Delegates the original values to <see cref="M:yWorks.Controls.Input.RectangleHandle.Set(System.Double,System.Double)" /></para>
      </summary>
      <param name="context" />
      <param name="originalLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.RectangleHandle.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>This implementation does nothing.</para>
      </summary>
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="T:yWorks.Controls.RectangleIndicatorInstaller">
      <summary>
        <para>A basis implementation of <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" />, <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> and <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> that draws a rectangle using a <see cref="P:yWorks.Controls.RectangleIndicatorInstaller.Template" />.</para>
      </summary>
      <remarks>
        <para>In the <see cref="M:yWorks.Controls.ICanvasObjectInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)" /> method, this implementation will add either a fixed <see cref="T:yWorks.Geometry.IRectangle" /> instance that is passed in the constructor as a parameter or the return value of the method <see cref="M:yWorks.Controls.RectangleIndicatorInstaller.GetRectangle(System.Object)" /> if the former does not exist (i.e. the parameterless constructor was used to instantiate this class).</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.RectangleIndicatorInstaller.SelectionTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> for drawing the selection indicator.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.RectangleIndicatorInstaller.FocusTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> for drawing the focus indicator.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.RectangleIndicatorInstaller.HighlightTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> for drawing the highlight indicator.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.RectangleIndicatorInstaller.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.RectangleIndicatorInstaller" /> class without fixed bounds.</para>
      </summary>
      <remarks>
        <para>The object that is created through this constructor relies on the value returned by the <see cref="M:yWorks.Controls.RectangleIndicatorInstaller.GetRectangle(System.Object)" /> method to <see cref="M:yWorks.Controls.ICanvasObjectGroup.AddChild(System.Object,yWorks.Controls.ICanvasObjectDescriptor)">add</see> to the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> in the <see cref="M:yWorks.Controls.ICanvasObjectInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)" /> method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.RectangleIndicatorInstaller.#ctor(yWorks.Geometry.IRectangle,yWorks.Controls.ResourceKey)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.RectangleIndicatorInstaller" /> class with fixed bounds and a <see cref="T:yWorks.Controls.ResourceKey" />.</para>
      </summary>
      <remarks>
        <para>The given <see cref="T:yWorks.Geometry.IOrientedRectangle" /> is used for all items as object that is added to the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> in the <see cref="M:yWorks.Controls.ICanvasObjectInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)" /> method.</para>
        <para>If the <see cref="P:yWorks.Controls.RectangleIndicatorInstaller.Template" /> property is not set, the <paramref name="resourceKey" /> is used to lookup a <see cref="T:yWorks.Controls.TemplateVisual" /> in the resources of the <see cref="T:yWorks.Controls.CanvasControl" />. If there is none, a default templated is used.</para>
      </remarks>
      <param name="fixedBounds" />
      <param name="resourceKey" />
    </member>
    <member name="P:yWorks.Controls.RectangleIndicatorInstaller.Template">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.TemplateVisual" /> to use for this indicator.</para>
      </summary>
      <remarks>
        <para>If this property is not set, the <see cref="T:yWorks.Controls.ResourceKey" /> passed in the constructor is used to lookup a <see cref="T:yWorks.Controls.TemplateVisual" /> in the resources of the <see cref="T:yWorks.Controls.CanvasControl" />. If there is none, a default templated is used.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.RectangleIndicatorInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">
      <param name="context" />
      <param name="group" />
      <param name="item" />
    </member>
    <member name="M:yWorks.Controls.RectangleIndicatorInstaller.GetRectangle(System.Object)">
      <summary>
        <para>Factory method that returns an <see cref="T:yWorks.Geometry.IRectangle" /> for a given user object.</para>
      </summary>
      <remarks>
        <para>This method is called for the object to <see cref="M:yWorks.Controls.ICanvasObjectGroup.AddChild(System.Object,yWorks.Controls.ICanvasObjectDescriptor)">add</see> to the <see cref="T:yWorks.Controls.ICanvasObjectGroup" />, if there are no fixed bounds set on this instance (i.e. the parameterless constructor was used to instantiate this class).</para>
        <para>This implementation returns null for every given object.</para>
      </remarks>
      <returns>
        <para>An <see cref="T:yWorks.Geometry.IRectangle" /> for the given item that is <see cref="M:yWorks.Controls.ICanvasObjectGroup.AddChild(System.Object,yWorks.Controls.ICanvasObjectDescriptor)">added</see> to the <see cref="T:yWorks.Controls.ICanvasObjectGroup" />.</para>
      </returns>
      <param name="userObject" />
    </member>
    <member name="T:yWorks.Controls.Input.ReshapeHandlerHandle">
      <summary>
        <para>A more sophisticated <see cref="T:yWorks.Controls.Input.IHandle" /> implementation that delegates to a <see cref="T:yWorks.Controls.Input.IReshapeHandler" />.</para>
      </summary>
      <remarks>
        <para>This class works on an <see cref="T:yWorks.Controls.Input.IReshapeHandler" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandlerHandle.ReshapeHandler">
      <summary>
        <para>Gets the reshapeable instance to write the changes to.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandlerHandle.MinimumSize">
      <summary>
        <para>Gets or sets the minimum size allowed for the reshapeable.</para>
      </summary>
      <remarks>
        <para>The value is stored by reference. The default is <see cref="F:yWorks.Geometry.SizeD.Zero" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandlerHandle.MinimumEnclosedArea">
      <summary>
        <para>Gets or sets the minimum enclosed area that needs to be encompassed by this reshapeable.</para>
      </summary>
      <remarks>
        <para>The value is stored by reference. The default is <see cref="F:yWorks.Geometry.SizeD.Zero" />, which does not restrict the area at all.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandlerHandle.MaximumSize">
      <summary>
        <para>Gets or sets the maximum size allowed for the reshapeable.</para>
      </summary>
      <remarks>
        <para>The value is stored by reference. The default is <see cref="F:yWorks.Geometry.SizeD.Infinite" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ReshapeHandlerHandle.#ctor(yWorks.Controls.Input.HandlePositions,yWorks.Controls.Input.IReshapeHandler,yWorks.Geometry.ISize,yWorks.Geometry.ISize)">
      <summary>
        <para>Subclass constructor that creates a handle for the given position using the location instance as the <see cref="P:yWorks.Controls.Input.IDragHandler.Location" /> for the handle.</para>
      </summary>
      <remarks>
        <para>The instance modifies the instances using the reshapeable interface and reads the current state using the rect. The handle will automatically trim changes of the rectangle to the specified minimum and maximum size.</para>
      </remarks>
      <param name="position">
        <para>The position of the handle.</para>
      </param>
      <param name="reshapeHandler">
        <para>The reshapeable to write the changes to.</para>
      </param>
      <param name="maximumSize">
        <para>The maximum size allowed for the rectangle.</para>
      </param>
      <param name="minimumSize">
        <para>The minimum size allowed for the rectangle.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandlerHandle.Location">
      <summary>
        <para>Gets a view of the center of the handle.</para>
      </summary>
      <value />
      <remarks>
        <para>The point describes the current world coordinate of the element that can be modified by this handle.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandlerHandle.Type">
      <summary>
        <para>Gets or sets the type of the handle that can be used by the rendering engine to render types differently.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeHandlerHandle.Cursor">
      <summary>
        <para>Gets or sets the cursor to display when the mouse hovers over or drags this handle.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ReshapeHandlerHandle.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>This implementation does nothing.</para>
      </summary>
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.ReshapeHandlerHandle.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Delegates the move request to the <see cref="M:yWorks.Controls.Input.IReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)" /> method.</para>
      </summary>
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.ReshapeHandlerHandle.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Delegates the cancel request to the <see cref="T:yWorks.Controls.Input.IReshapeHandler" />.</para>
      </summary>
      <param name="context" />
      <param name="originalLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.ReshapeHandlerHandle.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Delegates the finish request to the <see cref="T:yWorks.Controls.Input.IReshapeHandler" />.</para>
      </summary>
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="T:yWorks.Controls.ShapeVisual">
      <summary>
        <para>Base class for a number of <see cref="T:yWorks.Controls.IVisual" /> implementations for simple geometric primitives.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.IVisual" />
      <seealso cref="T:yWorks.Controls.CanvasControl" />
    </member>
    <member name="P:yWorks.Controls.ShapeVisual.Brush">
      <summary>
        <para>Gets or sets the brush for filling the interior of the shape.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ShapeVisual.Pen">
      <summary>
        <para>Gets or sets the pen for drawing the outline of the shape.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ShapeVisual.Transform">
      <summary>
        <para>Gets or sets a transform that is applied to shape.</para>
      </summary>
      <remarks>
        <para>If set to <c>null</c> the current transform is used.</para>
        <para>The transform is applied to the current transform.</para>
      </remarks>
      <value>
        <para>The transform.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.ShapeVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="T:yWorks.Controls.GeneralPathVisual">
      <summary>
        <para>Draws a given path.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.GeneralPathVisual.Path">
      <summary>
        <para>The path to draw.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GeneralPathVisual.#ctor(yWorks.Geometry.GeneralPath)">
      <summary>
        <para>Creates an instance that draws the given <paramref name="path" />.</para>
      </summary>
      <param name="path">
        <para>The path to draw.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GeneralPathVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="T:yWorks.Controls.EllipseVisual">
      <summary>
        <para>Draws an ellipse.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.EllipseVisual.Bounds">
      <summary>
        <para>The rectangular bounds of the ellipse.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.EllipseVisual.#ctor(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Creates an instance that will draw an ellipse inscribed in the given <paramref name="bounds" />.</para>
      </summary>
      <param name="bounds">
        <para>The bounds of the ellipse to draw.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.EllipseVisual.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates an instance that will draw an ellipse with the given center point and radii.</para>
      </summary>
      <param name="cx">
        <para>The x coordinate of the ellipse's center.</para>
      </param>
      <param name="cy">
        <para>The y coordinate of the ellipse's center.</para>
      </param>
      <param name="rx">
        <para>The ellipse's horizontal radius.</para>
      </param>
      <param name="ry">
        <para>The ellipse's vertical radius.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.EllipseVisual.#ctor(System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates an instance that will draw a circle with the given center point and radius.</para>
      </summary>
      <param name="cx">
        <para>The x coordinate of the ellipse's center.</para>
      </param>
      <param name="cy">
        <para>The y coordinate of the ellipse's center.</para>
      </param>
      <param name="r">
        <para>The circle's radius.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.EllipseVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="T:yWorks.Controls.RectangleVisual">
      <summary>
        <para>Draws a rectangle.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.RectangleVisual.#ctor(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Creates an instance that draws the given <paramref name="rectangle" />.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to draw.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.RectangleVisual.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates an instance paints a fixed rectangle using the values.</para>
      </summary>
      <param name="x">
        <para>The x coordinate of the upper left corner of the rectangle.</para>
      </param>
      <param name="y">
        <para>The y coordinate of the upper left corner of the rectangle.</para>
      </param>
      <param name="width">
        <para>The width of the rectangle.</para>
      </param>
      <param name="height">
        <para>The height of the rectangle.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.RectangleVisual.Rectangle">
      <summary>
        <para>Gets or sets the rectangle to draw.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.RectangleVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="T:yWorks.Controls.RoundedRectangleVisual">
      <summary>
        <para>Draws a rectangle with rounded corners.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.RoundedRectangleVisual.Rectangle">
      <summary>
        <para>Gets or sets the rectangle that is drawn with rounded corners defined by <see cref="P:yWorks.Controls.RoundedRectangleVisual.Radius" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.RoundedRectangleVisual.Radius">
      <summary>
        <para>Gets or sets the corner radius of the rounded rectangle.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.RoundedRectangleVisual.#ctor(yWorks.Geometry.IRectangle,System.Double)">
      <summary>
        <para>Creates an instance that draw a rounded rectangle using the given <paramref name="rectangle" /> and <paramref name="radius" />.</para>
      </summary>
      <remarks>
        <para>The arguments are kept by reference and are queried for each operation. Thus changing the values of the arguments after the creation will change the drawing.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to use for the bounds of the rounded rectangle.</para>
      </param>
      <param name="radius">
        <para>The radius of the corner arcs.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.RoundedRectangleVisual.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates an instance that draw a rounded rectangle using the given rectangle bounds and <paramref name="radius" />.</para>
      </summary>
      <remarks>
        <para>The arguments are kept by reference and are queried for each operation. Thus changing the values of the arguments after the creation will change the drawing.</para>
      </remarks>
      <param name="x">
        <para>The x coordinate of the upper left corner of the rectangle.</para>
      </param>
      <param name="y">
        <para>The y coordinate of the upper left corner of the rectangle.</para>
      </param>
      <param name="width">
        <para>The rectangle's width.</para>
      </param>
      <param name="height">
        <para>The rectangle's height.</para>
      </param>
      <param name="radius">
        <para>The radius of the corner arcs.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.RoundedRectangleVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="T:yWorks.Controls.GraphicsPathVisual">
      <summary>
        <para>Draws a <see cref="T:System.Drawing.Drawing2D.GraphicsPath" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.GraphicsPathVisual.Path">
      <summary>
        <para>The path to draw.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphicsPathVisual.#ctor(System.Drawing.Drawing2D.GraphicsPath)">
      <summary>
        <para>Creates an instance that draws the given path.</para>
      </summary>
      <param name="path">
        <para>The path to draw.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphicsPathVisual.#ctor">
      <summary>
        <para>Creates an instance.</para>
      </summary>
      <remarks>
        <para>A <see cref="T:System.Drawing.Drawing2D.GraphicsPath" /> has to be set to the <see cref="P:yWorks.Controls.GraphicsPathVisual.Path" /> property, otherwise nothing is drawn.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphicsPathVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="T:yWorks.Controls.LineVisual">
      <summary>
        <para>Draws a line between the points <see cref="P:yWorks.Controls.LineVisual.P1" /> and <see cref="P:yWorks.Controls.LineVisual.P2" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.LineVisual.P1">
      <summary>
        <para>Gets or sets the first point of the line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.LineVisual.P2">
      <summary>
        <para>Gets or sets the second point of the line.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.LineVisual.#ctor(yWorks.Geometry.IPoint,yWorks.Geometry.IPoint)">
      <summary>
        <para>Creates a new instance which draws a line between the given points.</para>
      </summary>
      <param name="p1">
        <para>First point of the line.</para>
      </param>
      <param name="p2">
        <para>Second point of the line.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.LineVisual.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new instance which draws a line between the given points.</para>
      </summary>
      <param name="x1">
        <para>The x coordinate of the first point of the line.</para>
      </param>
      <param name="y1">
        <para>The y coordinate of the first point of the line.</para>
      </param>
      <param name="x2">
        <para>The x coordinate of the last point of the line.</para>
      </param>
      <param name="y2">
        <para>The y coordinate of the last point of the line.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.LineVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="T:yWorks.Controls.TemplateVisual">
      <summary>
        <para>An abstract <see cref="T:yWorks.Controls.IVisual" /> implementation that can be used to serve as a template for a certain type of rendering.</para>
      </summary>
      <remarks>
        <para>Subclasses need to implement the <see cref="M:yWorks.Controls.TemplateVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)" /> method and adhere at least to the <see cref="P:yWorks.Controls.TemplateVisual.X" /> and <see cref="P:yWorks.Controls.TemplateVisual.Y" /> properties that indicate the origin of the rendering. Depending on the use-case, the <see cref="P:yWorks.Controls.TemplateVisual.Width" /> and <see cref="P:yWorks.Controls.TemplateVisual.Height" /> property may also provide meaningful values, as well as the <see cref="P:yWorks.Controls.TemplateVisual.Content" /> property.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.TemplateVisual.VoidTemplateVisual">
      <summary>
        <para>Gets the void template visual that never displays anything.</para>
      </summary>
      <value>
        <para>The void template visual.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.TemplateVisual.Bounds">
      <summary>
        <para>Gets or sets the bounds of this template.</para>
      </summary>
      <remarks>
        <para>Developers have to take care not to exceed these bounds in their <see cref="M:yWorks.Controls.TemplateVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)" /> method. Otherwise, rendering artifacts are possible.</para>
      </remarks>
      <value>
        <para>The bounds. The values are directly applied to the <see cref="P:yWorks.Controls.TemplateVisual.X" />, <see cref="P:yWorks.Controls.TemplateVisual.Y" />, <see cref="P:yWorks.Controls.TemplateVisual.Width" />, and <see cref="P:yWorks.Controls.TemplateVisual.Height" /> properties.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.TemplateVisual.Location">
      <summary>
        <para>Gets or sets the location for the rendering.</para>
      </summary>
      <value>
        <para>The location, which is the top left point of the <see cref="P:yWorks.Controls.TemplateVisual.Bounds" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.TemplateVisual.Width">
      <summary>
        <para>Gets or sets the width of the rendering.</para>
      </summary>
      <value>
        <para>The width, which is directly mapped to the width of the <see cref="P:yWorks.Controls.TemplateVisual.Bounds" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.TemplateVisual.Height">
      <summary>
        <para>Gets or sets the height of the rendering.</para>
      </summary>
      <value>
        <para>The height, which is directly mapped to the height of the <see cref="P:yWorks.Controls.TemplateVisual.Bounds" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.TemplateVisual.X">
      <summary>
        <para>Gets or sets the x coordinate of the <see cref="P:yWorks.Controls.TemplateVisual.Location" />.</para>
      </summary>
      <value>
        <para>The X coordinate of the location.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.TemplateVisual.Y">
      <summary>
        <para>Gets or sets the y coordinate of the <see cref="P:yWorks.Controls.TemplateVisual.Location" />.</para>
      </summary>
      <value>
        <para>The Y coordinate of the location.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.TemplateVisual.Content">
      <summary>
        <para>Gets or sets the content object that is rendered by this template.</para>
      </summary>
      <value>
        <para>The content object, or <c>null</c>.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.TemplateVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <summary>
        <para>Performs the actual painting into the given graphics context.</para>
      </summary>
      <param name="g">
        <para>the graphics context to paint into</para>
      </param>
      <param name="context">
        <para>the render context</para>
      </param>
      <remarks>
        <para>Implementations may not leave the state of the graphics context altered, specifically they must revert all changes applied to the graphics context's transform.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.TextVisual">
      <summary>
        <para>Provides <see cref="T:yWorks.Controls.IVisual" /> implementations for drawing text. This is an abstract class that provides factory methods that each return a concrete subclass of this.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.IVisual" />
    </member>
    <member name="P:yWorks.Controls.TextVisual.Brush">
      <summary>
        <para>Gets or sets the brush to draw the text with.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.TextVisual.Text">
      <summary>
        <para>Gets or sets the text to draw.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.TextVisual.Font">
      <summary>
        <para>Gets or sets the font to draw the text with.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.TextVisual.Location">
      <summary>
        <para>The location to draw the text at.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.TextVisual.Format">
      <summary>
        <para>The <see cref="T:System.Drawing.StringFormat" /> to use.</para>
      </summary>
      <remarks>
        <para>May be <c>null</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.TextVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="M:yWorks.Controls.TextVisual.GetBounds(yWorks.Controls.ICanvasContext)">
      <param name="context" />
    </member>
    <member name="T:yWorks.Controls.ViewportLimiter">
      <summary>
        <para>Helper class used by <see cref="T:yWorks.Controls.CanvasControl" /> to limit the interactive movement of the viewport.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Controls.CanvasControl.ViewportLimiter" /> instance should be consulted whenever the user tries to change the viewport. Using method <see cref="M:yWorks.Controls.ViewportLimiter.LimitViewport(yWorks.Controls.CanvasControl,yWorks.Geometry.RectD)" /> the desired viewport can be validated by the implementation. Note that setting the <see cref="P:yWorks.Controls.CanvasControl.Zoom" /> property or <see cref="P:yWorks.Controls.CanvasControl.ViewPoint" /> property will not be influenced by implementations of this class. It is up to the caller to perform verification.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.ViewportLimiter.Bounds" />
    </member>
    <member name="M:yWorks.Controls.ViewportLimiter.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.ViewportLimiter" /> class.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ViewportLimiter.LimitViewport(yWorks.Controls.CanvasControl,yWorks.Geometry.RectD)">
      <summary>
        <para>Inspects the desired or suggested new viewport for the given control and returns a valid viewport to use.</para>
      </summary>
      <param name="canvas">
        <para>The canvas control on which the viewport should be applied.</para>
      </param>
      <param name="suggestedViewport">
        <para>The suggested viewport.</para>
      </param>
      <returns>
        <para>The viewport that should be used.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ViewportLimiter.GetCurrentBounds(yWorks.Controls.CanvasControl,yWorks.Geometry.RectD)">
      <summary>
        <para>Gets the to bounds that should be honored for the upcoming call.</para>
      </summary>
      <remarks>
        <para>This method is used as callback by <see cref="M:yWorks.Controls.ViewportLimiter.LimitViewport(yWorks.Controls.CanvasControl,yWorks.Geometry.RectD)" /> for each request. The default implementation just yields <see cref="P:yWorks.Controls.ViewportLimiter.Bounds" />.</para>
      </remarks>
      <param name="canvas">
        <para>The canvas control.</para>
      </param>
      <param name="suggestedViewport">
        <para>The suggested viewport.</para>
      </param>
      <returns>
        <para>The bounds to honor or <c>null</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.ViewportLimiter.HonorBothDimensions">
      <summary>
        <para>Gets or sets a value indicating whether both dimensions of <see cref="P:yWorks.Controls.ViewportLimiter.Bounds" /> need to be honored.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if both dimensions need to be honored, otherwise <c>false</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.ViewportLimiter.Bounds">
      <summary>
        <para>Gets or sets the maximal allowed navigable bounds for the viewport.</para>
      </summary>
      <value>
        <para>The bounds or <c>null</c>. This value will be used by the default implementation of <see cref="M:yWorks.Controls.ViewportLimiter.LimitViewport(yWorks.Controls.CanvasControl,yWorks.Geometry.RectD)" /> to crop the desired viewport to.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.XamlNamespaceConstants">
      <summary>
        <para>Helper class that contains constants that are used in XAML files in conjunction with yFiles.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.YfilesFormsXamlNS">
      <summary>
        <para>The namespace URI that is used by the yFiles XAML extensions.</para>
      </summary>
      <remarks>
        <para>The value is 'http://www.yworks.com/xml/yfiles.net/5.0/forms'</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.YfilesFormsXamlPrefix">
      <summary>
        <para>The preferred namespace prefix for the yFiles XAML extensions.</para>
      </summary>
      <remarks>
        <para>The value is 'yforms'</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.YfilesCommonNS">
      <summary>
        <para>The namespace URI for common yFiles extensions to graphml.</para>
      </summary>
      <remarks>
        <para>This field has the constant value <c>"http://www.yworks.com/xml/yfiles-common/3.0"</c></para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.FormsXamlNS">
      <summary>
        <para>The namespace URI that is used classes of the .net forms framework.</para>
      </summary>
      <remarks>
        <para>The value is 'http://www.yworks.com/xml/yfiles-common/1.0/forms'</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.FormsXamlPrefix">
      <summary>
        <para>The preferred namespace prefix for classes of the .net forms framework.</para>
      </summary>
      <remarks>
        <para>The value is 'forms'</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.YfilesCommonPrefix">
      <summary>
        <para>The default namespace prefix for <see cref="F:yWorks.Controls.XamlNamespaceConstants.YfilesCommonNS" />.</para>
      </summary>
      <remarks>
        <para>This field has the constant value <c>"yfiles"</c></para>
      </remarks>
      <seealso cref="F:yWorks.Controls.XamlNamespaceConstants.YfilesCommonNS" />
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.YfilesPrimitivesMarkupNS">
      <summary>
        <para>The namespace URI for common yFiles extensions to graphml.</para>
      </summary>
      <remarks>
        <para>This field has the constant value <c>"http://www.yworks.com/xml/yfiles-common/markup/primitives/2.0"</c></para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.YfilesPrimitivesMarkupPrefix">
      <summary>
        <para>The default namespace prefix for <see cref="F:yWorks.Controls.XamlNamespaceConstants.YfilesPrimitivesMarkupNS" />.</para>
      </summary>
      <remarks>
        <para>This field has the constant value <c>"sys"</c></para>
      </remarks>
      <seealso cref="F:yWorks.Controls.XamlNamespaceConstants.YfilesCommonNS" />
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.YfilesCommonMarkupNS">
      <summary>
        <para>The namespace URI for common yFiles extensions to graphml.</para>
      </summary>
      <remarks>
        <para>This field has the constant value <c>"http://www.yworks.com/xml/yfiles-common/markup/3.0"</c></para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.YfilesCommonMarkupPrefix">
      <summary>
        <para>The default namespace prefix for <see cref="F:yWorks.Controls.XamlNamespaceConstants.YfilesCommonMarkupNS" />.</para>
      </summary>
      <remarks>
        <para>This field has the constant value <c>"x"</c></para>
      </remarks>
      <seealso cref="F:yWorks.Controls.XamlNamespaceConstants.YfilesCommonMarkupNS" />
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.MsXamlNS">
      <summary>
        <para>The default namespace URI for MS XAML elements that are not WPF specific.</para>
      </summary>
      <remarks>
        <para>This field has the constant value <c>"http://schemas.microsoft.com/winfx/2006/xaml"</c></para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.GraphMLCoreNS">
      <summary>
        <para>The default namespace URI for the GraphML core namespace.</para>
      </summary>
      <remarks>
        <para>This field has the constant value <c>"http://graphml.graphdrawing.org/xmlns"</c></para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.XamlNamespaceConstants.YfilesSchemaLocation">
      <summary>
        <para>The schema location for yFiles.NET enhanced GraphML</para>
      </summary>
      <remarks>
        <para>This field has the constant value <c>"http://www.yworks.com/xml/schema/graphml.net/5.0/ygraphml.xsd"</c></para>
      </remarks>
    </member>
    <member name="T:yWorks.Geometry.SizeD">
      <summary>
        <para>An immutable <see cref="T:yWorks.Geometry.ISize" /> implementation to describe a size in two-dimensional space.</para>
      </summary>
    </member>
    <member name="F:yWorks.Geometry.SizeD.Empty">
      <summary>
        <para>The "empty" size that has <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> set to <c>-1.0d</c>.</para>
      </summary>
    </member>
    <member name="F:yWorks.Geometry.SizeD.Zero">
      <summary>
        <para>The "zero" size that has <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> set to <c>0.0d</c>.</para>
      </summary>
      <remarks>
        <para>This size is not treated as <see cref="P:yWorks.Geometry.SizeD.IsEmpty" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Geometry.SizeD.Infinite">
      <summary>
        <para>The "infinite" size that has <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> set to <see cref="F:System.Double.PositiveInfinity" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.SizeD.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new size using the provided width and height.</para>
      </summary>
      <param name="width">
        <para>The new width.</para>
      </param>
      <param name="height">
        <para>The new height.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.SizeD.#ctor(System.Drawing.SizeF)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.SizeD" /> struct using the values of the provided <see cref="T:System.Drawing.SizeF" />.</para>
      </summary>
      <param name="size">
        <para>The size to get the initial values from.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.SizeD.#ctor(yWorks.Geometry.ISize)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.SizeD" /> struct using the values of the provided <see cref="T:yWorks.Geometry.ISize" />.</para>
      </summary>
      <param name="size">
        <para>The size to get the initial values from.</para>
      </param>
    </member>
    <member name="P:yWorks.Geometry.SizeD.Width">
      <summary>
        <para>Gets the width.</para>
      </summary>
      <remarks>
        <para>Negative values for the width indicate an <see cref="P:yWorks.Geometry.SizeD.IsEmpty">empty</see> size.</para>
      </remarks>
      <value>
        <para>The width.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.SizeD.Height">
      <summary>
        <para>Gets the height.</para>
      </summary>
      <remarks>
        <para>Negative values for the height indicate an <see cref="P:yWorks.Geometry.SizeD.IsEmpty">empty</see> size.</para>
      </remarks>
      <value>
        <para>The height.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.SizeD.Area">
      <summary>
        <para>Gets the area of this instance which is the product of <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" />.</para>
      </summary>
      <value>
        <para>The area.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.SizeD.IsEmpty">
      <summary>
        <para>Gets a value indicating whether this instance is deemed empty.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this at least one of <see cref="P:yWorks.Geometry.SizeD.Width" /> or <see cref="P:yWorks.Geometry.SizeD.Height" /> is negative; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.SizeD.IsFinite">
      <summary>
        <para>Gets a value indicating whether this instance is finite.</para>
      </summary>
      <remarks>
        <para>This means that neither <see cref="P:yWorks.Geometry.SizeD.Width" /> nor <see cref="P:yWorks.Geometry.SizeD.Height" /> are <see cref="M:System.Double.IsInfinity(System.Double)">infinite</see>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this instance is finite; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Geometry.SizeD.ToSize">
      <summary>
        <para>Converts this instance to a <see cref="T:System.Drawing.SizeF" /> instance</para>
      </summary>
      <returns>
        <para>The <see cref="T:System.Drawing.SizeF" /> instance, whose attributes have been initialized with the values of this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.ToMutableSize">
      <summary>
        <para>Converts this instance to an <see cref="T:yWorks.Geometry.MutableSize" /> instance</para>
      </summary>
      <returns>
        <para>The <see cref="T:yWorks.Geometry.MutableSize" /> instance, whose attributes have been initialized with the values of this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.op_Implicit(yWorks.Geometry.SizeD)~System.Drawing.SizeF">
      <summary>
        <para>Performs an implicit conversion from <see cref="T:yWorks.Geometry.SizeD" /> to <see cref="T:System.Drawing.SizeF" />.</para>
      </summary>
      <remarks>
        <para>If the source size <see cref="P:yWorks.Geometry.SizeD.IsEmpty" />, the resulting size will be (0,0).</para>
      </remarks>
      <param name="size">
        <para>The size.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.op_Implicit(System.Drawing.SizeF)~yWorks.Geometry.SizeD">
      <summary>
        <para>Performs an implicit conversion from <see cref="T:System.Drawing.SizeF" /> to <see cref="T:yWorks.Geometry.SizeD" />.</para>
      </summary>
      <param name="size">
        <para>The size.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.op_Implicit(yWorks.Geometry.MutableSize)~yWorks.Geometry.SizeD">
      <summary>
        <para>Performs an implicit conversion from <see cref="T:yWorks.Geometry.MutableSize" /> to <see cref="T:yWorks.Geometry.SizeD" />.</para>
      </summary>
      <param name="size">
        <para>The size.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.op_Explicit(yWorks.Geometry.SizeD)~yWorks.Geometry.MutableSize">
      <summary>
        <para>Performs an explicit conversion from <see cref="T:yWorks.Geometry.SizeD" /> to <see cref="T:yWorks.Geometry.MutableSize" />.</para>
      </summary>
      <param name="size">
        <para>The size.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.op_Equality(yWorks.Geometry.SizeD,yWorks.Geometry.SizeD)">
      <summary>
        <para>Implements the operator ==.</para>
      </summary>
      <param name="size1">
        <para>The first size.</para>
      </param>
      <param name="size2">
        <para>The second size.</para>
      </param>
      <returns>
        <para>The result of the operator, which is <c>true</c> iff the <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> of the two structs are identical.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.op_Multiply(yWorks.Geometry.SizeD,System.Double)">
      <summary>
        <para>Implements the operator * that multiplies the <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> by the given factor.</para>
      </summary>
      <param name="size">
        <para>The size to multiply the width and height of.</para>
      </param>
      <param name="factor">
        <para>The factor to multiply the width and height by.</para>
      </param>
      <returns>
        <para>The result of the operator, which is a new size that has the width and height multiplied by the factor.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.op_Multiply(System.Double,yWorks.Geometry.SizeD)">
      <summary>
        <para>Implements the operator * that multiplies the <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> by the given factor.</para>
      </summary>
      <param name="size">
        <para>The size to multiply the width and height of.</para>
      </param>
      <param name="factor">
        <para>The factor to multiply the width and height by.</para>
      </param>
      <returns>
        <para>The result of the operator, which is a new size that has the width and height multiplied by the factor.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.op_Division(yWorks.Geometry.SizeD,System.Double)">
      <summary>
        <para>Implements the operator / that divides the <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> by the given factor.</para>
      </summary>
      <param name="size">
        <para>The size to divide the width and height of.</para>
      </param>
      <param name="factor">
        <para>The factor to divide the width and height by.</para>
      </param>
      <returns>
        <para>The result of the operator, which is a new size that has the width and height divided by the factor.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.op_Inequality(yWorks.Geometry.SizeD,yWorks.Geometry.SizeD)">
      <summary>
        <para>Implements the operator !=.</para>
      </summary>
      <param name="p1">
        <para>The first size.</para>
      </param>
      <param name="p2">
        <para>The second size.</para>
      </param>
      <returns>
        <para>The result of the operator, which is the inverse of the <c>==</c> operator.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.ToString">
      <summary>
        <para>Returns a human readable string that contains information about the values of this struct.</para>
      </summary>
      <returns>
        <para>A <see cref="T:System.String" /> containing the width and height.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.Equals(yWorks.Geometry.SizeD)">
      <summary>
        <para>Returns whether this instance has the same width and height as the given instance.</para>
      </summary>
      <param name="other">
        <para>The other instance.</para>
      </param>
      <returns>
        <para>Whether they have the same width and height values.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.Equals(System.Object)">
      <param name="other" />
    </member>
    <member name="M:yWorks.Geometry.SizeD.GetHashCode" />
    <member name="M:yWorks.Geometry.SizeD.Max(yWorks.Geometry.SizeD,yWorks.Geometry.SizeD)">
      <summary>
        <para>Returns a size whose <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> is the <see cref="M:System.Math.Max(System.Double,System.Double)" /> of the respecting properties of the two parameters.</para>
      </summary>
      <param name="size1">
        <para>The first size.</para>
      </param>
      <param name="size2">
        <para>The second size.</para>
      </param>
      <returns>
        <para>A size whose <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> is the <see cref="M:System.Math.Max(System.Double,System.Double)" /> of the respecting properties of the two parameters.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.Min(yWorks.Geometry.SizeD,yWorks.Geometry.SizeD)">
      <summary>
        <para>Returns a size whose <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> is the <see cref="M:System.Math.Min(System.Double,System.Double)" /> of the respecting properties of the two parameters.</para>
      </summary>
      <param name="size1">
        <para>The first size.</para>
      </param>
      <param name="size2">
        <para>The second size.</para>
      </param>
      <returns>
        <para>A size whose <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> is the <see cref="M:System.Math.Min(System.Double,System.Double)" /> of the respecting properties of the two parameters.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.Multiply(yWorks.Geometry.SizeD,System.Double)">
      <summary>
        <para>Multiplies the <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> by the given factor.</para>
      </summary>
      <param name="size">
        <para>The size to multiply the width and height of.</para>
      </param>
      <param name="factor">
        <para>The factor to multiply the width and height by.</para>
      </param>
      <returns>
        <para>A new size that has the width and height multiplied by the factor.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.SizeD.Divide(yWorks.Geometry.SizeD,System.Double)">
      <summary>
        <para>Divides the <see cref="P:yWorks.Geometry.SizeD.Width" /> and <see cref="P:yWorks.Geometry.SizeD.Height" /> by the given factor.</para>
      </summary>
      <param name="size">
        <para>The size to divide the width and height of.</para>
      </param>
      <param name="factor">
        <para>The factor to divide the width and height by.</para>
      </param>
      <returns>
        <para>A new size that has the width and height divided by the factor.</para>
      </returns>
    </member>
    <member name="T:yWorks.Geometry.PointD">
      <summary>
        <para>An immutable struct that models a point in 2-d Cartesian coordinate space with double coordinates.</para>
      </summary>
      <remarks>
        <para>This struct implements the <see cref="T:yWorks.Geometry.IPoint" /> interface so that it can be used in methods that require that interface.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Geometry.PointD.Origin">
      <summary>
        <para>A struct instance that has <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" /> set to <c>0.0d</c>.</para>
      </summary>
    </member>
    <member name="P:yWorks.Geometry.PointD.X">
      <summary>
        <para>Gets the X coordinate of the point.</para>
      </summary>
      <value>
        <para>The X coordinate.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.PointD.Y">
      <summary>
        <para>Gets the Y coordinate of the point.</para>
      </summary>
      <value>
        <para>The Y coordinate.</para>
      </value>
    </member>
    <member name="M:yWorks.Geometry.PointD.#ctor(System.Double,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.PointD" /> struct using the given values for the <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" /> properties.</para>
      </summary>
      <param name="x">
        <para>The x coordinate.</para>
      </param>
      <param name="y">
        <para>The y coordinate.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.PointD.#ctor(yWorks.Geometry.IPoint)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.PointD" /> struct using the coordinates of the provided <see cref="T:yWorks.Geometry.IPoint" />.</para>
      </summary>
      <param name="point">
        <para>The point to get the initial coordinates from.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.PointD.#ctor(System.Drawing.PointF)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.PointD" /> struct using the coordinates of the provided <see cref="T:System.Drawing.PointF" />.</para>
      </summary>
      <param name="point">
        <para>The point to get the initial coordinates from.</para>
      </param>
    </member>
    <member name="P:yWorks.Geometry.PointD.VectorLength">
      <summary>
        <para>Gets the length of the vector that has <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" /> as its components.</para>
      </summary>
      <value>
        <para>The length of the vector which is the square root of <c>X*X + Y*Y</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.PointD.SquaredVectorLength">
      <summary>
        <para>Gets the squared length of the vector that has <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" /> as its components.</para>
      </summary>
      <value>
        <para>The squared length of the vector which is <c>X*X + Y*Y</c>.</para>
      </value>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Addition(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Implements the vector addition operator.</para>
      </summary>
      <remarks>
        <para>This operator is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="p1">
        <para>The first point.</para>
      </param>
      <param name="p2">
        <para>The second point.</para>
      </param>
      <returns>
        <para>The result of the operation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Subtraction(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Implements the vector subtraction operator.</para>
      </summary>
      <remarks>
        <para>This operator is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="p1">
        <para>The first point.</para>
      </param>
      <param name="p2">
        <para>The second point.</para>
      </param>
      <returns>
        <para>The result of the operation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_UnaryNegation(yWorks.Geometry.PointD)">
      <summary>
        <para>Implements the negation operator.</para>
      </summary>
      <remarks>
        <para>This negation is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="p1">
        <para>The point to negate the components of.</para>
      </param>
      <returns>
        <para>The result of the operation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_UnaryPlus(yWorks.Geometry.PointD)">
      <summary>
        <para>Yields the point itself.</para>
      </summary>
      <param name="p1">
        <para>The point to return.</para>
      </param>
      <returns>
        <para>The point itself.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Equality(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Implements the operator == which is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </summary>
      <param name="p1">
        <para>The first point.</para>
      </param>
      <param name="p2">
        <para>The second point.</para>
      </param>
      <returns>
        <para>Whether <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" /> are equal for both points.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Inequality(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Implements the operator != which is the inverse of the <c>==</c> operator.</para>
      </summary>
      <returns>
        <para>The inverse of the <c>==</c> operator.</para>
      </returns>
      <param name="p1" />
      <param name="p2" />
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Multiply(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Implements scalar multiplication.</para>
      </summary>
      <remarks>
        <para>This factor is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="point">
        <para>The point to scale the components of.</para>
      </param>
      <param name="factor">
        <para>The factor to scale the components by.</para>
      </param>
      <returns>
        <para>The result of the operation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Multiply(yWorks.Geometry.Matrix2D,yWorks.Geometry.PointD)">
      <summary>
        <para>Implements the operator * by calling <see cref="M:yWorks.Geometry.Matrix2D.Transform(yWorks.Geometry.PointD)" />.</para>
      </summary>
      <param name="matrix">
        <para>The matrix to use for the transformation.</para>
      </param>
      <param name="vector">
        <para>The vector to transform.</para>
      </param>
      <returns>
        <para>The result of the transformation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Division(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Implements scalar division.</para>
      </summary>
      <remarks>
        <para>The factor is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="point">
        <para>The point to divide the components of.</para>
      </param>
      <param name="factor">
        <para>The factor to divide the components by.</para>
      </param>
      <returns>
        <para>The result of the operation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Multiply(System.Double,yWorks.Geometry.PointD)">
      <summary>
        <para>Implements scalar multiplication.</para>
      </summary>
      <remarks>
        <para>This factor is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="point">
        <para>The point to scale the components of.</para>
      </param>
      <param name="factor">
        <para>The factor to scale the components by.</para>
      </param>
      <returns>
        <para>The result of the operation.</para>
      </returns>
    </member>
    <member name="P:yWorks.Geometry.PointD.Normalized">
      <summary>
        <para>Gets the normalized version of this vector.</para>
      </summary>
      <value>
        <para>The normalized version of this vector or <c>(1,0)</c> if this vector has <c>0.0d</c> length.</para>
      </value>
    </member>
    <member name="M:yWorks.Geometry.PointD.ScalarProduct(yWorks.Geometry.PointD)">
      <summary>
        <para>Calculates the scalar product of this and the given vector.</para>
      </summary>
      <param name="other">
        <para>The other vector.</para>
      </param>
      <returns>
        <para>The scalar product (<c>X*other.X + Y*other.Y</c>)</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.ToPoint">
      <summary>
        <para>Creates a <see cref="T:System.Drawing.PointF" /> that has the same coordinates as this struct.</para>
      </summary>
      <returns>
        <para>A <see cref="T:System.Drawing.PointF" /> with the same coordinates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.ToCeilingPoint">
      <summary>
        <para>Creates a <see cref="T:System.Drawing.Point" /> that has the same coordinates as this struct.</para>
      </summary>
      <returns>
        <para>A <see cref="T:System.Drawing.Point" /> with the same coordinates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.ToFloorPoint">
      <summary>
        <para>Creates a <see cref="T:System.Drawing.Point" /> that has the same coordinates as this struct.</para>
      </summary>
      <returns>
        <para>A <see cref="T:System.Drawing.Point" /> with the same coordinates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.ScalarProduct(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Calculates the scalar product of the two given points.</para>
      </summary>
      <param name="point1">
        <para>The first point.</para>
      </param>
      <param name="point2">
        <para>The second point.</para>
      </param>
      <returns>
        <para>The scalar product of the two points.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.ToMutablePoint">
      <summary>
        <para>Creates an <see cref="T:yWorks.Geometry.IMutablePoint" /> that has the same coordinates as this struct.</para>
      </summary>
      <returns>
        <para>A <see cref="T:yWorks.Geometry.IMutablePoint" /> with the same coordinates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Implicit(yWorks.Geometry.PointD)~System.Drawing.PointF">
      <summary>
        <para>Performs an implicit conversion from <see cref="T:yWorks.Geometry.PointD" /> to <see cref="T:System.Drawing.PointF" />.</para>
      </summary>
      <param name="point">
        <para>The point to convert.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Implicit(yWorks.Geometry.PointD)~yWorks.Geometry.MutablePoint">
      <summary>
        <para>Performs an implicit conversion from <see cref="T:yWorks.Geometry.PointD" /> to <see cref="T:yWorks.Geometry.MutablePoint" />.</para>
      </summary>
      <param name="point">
        <para>The point to convert.</para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Explicit(yWorks.Geometry.MutablePoint)~yWorks.Geometry.PointD">
      <summary>
        <para>Performs an explicit conversion from <see cref="T:yWorks.Geometry.MutablePoint" /> to <see cref="T:yWorks.Geometry.PointD" />.</para>
      </summary>
      <param name="p">
        <para>The point to convert.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.op_Implicit(System.Drawing.PointF)~yWorks.Geometry.PointD">
      <summary>
        <para>Performs an implicit conversion from <see cref="T:System.Drawing.PointF" /> to <see cref="T:yWorks.Geometry.PointD" />.</para>
      </summary>
      <param name="p">
        <para>The point to convert.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.Hits(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Determines if the point lies close to this point given an epsilon.</para>
      </summary>
      <param name="other">
        <para>The coordinates of the other point.</para>
      </param>
      <param name="hitTestRadius">
        <para>The hit test epsilon.</para>
      </param>
      <returns>
        <para>Whether the distance between the two points is smaller than <paramref name="hitTestRadius" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.DistanceTo(yWorks.Geometry.PointD)">
      <summary>
        <para>Calculates the Euclidean distance to the given point.</para>
      </summary>
      <param name="other">
        <para>The other point.</para>
      </param>
      <returns>
        <para>The Euclidean distance between the points.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.GetProjectionOnSegment(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Calculates the projection of this point onto a segment.</para>
      </summary>
      <remarks>
        <para>If the perpendicular projection onto the line is outside of the segment the nearest segment endpoint is returned.</para>
      </remarks>
      <param name="start">
        <para>The start of the segment.</para>
      </param>
      <param name="end">
        <para>The end of the segment.</para>
      </param>
      <returns>
        <para>The point on the segment that is closest to this point.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.GetProjectionOnRay(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Calculates the projection of this point onto a ray.</para>
      </summary>
      <remarks>
        <para>If the perpendicular projection onto the line is outside of the ray ("behind" the <paramref name="rayStart" />) the <paramref name="rayStart" /> is returned instead.</para>
      </remarks>
      <param name="rayStart">
        <para>The start of the segment.</para>
      </param>
      <param name="direction">
        <para>The direction of the ray.</para>
      </param>
      <returns>
        <para>The point on the ray that is closest to this point.</para>
      </returns>
    </member>
    <member name="P:yWorks.Geometry.PointD.IsVerticalVector">
      <summary>
        <para>Gets whether this instance is a vertically oriented vector.</para>
      </summary>
      <value>
        <para>
          <c>true</c> iff <c>Math.Abs(Y) &gt; Math.Abs(X)</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.PointD.IsHorizontalVector">
      <summary>
        <para>Gets whether this instance is a horizontally oriented vector.</para>
      </summary>
      <value>
        <para>
          <c>true</c> iff <c>Math.Abs(X) &gt; Math.Abs(Y)</c>.</para>
      </value>
    </member>
    <member name="M:yWorks.Geometry.PointD.GetProjectionOnLine(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Calculates the projection of this point onto a line.</para>
      </summary>
      <param name="anchor">
        <para>An anchor for the infinite line.</para>
      </param>
      <param name="direction">
        <para>A direction vector for the infinite line.</para>
      </param>
      <returns>
        <para>The point on the line that is closest to this point.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.DistanceToSegment(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Determines the distance between this point and a line segment.</para>
      </summary>
      <param name="start">
        <para>The coordinates of the first point of the line.</para>
      </param>
      <param name="end">
        <para>The coordinates of the second point of the line.</para>
      </param>
      <returns>
        <para>The distance between this point and the closest point on the line segment.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.ToString">
      <summary>
        <para>Returns a human readable string of this point.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.PointD.HitsLineSegment(yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Determines whether this point hits the line segment with respect to a given <paramref name="radius" />.</para>
      </summary>
      <param name="start">
        <para>The starting point of the line segment to test.</para>
      </param>
      <param name="end">
        <para>The ending point of the line segment to test.</para>
      </param>
      <param name="radius">
        <para>The hit test radius.</para>
      </param>
      <returns>
        <para>Whether this point hits the given line segment within the radius.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.HitsPolyline(System.Collections.Generic.IEnumerable{yWorks.Geometry.IPoint},System.Double)">
      <summary>
        <para>Determines whether a polygonal line is hit by this point given an epsilon.</para>
      </summary>
      <param name="points">
        <para>The list of points that is treated as a polygon</para>
      </param>
      <param name="radius">
        <para>A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than or equal to that value, it will be considered a hit.</para>
      </param>
      <returns>
        <para>Whether the point hits the polygon.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.Equals(yWorks.Geometry.PointD)">
      <summary>
        <para>Determines whether this instance has the same coordinates as the provided point.</para>
      </summary>
      <param name="other">
        <para>The other point.</para>
      </param>
      <returns>
        <para>Whether <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" /> are the same.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.Equals(System.Object)">
      <summary>
        <para>Indicates whether this instance and a specified object are equal.</para>
      </summary>
      <param name="other">
        <para>Another object to compare to.</para>
      </param>
      <returns>
        <para>true if <paramref name="other" /> and this instance are the same type and represent the same value; otherwise, false.</para>
      </returns>
      <seealso cref="M:yWorks.Geometry.PointD.Equals(yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Geometry.PointD.GetHashCode">
      <summary>
        <para>Returns the hash code for this instance that is calculated using the <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" /> values.</para>
      </summary>
      <returns>
        <para>A 32-bit signed integer that is the hash code for this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.GetConstrained(yWorks.Geometry.RectD)">
      <summary>
        <para>Create a constrained copy of this instance that lies within the given non-empty <paramref name="rectangle" />.</para>
      </summary>
      <remarks>
        <para>If the given rectangle is <see cref="F:yWorks.Geometry.RectD.Empty" />, this implementation will silently return.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to constrain this instance by.</para>
      </param>
      <returns>
        <para>A constrained copy of this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.EqualsEps(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Determines whether the two given points have the same coordinates with respect to a certain given <paramref name="eps" />.</para>
      </summary>
      <param name="other">
        <para>The other point to check for equality against this point.</para>
      </param>
      <param name="eps">
        <para>The epsilon value.</para>
      </param>
      <returns>
        <para>Whether both coordinates are equal with respect for the given epsilon.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.Add(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Adds the given vectors.</para>
      </summary>
      <remarks>
        <para>This operator is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="point1">
        <para>The first point.</para>
      </param>
      <param name="point2">
        <para>The second point.</para>
      </param>
      <returns>
        <para>The result of the vector addition.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.Subtract(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Substracts the second given vector from the first given vector.</para>
      </summary>
      <remarks>
        <para>This operator is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="point1">
        <para>The first point.</para>
      </param>
      <param name="point2">
        <para>The second point.</para>
      </param>
      <returns>
        <para>The result of the vector subtraction.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.Negate(yWorks.Geometry.PointD)">
      <summary>
        <para>Negates the given vector.</para>
      </summary>
      <remarks>
        <para>This negation is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="point">
        <para>The point to negate the components of.</para>
      </param>
      <returns>
        <para>The result of the vector negation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.Plus(yWorks.Geometry.PointD)">
      <summary>
        <para>Yields the point itself.</para>
      </summary>
      <param name="point">
        <para>The point to return.</para>
      </param>
      <returns>
        <para>The point itself.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.Multiply(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Implements scalar multiplication.</para>
      </summary>
      <remarks>
        <para>This factor is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="point">
        <para>The point to scale the components of.</para>
      </param>
      <param name="factor">
        <para>The factor to scale the components by.</para>
      </param>
      <returns>
        <para>The result of the scalar multiplication.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.Multiply(yWorks.Geometry.Matrix2D,yWorks.Geometry.PointD)">
      <summary>
        <para>Implements the vector transformation by calling <see cref="M:yWorks.Geometry.Matrix2D.Transform(yWorks.Geometry.PointD)" />.</para>
      </summary>
      <param name="matrix">
        <para>The matrix to use for the transformation.</para>
      </param>
      <param name="vector">
        <para>The vector to transform.</para>
      </param>
      <returns>
        <para>The result of the transformation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.PointD.Divide(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Implements scalar division.</para>
      </summary>
      <remarks>
        <para>The factor is applied componentwise to <see cref="P:yWorks.Geometry.PointD.X" /> and <see cref="P:yWorks.Geometry.PointD.Y" />.</para>
      </remarks>
      <param name="point">
        <para>The point to divide the components of.</para>
      </param>
      <param name="factor">
        <para>The factor to divide the components by.</para>
      </param>
      <returns>
        <para>The result of the scalar division.</para>
      </returns>
    </member>
    <member name="T:yWorks.Geometry.InsetsD">
      <summary>
        <para>An immutable struct that models the thickness of insets as double precision floating point values.</para>
      </summary>
    </member>
    <member name="F:yWorks.Geometry.InsetsD.Empty">
      <summary>
        <para>The "empty" insets that has all properties set to <c>0.0d</c>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.#ctor(System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.InsetsD" /> struct using the provided inset for all four sides.</para>
      </summary>
      <param name="inset">
        <para>The inset to use for all sides.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.InsetsD" /> struct.</para>
      </summary>
      <param name="left">
        <para>The left inset.</para>
      </param>
      <param name="top">
        <para>The top inset.</para>
      </param>
      <param name="right">
        <para>The right inset.</para>
      </param>
      <param name="bottom">
        <para>The bottom inset.</para>
      </param>
    </member>
    <member name="P:yWorks.Geometry.InsetsD.Top">
      <summary>
        <para>Gets the top inset.</para>
      </summary>
      <value>
        <para>The top inset.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.InsetsD.Left">
      <summary>
        <para>Gets the left inset.</para>
      </summary>
      <value>
        <para>The left inset.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.InsetsD.Bottom">
      <summary>
        <para>Gets the bottom inset.</para>
      </summary>
      <value>
        <para>The bottom inset.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.InsetsD.Right">
      <summary>
        <para>Gets the right inset.</para>
      </summary>
      <value>
        <para>The right inset.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.InsetsD.VerticalInsets">
      <summary>
        <para>Gets the vertical insets, which is the sum of <see cref="P:yWorks.Geometry.InsetsD.Top" /> and <see cref="P:yWorks.Geometry.InsetsD.Bottom" />.</para>
      </summary>
      <value>
        <para>The vertical insets (<see cref="P:yWorks.Geometry.InsetsD.Top" /> + <see cref="P:yWorks.Geometry.InsetsD.Bottom" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.InsetsD.HorizontalInsets">
      <summary>
        <para>Gets the horizontal insets, which is the sum of <see cref="P:yWorks.Geometry.InsetsD.Left" /> and <see cref="P:yWorks.Geometry.InsetsD.Right" />.</para>
      </summary>
      <value>
        <para>The horizontal insets (<see cref="P:yWorks.Geometry.InsetsD.Left" /> + <see cref="P:yWorks.Geometry.InsetsD.Right" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.InsetsD.IsEmpty">
      <summary>
        <para>Gets a value indicating whether this instance is empty, that is all insets are <c>0.0d</c>.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance has all properties set to <c>0.0d</c>; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.GetEnlarged(yWorks.Geometry.InsetsD)">
      <summary>
        <para>Creates an enlarged instance by adding the insets of the specified insets to this instance and returning the result.</para>
      </summary>
      <param name="insets">
        <para>The insets to add to this struct.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.CreateUnion(yWorks.Geometry.InsetsD)">
      <summary>
        <para>Calculates the union of this insets struct and the given inset which is done by performing <see cref="M:System.Math.Max(System.Double,System.Double)" /> on all four inset values.</para>
      </summary>
      <param name="insets">
        <para>The insets to max with these insets.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.op_Equality(yWorks.Geometry.InsetsD,yWorks.Geometry.InsetsD)">
      <summary>
        <para>Implements the equality operation on <see cref="T:yWorks.Geometry.InsetsD" /> comparing <see cref="P:yWorks.Geometry.InsetsD.Left" /> and <see cref="P:yWorks.Geometry.InsetsD.Top" /> and <see cref="P:yWorks.Geometry.InsetsD.Bottom" /> and <see cref="P:yWorks.Geometry.InsetsD.Right" /> for equality.</para>
      </summary>
      <param name="one">
        <para>The first operand.</para>
      </param>
      <param name="two">
        <para>The second operand.</para>
      </param>
      <returns>
        <para>Whether the <see cref="P:yWorks.Geometry.InsetsD.Left" />, <see cref="P:yWorks.Geometry.InsetsD.Top" />, <see cref="P:yWorks.Geometry.InsetsD.Bottom" />, and <see cref="P:yWorks.Geometry.InsetsD.Right" /> properties of the structs are equal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.op_Multiply(yWorks.Geometry.InsetsD,System.Double)">
      <summary>
        <para>Implements the operator * that multiplies each side of the insets by the given factor.</para>
      </summary>
      <param name="insets">
        <para>The insets to scales up.</para>
      </param>
      <param name="factor">
        <para>The factor to scales up by.</para>
      </param>
      <returns>
        <para>New insets scaled up by the factor.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.op_Multiply(System.Double,yWorks.Geometry.InsetsD)">
      <summary>
        <para>Implements the operator * that multiplies each side of the insets by the given factor.</para>
      </summary>
      <param name="factor">
        <para>The factor to scales up by.</para>
      </param>
      <param name="insets">
        <para>The insets to scales up.</para>
      </param>
      <returns>
        <para>New insets scaled up by the factor.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.op_Division(yWorks.Geometry.InsetsD,System.Double)">
      <summary>
        <para>Implements the operator / that divides each side of the insets by the given factor.</para>
      </summary>
      <param name="insets">
        <para>The insets to scales down.</para>
      </param>
      <param name="factor">
        <para>The factor to scales down by.</para>
      </param>
      <returns>
        <para>New insets scaled down by the factor.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.op_Inequality(yWorks.Geometry.InsetsD,yWorks.Geometry.InsetsD)">
      <summary>
        <para>Implements the inequality operation on <see cref="T:yWorks.Geometry.InsetsD" /> comparing <see cref="P:yWorks.Geometry.InsetsD.Left" /> and <see cref="P:yWorks.Geometry.InsetsD.Top" /> and <see cref="P:yWorks.Geometry.InsetsD.Bottom" /> and <see cref="P:yWorks.Geometry.InsetsD.Right" /> for inequality.</para>
      </summary>
      <param name="one">
        <para>The first operand.</para>
      </param>
      <param name="two">
        <para>The second operand.</para>
      </param>
      <returns>
        <para>Whether any of the <see cref="P:yWorks.Geometry.InsetsD.Left" />, <see cref="P:yWorks.Geometry.InsetsD.Top" />, <see cref="P:yWorks.Geometry.InsetsD.Bottom" />, and <see cref="P:yWorks.Geometry.InsetsD.Right" /> properties of the structs are not equal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.Equals(yWorks.Geometry.InsetsD)">
      <summary>
        <para>Determines whether this instance has the same values as the given one.</para>
      </summary>
      <remarks>
        <para>The equality is determined by comparing <see cref="P:yWorks.Geometry.InsetsD.Left" /> and <see cref="P:yWorks.Geometry.InsetsD.Right" /> and <see cref="P:yWorks.Geometry.InsetsD.Top" /> and <see cref="P:yWorks.Geometry.InsetsD.Bottom" /> for equality.</para>
      </remarks>
      <param name="other">
        <para>The second operand to compare with this struct.</para>
      </param>
      <returns>
        <para>Whether the <see cref="P:yWorks.Geometry.InsetsD.Left" />, <see cref="P:yWorks.Geometry.InsetsD.Right" />, <see cref="P:yWorks.Geometry.InsetsD.Bottom" />, and <see cref="P:yWorks.Geometry.InsetsD.Right" /> properties of the structs are equal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.Equals(System.Object)">
      <summary>
        <para>Indicates whether this instance and a specified object are equal.</para>
      </summary>
      <param name="other">
        <para>Another object to compare to.</para>
      </param>
      <returns>
        <para>true if <paramref name="other" /> and this instance are the same type and represent the same value; otherwise, false.</para>
      </returns>
      <seealso cref="M:yWorks.Geometry.InsetsD.Equals(yWorks.Geometry.InsetsD)" />
    </member>
    <member name="M:yWorks.Geometry.InsetsD.GetHashCode">
      <summary>
        <para>Returns the hash code for this instance.</para>
      </summary>
      <returns>
        <para>A 32-bit signed integer that is the hash code for this instance. The hash code is computed using the <see cref="P:yWorks.Geometry.InsetsD.Left" />, <see cref="P:yWorks.Geometry.InsetsD.Right" />, <see cref="P:yWorks.Geometry.InsetsD.Top" />, and <see cref="P:yWorks.Geometry.InsetsD.Bottom" /> property.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.Multiply(yWorks.Geometry.InsetsD,System.Double)">
      <summary>
        <para>Multiplies each side of the insets by the given factor.</para>
      </summary>
      <param name="insets">
        <para>The insets to scales up.</para>
      </param>
      <param name="factor">
        <para>The factor to scales up by.</para>
      </param>
      <returns>
        <para>New insets scaled up by the factor.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.InsetsD.Divide(yWorks.Geometry.InsetsD,System.Double)">
      <summary>
        <para>Devides each side of the insets by the given factor.</para>
      </summary>
      <param name="insets">
        <para>The insets to scales down.</para>
      </param>
      <param name="factor">
        <para>The factor to scales down by.</para>
      </param>
      <returns>
        <para>New insets scaled down by the factor.</para>
      </returns>
    </member>
    <member name="T:yWorks.Geometry.RectD">
      <summary>
        <para>An immutable struct that models a rectangle in 2-d Cartesian coordinate space with double coordinates.</para>
      </summary>
      <remarks>
        <para>This struct differs from other possible implementation in the way negative <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" /> properties are handled and interpreted. Width and/or height values may be negative in which case the rectangle is considered <see cref="P:yWorks.Geometry.RectD.IsEmpty">empty</see> and non-existent. Empty rectangles are not considered in <see cref="M:yWorks.Geometry.RectD.Add(yWorks.Geometry.RectD,yWorks.Geometry.RectD)">union-like</see> operations, whereas rectangles with <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" /> of <c>0.0d</c> are. This struct implements the <see cref="T:yWorks.Geometry.IRectangle" /> interface so that it can be used in methods that require that interface.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Geometry.RectD.Empty">
      <summary>
        <para>An <see cref="P:yWorks.Geometry.RectD.IsEmpty">empty</see> rectangle.</para>
      </summary>
      <remarks>
        <para>
          <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" /> are set to <c>-1.0d</c>, <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Y" /> are set to <c>0.0d</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Geometry.RectD.Infinite">
      <summary>
        <para>An infinite rectangle.</para>
      </summary>
      <remarks>
        <para>
          <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" /> are set to <see cref="F:System.Double.PositiveInfinity" />, <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Y" /> are set to <see cref="F:System.Double.NegativeInfinity" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.RectD.X">
      <summary>
        <para>Gets the X coordinate of the upper left corner of the rectangle.</para>
      </summary>
      <value>
        <para>The X coordinate.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.Y">
      <summary>
        <para>Gets the Y coordinate of the upper left corner of the rectangle.</para>
      </summary>
      <value>
        <para>The Y coordinate.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.Width">
      <summary>
        <para>Gets the width of the rectangle.</para>
      </summary>
      <value>
        <para>The width. Negative values make the rectangle <see cref="P:yWorks.Geometry.RectD.IsEmpty">empty</see>.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.Height">
      <summary>
        <para>Gets the height of the rectangle.</para>
      </summary>
      <value>
        <para>The height. Negative values make the rectangle <see cref="P:yWorks.Geometry.RectD.IsEmpty">empty</see>.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.CenterX">
      <summary>
        <para>Gets the center X coordinate of the rectangle.</para>
      </summary>
      <value>
        <para>The center x coordinate, or <see cref="P:yWorks.Geometry.RectD.X" /> if the <see cref="P:yWorks.Geometry.RectD.Width" /> is non-positive.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.CenterY">
      <summary>
        <para>Gets the center Y coordinate of the rectangle.</para>
      </summary>
      <value>
        <para>The center y coordinate, or <see cref="P:yWorks.Geometry.RectD.Y" /> if the <see cref="P:yWorks.Geometry.RectD.Height" /> is non-positive.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.Center">
      <summary>
        <para>Gets the center of the rectangle using <see cref="P:yWorks.Geometry.RectD.CenterX" /> and <see cref="P:yWorks.Geometry.RectD.CenterY" />.</para>
      </summary>
      <value>
        <para>A copy of the center of the rectangle.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.TopLeft">
      <summary>
        <para>Gets the coordinates of the top left corner of the rectangle.</para>
      </summary>
      <value>
        <para>The top left corner, which is always <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Y" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.TopRight">
      <summary>
        <para>Gets the coordinates of the top right corner of the rectangle.</para>
      </summary>
      <value>
        <para>The top right corner, which is always <see cref="P:yWorks.Geometry.RectD.MaxX" /> and <see cref="P:yWorks.Geometry.RectD.Y" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.BottomLeft">
      <summary>
        <para>Gets the coordinates of the bottom left corner of the rectangle.</para>
      </summary>
      <value>
        <para>The bottom left corner, which is always <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.MaxY" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.BottomRight">
      <summary>
        <para>Gets the coordinates of the bottom right corner of the rectangle.</para>
      </summary>
      <value>
        <para>The bottom right corner, which is always <see cref="P:yWorks.Geometry.RectD.MaxX" /> and <see cref="P:yWorks.Geometry.RectD.MaxY" />.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.Size">
      <summary>
        <para>Gets the size of this instance.</para>
      </summary>
      <value>
        <para>The size, which is <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" />.</para>
      </value>
    </member>
    <member name="M:yWorks.Geometry.RectD.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.RectD" /> struct.</para>
      </summary>
      <param name="x">
        <para>The <see cref="P:yWorks.Geometry.RectD.X" /> coordinate of the top left corner.</para>
      </param>
      <param name="y">
        <para>The <see cref="P:yWorks.Geometry.RectD.Y" /> coordinate of the top left corner.</para>
      </param>
      <param name="width">
        <para>The <see cref="P:yWorks.Geometry.RectD.Width" /> of the rectangle.</para>
      </param>
      <param name="height">
        <para>The <see cref="P:yWorks.Geometry.RectD.Height" /> of the rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectD.#ctor(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.RectD" /> struct with the initial values obtained from the given rectangle.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to retrieve the initial values from.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectD.#ctor(System.Drawing.RectangleF)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.RectD" /> struct with the initial values obtained from the given rectangle.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to retrieve the initial values from.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectD.GetTranslated(yWorks.Geometry.PointD)">
      <summary>
        <para>Returns a translated instance of this which has modified <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Y" /> by the given amount.</para>
      </summary>
      <param name="delta">
        <para>The delta to add to <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Y" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectD.#ctor(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.RectD" /> struct using two point to define the bounds</para>
      </summary>
      <remarks>
        <para>This will always result in non-<see cref="P:yWorks.Geometry.RectD.IsEmpty" /> rectangles as the coordinates of the points are sorted so that the smaller gets assigned to <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Y" /> respectively and the greater ones define the <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" />.</para>
      </remarks>
      <param name="p1">
        <para>The first point to determine the bounds.</para>
      </param>
      <param name="p2">
        <para>The second point to determine the bounds.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectD.#ctor(yWorks.Geometry.PointD,yWorks.Geometry.SizeD)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.RectD" /> struct using the <see cref="P:yWorks.Geometry.RectD.TopLeft" /> corner and the <see cref="P:yWorks.Geometry.RectD.Size" />.</para>
      </summary>
      <param name="location">
        <para>The top left corner.</para>
      </param>
      <param name="size">
        <para>The size to use.</para>
      </param>
    </member>
    <member name="P:yWorks.Geometry.RectD.IsEmpty">
      <summary>
        <para>Gets a value indicating whether this instance is considered empty.</para>
      </summary>
      <remarks>
        <para>Yields <c>true</c> if this at least one of <see cref="P:yWorks.Geometry.RectD.Width" /> or <see cref="P:yWorks.Geometry.RectD.Height" /> is negative; <c>false</c> otherwise. Note that a width and height of both <c>0.0d</c> is not considered empty for this implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Geometry.RectD.ToMutableRectangle">
      <summary>
        <para>Creates an <see cref="T:yWorks.Geometry.IMutableRectangle" /> using the values from this instance.</para>
      </summary>
      <returns>
        <para>An instance that has been initialized from the values of this struct.</para>
      </returns>
    </member>
    <member name="P:yWorks.Geometry.RectD.IsFinite">
      <summary>
        <para>Gets a value indicating whether this instance is finite.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this both <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" /> are not <see cref="M:System.Double.IsInfinity(System.Double)">infinity</see>; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.MaxX">
      <summary>
        <para>Gets the coordinates of the right border for this struct.</para>
      </summary>
      <value>
        <para>The maximum X value. This is either the sum of <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Width" /> or simply <see cref="P:yWorks.Geometry.RectD.X" /> if the width is non-positive.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.MaxY">
      <summary>
        <para>Gets the coordinates of the lower border for this struct.</para>
      </summary>
      <value>
        <para>The maximum Y value. This is either the sum of <see cref="P:yWorks.Geometry.RectD.Y" /> and <see cref="P:yWorks.Geometry.RectD.Height" /> or simply <see cref="P:yWorks.Geometry.RectD.Y" /> if the height is non-positive.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.MinX">
      <summary>
        <para>Gets the X coordinates of the left side of this instance.</para>
      </summary>
      <value>
        <para>The minimum X.</para>
      </value>
    </member>
    <member name="P:yWorks.Geometry.RectD.MinY">
      <summary>
        <para>Gets the Y coordinates of the top side of this instance.</para>
      </summary>
      <value>
        <para>The minimum Y.</para>
      </value>
    </member>
    <member name="M:yWorks.Geometry.RectD.Contains(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Determines whether this rectangle contains the specified point with respect to a given epsilon.</para>
      </summary>
      <param name="point">
        <para>The point to test.</para>
      </param>
      <param name="eps">
        <para>The positive epsilon distance that the point may lie outside the rectangle and still be considered contained.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this rectangle contains the specified point; <c>false</c> otherwise. An <see cref="P:yWorks.Geometry.RectD.IsEmpty">empty</see> instance never contains any point. A point is considered to be contained in the rectangle when the coordinates are not smaller than <see cref="P:yWorks.Geometry.RectD.MinX" /> and <see cref="P:yWorks.Geometry.RectD.MinY" /> minus <paramref name="eps" /> nor greater than <see cref="P:yWorks.Geometry.RectD.MaxX" /> and <see cref="P:yWorks.Geometry.RectD.MaxY" /> plus <paramref name="eps" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.Add(yWorks.Geometry.RectD,yWorks.Geometry.PointD)">
      <summary>
        <para>Returns the union of the given rectangle and the given point.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to modify.</para>
      </param>
      <param name="point">
        <para>The point to include in the rectangle's bounds.</para>
      </param>
      <returns>
        <para>The enlarged rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.Add(yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Returns the union of the given rectangles.</para>
      </summary>
      <remarks>
        <para>
          <see cref="P:yWorks.Geometry.RectD.IsEmpty">empty</see> rectangles will not be considered.</para>
      </remarks>
      <param name="firstRectangle">
        <para>The first rectangle to use for the union.</para>
      </param>
      <param name="secondRectangle">
        <para>The second rectangle to use for the union.</para>
      </param>
      <returns>
        <para>A rectangle that encompasses the area of the two given rectangles.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.GetEnlarged(yWorks.Geometry.InsetsD)">
      <summary>
        <para>Creates an enlarged instance that is the same as this one but enlarged by the specified insets.</para>
      </summary>
      <remarks>
        <para>If this struct <see cref="P:yWorks.Geometry.RectD.IsEmpty" />, the same will be returned.</para>
      </remarks>
      <param name="insets">
        <para>The insets to use to add to the instance.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectD.op_Addition(yWorks.Geometry.RectD,yWorks.Geometry.PointD)">
      <summary>
        <para>Returns the union of the given rectangle and the given point.</para>
      </summary>
      <remarks>
        <para>If <paramref name="rectangle" /> <see cref="P:yWorks.Geometry.RectD.IsEmpty" />, the point will be used to set the <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Y" /> coordinates and <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" /> will be set to <c>0.0d</c>, making it non-<see cref="P:yWorks.Geometry.RectD.IsEmpty">empty</see>.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to enlarge.</para>
      </param>
      <param name="point">
        <para>The point to add to the rectangle.</para>
      </param>
      <returns>
        <para>The union rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.op_Addition(yWorks.Geometry.RectD,yWorks.Geometry.InsetsD)">
      <summary>
        <para>Enlarges the given rectangle by the given insets.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to enlarge.</para>
      </param>
      <param name="insets">
        <para>The insets to use.</para>
      </param>
      <returns>
        <para>The enlarge rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.op_Addition(yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Returns the union of the given rectangles.</para>
      </summary>
      <param name="firstRectangle">
        <para>The first rectangle.</para>
      </param>
      <param name="secondRectangle">
        <para>The second rectangle.</para>
      </param>
      <returns>
        <para>The union rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.op_Explicit(yWorks.Geometry.MutableRectangle)~yWorks.Geometry.RectD">
      <summary>
        <para>Performs an explicit conversion from <see cref="T:yWorks.Geometry.MutableRectangle" /> to <see cref="T:yWorks.Geometry.RectD" />.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to convert.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.op_Implicit(System.Drawing.RectangleF)~yWorks.Geometry.RectD">
      <summary>
        <para>Performs an implicit conversion from <see cref="T:System.Drawing.RectangleF" /> to <see cref="T:yWorks.Geometry.RectD" />.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to convert.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.op_Explicit(yWorks.Geometry.RectD)~System.Drawing.RectangleF">
      <summary>
        <para>Performs an explicit conversion from <see cref="T:yWorks.Geometry.RectD" /> to <see cref="T:System.Drawing.RectangleF" />.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Geometry.RectD.Width" /> or <see cref="P:yWorks.Geometry.RectD.Height" /> of the <paramref name="rect" /> are negative, they will be set to <c>0.0d</c> in the result.</para>
      </remarks>
      <param name="rect">
        <para>The rectangle to convert.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.op_Explicit(yWorks.Geometry.RectD)~yWorks.Geometry.MutableRectangle">
      <summary>
        <para>Performs an explicit conversion from <see cref="T:yWorks.Geometry.RectD" /> to <see cref="T:yWorks.Geometry.MutableRectangle" />.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to convert.</para>
      </param>
      <returns>
        <para>The result of the conversion.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.op_Equality(yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Implements the equality operation on <see cref="T:yWorks.Geometry.RectD" /> comparing <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Y" /> and <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" /> for equality.</para>
      </summary>
      <param name="firstRectangle">
        <para>The first operand.</para>
      </param>
      <param name="secondRectangle">
        <para>The second operand.</para>
      </param>
      <returns>
        <para>Whether the <see cref="P:yWorks.Geometry.RectD.X" />, <see cref="P:yWorks.Geometry.RectD.Y" />, <see cref="P:yWorks.Geometry.RectD.Width" />, and <see cref="P:yWorks.Geometry.RectD.Height" /> properties of the structs are equal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.op_Inequality(yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <summary>
        <para>Implements the inequality operation on <see cref="T:yWorks.Geometry.RectD" /> comparing <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Y" /> and <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" /> for equality.</para>
      </summary>
      <param name="firstRectangle">
        <para>The first operand.</para>
      </param>
      <param name="secondRectangle">
        <para>The second operand.</para>
      </param>
      <returns>
        <para>Whether the at least one of <see cref="P:yWorks.Geometry.RectD.X" />, <see cref="P:yWorks.Geometry.RectD.Y" />, <see cref="P:yWorks.Geometry.RectD.Width" />, or <see cref="P:yWorks.Geometry.RectD.Height" /> properties of the structs are not equal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.GetEnlarged(System.Double)">
      <summary>
        <para>Creates an enlarged instance of this rectangle using the same insets for all sides.</para>
      </summary>
      <remarks>
        <para>If this struct <see cref="P:yWorks.Geometry.RectD.IsEmpty" />, the result will be the same.</para>
      </remarks>
      <param name="size">
        <para>The inset to add to each of the sides to grow the new instance.</para>
      </param>
      <seealso cref="M:yWorks.Geometry.RectD.GetEnlarged(yWorks.Geometry.InsetsD)" />
    </member>
    <member name="P:yWorks.Geometry.RectD.Area">
      <summary>
        <para>Gets the area of this instance which is the product of <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" />.</para>
      </summary>
      <value>
        <para>The area.</para>
      </value>
    </member>
    <member name="M:yWorks.Geometry.RectD.Intersects(yWorks.Geometry.RectD)">
      <summary>
        <para>Determines whether the bounds of this struct intersect with the bounds of the specified rectangle.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to check.</para>
      </param>
      <returns>
        <para>Whether both instance are non-empty and have an intersection with positive <see cref="P:yWorks.Geometry.RectD.Area" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.Intersects(yWorks.Geometry.IOrientedRectangle,System.Double)">
      <summary>
        <para>Determines whether this rectangle intersects an <see cref="T:yWorks.Geometry.IOrientedRectangle" />, given an epsilon.</para>
      </summary>
      <param name="rectangle">
        <para>The <see cref="T:yWorks.Geometry.IOrientedRectangle" /> to test.</para>
      </param>
      <param name="eps">
        <para>A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than or equal to that value, it will be considered a hit.</para>
      </param>
      <returns>
        <para>Whether they have a non-empty intersection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.IntersectsLine(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Determines whether this rectangle intersects a line.</para>
      </summary>
      <param name="start">
        <para>The first end point of the line.</para>
      </param>
      <param name="end">
        <para>The second end point of the line.</para>
      </param>
      <returns>
        <para>Whether the line intersects the rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.IntersectsPolyline(System.Collections.Generic.IEnumerable{yWorks.Geometry.IPoint})">
      <summary>
        <para>Determines whether a rectangle intersects a polygonal line.</para>
      </summary>
      <param name="points">
        <para>The list of points that is interpreted as a number of line segments.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the rectangle intersects at least one segment of the line.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.FindLineIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the intersection between a rectangle and a line.</para>
      </summary>
      <param name="inner">
        <para>The coordinates of a point lying inside the rectangle.</para>
      </param>
      <param name="outer">
        <para>The coordinates of a point lying outside the rectangle.</para>
      </param>
      <returns>
        <para>The intersection point if the inner point lies inside the rectangle, the outer point lies outside the rectangle and thus an intersection point has been found, or <c>null</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.ToRectangleF">
      <summary>
        <para>Creates an <see cref="T:System.Drawing.RectangleF" /> instance that uses the same values as this instance.</para>
      </summary>
      <remarks>
        <para>If this instance is <see cref="P:yWorks.Geometry.RectD.IsEmpty">empty</see> the return value is <see cref="F:System.Drawing.RectangleF.Empty" />.</para>
      </remarks>
      <returns>
        <para>Returns an instance using the values from this struct.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.ToRectangleI">
      <summary>
        <para>Creates an <see cref="T:System.Drawing.Rectangle" /> instance that uses the same values as this instance.</para>
      </summary>
      <remarks>
        <para>If this instance is <see cref="P:yWorks.Geometry.RectD.IsEmpty">empty</see> the return value is <see cref="F:System.Drawing.Rectangle.Empty" />.</para>
      </remarks>
      <returns>
        <para>Returns an instance using the values from this struct.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.ToString">
      <summary>
        <para>Creates a human readable from of this instance.</para>
      </summary>
      <returns>
        <para>A string describing the properties of this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.GetTransformed(yWorks.Geometry.Matrix2D)">
      <summary>
        <para>Transforms this instance using specified transform storing the bounds in place.</para>
      </summary>
      <param name="transform">
        <para>The transform matrix to apply to this instance.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectD.FromCenter(yWorks.Geometry.PointD,yWorks.Geometry.SizeD)">
      <summary>
        <para>Creates a new instance given the center of the rectangle and its size.</para>
      </summary>
      <param name="center">
        <para>The center to use.</para>
      </param>
      <param name="size">
        <para>The size to assign.</para>
      </param>
      <returns>
        <para>An instance whose center is set to <paramref name="center" /> and size is <paramref name="size" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.Equals(yWorks.Geometry.RectD)">
      <summary>
        <para>Determines whether this instance has the same values as the given one.</para>
      </summary>
      <remarks>
        <para>The equality is determined by comparing <see cref="P:yWorks.Geometry.RectD.X" /> and <see cref="P:yWorks.Geometry.RectD.Y" /> and <see cref="P:yWorks.Geometry.RectD.Width" /> and <see cref="P:yWorks.Geometry.RectD.Height" /> for equality.</para>
      </remarks>
      <param name="other">
        <para>The second operand to compare with this struct.</para>
      </param>
      <returns>
        <para>Whether the <see cref="P:yWorks.Geometry.RectD.X" />, <see cref="P:yWorks.Geometry.RectD.Y" />, <see cref="P:yWorks.Geometry.RectD.Width" />, and <see cref="P:yWorks.Geometry.RectD.Height" /> properties of the structs are equal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectD.Equals(System.Object)">
      <summary>
        <para>Indicates whether this instance and a specified object are equal.</para>
      </summary>
      <param name="other">
        <para>Another object to compare to.</para>
      </param>
      <returns>
        <para>true if <paramref name="other" /> and this instance are the same type and represent the same value; otherwise, false.</para>
      </returns>
      <seealso cref="M:yWorks.Geometry.RectD.Equals(yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Geometry.RectD.GetHashCode">
      <summary>
        <para>Returns the hash code for this instance.</para>
      </summary>
      <returns>
        <para>A 32-bit signed integer that is the hash code for this instance. The hash code is computed using the <see cref="P:yWorks.Geometry.RectD.X" />, <see cref="P:yWorks.Geometry.RectD.Y" />, <see cref="P:yWorks.Geometry.RectD.Width" />, and <see cref="P:yWorks.Geometry.RectD.Height" /> property.</para>
      </returns>
    </member>
    <member name="T:yWorks.Geometry.Tangent">
      <summary>
        <para>An immutable struct that represents a tangent in a 2-d Cartesian coordinate space with double values.</para>
      </summary>
      <remarks>
        <para>The tangent consists of its point of tangency (<see cref="P:yWorks.Geometry.Tangent.Point" />) and a direction (<see cref="P:yWorks.Geometry.Tangent.Vector" />).</para>
      </remarks>
    </member>
    <member name="M:yWorks.Geometry.Tangent.#ctor(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.Tangent" /> struct using the given values for the <see cref="P:yWorks.Geometry.Tangent.Point" /> and <see cref="P:yWorks.Geometry.Tangent.Vector" /> properties.</para>
      </summary>
      <param name="point">
        <para>The point of tangency.</para>
      </param>
      <param name="vector">
        <para>The directional vector.</para>
      </param>
    </member>
    <member name="P:yWorks.Geometry.Tangent.Point">
      <summary>
        <para>Gets the point of tangency.</para>
      </summary>
    </member>
    <member name="P:yWorks.Geometry.Tangent.Vector">
      <summary>
        <para>Gets the directional vector.</para>
      </summary>
    </member>
    <member name="T:yWorks.Geometry.GeomUtilities">
      <summary>
        <para>Utility class that performs all kind of geometric operations.</para>
      </summary>
      <remarks>
        <para>Also it serves as a factory for various implementations of geometric primitives.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Geometry.GeomUtilities.FindRayIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the intersection between a line segment and an infinite ray.</para>
      </summary>
      <remarks>
        <para>The ray is described using an anchor point and a ray direction. The direction vector does not need to be normalized. In order to obtain the intersection point do the following:</para>
      </remarks>
      <param name="start">
        <para>The coordinates of the first end point of the line segment.</para>
      </param>
      <param name="end">
        <para>The coordinates of the second end point of the line segment.</para>
      </param>
      <param name="anchor">
        <para>The coordinates of the starting point of the ray.</para>
      </param>
      <param name="rayDirection">
        <para>The direction vector of the ray.</para>
      </param>
      <returns>
        <para>The distance factor or <see cref="F:System.Double.PositiveInfinity" /> if the ray does not intersect the line.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeomUtilities.EllipseContains(yWorks.Geometry.RectD,yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Checks whether an ellipse contains the given point.</para>
      </summary>
      <param name="bounds">
        <para>The coordinates of the bounds of the ellipse's enclosing rectangle.</para>
      </param>
      <param name="point">
        <para>The coordinates of the point to test.</para>
      </param>
      <param name="eps">
        <para>A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than or equal to that value, it will be considered a hit.</para>
      </param>
      <returns>
        <para>Whether the point lies within the ellipse</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.GeomUtilities.FindEllipseLineIntersection(yWorks.Geometry.RectD,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Returns the ellipse/line intersection point for the given point pair.</para>
      </summary>
      <remarks>
        <para>This will always return the intersection point that lies in the direction from inner to outer.</para>
      </remarks>
      <param name="bounds">
        <para>The coordinates of the bounds of the ellipse's enclosing rectangle.</para>
      </param>
      <param name="inner">
        <para>The coordinates of a point lying inside the ellipse.</para>
      </param>
      <param name="outer">
        <para>The coordinates of a point lying outside the ellipse.</para>
      </param>
      <returns>
        <para>The intersection point iff the inner point lies inside the ellipse and an intersection point has been found, otherwise <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Geometry.IMutableOrientedRectangle">
      <summary>
        <para>Interface for mutable oriented rectangles in 2D coordinate space with double precision coordinates.</para>
      </summary>
      <seealso cref="T:yWorks.Geometry.ISize" />
      <seealso cref="T:yWorks.Geometry.IOrientedRectangle" />
      <seealso cref="T:yWorks.Geometry.OrientedRectangle" />
    </member>
    <member name="P:yWorks.Geometry.IMutableOrientedRectangle.AnchorX">
      <summary>
        <para>Gets or sets the x coordinate for the anchor of the rectangle.</para>
      </summary>
      <remarks>
        <para>Implementations may adjust the coordinates internally, e.g. to automatically snap the coordinates to grid points. So depending on context the value that can be read might not necessarily be the exact same value that has just been written.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.IMutableOrientedRectangle.AnchorY">
      <summary>
        <para>Gets or sets the y coordinate for the anchor of the rectangle.</para>
      </summary>
      <remarks>
        <para>Implementations may adjust the coordinates internally, e.g. to automatically snap the coordinates to grid points. So depending on context the value that can be read might not necessarily be the exact same value that has just been written.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Geometry.IMutableOrientedRectangle.SetUpVector(System.Double,System.Double)">
      <summary>
        <para>Sets the orientation of this oriented rectangle by modifying the up vector components.</para>
      </summary>
      <remarks>
        <para>It is up to the caller to assure that the values describe a vector of length 1.</para>
      </remarks>
      <param name="upx">
        <para>The x component of the normalized up vector.</para>
      </param>
      <param name="upy">
        <para>The y component of the normalized up vector.</para>
      </param>
      <seealso cref="P:yWorks.Geometry.IOrientedRectangle.UpX" />
      <seealso cref="P:yWorks.Geometry.IOrientedRectangle.UpY" />
    </member>
    <member name="T:yWorks.Geometry.IMutablePoint">
      <summary>
        <para>Interface for a mutable point in 2D coordinate space with double precision coordinates.</para>
      </summary>
      <remarks>
        <para>This interface provides read and write access to the coordinates. It adds write access to the read only interface <see cref="T:yWorks.Geometry.IPoint" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.IPoint" />
      <seealso cref="T:yWorks.Geometry.MutablePoint" />
    </member>
    <member name="P:yWorks.Geometry.IMutablePoint.X">
      <summary>
        <para>Gets or sets the x coordinate for this point.</para>
      </summary>
      <remarks>
        <para>Implementations may adjust the coordinates internally, e.g. to automatically snap the coordinates to grid points. So depending on context the value that can be read might not necessarily be the exact same value that has just been written.</para>
      </remarks>
      <seealso cref="P:yWorks.Geometry.IPoint.X" />
    </member>
    <member name="P:yWorks.Geometry.IMutablePoint.Y">
      <summary>
        <para>Gets or sets the y coordinate for this point.</para>
      </summary>
      <remarks>
        <para>Implementations may adjust the coordinates internally, e.g. to automatically snap the coordinates to grid points. So depending on context the value that can be read might not necessarily be the exact same value that has just been written.</para>
      </remarks>
      <seealso cref="P:yWorks.Geometry.IPoint.Y" />
    </member>
    <member name="T:yWorks.Geometry.IMutableRectangle">
      <summary>
        <para>Interface for mutable rectangles aligned to the axes in 2D coordinate space with double precision coordinates.</para>
      </summary>
      <remarks>
        <para>This interface provides read and write access to the features of the rectangle. This interface does not declare any additional methods. It combines the <see cref="T:yWorks.Geometry.IMutablePoint" /> interface that describes the upper left corner of the rectangle with the <see cref="T:yWorks.Geometry.IMutableSize" /> interface that describes the width and height of the rectangle.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.ISize" />
      <seealso cref="T:yWorks.Geometry.IPoint" />
      <seealso cref="T:yWorks.Geometry.MutableRectangle" />
    </member>
    <member name="T:yWorks.Geometry.IMutableSize">
      <summary>
        <para>Interface for a mutable size in 2D coordinate space with double precision width and height.</para>
      </summary>
      <remarks>
        <para>This interface provides read and write access to the size. It extends the read only interface <see cref="T:yWorks.Geometry.ISize" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.ISize" />
      <seealso cref="T:yWorks.Geometry.MutableSize" />
    </member>
    <member name="P:yWorks.Geometry.IMutableSize.Width">
      <summary>
        <para>Gets or sets the width of this instance.</para>
      </summary>
      <remarks>
        <para>Implementations may adjust the values internally, e.g. to automatically snap the values to grid sizes. So depending on context the value that can be read might not necessarily be the exact same value that has just been written.</para>
      </remarks>
      <seealso cref="P:yWorks.Geometry.ISize.Width" />
    </member>
    <member name="P:yWorks.Geometry.IMutableSize.Height">
      <summary>
        <para>Gets or sets the height of this instance.</para>
      </summary>
      <remarks>
        <para>Implementations may adjust the values internally, e.g. to automatically snap the values to grid sizes. So depending on context the value that can be read might not necessarily be the exact same value that has just been written.</para>
      </remarks>
      <seealso cref="P:yWorks.Geometry.ISize.Height" />
    </member>
    <member name="T:yWorks.Geometry.IOrientedRectangle">
      <summary>
        <para>Interface for oriented rectangles in 2D coordinate space with double precision coordinates.</para>
      </summary>
      <remarks>
        <para>The rectangle described by this interface has its lower left corner at the anchor as described by the <see cref="P:yWorks.Geometry.IOrientedRectangle.AnchorX" /> and <see cref="P:yWorks.Geometry.IOrientedRectangle.AnchorY" /> properties and is oriented in space so that its upper left corner lies in direction of the (<see cref="P:yWorks.Geometry.IOrientedRectangle.UpX" />,<see cref="P:yWorks.Geometry.IOrientedRectangle.UpY" />) vector. The size of the instance does not describe the bounds of the instance but the lengths of the sides of the rectangle. An <see cref="T:yWorks.Geometry.IRectangle" /> would thus be an oriented rectangle, whose anchor is the lower left corner of the rectangle, whose size is the same as that of the rectangle and whose up vector is <c>(0,-1)</c>. This interface provides read access to the features of the oriented rectangle only, however this does not mean that an instance that implements <c>IOrientedRectangle</c> will always return the same values for its properties. Often times the instance provides a dynamic read access to the current state of a rectangle. It depends on the context whether it is allowed to or even necessary to copy the state of the properties or whether the reference to the instance should always be used to query the values.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.ISize" />
      <seealso cref="T:yWorks.Geometry.IRectangle" />
      <seealso cref="T:yWorks.Geometry.OrientedRectangle" />
      <seealso cref="T:yWorks.Geometry.MutableRectangle" />
    </member>
    <member name="P:yWorks.Geometry.IOrientedRectangle.AnchorX">
      <summary>
        <para>Gets the x coordinate of the anchor of the oriented rectangle.</para>
      </summary>
      <remarks>
        <para>The anchor is the lower left corner of the oriented rectangle if the up vector is <c>(0,-1)</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.IOrientedRectangle.AnchorY">
      <summary>
        <para>Gets the y coordinate of the anchor of the oriented rectangle.</para>
      </summary>
      <remarks>
        <para>The anchor is the lower left corner of the oriented rectangle if the up vector is <c>(0,-1)</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.IOrientedRectangle.UpX">
      <summary>
        <para>Gets the x value of the up vector.</para>
      </summary>
      <remarks>
        <para>The up vector points from the lower left corner to the upper left corner and is always normalized, i.e. it's length is always 1.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.IOrientedRectangle.UpY">
      <summary>
        <para>Gets the y value of the up vector.</para>
      </summary>
      <remarks>
        <para>The up vector points from the lower left corner to the upper left corner and is always normalized, i.e. it's length is always 1.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Geometry.IPoint">
      <summary>
        <para>Interface for a point in 2D coordinate space with double precision coordinates.</para>
      </summary>
      <remarks>
        <para>This interface provides read access to the coordinates only, however this does not mean that an instance that implements <c>IPoint</c> will always return the same values for the coordinate properties. Often times the instance provides a dynamic read access to the current state of a point. It depends on the context whether it is allowed to or even necessary to copy the state of the properties or whether the reference to the instance should always be used to query the values.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.IMutablePoint" />
      <seealso cref="T:yWorks.Geometry.MutablePoint" />
    </member>
    <member name="P:yWorks.Geometry.IPoint.X">
      <summary>
        <para>Gets the current x coordinate of this point.</para>
      </summary>
      <remarks>
        <para>Depending on context the values returned may change over time.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.IPoint.Y">
      <summary>
        <para>Gets the current y coordinate of this point.</para>
      </summary>
      <remarks>
        <para>Depending on context the values returned may change over time.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Geometry.IRectangle">
      <summary>
        <para>Interface for rectangles aligned to the axes in 2D coordinate space with double precision coordinates.</para>
      </summary>
      <remarks>
        <para>This interface provides read access to the features of the rectangle only, however this does not mean that an instance that implements <c>IRectangle</c> will always return the same values for its properties. Often times the instance provides a dynamic read access to the current state of a rectangle. It depends on the context whether it is allowed to or even necessary to copy the state of the properties or whether the reference to the instance should always be used to query the values. This interface does not declare any additional methods. It combines the <see cref="T:yWorks.Geometry.IPoint" /> interface that describes the upper left corner of the rectangle with the <see cref="T:yWorks.Geometry.ISize" /> interface that describes the width and height of the rectangle.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.IMutableRectangle" />
      <seealso cref="T:yWorks.Geometry.IMutablePoint" />
      <seealso cref="T:yWorks.Geometry.ISize" />
      <seealso cref="T:yWorks.Geometry.IPoint" />
      <seealso cref="T:yWorks.Geometry.MutableRectangle" />
    </member>
    <member name="T:yWorks.Geometry.ISize">
      <summary>
        <para>Interface for an object that has a size in 2D coordinate space with double precision floating point size values.</para>
      </summary>
      <remarks>
        <para>This interface provides read access to the size only, however this does not mean that an instance that implements <c>ISize</c> will always return the same values for the size properties. Often times the instance provides a dynamic read access to the current state of an instance. It depends on the context whether it is allowed to or even necessary to copy the state of the properties or whether the reference to the instance should always be used to query the values.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.IMutableSize" />
      <seealso cref="T:yWorks.Geometry.MutableSize" />
    </member>
    <member name="P:yWorks.Geometry.ISize.Width">
      <summary>
        <para>Gets the current width of this instance.</para>
      </summary>
      <remarks>
        <para>Depending on context the values returned may change over time.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.ISize.Height">
      <summary>
        <para>Gets the current height of this instance.</para>
      </summary>
      <remarks>
        <para>Depending on context the values returned may change over time.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Geometry.MatrixOrder">
      <summary>
        <para>Enumeration constant for use in <see cref="T:yWorks.Geometry.Matrix2D" /> operations.</para>
      </summary>
    </member>
    <member name="F:yWorks.Geometry.MatrixOrder.Prepend">
      <summary>
        <para>Constant that defines a prepend operation for matrix multiplications.</para>
      </summary>
      <remarks>
        <para>Prepending a matrix <b>T</b> to another matrix <b>M</b> results in the operation <b>M</b>′ = <b>M</b> <b>T</b>. Essentially, this means that <b>T</b> is applied before <b>M</b> when applying <b>M</b>′ to a vector.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Geometry.MatrixOrder.Append">
      <summary>
        <para>Constant that defines an append operation for matrix multiplications.</para>
      </summary>
      <remarks>
        <para>Appending a matrix <b>T</b> to another matrix <b>M</b> results in the operation <b>M</b>′ = <b>T</b> <b>M</b>. Essentially, this means that <b>T</b> is applied after <b>M</b> when applying <b>M</b>′ to a vector.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Geometry.Matrix2D">
      <summary>
        <para>A very simple <see cref="T:System.Drawing.Drawing2D.Matrix" /> replacement class, that offers better performance for many use cases.</para>
      </summary>
      <remarks>
        <para>The matrix is interpreted row-major. The rows are defined as follows: [ m11 m12 dx ], [ m21 m22 dy ], ([ 0 0 1 ] implicitly).</para>
        <para>When transforming a vector <b>v</b> using this matrix, the multiplication is done in this order: <b>v</b>' = <b>M</b> <b>v</b>.</para>
        <para>
          <see cref="F:yWorks.Geometry.MatrixOrder.Prepend">Prepending</see> a matrix <b>T</b> to this instance results in the operation <b>M</b>′ = <b>M</b> <b>T</b>. In concept, this means that <b>T</b> is applied before <b>M</b> when applying <b>M</b>' to a vector. <see cref="F:yWorks.Geometry.MatrixOrder.Append">Appending</see> <b>T</b> to <b>M</b> results in <b>M</b>′ = <b>T</b> <b>M</b>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.#ctor">
      <summary>
        <para>Create an identity matrix.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Create a matrix using the provided matrix entries.</para>
      </summary>
      <param name="m11" />
      <param name="m12" />
      <param name="m21" />
      <param name="m22" />
      <param name="dx" />
      <param name="dy" />
    </member>
    <member name="P:yWorks.Geometry.Matrix2D.Elements">
      <summary>
        <para>Gets a new double[] of the elements describing the matrix.</para>
      </summary>
      <remarks>
        <para>The order is m11, m12, m21, m22, dx, dy.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Transform(yWorks.Geometry.PointD)">
      <summary>
        <para>Transforms the given coordinate.</para>
      </summary>
      <param name="point">
        <para>The coordinate to transform.</para>
      </param>
      <returns>
        <para>The transformed coordinates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Transform``1(``0)">
      <summary>
        <para>Transforms the given point in place.</para>
      </summary>
      <param name="point">
        <para>The point to transform and return.</para>
      </param>
      <returns>
        <para>
          <paramref name="point" />
        </para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Translate(yWorks.Geometry.PointD,yWorks.Geometry.MatrixOrder)">
      <summary>
        <para>Appends or Prepends a translation to this instance.</para>
      </summary>
      <param name="delta" />
      <param name="order" />
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Reset">
      <summary>
        <para>Resets this instance to the identity.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Set(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Sets all elements of this instance.</para>
      </summary>
      <param name="m0" />
      <param name="m1" />
      <param name="m2" />
      <param name="m3" />
      <param name="dx" />
      <param name="dy" />
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Clone">
      <summary>
        <para>Clones this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Transform(System.Drawing.PointF@)">
      <summary>
        <para>Transforms the given point in place.</para>
      </summary>
      <param name="point" />
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Transform(System.Drawing.PointF[])">
      <summary>
        <para>Transforms all of the points in place.</para>
      </summary>
      <param name="point">
        <para>The points to transform.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Invert">
      <summary>
        <para>Inverts this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Set(System.Drawing.Drawing2D.Matrix)">
      <summary>
        <para>Sets the values of the given matrix to this instance.</para>
      </summary>
      <param name="matrix" />
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Set(yWorks.Geometry.Matrix2D)">
      <summary>
        <para>Sets the values of the given matrix to this instance.</para>
      </summary>
      <param name="matrix" />
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.op_Explicit(System.Drawing.Drawing2D.Matrix)~yWorks.Geometry.Matrix2D">
      <summary>
        <para>Converts the given matrix to a matrix of this type.</para>
      </summary>
      <param name="m" />
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.op_Explicit(yWorks.Geometry.Matrix2D)~System.Drawing.Drawing2D.Matrix">
      <summary>
        <para>Converts a given matrix of this type to a .net matrix.</para>
      </summary>
      <param name="m" />
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Scale(System.Double,System.Double,yWorks.Geometry.MatrixOrder)">
      <summary>
        <para>Appends or prepends a scale operation to this instance.</para>
      </summary>
      <param name="x" />
      <param name="y" />
      <param name="order" />
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.CreateRotateInstance(System.Double)">
      <summary>
        <para>Creates a matrix rotation instance around the origin.</para>
      </summary>
      <param name="theta">
        <para>The rotation angle in radians.</para>
      </param>
      <returns>
        <para>A new matrix.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Rotate(System.Double)">
      <summary>
        <para>Prepends a rotate operation to this matrix.</para>
      </summary>
      <param name="theta">
        <para>The angle to rotate in radians.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Rotate(System.Double,yWorks.Geometry.PointD,yWorks.Geometry.MatrixOrder)">
      <summary>
        <para>Prepends or appends a rotation operation to this matrix around the specified rotation center.</para>
      </summary>
      <param name="theta">
        <para>The rotation angle in radians</para>
      </param>
      <param name="center">
        <para>The coordinate of the center of the rotation.</para>
      </param>
      <param name="order">
        <para>Whether to append or prepend the rotation matrix.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Rotate(System.Double,yWorks.Geometry.MatrixOrder)">
      <summary>
        <para>Prepends or appends a rotation operation to this matrix around the origin.</para>
      </summary>
      <param name="theta">
        <para>The rotation angle in radians</para>
      </param>
      <param name="order">
        <para>Whether to append or prepend the rotation matrix.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Multiply(yWorks.Geometry.Matrix2D,yWorks.Geometry.MatrixOrder)">
      <summary>
        <para>Multiplies this matrix instance by the given instance using the given order.</para>
      </summary>
      <param name="matrix">
        <para>The matrix to multiply with this one.</para>
      </param>
      <param name="order">
        <para>The order of the multiplication.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Equals(yWorks.Geometry.Matrix2D)">
      <param name="other" />
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.Equals(System.Object)">
      <param name="obj" />
    </member>
    <member name="M:yWorks.Geometry.Matrix2D.GetHashCode" />
    <member name="T:yWorks.Geometry.MutablePoint">
      <summary>
        <para>A simple default implementation of a mutable point in 2D coordinate space with double precision coordinates.</para>
      </summary>
      <remarks>
        <para>This implementation stores the values of the coordinates in double precision floating point members. As a convenience it implements the <see cref="T:System.ICloneable" /> interface.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.IPoint" />
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.#ctor">
      <summary>
        <para>Creates the point with initially <c>0.0d</c> values for <see cref="P:yWorks.Geometry.MutablePoint.X" /> and <see cref="P:yWorks.Geometry.MutablePoint.Y" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.#ctor(yWorks.Geometry.IPoint)">
      <summary>
        <para>Creates an instance using the given coordinate pair.</para>
      </summary>
      <param name="point">
        <para>The coordinate.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates an instance using the given coordinate pair.</para>
      </summary>
      <param name="x">
        <para>The x coordinate</para>
      </param>
      <param name="y">
        <para>The y coordinate</para>
      </param>
    </member>
    <member name="P:yWorks.Geometry.MutablePoint.X">
      <summary>
        <para>Gets or sets the x coordinate.</para>
      </summary>
    </member>
    <member name="P:yWorks.Geometry.MutablePoint.Y">
      <summary>
        <para>Gets or sets the y coordinate.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.Normalize">
      <summary>
        <para>Normalizes this point as if it was a vector.</para>
      </summary>
      <remarks>
        <para>After this the "length" of this point is <c>1.0d</c> if it is treated as a vector.</para>
      </remarks>
      <seealso cref="P:yWorks.Geometry.PointD.Normalized" />
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.Clone">
      <summary>
        <para>Returns a clone of this instance.</para>
      </summary>
      <returns>
        <para>An instance of <see cref="T:yWorks.Geometry.MutablePoint" /> initialized to the current state of this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.ToString" />
    <member name="M:yWorks.Geometry.MutablePoint.ToPoint">
      <summary>
        <para>Creates a <see cref="T:System.Drawing.PointF" /> initialized using the current state of this instance.</para>
      </summary>
      <returns>
        <para>A new <see cref="T:System.Drawing.PointF" /> instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.op_Explicit(System.Drawing.PointF)~yWorks.Geometry.MutablePoint">
      <summary>
        <para>A casting operator that creates a new instance of <see cref="T:yWorks.Geometry.MutablePoint" /> using the current state of the point that is cast.</para>
      </summary>
      <remarks>
        <para>Unlike true casting this will create a new instance that will be initialized to the current state of the object being cast, but which will not stay in sync with the state of the object.</para>
      </remarks>
      <param name="point">
        <para>the point to get the current state from</para>
      </param>
      <returns>
        <para>A new instance of <see cref="T:yWorks.Geometry.MutablePoint" /> that holds no reference to the point provided.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.op_Explicit(yWorks.Geometry.MutablePoint)~System.Drawing.PointF">
      <summary>
        <para>A casting operator that creates a new instance of <see cref="T:System.Drawing.PointF" /> using the current state of this point.</para>
      </summary>
      <remarks>
        <para>Unlike true casting this will create a new instance that will be initialized to the current state of the object being cast, but which will not stay in sync with the state of the object.</para>
      </remarks>
      <param name="point">
        <para>the point to get the current state from</para>
      </param>
      <returns>
        <para>A new instance of <see cref="T:System.Drawing.PointF" /> that holds no reference to the point being cast.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.MoveBy(yWorks.Geometry.PointD)">
      <summary>
        <para>Moves this instance by adding the provided offsets to the coordinates of this point.</para>
      </summary>
      <param name="delta">
        <para>The offset to add to this point's x coordinate</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.Equals(yWorks.Geometry.MutablePoint)">
      <param name="other" />
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.Equals(System.Object)">
      <param name="other" />
    </member>
    <member name="M:yWorks.Geometry.MutablePoint.GetHashCode" />
    <member name="T:yWorks.Geometry.MutableRectangle">
      <summary>
        <para>A simple default implementation of a mutable rectangle in 2D coordinate space with double precision values stored in an instance of <see cref="T:yWorks.Geometry.IMutablePoint" /> and <see cref="T:yWorks.Geometry.IMutableSize" />.</para>
      </summary>
      <remarks>
        <para>This implementation delegates the storage to implementations of <see cref="T:yWorks.Geometry.IMutablePoint" /> for the upper left corner of the rectangle and <see cref="T:yWorks.Geometry.IMutableSize" /> for the size of the rectangle. members. As a convenience it implements the <see cref="T:yWorks.Geometry.IOrientedRectangle" />, and the <see cref="T:System.ICloneable" /> interfaces.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.IRectangle" />
      <seealso cref="T:yWorks.Geometry.IMutableRectangle" />
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.op_Explicit(System.Drawing.RectangleF)~yWorks.Geometry.MutableRectangle">
      <summary>
        <para>A casting operator that creates a new instance of <see cref="T:yWorks.Geometry.MutableRectangle" /> using the current state of the rectangle that is cast.</para>
      </summary>
      <remarks>
        <para>Unlike true casting this will create a new instance that will be initialized to the current state of the object being cast, but which will not stay in sync with the state of the object.</para>
      </remarks>
      <param name="rect">
        <para>the rectangle to get the current state from</para>
      </param>
      <returns>
        <para>A new instance of <see cref="T:yWorks.Geometry.MutableRectangle" /> that holds no reference to the rectangle provided.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.op_Explicit(yWorks.Geometry.MutableRectangle)~System.Drawing.RectangleF">
      <summary>
        <para>A casting operator that creates a new instance of <see cref="T:System.Drawing.RectangleF" /> using the current state of the rectangle that is cast.</para>
      </summary>
      <remarks>
        <para>Unlike true casting this will create a new instance that will be initialized to the current state of the object being cast, but which will not stay in sync with the state of the object.</para>
      </remarks>
      <param name="rect">
        <para>the rectangle to get the current state from</para>
      </param>
      <returns>
        <para>A new instance of <see cref="T:System.Drawing.RectangleF" /> that holds no reference to the rectangle provided.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.op_Explicit(yWorks.Geometry.MutableRectangle)~System.Drawing.SizeF">
      <summary>
        <para>A casting operator that creates a new instance of <see cref="T:System.Drawing.SizeF" /> using the current size of the rectangle that is cast.</para>
      </summary>
      <remarks>
        <para>Unlike true casting this will create a new instance that will be initialized to the current state of the object being cast, but which will not stay in sync with the state of the object.</para>
      </remarks>
      <param name="rect">
        <para>the rectangle to get the current state from</para>
      </param>
      <returns>
        <para>A new instance of <see cref="T:System.Drawing.SizeF" /> initialized to the size of the rectangle that holds no reference to the rectangle provided.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.#ctor(yWorks.Geometry.IMutablePoint,yWorks.Geometry.IMutableSize)">
      <summary>
        <para>Creates a new instance using the provided implementation for the storage of the position and size of the rectangle.</para>
      </summary>
      <remarks>
        <para>The instances provided will be referenced by this instance. This instance will be used as a live view over the provided instances. Changes to them will indirectly change the state of this instance and changes applied through this instance will be written to the referenced implementations.</para>
      </remarks>
      <param name="location">
        <para>The provider for the dynamic position of this instance.</para>
      </param>
      <param name="size">
        <para>The provider for the dynamic size of this instance.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new instance using the provided values to initialize the position and size.</para>
      </summary>
      <remarks>
        <para>An instance of <see cref="T:yWorks.Geometry.MutablePoint" /> will be used to store the position and an instance of <see cref="P:yWorks.Geometry.MutableRectangle.Size" /> will be used to store the size.</para>
      </remarks>
      <param name="x">
        <para>The x coordinate of the upper left corner of the rectangle.</para>
      </param>
      <param name="y">
        <para>The y coordinate of the upper left corner of the rectangle.</para>
      </param>
      <param name="width">
        <para>The width of the rectangle.</para>
      </param>
      <param name="height">
        <para>The height of the rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.#ctor(yWorks.Geometry.PointD,yWorks.Geometry.SizeD)">
      <summary>
        <para>Creates a new instance using the provided values to initialize the position and size.</para>
      </summary>
      <remarks>
        <para>An instance of <see cref="T:yWorks.Geometry.MutablePoint" /> will be used to store the position and an instance of <see cref="P:yWorks.Geometry.MutableRectangle.Size" /> will be used to store the size.</para>
      </remarks>
      <param name="location">
        <para>The coordinates of the upper left corner of the rectangle.</para>
      </param>
      <param name="size">
        <para>The size of the rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.#ctor">
      <summary>
        <para>Creates a new empty instance located at the origin with width and height set to <c>-1</c>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.#ctor(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Creates a new instance initialized to the values of the provided argument.</para>
      </summary>
      <param name="rectangle" />
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.IsEmpty">
      <summary>
        <para>Gets whether this instance has negative width or height.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.Clone">
      <summary>
        <para>Creates a copy of the current state of this instance using a new <see cref="T:yWorks.Geometry.MutablePoint" /> and <see cref="P:yWorks.Geometry.MutableRectangle.Size" /> to store the position and size.</para>
      </summary>
      <returns>
        <para>A new instance of <see cref="T:yWorks.Geometry.MutableRectangle" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.ToString" />
    <member name="P:yWorks.Geometry.MutableRectangle.Location">
      <summary>
        <para>Gets the position of this rectangle.</para>
      </summary>
      <remarks>
        <para>This will return a live view of the position of this rectangle. However setting a position instance will only copy the values of the point provided to the current position.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.Size">
      <summary>
        <para>Gets the size of this rectangle.</para>
      </summary>
      <remarks>
        <para>This will return a live view of the size of this rectangle. However setting a size instance will only copy the values of the size provided to the current size.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.Width">
      <summary>
        <para>Gets or sets the width of this instance from the <see cref="P:yWorks.Geometry.MutableRectangle.Size" /> instance.</para>
      </summary>
      <remarks>
        <para>Note that depending on the implementation used for holding the size the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.Height">
      <summary>
        <para>Gets or sets the height of this instance from the <see cref="P:yWorks.Geometry.MutableRectangle.Size" /> instance.</para>
      </summary>
      <remarks>
        <para>Note that that depending on the implementation used for holding the size the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.X">
      <summary>
        <para>Gets or sets the x coordinate of the upper left corner of this instance from the <see cref="P:yWorks.Geometry.MutableRectangle.Location" /> instance.</para>
      </summary>
      <remarks>
        <para>Note that depending on the implementation used for holding the position the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.Y">
      <summary>
        <para>Gets or sets the y coordinate of the upper left corner of this instance from the <see cref="P:yWorks.Geometry.MutableRectangle.Location" /> instance.</para>
      </summary>
      <remarks>
        <para>Note that depending on the implementation used for holding the position the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.X2">
      <summary>
        <para>Gets or sets the x coordinate of the lower right corner of this instance using the <see cref="P:yWorks.Geometry.MutableRectangle.Location" /> and <see cref="P:yWorks.Geometry.MutableRectangle.Size" /> instances.</para>
      </summary>
      <remarks>
        <para>Setting this value will update the width accordingly. Note that depending on the implementation used for holding the <see cref="P:yWorks.Geometry.MutableRectangle.Size" /> the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.Y2">
      <summary>
        <para>Gets or sets the y coordinate of the lower right corner of this instance using the <see cref="P:yWorks.Geometry.MutableRectangle.Location" /> and <see cref="P:yWorks.Geometry.MutableRectangle.Size" /> instances.</para>
      </summary>
      <remarks>
        <para>Setting this value will update the height accordingly. Note that depending on the implementation used for holding the <see cref="P:yWorks.Geometry.MutableRectangle.Size" /> the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.AnchorX">
      <summary>
        <para>Gets the x coordinate of the <see cref="P:yWorks.Geometry.MutableRectangle.Location" />.</para>
      </summary>
      <remarks>
        <para>This implementation behaves like an <see cref="T:yWorks.Geometry.IOrientedRectangle" /> that is anchored at the lower left corner of this rectangle and whose up vector is (0, -1).</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.AnchorY">
      <summary>
        <para>Gets the y coordinate of the <see cref="P:yWorks.Geometry.MutableRectangle.Location" /> plus the <see cref="P:yWorks.Geometry.ISize.Height" />.</para>
      </summary>
      <remarks>
        <para>This implementation behaves like an <see cref="T:yWorks.Geometry.IOrientedRectangle" /> that is anchored at the lower left corner of this rectangle and whose up vector is (0, -1).</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.UpX">
      <summary>
        <para>Gets the x value of the up vector which is always <c>0</c></para>
      </summary>
      <remarks>
        <para>This implementation behaves like an <see cref="T:yWorks.Geometry.IOrientedRectangle" /> that is anchored at the lower left corner of this rectangle and whose up vector is (0, -1).</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.MutableRectangle.UpY">
      <summary>
        <para>Gets the y value of the up vector which is always <c>-1</c></para>
      </summary>
      <remarks>
        <para>This implementation behaves like an <see cref="T:yWorks.Geometry.IOrientedRectangle" /> that is anchored at the lower left corner of this rectangle and whose up vector is (0, -1).</para>
      </remarks>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.MoveBy(yWorks.Geometry.PointD)">
      <summary>
        <para>Moves this rectangle by applying the offset to the <see cref="P:yWorks.Geometry.MutableRectangle.Location" /></para>
      </summary>
      <param name="delta">
        <para>The offset to move the rectangle's position by.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.Equals(System.Object)">
      <param name="other" />
    </member>
    <member name="M:yWorks.Geometry.MutableRectangle.GetHashCode" />
    <member name="M:yWorks.Geometry.MutableRectangle.Equals(yWorks.Geometry.MutableRectangle)">
      <param name="other" />
    </member>
    <member name="T:yWorks.Geometry.MutableSize">
      <summary>
        <para>A simple default implementation of a mutable size in 2D coordinate space with double precision values.</para>
      </summary>
      <remarks>
        <para>This implementation stores the values of the width and height in double precision floating point members. As a convenience it implements the <see cref="T:System.ICloneable" /> interface.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.ISize" />
    </member>
    <member name="M:yWorks.Geometry.MutableSize.#ctor(yWorks.Geometry.ISize)">
      <summary>
        <para>Creates an instance using the values provided by the size instance.</para>
      </summary>
      <remarks>
        <para>This will not create a dynamic instance. The values will be copied from <paramref name="size" /> immediately and no reference is held to that instance thereafter.</para>
      </remarks>
      <param name="size">
        <para>A size to retrieve the initial values from.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.MutableSize.#ctor">
      <summary>
        <para>Creates the initially empty size, that is both <see cref="P:yWorks.Geometry.MutableSize.Width" /> and <see cref="P:yWorks.Geometry.MutableSize.Height" /> are <c>0.0d</c>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.MutableSize.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates an instance using the given width and height.</para>
      </summary>
      <param name="width">
        <para>The width.</para>
      </param>
      <param name="height">
        <para>The height</para>
      </param>
    </member>
    <member name="P:yWorks.Geometry.MutableSize.Width">
      <summary>
        <para>Gets or sets the width.</para>
      </summary>
    </member>
    <member name="P:yWorks.Geometry.MutableSize.Height">
      <summary>
        <para>Gets or sets the height.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.MutableSize.Clone">
      <summary>
        <para>Returns a memberwise clone of this instance.</para>
      </summary>
      <returns>
        <para>A clone that holds the same state initially as the current state of this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutableSize.op_Explicit(System.Drawing.SizeF)~yWorks.Geometry.MutableSize">
      <summary>
        <para>A casting operator that creates a new instance of <see cref="T:yWorks.Geometry.MutableSize" /> using the current state of the size that is cast.</para>
      </summary>
      <remarks>
        <para>Unlike true casting this will create a new instance that will be initialized to the current state of the object being cast, but which will not stay in sync with the state of the object.</para>
      </remarks>
      <param name="size">
        <para>the size to get the current state from</para>
      </param>
      <returns>
        <para>A new instance of <see cref="T:yWorks.Geometry.MutableSize" /> that holds no reference to the size provided.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutableSize.op_Explicit(yWorks.Geometry.MutableSize)~System.Drawing.SizeF">
      <summary>
        <para>A casting operator that creates a new instance of <see cref="T:System.Drawing.SizeF" /> using the current state of this size.</para>
      </summary>
      <remarks>
        <para>Unlike true casting this will create a new instance that will be initialized to the current state of the object being cast, but which will not stay in sync with the state of the object.</para>
      </remarks>
      <param name="size">
        <para>the size to get the current state from</para>
      </param>
      <returns>
        <para>A new instance of <see cref="T:System.Drawing.SizeF" /> that holds no reference to the size being cast.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.MutableSize.Equals(yWorks.Geometry.MutableSize)">
      <param name="other" />
    </member>
    <member name="M:yWorks.Geometry.MutableSize.Equals(System.Object)">
      <param name="other" />
    </member>
    <member name="M:yWorks.Geometry.MutableSize.GetHashCode" />
    <member name="T:yWorks.Geometry.OrientedRectangle">
      <summary>
        <para>A simple default implementation of a mutable oriented rectangle in 2D coordinate space with double precision values stored in an instance of <see cref="T:yWorks.Geometry.IMutablePoint" /> and <see cref="T:yWorks.Geometry.IMutableSize" /> as well as two doubles for the up vector components.</para>
      </summary>
      <remarks>
        <para>This implementation delegates the storage to implementations of <see cref="T:yWorks.Geometry.IMutablePoint" /> for the anchor of the oriented rectangle. and <see cref="T:yWorks.Geometry.IMutableSize" /> for the size of the oriented rectangle. members. As a convenience it implements the <see cref="T:yWorks.Geometry.IMutablePoint" /> and the <see cref="T:System.ICloneable" /> interfaces.</para>
      </remarks>
      <seealso cref="T:yWorks.Geometry.IOrientedRectangle" />
      <seealso cref="T:yWorks.Geometry.IMutableOrientedRectangle" />
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.op_Explicit(System.Drawing.RectangleF)~yWorks.Geometry.OrientedRectangle">
      <summary>
        <para>A casting operator that creates a new instance of <see cref="T:yWorks.Geometry.OrientedRectangle" /> using the current state of the rectangle that is cast.</para>
      </summary>
      <remarks>
        <para>The anchor will be set to the lower left corner of the provided rectangle. Thus this instance will have the exact same bounds as the rectangle initially. The up vector will be initialized to <c>(0, -1)</c>. Unlike true casting this will create a new instance that will be initialized to the current state of the object being cast, but which will not stay in sync with the state of the object.</para>
      </remarks>
      <param name="rect">
        <para>the rectangle to get the current state from</para>
      </param>
      <returns>
        <para>A new instance of <see cref="T:yWorks.Geometry.OrientedRectangle" /> that holds no reference to the provided rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.Clone">
      <summary>
        <para>Creates a copy of the current state of this instance using a new <see cref="T:yWorks.Geometry.MutablePoint" /> and <see cref="P:yWorks.Geometry.OrientedRectangle.Size" /> to store the anchor and size.</para>
      </summary>
      <returns>
        <para>A new instance of <see cref="T:yWorks.Geometry.OrientedRectangle" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.op_Explicit(yWorks.Geometry.OrientedRectangle)~System.Drawing.SizeF">
      <summary>
        <para>A casting operator that creates a new instance of <see cref="T:System.Drawing.SizeF" /> using the current size of the oriented rectangle that is cast.</para>
      </summary>
      <remarks>
        <para>Unlike true casting this will create a new instance that will be initialized to the current state of the object being cast, but which will not stay in sync with the state of the object.</para>
      </remarks>
      <param name="rect">
        <para>the rectangle to get the current <see cref="P:yWorks.Geometry.OrientedRectangle.Size" /> from</para>
      </param>
      <returns>
        <para>A new instance of <see cref="T:System.Drawing.SizeF" /> initialized to the size of the rectangle that holds no reference to the rectangle provided.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.#ctor(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Creates a new instance using the provided rectangle to initialize the anchor and size.</para>
      </summary>
      <remarks>
        <para>The anchor will be set to the lower left corner of the provided rectangle. Thus this instance will have the exact same bounds as the rectangle initially. The up vector will be initialized to <c>(0, -1)</c>.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to initialize the anchor and size from.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.#ctor(yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Creates a new instance using the provided values to initialize.</para>
      </summary>
      <remarks>
        <para>This will basically create a copy of the given rectangle</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to initialize the anchor and size and up vector from.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.#ctor(yWorks.Geometry.IMutablePoint,yWorks.Geometry.IMutableSize)">
      <summary>
        <para>Creates a new instance using the provided values to initialize the anchor and size.</para>
      </summary>
      <remarks>
        <para>The up vector will be initialized to <c>(0, -1)</c>. The instances provided will be referenced by this instance. This instance will be used as a live view over the provided instances. Changes to them will indirectly change the state of this instance and changes applied through this instance will be written to the referenced implementations.</para>
      </remarks>
      <param name="anchor">
        <para>The provider for the dynamic anchor of this instance.</para>
      </param>
      <param name="size">
        <para>The provider for the dynamic size of this instance.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Geometry.OrientedRectangle" /> class located at <c>0.0d,0.0d</c> with empty width and height (<c>-1.0d</c>).</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new instance using the provided values to initialize the anchor and size.</para>
      </summary>
      <remarks>
        <para>It is up to the caller to ensure that the up vector is normalized.</para>
      </remarks>
      <param name="anchorX">
        <para>The x coordinate of the anchor of the oriented rectangle.</para>
      </param>
      <param name="anchorY">
        <para>The y coordinate of the anchor of the oriented rectangle.</para>
      </param>
      <param name="width">
        <para>The width of the rectangle.</para>
      </param>
      <param name="height">
        <para>The height of the rectangle.</para>
      </param>
      <param name="upX">
        <para>The x component of the up vector.</para>
      </param>
      <param name="upY">
        <para>The y component of the up vector.</para>
      </param>
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.IsEmpty">
      <summary>
        <para>Gets whether this instance has negative width or height.</para>
      </summary>
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.Anchor">
      <summary>
        <para>Gets or sets the anchor of this oriented rectangle.</para>
      </summary>
      <remarks>
        <para>This will return a live view of the anchor of this rectangle. However setting an anchor instance will only copy the values of the point provided to the current anchor.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.Size">
      <summary>
        <para>Gets or sets the size of this rectangle.</para>
      </summary>
      <remarks>
        <para>This will return a live view of the size of this rectangle. However setting a size instance will only copy the values of the size provided to the current size.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.Width">
      <summary>
        <para>Gets or sets the width of this instance from the <see cref="P:yWorks.Geometry.OrientedRectangle.Size" /> instance.</para>
      </summary>
      <remarks>
        <para>Note that depending on the implementation used for holding the size the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.Height">
      <summary>
        <para>Gets or sets the height of this instance from the <see cref="P:yWorks.Geometry.OrientedRectangle.Size" /> instance.</para>
      </summary>
      <remarks>
        <para>Note that that depending on the implementation used for holding the size the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.X">
      <summary>
        <para>Gets or sets the x coordinate of the anchor of this instance from the <see cref="P:yWorks.Geometry.OrientedRectangle.Anchor" /> instance.</para>
      </summary>
      <remarks>
        <para>Note that depending on the implementation used for holding the anchor the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.Y">
      <summary>
        <para>Gets or sets the y coordinate of the anchor of this instance from the <see cref="P:yWorks.Geometry.OrientedRectangle.Anchor" /> instance.</para>
      </summary>
      <remarks>
        <para>Note that depending on the implementation used for holding the anchor the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.AnchorX">
      <summary>
        <para>Gets or sets the x coordinate of the anchor of this instance from the <see cref="P:yWorks.Geometry.OrientedRectangle.Anchor" /> instance.</para>
      </summary>
      <remarks>
        <para>Note that depending on the implementation used for holding the anchor the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.AnchorY">
      <summary>
        <para>Gets or sets the y coordinate of the anchor of this instance from the <see cref="P:yWorks.Geometry.OrientedRectangle.Anchor" /> instance.</para>
      </summary>
      <remarks>
        <para>Note that depending on the implementation used for holding the anchor the results may vary. However the default implementation will do just that: read and write the values without modifying them in any way.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.SetUpVector(System.Double,System.Double)">
      <summary>
        <para>Sets the components of the up vector to the new values.</para>
      </summary>
      <remarks>
        <para>It is up to the caller to assure that the values describe a vector of length 1.</para>
      </remarks>
      <param name="upx">
        <para>The x component of the normalized up vector.</para>
      </param>
      <param name="upy">
        <para>The y component of the normalized up vector.</para>
      </param>
      <seealso cref="P:yWorks.Geometry.OrientedRectangle.Angle" />
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.UpX">
      <summary>
        <para>Gets or sets the x component of the up vector to the new value.</para>
      </summary>
      <remarks>
        <para>It is up to the caller to assure that the values describe a vector of length 1.</para>
      </remarks>
      <seealso cref="P:yWorks.Geometry.OrientedRectangle.Angle" />
      <seealso cref="M:yWorks.Geometry.OrientedRectangle.SetUpVector(System.Double,System.Double)" />
      <seealso cref="P:yWorks.Geometry.OrientedRectangle.UpY" />
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.UpY">
      <summary>
        <para>Gets or sets the y component of the up vector to the new value.</para>
      </summary>
      <remarks>
        <para>It is up to the caller to assure that the values describe a vector of length 1.</para>
      </remarks>
      <seealso cref="P:yWorks.Geometry.OrientedRectangle.Angle" />
      <seealso cref="M:yWorks.Geometry.OrientedRectangle.SetUpVector(System.Double,System.Double)" />
      <seealso cref="P:yWorks.Geometry.OrientedRectangle.UpX" />
    </member>
    <member name="P:yWorks.Geometry.OrientedRectangle.Angle">
      <summary>
        <para>Gets or sets the orientation of this rectangle.</para>
      </summary>
      <remarks>
        <para>The angle is specified in radians. An angle of <c>0</c> means the up vector points up in direction <c>(0,-1)</c>. The angle value is not stored and will be recalculated from <see cref="P:yWorks.Geometry.OrientedRectangle.UpX" /> and <see cref="P:yWorks.Geometry.OrientedRectangle.UpY" /> every time this is invoked, so this is a costly method. Setting the angle changes the <see cref="P:yWorks.Geometry.OrientedRectangle.UpX" /> and <see cref="P:yWorks.Geometry.OrientedRectangle.UpY" /> values accordingly.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.MoveBy(yWorks.Geometry.PointD)">
      <summary>
        <para>Moves this rectangle by applying the offset to the <see cref="P:yWorks.Geometry.OrientedRectangle.Anchor" /></para>
      </summary>
      <param name="delta">
        <para>The offset to move the rectangle's anchor by.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.Reshape(yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Applies the values provided by the given instance to the values of this instance.</para>
      </summary>
      <param name="rectangle">
        <para>The instance to retrieve the values from.</para>
      </param>
    </member>
    <member name="F:yWorks.Geometry.OrientedRectangle.Empty">
      <summary>
        <para>An immutable empty <see cref="T:yWorks.Geometry.IOrientedRectangle" /> with width and height of <c>-1</c>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.CreateImmutable(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates an immutable <see cref="T:yWorks.Geometry.IOrientedRectangle" /> with the given values.</para>
      </summary>
      <param name="anchorX" />
      <param name="anchorY" />
      <param name="width" />
      <param name="height" />
      <param name="upX" />
      <param name="upY" />
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.Equals(System.Object)">
      <summary>
        <para>Implements the equals method by comparing the given object's values.</para>
      </summary>
      <remarks>
        <para>Note that only instances of this type and the ones returned by the factory methods of this type can be equal to each other.</para>
      </remarks>
      <seealso cref="T:System.IEquatable`1" />
      <param name="other">
        <para>The other instance to compare the values against.</para>
      </param>
      <returns>
        <para>Whether the other instance is of this type or the immutable types created by this class and whether their values are the same as for this type.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.GetHashCode">
      <summary>
        <para>Yields a hash code for this type based on the values of <see cref="P:yWorks.Geometry.OrientedRectangle.UpX" />, <see cref="P:yWorks.Geometry.OrientedRectangle.UpY" />, <see cref="P:yWorks.Geometry.OrientedRectangle.Width" />, <see cref="P:yWorks.Geometry.OrientedRectangle.AnchorX" />, <see cref="P:yWorks.Geometry.OrientedRectangle.AnchorY" />, and <see cref="P:yWorks.Geometry.OrientedRectangle.Height" />.</para>
      </summary>
      <returns>
        <para>A hashcode for the values of this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangle.ToString">
      <summary>
        <para>Creates a human readable from of this instance.</para>
      </summary>
      <returns>
        <para>A string describing the properties of this instance.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs">
      <summary>
        <para>Event arguments for the <see cref="E:yWorks.Controls.Input.GraphSnapContext.CollectSnapLines" /> event.</para>
      </summary>
      <remarks>
        <para>Instances of this class are also passed to <see cref="M:yWorks.Controls.Input.ISnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)" />. Implementations of that interface can use the following methods to add snap lines for specific purposes:</para>
        <list type="bullet">
          <item>
            <term>
              <see cref="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.AddFixedNodeSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)" />
            </term>
            <description>Adds an orthogonal snap line for nodes.</description>
          </item>
          <item>
            <term>
              <see cref="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.AddFixedSegmentSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)" />
            </term>
            <description>Adds an orthogonal snap line for edge segments and bends.</description>
          </item>
          <item>
            <term>
              <see cref="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.AddPortSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)" />
            </term>
            <description>Adds an orthogonal snap line for ports.</description>
          </item>
          <item>
            <term>
              <see cref="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.AddAdditionalSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)" />
            </term>
            <description>Adds an additional orthogonal snap line to which all element will snap.</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext,System.Collections.Generic.ICollection{yWorks.Controls.Input.OrthogonalSnapLine},System.Collections.Generic.ICollection{yWorks.Controls.Input.OrthogonalSnapLine},System.Collections.Generic.ICollection{yWorks.Controls.Input.OrthogonalSnapLine},System.Collections.Generic.ICollection{yWorks.Controls.Input.OrthogonalSnapLine})">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context where the event is being used in.</para>
      </param>
      <param name="fixedNodeSnapLines">
        <para>The fixed node snap lines collection to add to.</para>
      </param>
      <param name="fixedSegmentSnapLines">
        <para>The fixed segment snap lines collection to add to.</para>
      </param>
      <param name="fixedPortSnapLines">
        <para>The fixed port snap lines collection to add to.</para>
      </param>
      <param name="additionalSnapLines">
        <para>The additional snap lines collection to add to.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.AddFixedNodeSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)">
      <summary>
        <para>Adds a snap line for nodes.</para>
      </summary>
      <param name="snapLine">
        <para>The snap line to add to the list of lines that nodes snap to by default.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.GraphSnapContext.FixedNodeSnapLines" />
    </member>
    <member name="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.AddFixedSegmentSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)">
      <summary>
        <para>Adds a snap line for edge segments and bends.</para>
      </summary>
      <param name="snapLine">
        <para>The snap line to add to the list of lines that segments snap to by default.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.GraphSnapContext.FixedSegmentSnapLines" />
    </member>
    <member name="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.AddPortSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)">
      <summary>
        <para>Adds a snap line for ports.</para>
      </summary>
      <param name="snapLine">
        <para>The snap line to add to the list of lines that ports snap to by default.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.GraphSnapContext.FixedPortSnapLines" />
    </member>
    <member name="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.AddAdditionalSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)">
      <summary>
        <para>Adds a snap line all elements will snap to.</para>
      </summary>
      <param name="snapLine">
        <para>The snap line to add to the list of lines that all elements snap to by default.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.GraphSnapContext.AdditionalSnapLines" />
    </member>
    <member name="T:yWorks.Controls.Input.CreateBendInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> used for recognizing the gesture of creating <see cref="T:yWorks.Graph.IBend" />s in an <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <remarks>
        <para>This mode is used by <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> but can be used stand-alone, too. Client code should register with the <see cref="E:yWorks.Controls.Input.CreateBendInputMode.BendCreated" /> event to perform additional actions after the bend has been created.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.CreateBendInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.CreateBendInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.TryStop" />
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.Cancel">
      <summary>
        <para>Cancels the editing of this mode.</para>
      </summary>
      <remarks>
        <para>This implementation <see cref="M:yWorks.Controls.Input.ConcurrencyController.ReleaseMutex">releases</see> the mutex if it is currently owned by this instance and calls <see cref="M:yWorks.Controls.Input.CreateBendInputMode.OnCanceled" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.CreateBendInputMode.OnCanceled" />
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.CreateBendInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.CreateBendInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.CreateBendInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.CreateBendInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.CreateBendInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.CreateBendInputMode.BendCreated">
      <summary>
        <para>Occurs once a bend creation gesture has been recognized.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.#ctor">
      <summary>
        <para>Creates a new instance that will use the <see cref="T:yWorks.Graph.IGraph" /> from the <see cref="P:yWorks.Controls.Input.CreateBendInputMode.InputModeContext" /> to create bends in.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.CreateBendInputMode.Graph" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.ArmedCursor">
      <summary>
        <para>Gets or sets the cursor to use when this mode is in "armed" state.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.PressedRecognizer">
      <summary>
        <para>Gets or sets the "pressed" state recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance will be used to determine when the user begins to move the selection.</para>
      </remarks>
      <value>
        <para>The "pressed" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.DraggedRecognizer">
      <summary>
        <para>Gets or sets the "dragged" recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance determines when the user is moving the selection</para>
      </remarks>
      <value>
        <para>The "dragged" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.ReleasedRecognizer">
      <summary>
        <para>Gets or sets the "released" recognizer.</para>
      </summary>
      <remarks>
        <para>This instance determines when the user has finished the move.</para>
      </remarks>
      <value>
        <para>The "released" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.BeginHitTestable">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.IHitTestable" /> that determines where bends may be created.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.Location">
      <summary>
        <para>Gets the location where the bend creation gesture was initialized.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.Graph">
      <summary>
        <para>Gets the Graph this mode is acting upon.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.OnDragged(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the end of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.CreateBendInputMode.Dragged" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.OnDragging(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the start of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.CreateBendInputMode.Dragging" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.CreateBendInputMode.Dragging">
      <summary>
        <para>Occurs at the start of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.CreateBendInputMode.Dragged">
      <summary>
        <para>Occurs at the end of every drag.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.OnDragCanceled(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.CreateBendInputMode.DragCanceled" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.CreateBendInputMode.DragCanceled">
      <summary>
        <para>Occurs when the drag has been canceled.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.CreateInputModeContext">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> for use with the upcoming <see cref="M:yWorks.Controls.Input.IBendCreator.CreateBend(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.IEdge,yWorks.Geometry.PointD)" /> call in <see cref="M:yWorks.Controls.Input.CreateBendInputMode.CreateBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD)" />.</para>
      </summary>
      <returns>
        <para>An instance of <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.GetEdge(yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the edge at the given coordinate.</para>
      </summary>
      <param name="location">
        <para>The coordinates.</para>
      </param>
      <returns>
        <para>The edge that has been hit.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.IsValidBegin(System.Object,System.EventArgs)">
      <summary>
        <para>Determines whether the current location is valid to begin a bend creation gesture.</para>
      </summary>
      <returns />
      <param name="source" />
      <param name="args" />
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.Arm">
      <summary>
        <para>Called when a bend creation gesture can be started at the current mouse pointer location.</para>
      </summary>
      <remarks>
        <para>This implementation sets the <see cref="P:yWorks.Controls.Input.ConcurrencyController.PreferredCursor" /> to <see cref="P:yWorks.Controls.Input.CreateBendInputMode.ArmedCursor" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.Disarm">
      <summary>
        <para>Called when a bend creation gesture can no longer be started at the current mouse pointer location.</para>
      </summary>
      <remarks>
        <para>This implementation sets the <see cref="P:yWorks.Controls.Input.ConcurrencyController.PreferredCursor" /> back to <c>null</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.SplitOrthogonalSegmentRecognizer">
      <summary>
        <para>Gets or sets the event recognizer that determines whether the bend creation should be treated as a split segment operation.</para>
      </summary>
      <value>
        <para>The event recognizer that determines whether orthogonal edge segments should be split during the bend creation.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.DragSegment(yWorks.Graph.IEdge,yWorks.Geometry.PointD)">
      <summary>
        <para>Updates the <see cref="P:yWorks.Controls.Input.CreateBendInputMode.SplitOrthogonalSegment" /> property and then delegates to <see cref="M:yWorks.Controls.Input.CreateBendInputMode.CreateBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD)" />.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.CreateBendInputMode.BendCreated" /> event if a bend is created.</para>
      </remarks>
      <param name="edge">
        <para>The edge to create a bend for.</para>
      </param>
      <param name="dragLocation">
        <para>The location at which the user initiated the gesture.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.SplitOrthogonalSegment">
      <summary>
        <para>Gets or sets a value indicating whether an orthogonal segment should be split by the last bend creation.</para>
      </summary>
      <remarks>
        <para>This property can be read by implementations of <see cref="T:yWorks.Controls.Input.IBendCreator" /> if they retrieve this instance from their <see cref="P:yWorks.Controls.Input.IInputModeContext.ParentInputMode" />. If this property is <c>true</c>, implementation are advised to treat the bend creation as a gesture that splits the segment into two.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.CreateBendInputMode.SplitOrthogonalSegmentRecognizer" />
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.CreateBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD)">
      <summary>
        <para>Creates the bend.</para>
      </summary>
      <remarks>
        <para>The bend is created using the hit edge's <see cref="T:yWorks.Controls.Input.IBendCreator" /> implementation, as obtained from the edge's <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <param name="edge">
        <para>The hit edge.</para>
      </param>
      <param name="location">
        <para>The coordinates of the hit.</para>
      </param>
      <returns>
        <para>The created bend or <c>null</c>.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.CreateBendInputMode.CreateInputModeContext" />
    </member>
    <member name="M:yWorks.Controls.Input.CreateBendInputMode.OnBendCreated(yWorks.Graph.BendEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.CreateBendInputMode.BendCreated" /> event.</para>
      </summary>
      <param name="args" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateBendInputMode.UseExistingBend">
      <summary>
        <para>Gets or sets a property that determines whether this mode should use an existing bend in <see cref="M:yWorks.Controls.Input.CreateBendInputMode.CreateBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD)" /> if there is one found at the given location.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c></para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.ResizeStripeInputMode">
      <summary>
        <para>Specialized input mode that is used to resize a stripe by dragging one of its borders.</para>
      </summary>
      <remarks>
        <para>By default, adjacent stripes are moved. To redistribute the space instead, use <see cref="P:yWorks.Controls.Input.ResizeStripeInputMode.ResizeNeighborsRecognizer" />. Also, by default the content of the stripes is either moved or constrains the minimum available sizes for the stripe resize operations. To completely ignore all content nodes, use <see cref="P:yWorks.Controls.Input.ResizeStripeInputMode.IgnoreContentRecognizer" />.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.ResizeStripeInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ResizeStripeInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.ResizeStripeInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.ResizeStripeInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.TryStop" />
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.Cancel">
      <summary>
        <para>Cancels the editing of this mode.</para>
      </summary>
      <remarks>
        <para>This implementation <see cref="M:yWorks.Controls.Input.ConcurrencyController.ReleaseMutex">releases</see> the mutex if it is currently owned by this instance and calls <see cref="M:yWorks.Controls.Input.ResizeStripeInputMode.OnCanceled" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.ResizeStripeInputMode.OnCanceled" />
    </member>
    <member name="P:yWorks.Controls.Input.ResizeStripeInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.ResizeStripeInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ResizeStripeInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.ResizeStripeInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.ResizeStripeInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.ResizeStripeInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.#ctor">
      <summary>
        <para>Creates a new instance of this input mode.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ResizeStripeInputMode.PressedRecognizer">
      <summary>
        <para>Gets or sets the "pressed" state recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance will be used to determine when the user begins to resize the stripe.</para>
      </remarks>
      <value>
        <para>The "pressed" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ResizeStripeInputMode.DraggedRecognizer">
      <summary>
        <para>Gets or sets the "dragged" recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer instance determines when the user is dragging the mouse to resize the stripe.</para>
      </remarks>
      <value>
        <para>The "dragged" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ResizeStripeInputMode.CancelRecognizer">
      <summary>
        <para>Gets or sets the "cancel" recognizer.</para>
      </summary>
      <remarks>
        <para>This recognizer recognizes a cancel action during the resize operation.</para>
      </remarks>
      <value>
        <para>The "cancel" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ResizeStripeInputMode.ReleasedRecognizer">
      <summary>
        <para>Gets or sets the "released" recognizer.</para>
      </summary>
      <remarks>
        <para>This instance determines when the user has finished the resize operation.</para>
      </remarks>
      <value>
        <para>The "released" recognizer.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ResizeStripeInputMode.ResizeNeighborsRecognizer">
      <summary>
        <para>Gets or sets the recognizer that changes the behavior to resize adjacent stripes instead of moving them.</para>
      </summary>
      <remarks>
        <para>If this recognizer recognizes its gesture, the behavior will be to resize adjacent stripes instead of moving them (which is the default).</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ResizeStripeInputMode.IgnoreContentRecognizer">
      <summary>
        <para>Gets or sets the recognizer that changes the behavior to ignore the content of all stripes instead of moving them or considering for minimum sizes.</para>
      </summary>
      <remarks>
        <para>If this recognizer recognizes its gesture, the behavior will be to completely ignore all stripe contents.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.IsValidBegin(System.Object,System.EventArgs)">
      <summary>
        <para>Called to determine whether it is valid to begin the gesture</para>
      </summary>
      <remarks>
        <para>This implementation checks whether a stripe border has been hit at the latest <see cref="T:yWorks.Controls.Mouse2DEventArgs" /></para>
      </remarks>
      <param name="source" />
      <param name="args" />
      <returns>
        <para>true iff a stripe border has been hit at the latest <see cref="T:yWorks.Controls.Mouse2DEventArgs" /></para>
      </returns>
    </member>
    <member name="E:yWorks.Controls.Input.ResizeStripeInputMode.DragFinishing">
      <summary>
        <para>Occurs before the drag will be finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.ResizeStripeInputMode.DragFinished">
      <summary>
        <para>Occurs once the drag has been finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.ResizeStripeInputMode.DragStarting">
      <summary>
        <para>Occurs once the drag is starting.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.ResizeStripeInputMode.DragStarted">
      <summary>
        <para>Occurs once the drag is initialized and has started.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.ResizeStripeInputMode.Dragging">
      <summary>
        <para>Occurs at the start of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.ResizeStripeInputMode.Dragged">
      <summary>
        <para>Occurs at the end of every drag.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.ResizeStripeInputMode.DragCanceled">
      <summary>
        <para>Occurs when the drag has been canceled.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.ResizeStripeInputMode.DragCanceling">
      <summary>
        <para>Occurs before the drag will be canceled.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnDragStarting(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.ResizeStripeInputMode.DragStarting" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnDragStarted(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.ResizeStripeInputMode.DragStarted" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnDragging(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the start of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.ResizeStripeInputMode.Dragging" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnDragged(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the end of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.ResizeStripeInputMode.Dragged" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnDragFinished(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered once the drag has been finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.ResizeStripeInputMode.DragFinished" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnDragFinishing(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered before the drag will be finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.ResizeStripeInputMode.DragFinishing" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnDragCanceled(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.ResizeStripeInputMode.DragCanceled" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.OnDragCanceling(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.ResizeStripeInputMode.DragCanceling" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ResizeStripeInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.EditLabelHelper">
      <summary>
        <para>Simple default implementation of the <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> interface.</para>
      </summary>
      <remarks>
        <para>This class provided a number of factory methods that can be overwritten to change the default behavior which is modeled after the behavior used by <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />'s <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateLabel(yWorks.Graph.ILabelOwner)" /> and <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabel(yWorks.Graph.ILabel)" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.EditLabelHelper.Graph">
      <summary>
        <para>Gets or sets the graph instance to retrieve the default values from.</para>
      </summary>
      <remarks>
        <para>If this instance is not set, the implementation will try to retrieve the graph from the <see cref="T:yWorks.Controls.Input.IInputModeContext" />'s <see cref="T:yWorks.Graph.ILookup" />.</para>
      </remarks>
      <value>
        <para>The graph instance.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.EditLabelHelper.OnLabelAdding(yWorks.Controls.Input.LabelEditingEventArgs)">
      <summary>
        <para>Helper method that will be called for <see cref="T:yWorks.Graph.ILabelOwner" />s.</para>
      </summary>
      <param name="args">
        <para>The original event arguments.</para>
      </param>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Controls.Input.EditLabelHelper.GetLabelParameter(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabelOwner)" />, <see cref="M:yWorks.Controls.Input.EditLabelHelper.GetLabelStyle(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabelOwner)" />, and <see cref="M:yWorks.Controls.Input.EditLabelHelper.GetPreferredSize(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)" /> to set the appropriate properties on <paramref name="args" /> and sets the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled" /> property to <c>true</c>. Label creation thus is always possible.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.EditLabelHelper.OnLabelEditing(yWorks.Controls.Input.LabelEditingEventArgs)">
      <summary>
        <para>Helper method that will be called for <see cref="T:yWorks.Graph.ILabelOwner" />s.</para>
      </summary>
      <param name="args">
        <para>The original event arguments.</para>
      </param>
      <remarks>
        <para>This method returns the first of the <see cref="P:yWorks.Graph.ILabelOwner.Labels" /> that belong to the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Owner" />, if set. Otherwise, it delegates to <see cref="M:yWorks.Controls.Input.EditLabelHelper.GetLabelParameter(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabelOwner)" />, <see cref="M:yWorks.Controls.Input.EditLabelHelper.GetLabelStyle(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabelOwner)" />, and <see cref="M:yWorks.Controls.Input.EditLabelHelper.GetPreferredSize(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)" /> to set the appropriate properties on <paramref name="args" />.</para>
        <para>The arguments are always set as <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled" />, so label editing is always possible.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.EditLabelHelper.GetPreferredSize(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)">
      <summary>
        <para>Gets the preferred size for the label.</para>
      </summary>
      <remarks>
        <para>This implementation yields <c>null</c> to indicate that the preferred size should be calculated after the text has been entered.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="label">
        <para>The label to get the preferred size from.</para>
      </param>
      <returns>
        <para>The size to use or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.EditLabelHelper.GetLabelStyle(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Determines the style to use for the label, depending on the <paramref name="owner" />.</para>
      </summary>
      <remarks>
        <para>This method will obtain the default style instances from the <see cref="P:yWorks.Controls.Input.EditLabelHelper.Graph" /> considering the type of the current <paramref name="owner" />.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="owner">
        <para>The label's owner.</para>
      </param>
      <returns>
        <para>The style to use or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.EditLabelHelper.GetLabelParameter(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Determines the label model parameter to use for the label, depending on the <paramref name="owner" />.</para>
      </summary>
      <remarks>
        <para>This method will obtain the default parameter instances from the <see cref="P:yWorks.Controls.Input.EditLabelHelper.Graph" /> considering the type of the current <paramref name="owner" />.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="owner">
        <para>The label's owner.</para>
      </param>
      <returns>
        <para>The layout parameter to use or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.Commands">
      <summary>
        <para>The <c>Commands</c> class exposes a standard set of <see cref="T:yWorks.Graph.IGraph" />-related editing and navigation <see cref="T:yWorks.Controls.ICommand">commands</see>.</para>
      </summary>
      <remarks>
        <para>The commands in this class are abstract, i.e. they cannot be executed on their own. Instead <see cref="T:yWorks.Controls.Input.IInputMode" />s for <see cref="T:yWorks.Controls.GraphControl" /> provide implementations for these commands. For more information on commands and commanding, see <see cref="T:yWorks.Controls.ICommand" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.GraphEditorInputMode" />
      <seealso cref="T:yWorks.Controls.Input.GraphViewerInputMode" />
      <seealso cref="T:yWorks.Controls.Input.NavigationInputMode" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.SelectItem">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to select the item that is specified by the <see cref="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter" />.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ToggleItemSelection">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to toggle the selection state of the item that is specified by the <see cref="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter" />.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.DeselectItem">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to deselect the item that is specified by the <see cref="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter" />.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.EditLabel">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabel(yWorks.Graph.ILabel)">edit the label</see> that is specified by the <see cref="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter" />.</para>
      </summary>
      <remarks>
        <para>If no <see cref="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter" /> is set, this will trigger the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnEditLabel" /> if <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> is used.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.AddLabel">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AddLabel(yWorks.Graph.ILabelOwner)">add another label</see> to the <see cref="T:yWorks.Graph.ILabelOwner" /> that is specified by the <see cref="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter" />.</para>
      </summary>
      <remarks>
        <para>If no <see cref="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter" /> is set, this will trigger the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnAddLabel" /> if <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> is used.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.GroupSelection">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.GroupSelection">group the currently selected items</see>.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.AdjustGroupNodeSize">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustGroupNodeSize(System.Collections.Generic.IEnumerable{yWorks.Graph.INode})">adjust the size of the selected group nodes</see>.</para>
      </summary>
      <remarks>
        <para>The default keyboard binding for this command is ctrl-shift-G.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.UngroupSelection">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.UngroupSelection">ungroup the currently selected items</see>.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.DeselectAll">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="M:yWorks.Controls.ISelectionModel`1.Clear">clear the selection</see>.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ExpandGroup">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExpandGroup(yWorks.Graph.INode)">expand</see> group nodes.</para>
      </summary>
      <remarks>
        <para>If the parameter to this command is <c>null</c>, the currently selected group nodes are expanded. If the parameter is an <see cref="T:yWorks.Graph.INode" /> instance, that node will be expanded. If the parameter is an <see cref="T:System.Collections.IEnumerable" /> instance, then all group nodes in that enumeration are expanded.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.CollapseGroup">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="M:yWorks.Controls.Input.NavigationInputMode.CollapseGroup(yWorks.Graph.INode)">collapse</see> group nodes.</para>
      </summary>
      <remarks>
        <para>If the parameter to this command is <c>null</c>, the currently selected group nodes are collapsed. If the parameter is an <see cref="T:yWorks.Graph.INode" /> instance, that group node will be collapsed. If the parameter is an <see cref="T:System.Collections.IEnumerable" /> instance, then all group nodes in that enumeration are collapsed.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ToggleExpansionState">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="M:yWorks.Controls.Input.NavigationInputMode.ToggleExpansionState(yWorks.Graph.INode)">toggle</see> the collapsed/expanded state of currently selected group nodes.</para>
      </summary>
      <remarks>
        <para>If the parameter to this command is <c>null</c>, the currently selected group nodes are toggled. If the parameter is an <see cref="T:yWorks.Graph.INode" /> instance, that group node will be toggled. If the parameter is an <see cref="T:System.Collections.IEnumerable" /> instance, then all group nodes in that enumeration are toggled.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.EnterGroup">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="P:yWorks.Graph.IFoldingView.LocalRoot">switch the local root</see> of the current <see cref="T:yWorks.Graph.IFoldingView" /> view to the given group node.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ExitGroup">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="P:yWorks.Graph.IFoldingView.LocalRoot">exit the current local root</see> of the current <see cref="T:yWorks.Graph.IFoldingView" /> view to the given parent view.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.KeyboardInputMode.AddCommandBinding(yWorks.Controls.ICommand,System.EventHandler{yWorks.Controls.ExecutedCommandEventArgs},System.EventHandler{yWorks.Controls.CanExecuteCommandEventArgs})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.BeginEdgeCreation">
      <summary>
        <para>This is an <see cref="T:yWorks.Controls.ICommand" /> that <see cref="T:yWorks.Controls.Input.CreateEdgeInputMode" /> instances can execute if they have been <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see> in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>If this command gets executed, the <see cref="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter" /> is inspected to see if it is set to either an <see cref="T:yWorks.Controls.Input.IPortCandidate" />, an <see cref="T:yWorks.Graph.IPort" />, or an <see cref="T:yWorks.Graph.INode" /> that is an element in the currently edited graph instance. If so, method <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.DoStartEdgeCreation(yWorks.Controls.Input.IPortCandidate)" /> will be invoked and the user can finish the edge creation gesture.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Duplicate">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that can be <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">executed</see> from within the <see cref="T:yWorks.Controls.GraphControl" /> to <see cref="M:yWorks.Graph.GraphClipboard.Duplicate(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.ElementCopiedCallback)">duplicate items</see> of the current <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ReverseEdge">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that reverses the direction of edges.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> can execute this command if it is installed in a <see cref="T:yWorks.Controls.GraphControl" />. The <see cref="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter" /> specifies the edges to be reversed and can be an <see cref="T:yWorks.Graph.IEdge" />, an <see cref="T:System.Collections.Generic.IEnumerable`1">IEnumerable&lt;IEdge&gt;</see> or <c>null</c>. If the parameter is <c>null</c> the currently selected edges will be reversed.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdges(System.Collections.Generic.IEnumerable{yWorks.Graph.IEdge})" />
    </member>
    <member name="F:yWorks.Controls.Input.Commands.IncreaseZoom">
      <summary>
        <para>Gets the increase zoom command.</para>
      </summary>
      <value>
        <para>The increase zoom command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.DecreaseZoom">
      <summary>
        <para>Gets the decrease zoom command.</para>
      </summary>
      <value>
        <para>The decrease zoom command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Zoom">
      <summary>
        <para>Gets the zoom command.</para>
      </summary>
      <value>
        <para>The zoom command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.SelectAll">
      <summary>
        <para>Gets the "select all" command.</para>
      </summary>
      <value>
        <para>The "select all" command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Close">
      <summary>
        <para>Gets the "close" command.</para>
      </summary>
      <value>
        <para>The "close" command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Help">
      <summary>
        <para>Gets the "help" command.</para>
      </summary>
      <value>
        <para>The "help" command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Properties">
      <summary>
        <para>Gets the "Properties" command.</para>
      </summary>
      <value>
        <para>The "Properties" command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Delete">
      <summary>
        <para>Gets the delete command.</para>
      </summary>
      <value>
        <para>The delete command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Print">
      <summary>
        <para>Gets the print command.</para>
      </summary>
      <value>
        <para>The print command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.New">
      <summary>
        <para>Gets the new command.</para>
      </summary>
      <value>
        <para>The command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.PrintPreview">
      <summary>
        <para>Gets the print preview command.</para>
      </summary>
      <value>
        <para>The print preview command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Open">
      <summary>
        <para>Gets the open command.</para>
      </summary>
      <value>
        <para>The open command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Save">
      <summary>
        <para>Gets the save command.</para>
      </summary>
      <value>
        <para>The save command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.SaveAs">
      <summary>
        <para>Gets the "save as" command.</para>
      </summary>
      <value>
        <para>The "save as" command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Cut">
      <summary>
        <para>Gets the cut command.</para>
      </summary>
      <value>
        <para>The cut command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Copy">
      <summary>
        <para>Gets the copy command.</para>
      </summary>
      <value>
        <para>The copy command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Paste">
      <summary>
        <para>Gets the paste command.</para>
      </summary>
      <value>
        <para>The paste command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Undo">
      <summary>
        <para>Gets the undo command.</para>
      </summary>
      <value>
        <para>The undo command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.Redo">
      <summary>
        <para>Gets the redo command.</para>
      </summary>
      <value>
        <para>The redo command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveLeft">
      <summary>
        <para>Gets the move left command.</para>
      </summary>
      <value>
        <para>The move left command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveRight">
      <summary>
        <para>Gets the move right command.</para>
      </summary>
      <value>
        <para>The move right command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveUp">
      <summary>
        <para>Gets the move up command.</para>
      </summary>
      <value>
        <para>The move up command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveDown">
      <summary>
        <para>Gets the move down command.</para>
      </summary>
      <value>
        <para>The move down command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveToPageUp">
      <summary>
        <para>Gets the move to page up command.</para>
      </summary>
      <value>
        <para>The move to page up command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveToPageDown">
      <summary>
        <para>Gets the move to page down command.</para>
      </summary>
      <value>
        <para>The move to page down command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveFocusBack">
      <summary>
        <para>Gets the move focus back command.</para>
      </summary>
      <value>
        <para>The move focus back command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveFocusForward">
      <summary>
        <para>Gets the move focus forward command.</para>
      </summary>
      <value>
        <para>The move focus forward command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveFocusUp">
      <summary>
        <para>Gets the move focus up command.</para>
      </summary>
      <value>
        <para>The move focus up command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveFocusDown">
      <summary>
        <para>Gets the move focus down command.</para>
      </summary>
      <value>
        <para>The move focus down command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveFocusPageUp">
      <summary>
        <para>Gets the move focus page up command.</para>
      </summary>
      <value>
        <para>The move focus page up command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.MoveFocusPageDown">
      <summary>
        <para>Gets the move focus page down command.</para>
      </summary>
      <value>
        <para>The move focus page down command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ExtendSelectionLeft">
      <summary>
        <para>Gets the extend selection left command.</para>
      </summary>
      <value>
        <para>The extend selection left command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ExtendSelectionRight">
      <summary>
        <para>Gets the extend selection right command.</para>
      </summary>
      <value>
        <para>The extend selection right command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ExtendSelectionUp">
      <summary>
        <para>Gets the extend selection up command.</para>
      </summary>
      <value>
        <para>The extend selection up command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ExtendSelectionDown">
      <summary>
        <para>Gets the extend selection down command.</para>
      </summary>
      <value>
        <para>The extend selection down command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.SelectToPageUp">
      <summary>
        <para>Gets the select to page up command.</para>
      </summary>
      <value>
        <para>The select to page up command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.SelectToPageDown">
      <summary>
        <para>Gets the select to page down command.</para>
      </summary>
      <value>
        <para>The select to page down command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ScrollPageUp">
      <summary>
        <para>Gets the scroll page up command.</para>
      </summary>
      <value>
        <para>The scroll page up command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ScrollPageDown">
      <summary>
        <para>Gets the scroll page down command.</para>
      </summary>
      <value>
        <para>The scroll page down command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ScrollPageLeft">
      <summary>
        <para>Gets the scroll page left command.</para>
      </summary>
      <value>
        <para>The scroll page left command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ScrollPageRight">
      <summary>
        <para>Gets the scroll page right command.</para>
      </summary>
      <value>
        <para>The scroll page right command.</para>
      </value>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.FitContent">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that invokes <see cref="M:yWorks.Controls.CanvasControl.FitContent" /> if executed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.UpdateContentRect">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that invokes <see cref="M:yWorks.Controls.CanvasControl.UpdateContentRect(yWorks.Geometry.InsetsD,yWorks.Controls.ICanvasObjectGroup)" /> if executed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.SetCurrentItem">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that invokes <see cref="P:yWorks.Controls.GraphControl.CurrentItem" /> if executed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.FitGraphBounds">
      <summary>
        <para>The <see cref="T:yWorks.Controls.ICommand" /> that performs the <see cref="M:yWorks.Controls.GraphControl.FitGraphBounds(System.Nullable{yWorks.Geometry.InsetsD})" /> action.</para>
      </summary>
      <remarks>
        <para>The parameter can be either an <see cref="T:yWorks.Geometry.InsetsD" /> or convertible that will be used to create an appropriately sized insets object from.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.Commands.ZoomToCurrentItem">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ICommand" /> that changes the <see cref="P:yWorks.Controls.CanvasControl.Zoom" /> and the <see cref="P:yWorks.Controls.CanvasControl.ViewPoint" /> in an animated fashion such that the <see cref="P:yWorks.Controls.GraphControl.CurrentItem" /> becomes fully visible.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.Commands.CreateCommand(System.String)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Controls.ICommand" /> instance that does nothing.</para>
      </summary>
      <remarks>
        <para>The return value serves as a token and does not in itself contain any command handling logic. Use to associate command handlers with the instance returned.</para>
      </remarks>
      <param name="name">
        <para>The optional name for the command.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Controls.ICommand" /> instance.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.EdgeCreationCallback">
      <summary>
        <para>The delegate method that is used by <see cref="T:yWorks.Controls.Input.CreateEdgeInputMode" /> to create edges between instances of <see cref="T:yWorks.Graph.IPort" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreator" /> uses this type of callback to actually create edges between nodes.</para>
      </remarks>
      <param name="context">
        <para>The context of the input mode this action is used in.</para>
      </param>
      <param name="graph">
        <para>The graph to create the edge in.</para>
      </param>
      <param name="sourcePortCandidate">
        <para>The source port candidate.</para>
      </param>
      <param name="targetPortCandidate">
        <para>The target port candidate.</para>
      </param>
      <param name="templateEdge">
        <para>The dummy edge instance that serves as template for the actual edge creation. This edge is <b>not</b> part of the <paramref name="graph" /></para>
      </param>
      <returns>
        <para>The newly created edge or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.CreateEdgeInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> for interacticely creating edges between nodes and edges in an <see cref="T:yWorks.Graph.IGraph" /> displayed in a <see cref="T:yWorks.Controls.CanvasControl" /> or <see cref="T:yWorks.Controls.GraphControl" />.</para>
      </summary>
      <remarks>
        <para>This class provides a <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreator">factory callback</see> that the final edge creation will be delegated to. The styling of the newly created edge can be customized via the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.EdgeDefaults" />. Defaults can be automatically adjusted in response to the various events that will be triggered by this instance during the edge creation. Use the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdgeGraph" /> property to modify the appearance of the dummy edge. This class uses <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> instances found in the <see cref="T:yWorks.Graph.ILookup" /> of the <see cref="T:yWorks.Graph.INode">nodes</see> in the graph to display port candidates and to finally create the edges.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.TryStop" />
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.Cancel">
      <summary>
        <para>Cancels the editing of this mode.</para>
      </summary>
      <remarks>
        <para>This implementation <see cref="M:yWorks.Controls.Input.ConcurrencyController.ReleaseMutex">releases</see> the mutex if it is currently owned by this instance and calls <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.OnCanceled" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.CreateEdgeInputMode.OnCanceled" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.ValidBeginCursor">
      <summary>
        <para>Gets or sets the cursor that indicates a valid place to begin an edge creation.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.ValidBendCursor">
      <summary>
        <para>Gets or sets the cursor that indicates a valid place to create a bend.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.ValidEndCursor">
      <summary>
        <para>Gets or sets the cursor that indicates a valid place to finish creation.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.DisableSnappingRecognizer">
      <summary>
        <para>Gets or sets <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that temporarily disables snapping.</para>
      </summary>
      <value>
        <para>The disable snapping recognizer. The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlDown" /></para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.EnableSnappingRecognizer">
      <summary>
        <para>Gets or sets <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that reenables temporarily disabled snapping.</para>
      </summary>
      <value>
        <para>The disable snapping recognizer. The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlUp" /></para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.DisableSnappingRecognizer" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.ToggleSegmentOrientationRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that toggles the orientation of the first orthogonally created segment.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.OrthogonalEdgeCreation" />
      <value>
        <para>The recognizer instances that identifies the event that toggles the orientation of the first segment. The default instance recognizes if the user presses the space key.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.FinishRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that recognizes the finishing gesture that is used to end the edge creation on the target node.</para>
      </summary>
      <remarks>
        <para>The default is a combination of <see cref="F:yWorks.Controls.Input.MouseEventRecognizers.LeftPressed" /> and <see cref="F:yWorks.Controls.Input.MouseEventRecognizers.LeftReleased" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.PrepareRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that recognizes the starting gesture that is used to prepare the edge creation on the source node.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.Input.MouseEventRecognizers.LeftPressed" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.DraggedRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that recognizes the initial dragging gesture that is used to initiate the creation after the preparation.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.Input.MouseEventRecognizers.Dragged" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.EndPointMovedRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that recognizes the movement of the end point of the edge.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.Input.MouseEventRecognizers.MovedOrDragged" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.CreateBendRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that recognizes the creation of a bend.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.Input.MouseEventRecognizers.LeftReleased" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.CancelRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that determines cancel events.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.RemoveBendRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that determines bend removal events.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.PortCandidateResolutionRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that determines whether dynamic port candidates should be resolved.</para>
      </summary>
      <remarks>
        <para>By default this is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.ShiftPressed" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.ShowPortCandidates">
      <summary>
        <para>Gets or sets whether or not to display possible port candidates during the creation of the edge.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.AllowEdgeToEdgeConnections">
      <summary>
        <para>Gets or sets whether or not edges are allowed to connect to other edges.</para>
      </summary>
      <remarks>
        <para>The default is <c>false</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.SnapDistance">
      <summary>
        <para>Gets or sets the distance in the view coordinate system that determines how far the mouse should be snapped to a port candidate if <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.SnapToTargetCandidate" /> is enabled.</para>
      </summary>
      <remarks>
        <para>The default value is <c>20</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.SnapContext">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.SnapContext" /> which manages snapping model items to certain coordinates (for instance, other items).</para>
      </summary>
      <remarks>
        <para>If set to <c>null</c> (the default) this input mode tries to obtain the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.SnapContext" /> from the <see cref="T:yWorks.Controls.Input.IInputModeContext" />. To explicitly disable snapping, a <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.SnapContext" /> implementation that does nothing has to be set to this instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.CandidateDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> that is used for visualizing the <see cref="T:yWorks.Controls.Input.IPortCandidate" />s in the canvas during the edit.</para>
      </summary>
      <remarks>
        <para>This descriptor is queried for the <see cref="T:yWorks.Controls.IVisualCreator" /> to obtain the visualizations for the candidates that are not currently closest. By default an instance of <see cref="T:yWorks.Controls.DefaultPortCandidateDescriptor" /> is used.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.ClosestCandidateDescriptor" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.ClosestCandidateDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> that is used for visualizing the closest <see cref="T:yWorks.Controls.Input.IPortCandidate" /> in the canvas during the edit.</para>
      </summary>
      <remarks>
        <para>This descriptor is queried for the <see cref="T:yWorks.Controls.IVisualCreator" /> to obtain the visualization for the currently closest candidate. By default an instance of <see cref="T:yWorks.Controls.DefaultPortCandidateDescriptor" /> is used.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.CandidateDescriptor" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.OrthogonalSnapDistance">
      <summary>
        <para>Gets or sets the distance in the view coordinate system that determines how far the mouse should be snapped to a horizontal or vertical line.</para>
      </summary>
      <remarks>
        <para>The default value is <c>5</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.ForceSnapToCandidate">
      <summary>
        <para>Gets or sets a property that determines whether the mouse should be forced to snap to the nearest valid port candidate if the mouse hovers over a target node.</para>
      </summary>
      <remarks>
        <para>If the nearest port candidate is farther away than <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.SnapDistance" /> and the mouse hovers over a valid <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTarget(yWorks.Geometry.PointD)">target</see>, this property will cause the mouse to snap to the nearest valid candidate. The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.UseHitItemsCandidatesOnly">
      <summary>
        <para>Gets or sets a property that determines whether this mode should use only the <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTargetPortCandidates(yWorks.Geometry.PointD,System.Boolean)">target port candidates</see> of the node the mouse currently hovers over.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.ShowPortCandidates" />
      <seealso cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTarget(yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTargetPortCandidates(yWorks.Geometry.PointD,System.Boolean)" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.OrthogonalEdgeCreation">
      <summary>
        <para>Gets or sets the the policy that controls whether edges will be create orthogonally.</para>
      </summary>
      <remarks>
        <para>By default orthogonal edge creation is enabled if orthogonal edge editing is enabled on the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode">parent input mode</see>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.OrthogonalEdgeEditingContext" />
      <seealso cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Enabled" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.PreferredMinimalEdgeDistance">
      <summary>
        <para>Gets or sets the preferred minimal distance of orthogonal edges.</para>
      </summary>
      <remarks>
        <para>This information is needed when deciding which way to route the first segment of an orthogonal edge.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.ResolveSourcePortCandidates">
      <summary>
        <para>Gets or sets a value indicating whether <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" /> ports that are part of the <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSourcePortCandidate(yWorks.Controls.Input.IPortCandidateProvider,yWorks.Geometry.PointD,System.Boolean)">source port candidates</see> should be resolved for the current mouse location.</para>
      </summary>
      <remarks>
        <para>By default this feature is enabled and the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.PortCandidateResolutionRecognizer" /> is configured so that the resolution mechanism is used if the user holds the shift modifier during the gesture.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.PortCandidateResolutionRecognizer" />
      <seealso cref="M:yWorks.Controls.Input.CreateEdgeInputMode.ResolveCandidates(System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate},System.Nullable{yWorks.Geometry.PointD})" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.ResolveTargetPortCandidates">
      <summary>
        <para>Gets or sets a value indicating whether <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" /> ports that are part of the <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTargetPortCandidates(yWorks.Geometry.PointD,System.Boolean)">target port candidates</see> should be resolved for the current mouse location.</para>
      </summary>
      <remarks>
        <para>By default this feature is enabled and the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.PortCandidateResolutionRecognizer" /> is configured so that the resolution mechanism is used if the user holds the shift modifier during the gesture.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.PortCandidateResolutionRecognizer" />
      <seealso cref="M:yWorks.Controls.Input.CreateEdgeInputMode.ResolveCandidates(System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate},System.Nullable{yWorks.Geometry.PointD})" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.NodeBorderWidthRatio">
      <summary>
        <para>Gets or sets the width of a node's border which is taken into account when deciding which way to route the first segment of an orthogonal edge.</para>
      </summary>
      <remarks>
        <para>An edge starting inside a given margin is always pointing away from it.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.#ctor">
      <summary>
        <para>Creates a new instance that will use the <see cref="T:yWorks.Graph.IGraph" /> from the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.InputModeContext" /> to create edges in.</para>
      </summary>
      <remarks>
        <para>Setting the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Graph" /> property can be used to optionally set a different graph to work on.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Graph" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreator">
      <summary>
        <para>Gets or sets the ports based edge creation callback.</para>
      </summary>
      <value>
        <para>The ports based edge creation callback that will be used during <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateEdge(yWorks.Graph.IGraph,yWorks.Controls.Input.IPortCandidate,yWorks.Controls.Input.IPortCandidate)" />.</para>
      </value>
      <remarks>
        <para>The default creator will delegate to <see cref="M:yWorks.Graph.IGraph.CreateEdge(yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Graph.Styles.IEdgeStyle,System.Object)" /> and obtain the tag from the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdge" />. It will then copy over all bends, labels, and ports from the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdge" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <para>If the argument is <c>null</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetPortOwners">
      <summary>
        <para>Retrieves the port owners from the graph in the order of their importance.</para>
      </summary>
      <remarks>
        <para>This implementation only considers nodes in the graph unless <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.AllowEdgeToEdgeConnections" /> is set to <c>true</c>, in which case edges are also added to the enumerable.</para>
      </remarks>
      <returns>
        <para>An enumerable over all <see cref="T:yWorks.Graph.IPortOwner" />s in this graph</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.AllowSelfloops">
      <summary>
        <para>Gets or sets whether or not to allow the creation of self loops.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>, which enables that an edge is connected to a <see cref="P:yWorks.Graph.IEdge.SourcePort" /> and <see cref="P:yWorks.Graph.IEdge.TargetPort" /> that have the same <see cref="P:yWorks.Graph.IPort.Owner" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.CancelGestureOnInvalidTarget">
      <summary>
        <para>Gets or sets whether an edge creation gesture will be canceled when the gesture is ended on an invalid target and no bend may be created there.</para>
      </summary>
      <remarks>
        <para>If bend creation is allowed at the target location (i.e. <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.ValidBendHitTestable" /> returns true), the gesture will always continue by creating a bend. Otherwise, if this property is <c>true</c>, the gesture will be canceled automatically.</para>
        <para>The default is <c>false</c>, meaning that the gesture must always be canceled explicitely.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.AllowCreateBend" />
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.ValidBendHitTestable" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.AllowCreateBend">
      <summary>
        <para>Gets or sets whether or not to allow the creation of bends.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdge">
      <summary>
        <para>Gets the dummy edge instance that will be used to render a preview of the edge to be created.</para>
      </summary>
      <remarks>
        <para>This instance will be used for rendering the edge during the gesture. If this property is unset initially, factory method <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateDummyEdge" /> will be called.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdgeGraph">
      <summary>
        <para>Gets the dummy graph instance that will hold the items that will render a preview of the newly created edge.</para>
      </summary>
      <remarks>
        <para>The dummy edge graph can be used to change the appearance and other properties of the dummy edge, either when starting a gesture or during it in response to certain events. Possible actions are:</para>
        <list type="bullet">
          <item>Changing the style of the dummy edge.</item>
          <item>Adding bends to the dummy edge.</item>
          <item>Adding labels to the dummy edge.</item>
          <item>Changing style and other properties of the added labels.</item>
        </list>
        <para>All changes made to the dummy edge during the gesture will be persisted to the created edge in the original graph. This behavior can be changed by setting a custom <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreator" />.</para>
        <para>The dummy edge graph only allows operations on the dummy edge.</para>
        <para>If the property is not set initially, method <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateDummyEdgeGraph" /> will be used as the factory method.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdge" />
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.EdgeDefaults">
      <summary>
        <para>Gets or sets the appearance of newly created edges.</para>
      </summary>
      <remarks>
        <para>This property directly delegates to the <see cref="P:yWorks.Graph.IGraph.EdgeDefaults" /> of the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdgeGraph" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.SourcePortCandidate">
      <summary>
        <para>Gets or sets the candidate for the <see cref="P:yWorks.Graph.IEdge.SourcePort" /> of the edge to be created.</para>
      </summary>
      <remarks>
        <para>This property will be populated automatically when edge creation has started.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.TargetPortCandidate">
      <summary>
        <para>Gets or sets the current candidate for the <see cref="P:yWorks.Graph.IEdge.TargetPort" /> of the edge to be created.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnSourcePortCandidateChanged(yWorks.Utils.ItemEventArgs{yWorks.Controls.Input.IPortCandidate})">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.SourcePortCandidateChanged" /> event.</para>
      </summary>
      <param name="args">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnTargetPortCandidateChanged(yWorks.Utils.ItemEventArgs{yWorks.Controls.Input.IPortCandidate})">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.TargetPortCandidateChanged" /> event.</para>
      </summary>
      <param name="args">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.SourcePortCandidateChanged">
      <summary>
        <para>Occurs when the value of the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.SourcePortCandidate" /> property changes.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.TargetPortCandidateChanged">
      <summary>
        <para>Occurs when the value of the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.TargetPortCandidate" /> property changes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.DoStartEdgeCreation(yWorks.Controls.Input.IPortCandidate)">
      <summary>
        <para>Synthetically starts the interactive edge creation process using the provided <see cref="T:yWorks.Controls.Input.IPortCandidate" /> as the source port.</para>
      </summary>
      <param name="sourcePortCandidate">
        <para>The source port candidate to use for the edge creation.</para>
      </param>
      <remarks>
        <para>This instance needs to be <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see> and <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Enabled" /> and it needs to be able to <see cref="M:yWorks.Controls.Input.ConcurrencyController.CanRequestMutex">request the input mutex</see> in order to proceed. If any of these conditions are not satisfied, this method will throw an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSource(yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the source <see cref="T:yWorks.Graph.IPortOwner">port owner</see> at the specified location.</para>
      </summary>
      <remarks>
        <para>This always is the source <see cref="T:yWorks.Graph.INode">node</see> if <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.AllowEdgeToEdgeConnections" /> is set to <c>false</c>.<br /> This default implementation simply delegates to <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetPortOwner(yWorks.Geometry.PointD)" />.</para>
      </remarks>
      <param name="sourceLocation">
        <para>The location of the mouse at the beginning of the gesture.</para>
      </param>
      <returns>
        <para>The port owner to use for the source node or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateEdge">
      <summary>
        <para>Callback at the end of the edge creation process.</para>
      </summary>
      <remarks>
        <para>This method will actually create the edge using the <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateEdge(yWorks.Graph.IGraph,yWorks.Controls.Input.IPortCandidate,yWorks.Controls.Input.IPortCandidate)" /> method. This method will ultimately call <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.OnEdgeCreated(yWorks.Graph.EdgeEventArgs)" />.</para>
      </remarks>
      <returns>
        <para>The edge created or <c>null</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.CancelEditImplicitly">
      <summary>
        <para>Gets or sets whether after calls to <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateEdge(yWorks.Graph.IGraph,yWorks.Controls.Input.IPortCandidate,yWorks.Controls.Input.IPortCandidate)" /> the current undo edit should be canceled if the method returns <c>null</c>.</para>
      </summary>
      <remarks>
        <para>This should be set to <c>false</c> if you want to perform some undoable actions in these methods and/or in the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreator" /> callback, but need to return <c>null</c> from any of these methods. Default value is <c>true</c>, meaning that returning <c>null</c> results in canceling the composite undo entry.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnEdgeCreated(yWorks.Graph.EdgeEventArgs)">
      <summary>
        <para>Called by <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateEdge" /> after the edge has been finalized.</para>
      </summary>
      <remarks>
        <para>This method will trigger the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreated" /> event.</para>
      </remarks>
      <param name="args">
        <para>The event argument holding the edge.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreated">
      <summary>
        <para>Occurs after an edge has been created by this mode.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.CreateEdgeInputMode.OnEdgeCreated(yWorks.Graph.EdgeEventArgs)" />
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateEdge(yWorks.Graph.IGraph,yWorks.Controls.Input.IPortCandidate,yWorks.Controls.Input.IPortCandidate)">
      <summary>
        <para>Callback used by <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateEdge" /> if both <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.SourcePortCandidate" /> and <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.TargetPortCandidate" /> have been set.</para>
      </summary>
      <remarks>
        <para>This method will first <see cref="M:yWorks.Controls.Input.IPortCandidate.CreatePort(yWorks.Controls.Input.IInputModeContext)">create the new ports</see> if necessary and then create the edge via the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreator" /> callback to the ports. After the ports are created the corresponding <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.PortAdded" /> events are triggered. If the edge creation is canceled by the creator callback, newly created ports will be removed again.</para>
      </remarks>
      <param name="graph">
        <para>The graph to create the edge for.</para>
      </param>
      <param name="sourcePortCandidate">
        <para>The candidate to use for the source.</para>
      </param>
      <param name="targetPortCandidate">
        <para>The candidate to use for the target.</para>
      </param>
      <returns>
        <para>The edge created or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnPortAdded(yWorks.Utils.ItemEventArgs{yWorks.Graph.IPort})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.PortAdded" /> event if the mode has <see cref="M:yWorks.Graph.IGraph.AddPort(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)">added a port</see> for the source or target node to complete the edge creation.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance containing the port that has been added.</para>
      </param>
      <seealso cref="E:yWorks.Controls.Input.CreateEdgeInputMode.PortAdded" />
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.PortAdded">
      <summary>
        <para>Occurs when this instance <see cref="M:yWorks.Graph.IGraph.AddPort(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)">adds a port</see> to the source or target node during completion of the edge creation gesture.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSourcePortCandidate(yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the best matching source <see cref="T:yWorks.Controls.Input.IPortCandidate">port candidate</see> based on the given location.</para>
      </summary>
      <remarks>
        <para>This implementation will use the <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSource(yWorks.Geometry.PointD)">port owner</see> to look up the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider">port candidate provider</see> and finally delegate to <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSourcePortCandidate(yWorks.Controls.Input.IPortCandidateProvider,yWorks.Geometry.PointD,System.Boolean)" />.</para>
      </remarks>
      <param name="location">
        <para>The location where the gesture was initiated.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSource(yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSourcePortCandidateProvider(yWorks.Graph.IPortOwner)" />
      <seealso cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSourcePortCandidate(yWorks.Controls.Input.IPortCandidateProvider,yWorks.Geometry.PointD,System.Boolean)" />
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSourcePortCandidate(yWorks.Controls.Input.IPortCandidateProvider,yWorks.Geometry.PointD,System.Boolean)">
      <summary>
        <para>Finds the best matching source port <see cref="T:yWorks.Controls.Input.IPortCandidate" /> given a provider and the current location.</para>
      </summary>
      <remarks>
        <para>The <paramref name="resolveCandidates" /> parameter determines whether dynamic port candidates should be <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.ResolveCandidates(System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate},System.Nullable{yWorks.Geometry.PointD})">resolved</see> with respect to <paramref name="location" /> or simply be discarded.</para>
      </remarks>
      <param name="provider">
        <para>The provider for the candidates.</para>
      </param>
      <param name="location">
        <para>The location where the gesture was initiated.</para>
      </param>
      <param name="resolveCandidates">
        <para>Determines whether <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" /> ports should be resolved with respect to the <paramref name="location" /> or not.</para>
      </param>
      <returns>
        <para>The candidate to use or <c>null</c>.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.ResolveSourcePortCandidates" />
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.PortCandidateResolutionRecognizer" />
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.ResolveCandidates(System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate},System.Nullable{yWorks.Geometry.PointD})">
      <summary>
        <para>Returns an enumerable over the given candidates where no instance has <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" /> <see cref="P:yWorks.Controls.Input.IPortCandidate.Validity" />.</para>
      </summary>
      <remarks>
        <para>If the location has a value, method <see cref="M:yWorks.Controls.Input.IPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> is used to resolve the dynamic candidate to a real candidate, otherwise that candidate is discarded.</para>
      </remarks>
      <param name="candidates">
        <para>The candidates to possibly resolve.</para>
      </param>
      <param name="location">
        <para>The location to resolve dynamic candidates against or <c>null</c> if they should be discarded instead.</para>
      </param>
      <returns>
        <para>An enumerable of non-<see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" /> port candidates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateEdgeCreationInputModeContext">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> for use with the port candidates queries for the upcoming edge creation operation and the actual edge creation</para>
      </summary>
      <returns>
        <para>An instance of <see cref="T:yWorks.Controls.Input.IInputModeContext" /> that is configured for this mode.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateDummyEdgeGraph">
      <summary>
        <para>Factory method that will create the dummy graph to hold the preview of the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdge" />.</para>
      </summary>
      <remarks>
        <para>Note that the instance returned by this instance must accept any port as valid source and target ports for it's <see cref="M:yWorks.Graph.IGraph.SetEdgePorts(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)" /> method. This will allow the preview edge to be connected to the actual <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Graph" />.</para>
      </remarks>
      <returns>
        <para>A graph instance that will be rendered as a preview.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.CreateDummyEdge">
      <summary>
        <para>Creates the dummy edge that will be displayed by the input mode during the creation.</para>
      </summary>
      <remarks />
      <returns>
        <para>An <see cref="T:yWorks.Graph.IEdge" /> implementation that can be used as a dummy.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTarget(yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the target <see cref="T:yWorks.Graph.IPortOwner">port owner</see> at the specified location.</para>
      </summary>
      <remarks>
        <para>This always is a target <see cref="T:yWorks.Graph.INode">node</see> if <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.AllowEdgeToEdgeConnections" /> is set to <c>false</c>.<br /> This default implementation simply delegates to <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetPortOwner(yWorks.Geometry.PointD)" />.</para>
      </remarks>
      <param name="targetLocation">
        <para>The location of the pointer at the beginning of the gesture.</para>
      </param>
      <returns>
        <para>The port owner or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTargetPortCandidateProvider(yWorks.Controls.Input.IPortCandidate,yWorks.Geometry.PointD)">
      <summary>
        <para>Retrieves the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> instance that provides the possible candidates for the target of the edge given the current source candidate.</para>
      </summary>
      <remarks>
        <para>This implementation queries all nodes in the graph for <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTargetPortCandidateProvider(yWorks.Controls.Input.IPortCandidate,yWorks.Graph.IPortOwner,yWorks.Geometry.PointD)">their provider</see> and returns a composite unless <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.UseHitItemsCandidatesOnly" /> is set to <c>true</c> in which case the <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTargetPortCandidateProvider(yWorks.Controls.Input.IPortCandidate,yWorks.Graph.IPortOwner,yWorks.Geometry.PointD)" /> is queried using the current <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTarget(yWorks.Geometry.PointD)">target</see>.</para>
      </remarks>
      <param name="sourcePortCandidate">
        <para>The source candidate that has been chosen for the edge creation.</para>
      </param>
      <param name="location">
        <para>The location of the mouse.</para>
      </param>
      <returns>
        <para>The provider to get the port candidates from.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetClosestTargetCandidate(System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate},yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the closest target candidate given a number of <see cref="T:yWorks.Controls.Input.IPortCandidate" />s and a location in world coordinates.</para>
      </summary>
      <param name="candidates">
        <para>The candidates to find the closest from.</para>
      </param>
      <param name="location">
        <para>The location of the mouse in world coordinates.</para>
      </param>
      <returns>
        <para>The candidate to use or <c>null</c> if no candidate satisfies the needs or <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.EnforceBendCreationRecognizer" /> yields <c>true</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetClosestSourceCandidate(System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate},yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the closest candidate given a number of <see cref="T:yWorks.Controls.Input.IPortCandidate" />s and a location in world coordinates.</para>
      </summary>
      <param name="candidates">
        <para>The candidates to find the closest from.</para>
      </param>
      <param name="location">
        <para>The location of the pointer in world coordinates.</para>
      </param>
      <returns>
        <para>The candidate to use or <c>null</c> if no candidate satisfies the needs</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetClosestCandidate(System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate},yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the closest <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Valid" /> candidate given a number of <see cref="T:yWorks.Controls.Input.IPortCandidate" />s and a location in world coordinates.</para>
      </summary>
      <param name="candidates">
        <para>The candidates to find the closest from.</para>
      </param>
      <param name="location">
        <para>The location of the mouse in world coordinates.</para>
      </param>
      <returns>
        <para>The candidate to use or <c>null</c> if no candidate satisfies the needs</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTargetPortCandidateProvider(yWorks.Controls.Input.IPortCandidate,yWorks.Graph.IPortOwner,yWorks.Geometry.PointD)">
      <summary>
        <para>Retrieves the port candidate provider instance given a source port candidate and a possible target item.</para>
      </summary>
      <remarks>
        <para>This implementations uses the <paramref name="targetOwner" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> to retrieve an <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> implementation.</para>
      </remarks>
      <param name="sourcePortCandidate">
        <para>The current source port candidate.</para>
      </param>
      <param name="targetOwner">
        <para>The <see cref="T:yWorks.Graph.IPortOwner" /> to find the candidates for.</para>
      </param>
      <param name="location">
        <para>The location of the mouse.</para>
      </param>
      <returns>
        <para>A provider instance or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSourcePortCandidateProvider(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Retrieves the port candidate provider instance given a source port owner.</para>
      </summary>
      <remarks>
        <para>This implementations uses the <paramref name="sourceOwner" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> to retrieve an <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> implementation.</para>
      </remarks>
      <param name="sourceOwner">
        <para>The <see cref="T:yWorks.Graph.IPortOwner" /> to find the candidates for.</para>
      </param>
      <returns>
        <para>A provider instance or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetPortOwner(yWorks.Geometry.PointD)">
      <summary>
        <para>Retrieves the port owner at a given position in world coordinates.</para>
      </summary>
      <remarks>
        <para>If there is a <see cref="T:yWorks.Controls.Input.IHitTester`1" /> for type <see cref="T:yWorks.Graph.INode" /> in the lookup of this mode's <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.InputModeContext" /> then this instance will be used for the query. <br /> Otherwise this implementation calls the <see cref="M:yWorks.Graph.Styles.INodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> method of the nodes to find hit nodes and uses the <see cref="T:System.Collections.Comparer" /> to determine the first hit node.</para>
      </remarks>
      <param name="location">
        <para>The position in world coordinates.</para>
      </param>
      <returns>
        <para>The node or <c>null</c> if no suitable node was found.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.SnapToTargetCandidate">
      <summary>
        <para>Gets or sets whether or not the edge's end point should snap to the current target port candidate during the creation of the edge.</para>
      </summary>
      <remarks>
        <para>This will make the edge's end point point to the position of the target port candidate. This will result in the preview edge looking exactly like the edge after creation.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.BeginHitTestable">
      <summary>
        <para>Gets or sets a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that determines, whether it is valid to start an edge creation gesture here.</para>
      </summary>
      <remarks>
        <para>The default implementation returns <c>true</c> if <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetSource(yWorks.Geometry.PointD)" /> yields a non-<c>null</c> value.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.EndHitTestable">
      <summary>
        <para>Gets or sets a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that determines, whether it is valid to finish an edge creation gesture here.</para>
      </summary>
      <remarks>
        <para>If fact this hit testable is only queried at all if <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.ForceSnapToCandidate" /> is disabled and if there is currently no <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.TargetPortCandidate" /> available.</para>
        <para>The default implementation returns <c>true</c> if there is a node at the given location.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.ValidBendHitTestable">
      <summary>
        <para>Gets or sets a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that determines, whether it is valid to create a bend here.</para>
      </summary>
      <remarks>
        <para>The default implementation returns always <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.StartPoint">
      <summary>
        <para>Gets a copy of the starting point at which the edge creation gesture started.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.DragPoint">
      <summary>
        <para>Gets the dynamically updated dragging point for the edge creation.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTargetPortCandidates(yWorks.Geometry.PointD,System.Boolean)">
      <summary>
        <para>Retrieves the target port candidates for a given location in world coordinates.</para>
      </summary>
      <remarks>
        <para>The <paramref name="resolveCandidates" /> parameter determines whether dynamic port candidates should be <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.ResolveCandidates(System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate},System.Nullable{yWorks.Geometry.PointD})">resolved</see> with respect to <paramref name="location" /> or simply be discarded. This implementation delegates to <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetTargetPortCandidateProvider(yWorks.Controls.Input.IPortCandidate,yWorks.Geometry.PointD)" /> or returns an empty enumerable if no provider has been found.</para>
      </remarks>
      <param name="location">
        <para>The location of the mouse in world coordinates.</para>
      </param>
      <returns>
        <para>A possibly empty enumeration over all target port candidates.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.SourcePortCandidate" />
      <param name="resolveCandidates">
        <para>Determines whether <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" /> ports should be resolved with respect to the <paramref name="location" /> or not.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.ResolveTargetPortCandidates" />
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.PortCandidateResolutionRecognizer" />
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.UpdateDummyEdgeSourcePort(yWorks.Controls.Input.IPortCandidate)">
      <summary>
        <para>Updates the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdge" /> to reflect the current source port candidate.</para>
      </summary>
      <remarks>
        <para>This implementation creates a self loop of the dummy edge if the <paramref name="sourcePortCandidate" /> is the same as the owner of the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.TargetPortCandidate" />.</para>
      </remarks>
      <param name="sourcePortCandidate">
        <para>The new owner target port candidate.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.UpdateDummyEdgeTargetPort(yWorks.Controls.Input.IPortCandidate)">
      <summary>
        <para>Updates the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdge" /> to reflect the current target port candidate.</para>
      </summary>
      <remarks>
        <para>This implementation creates a self loop of the dummy edge if the <paramref name="targetPortCandidate" /> is the same as the owner of the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.SourcePortCandidate" />.</para>
      </remarks>
      <param name="targetPortCandidate">
        <para>The new owner target port candidate.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.IsCreationInProgress">
      <summary>
        <para>Gets whether currently an edge creation is in progress.</para>
      </summary>
      <remarks>
        <para>This property yields <c>true</c> after the edge creation has been started and before it has been <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.Cancel">cancelled</see> or finalized.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureFinishing">
      <summary>
        <para>Occurs before the gesture will be finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureFinished">
      <summary>
        <para>Occurs once the gesture has been finished.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureStarting">
      <summary>
        <para>Occurs once the gesture is starting.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureStarted">
      <summary>
        <para>Occurs once the gesture is initialized and has started.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.Moving">
      <summary>
        <para>Occurs at the start of every drag or move.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.Moved">
      <summary>
        <para>Occurs at the end of every drag or move.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureCanceled">
      <summary>
        <para>Occurs when the gesture has been canceled.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureCanceling">
      <summary>
        <para>Occurs before the gesture will be canceled.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnGestureStarting(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureStarting" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnGestureStarted(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureStarted" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnMoving(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the start of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.Moving" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnMoved(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered at the end of each drag.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.Moved" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnGestureFinished(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered once the drag has been finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureFinished" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnGestureFinishing(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Callback triggered before the drag will be finalized.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureFinishing" /> event.</para>
      </remarks>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnGestureCanceled(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureCanceled" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnGestureCanceling(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.GestureCanceling" /> event.</para>
      </summary>
      <param name="inputModeEventArgs">
        <para>The event argument that contains context information.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetDummyEdgeSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.ISnapLineProvider)">
      <summary>
        <para>Gets the snap lines lines that are induced by the current dummy edge.</para>
      </summary>
      <param name="context">
        <para>The graph snap context.</para>
      </param>
      <param name="provider">
        <para>The dummy edge segment snap line provider.</para>
      </param>
      <returns>
        <para>The snap lines induced by the current dummy edge.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.GetFirstSegmentDirection">
      <summary>
        <para>Calculates direction of first edge segment of the DummyNode.</para>
      </summary>
      <remarks>
        <para>An edge starting in an border will always be orthogonal to the border's outer line. An edge starting in a corner will point the way the user dragged the mouse. An edge starting in the inner of the node will be directed the way dragged unless another edge that is close to the new edge (<see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.PreferredMinimalEdgeDistance" />) already went that way.</para>
      </remarks>
      <returns>
        <para>A <see cref="T:yWorks.Controls.Input.EdgeSegmentDirection" /> defining the direction of the first edge segment.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.OnEdgeCreationStarted(yWorks.Graph.EdgeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreationStarted" /> event when the gesture for creating an edge has been initialized.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Graph.EdgeEventArgs" /> instance containing the dummy edge that will be used during edge creation.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreationStarted">
      <summary>
        <para>Occurs when the edge creation has started.</para>
      </summary>
      <remarks>
        <para>The edge that is stored in the <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" /> property is the <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.DummyEdge" /> that is used during creation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.CreateEdgeInputMode.UpdateTargetLocation(yWorks.Geometry.PointD)">
      <summary>
        <para>Updates the drag point.</para>
      </summary>
      <remarks>
        <para>This method is called when the current target location for the creation gesture is changed.</para>
      </remarks>
      <param name="location">
        <para>The new coordinates.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.EnforceBendCreationRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that will be queried to decide if bend creation is enforced.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlPressed" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.CreateEdgeInputMode.Graph">
      <summary>
        <para>Gets the Graph this mode is acting upon.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.EdgeSegmentDirection">
      <summary>
        <para>Defines the direction of an edge segment</para>
      </summary>
      <remarks>
        <para>This enumeration is used by <see cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetFirstSegmentDirection" /></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.CreateEdgeInputMode.GetFirstSegmentDirection" />
    </member>
    <member name="F:yWorks.Controls.Input.EdgeSegmentDirection.North">
      <summary>
        <para>The edge segment is going into north direction</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.EdgeSegmentDirection.East">
      <summary>
        <para>The edge segment is going into east direction</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.EdgeSegmentDirection.South">
      <summary>
        <para>The edge segment is going into south direction</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.EdgeSegmentDirection.West">
      <summary>
        <para>The edge segment is going into west direction</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.NodeCreationCallback">
      <summary>
        <para>A callback that is used by <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> for the creation of nodes.</para>
      </summary>
      <remarks>
        <para>This callback can be used to conveniently provide a hook to the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> using its <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeCreator" /> property.</para>
      </remarks>
      <param name="context">
        <para>The context for which the node should be created.</para>
      </param>
      <param name="graph">
        <para>The graph to create the node for.</para>
      </param>
      <param name="location">
        <para>The location where the node shall be created.</para>
      </param>
      <param name="parent">
        <para>A group node at the click location which can be used as parent node for the newly-created node. <c>null</c> if the new node should be created at root level.</para>
      </param>
      <returns>
        <para>The created node or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.AdjustContentRectPolicy">
      <summary>
        <para>Policy to determine how the <see cref="P:yWorks.Controls.CanvasControl.ContentRect">content rectangle</see> of the <see cref="T:yWorks.Controls.GraphControl" /> should be recalculated after interactive graph changes.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AdjustContentRectPolicy" />
    </member>
    <member name="F:yWorks.Controls.Input.AdjustContentRectPolicy.Never">
      <summary>
        <para>The content rectangle is not adjusted automatically after interactive changes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.AdjustContentRectPolicy.Union">
      <summary>
        <para>The new content rectangle is recalculated with the union of the previous content rectangle and the new <see cref="M:yWorks.Controls.GraphControl.FitGraphBounds(System.Nullable{yWorks.Geometry.InsetsD})">bounds of the graph</see>.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.AdjustContentRectPolicy.Always">
      <summary>
        <para>The new content rectangle is recalculated with the new <see cref="M:yWorks.Controls.GraphControl.FitGraphBounds(System.Nullable{yWorks.Geometry.InsetsD})">bounds of the graph</see>.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.GraphEditorInputMode">
      <summary>
        <para>A complex <see cref="T:yWorks.Controls.Input.IInputMode" /> that can be used in a <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.GraphControl" /> to edit an <see cref="T:yWorks.Graph.IGraph" /> instance.</para>
      </summary>
      <remarks>
        <para>This class delegates most of the work to minor <see cref="T:yWorks.Controls.Input.IInputMode" /> implementations. However it contains a number of properties that influence the general behavior:</para>
        <list type="bullet">
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphInputMode.SelectableItems" />
            </term>
            <description>Determines the types of items that can be selected at all.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphInputMode.SelectablePredicate" />
            </term>
            <description>Allows to further constrain <see cref="P:yWorks.Controls.Input.GraphInputMode.SelectableItems" /> with a predicate.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectableItems" />
            </term>
            <description>Determines the types of items that can be selected with <see cref="T:yWorks.Controls.Input.MarqueeSelectionInputMode">marquee selection</see>.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickSelectableItems" />
            </term>
            <description>Determines the types of items that can be selected by <see cref="T:yWorks.Controls.Input.ClickInputMode">clicking them</see>.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphInputMode.DetailSelectionRecognizer" />
            </term>
            <description>Determines when to use a detail click selection mode, which allows for selecting the item that is directly under the mouse without taking into account the <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickHitTestOrder" />.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickHitTestOrder" />
            </term>
            <description>Determines the priorities for hit tests during mouse clicks to determine which items should get <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked">click events</see>.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphInputMode.DoubleClickHitTestOrder" />
            </term>
            <description>Determines the priorities for hit tests when <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked">double-clicking items</see>.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MovableItems" />
            </term>
            <description>Determines the type of the items that can be <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode">moved</see> with the mouse.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ShowHandleItems" />
            </term>
            <description>Determines the type of the items whose <see cref="T:yWorks.Controls.Input.IHandle" />s should be shown and movable by the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode" />.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.DeletableItems" />
            </term>
            <description>Determines the type of the items that can be deleted by <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DeleteSelection" />.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.DeletablePredicate" />
            </term>
            <description>Allows to further constrain <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.DeletableItems" /> with a predicate.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.LabelEditableItems" />
            </term>
            <description>Determines the type of the items that can have their labels edited.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" />
            </term>
            <description>Determines whether this input mode should allow grouping operations at all.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupSelection" />
            </term>
            <description>Determines whether this input mode should allow <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.GroupSelection">grouping the current selection</see>.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowUngroupSelection" />
            </term>
            <description>Determines whether this input mode should allow <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.UngroupSelection">ungrouping the current selection</see>.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowClearSelection" />
            </term>
            <description>Determines whether this input mode should allow <see cref="M:yWorks.Controls.Input.GraphInputMode.ClearSelection">clearing the selection</see>. This has implications both for the <see cref="F:yWorks.Controls.Input.Commands.DeselectAll" /> and for click/marquee selection which usually clear the selection unless the <see cref="P:yWorks.Controls.Input.GraphInputMode.MultiSelectionRecognizer" /> is pressed.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphInputMode.AllowClipboardOperations" />
            </term>
            <description>Determines whether this input mode should enable <see cref="T:yWorks.Graph.GraphClipboard">graph clipboard operations.</see></description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowDuplicate" />
            </term>
            <description>Determines whether this input mode should enable <see cref="T:yWorks.Graph.GraphClipboard">graph clipboard's</see> <see cref="M:yWorks.Graph.GraphClipboard.Duplicate(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.ElementCopiedCallback)" /> operation.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabel" />
            </term>
            <description>Determines whether this input mode should allow editing labels.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReparentNodes" />
            </term>
            <description>Determines whether this input mode should allow <see cref="T:yWorks.Controls.Input.IReparentNodeHandler">reparenting nodes to other groups.</see></description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowCreateNode" />
            </term>
            <description>Determines whether this input mode should allow <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeCreator">creating new nodes</see> via simple mouse clicks.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowCreateEdge" />
            </term>
            <description>Determines whether <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode" /> should be <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Enabled" /> to allow for creating new edges.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabelOnDoubleClick" />
            </term>
            <description>Determines whether labels should be editable on otherwise unhandled double clicks.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReverseEdge" />
            </term>
            <description>Determines whether edges can be reversed.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowCreateBend" />
            </term>
            <description>Determines whether the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode" /> should be <see cref="P:yWorks.Controls.Input.CreateBendInputMode.Enabled" /> to allow for creating new bends.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowEnterGroup" />
            </term>
            <description>Determines whether the mode allows for <see cref="M:yWorks.Controls.Input.NavigationInputMode.EnterGroup(yWorks.Graph.INode)">entering</see> group nodes in <see cref="T:yWorks.Graph.IFoldingView" />s.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowExitGroup" />
            </term>
            <description>Determines whether the mode allows for <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExitGroup">exiting</see> the current group node in <see cref="T:yWorks.Graph.IFoldingView" />s.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowCollapseGroup" />
            </term>
            <description>Determines whether the mode allows for <see cref="M:yWorks.Controls.Input.NavigationInputMode.CollapseGroup(yWorks.Graph.INode)">collapsing</see> group nodes in <see cref="T:yWorks.Graph.IFoldingView" />s.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowExpandGroup" />
            </term>
            <description>Determines whether the mode allows for <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExpandGroup(yWorks.Graph.INode)">expanding</see> group nodes in <see cref="T:yWorks.Graph.IFoldingView" />s.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.ItemHoverInputMode.HoverItems" />
            </term>
            <description>Determines which items should be reported as being hovered through the <see cref="E:yWorks.Controls.Input.ItemHoverInputMode.HoveredItemChanged">corresponding event</see> in this instance's <see cref="T:yWorks.Controls.Input.ItemHoverInputMode" />.</description>
          </item>
          <item>
            <term>
              <see cref="M:yWorks.Controls.Input.GraphInputMode.ShouldInstallCommand(yWorks.Controls.ICommand)" />
            </term>
            <description>Determines which of the built-in <see cref="T:yWorks.Controls.ICommand" />s this input mode should provide and install.</description>
          </item>
        </list>
        <para>By default, <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> supports the following commands. Most of them have default keybindings:</para>
        <list type="bullet">
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.Undo" /> (Ctrl+Z)</term>
            <description>Undoes the last operation. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowUndoOperations" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.Redo" /> (Ctrl+Y)</term>
            <description>Redoes the last operation that was undone. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowUndoOperations" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.SelectAll" /> (Ctrl+A)</term>
            <description>Selects all items. Can be configured with <see cref="P:yWorks.Controls.Input.GraphInputMode.SelectableItems" /> and <see cref="P:yWorks.Controls.Input.GraphInputMode.SelectablePredicate" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.DeselectAll" /> (Ctrl+Shift+A)</term>
            <description>Clears the current selection. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowClearSelection" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.Cut" /> (Ctrl+X, Shift+Del)</term>
            <description>Cuts the current selection and places it in the clipboard. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphInputMode.AllowClipboardOperations" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.Copy" /> (Ctrl+C, Ctrl+Ins)</term>
            <description>Copies the current selection to the clipboard. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphInputMode.AllowClipboardOperations" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.Paste" /> (Ctrl+V, Shift+Ins)</term>
            <description>Pastes the current clipboard contents into the graph. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphInputMode.AllowClipboardOperations" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.Duplicate" /> (Ctrl+D)</term>
            <description>Duplicates the current selection. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowDuplicate" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.Delete" /> (Del)</term>
            <description>Deletes the current selection. Can be configured with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.DeletablePredicate" /> and <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.DeletableItems" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.AddLabel" /> (Shift+F2)</term>
            <description>Adds a new label to the selected item. Can be configured with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.LabelEditableItems" /> and disabled with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowAddLabel" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.EditLabel" /> (F2)</term>
            <description>Edits an existing label or adds a new one to the selected item. Can be configured with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.LabelEditableItems" /> and disabled with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabel" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.ReverseEdge" /> (Ctrl+R)</term>
            <description>Reverses the direction of the selected edges. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReverseEdge" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.GroupSelection" /> (Ctrl+G)</term>
            <description>Creates a new group node and places the currently selected nodes into it. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" /> and <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupSelection" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.UngroupSelection" /> (Ctrl+U)</term>
            <description>Creates a new group node and places the currently selected nodes into it. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" /> and <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowUngroupSelection" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.AdjustGroupNodeSize" /> (Ctrl+Shift+G)</term>
            <description>Adjusts the sizes of the selected group nodes to fit exactly around their contents. Can be disabled with <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" /> and <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowAdjustGroupNodeSize" />.</description>
          </item>
        </list>
        <para>All commands can also be selectively disabled by using the <see cref="P:yWorks.Controls.Input.GraphInputMode.AvailableCommands" /> collection. Furthermore, there are a few commands provided by <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" />:</para>
        <list type="bullet">
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.CollapseGroup" /> (Ctrl+Minus)</term>
            <description>Collapses the currently selected group nodes. Can be disabled with <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowCollapseGroup" /> of <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.ExpandGroup" /> (Ctrl+Plus)</term>
            <description>Expands the currently selected group nodes. Can be disabled with <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowExpandGroup" /> of <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.ToggleExpansionState" /> (Ctrl+Multiply)</term>
            <description>Collapses expanded group nodes and expands collapsed group nodes in the current selection. Can be disabled with <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowCollapseGroup" /> and <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowExpandGroup" /> of <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.EnterGroup" /> (Ctrl+Enter)</term>
            <description>Replaces the currently displayed graph with the contents of the selected group node. Can be disabled with <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowEnterGroup" /> of <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" />.</description>
          </item>
          <item>
            <term>
              <see cref="F:yWorks.Controls.Input.Commands.ExitGroup" /> (Ctrl+Backspace)</term>
            <description>Replaces the currently displayed graph with the contents of the parent of the group node whose contents are currently displayed. Can be disabled with <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowExitGroup" /> of <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" />.</description>
          </item>
        </list>
        <para>
          <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> can be configured to automatically <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustContentRect">adjust the content rectangle</see> of the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.GraphControl" /> whenever the graph is changed using gestures.<br /> This class contains a number of public methods that can be used to programmatically perform the corresponding actions, too. <br /> Setting the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeCreator" /> to another instance or <c>null</c> changes the way nodes are created. Also the various minor <see cref="T:yWorks.Controls.Input.IInputMode" /> instances can be disabled, to change the behavior, too.</para>
        <para>This input mode manages a set of specialized input modes, each handling a specific part of the interaction with the graph. The following list details those along with their default <see cref="P:yWorks.Controls.Input.IInputMode.Priority">priorities</see>. Lower priorities come earlier when handling events.</para>
        <list type="bullet">
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.WaitInputMode" /> (−1)</term>
            <description>Disables this input mode when layouts or animations run.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode" /> (0)</term>
            <description>Deals with displaying handles on or around items and interacting with them.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.KeyboardInputMode" /> (0)</term>
            <description>Handles commands and arbitrary keyboard shortcuts.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.ClickInputMode" /> (10)</term>
            <description>Handles mouse clicks and double-clicks.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.MoveViewportInputMode" /> (39)</term>
            <description>Allows panning the viewport.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode" /> (39)</term>
            <description>Allows moving labels to new positions.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode" /> (40)</term>
            <description>Allows moving items that are not labels.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode" /> (42)</term>
            <description>Allows creating bends on edges.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode" /> (45)</term>
            <description>Allows creating edges</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.MarqueeSelectionInputMode" /> (50)</term>
            <description>Allows dragging a rectangle to select items within it.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.ItemHoverInputMode" /> (55)</term>
            <description>Provides events to indicate that the mouse pointer hovers over an item.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.NavigationInputMode" /> (55)</term>
            <description>Provides general navigation facilities, such as navigating from one item to another with the arrow keys, collapsing, expanding, entering or exiting groups, as well as providing commands for those tasks.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.ContextMenuInputMode" /> (60)</term>
            <description>Handles querying the context menu contents based on a location as well as preparing the menu for display.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeDropInputMode" /> (70)</term>
            <description>Allows dropping nodes on the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.GraphControl" />, e.g. for dragging items from a palette.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.MouseHoverInputMode" /> (100)</term>
            <description>Handles tool tips.</description>
          </item>
          <item>
            <term>
              <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.TextEditorInputMode" /> (100)</term>
            <description>Handles editing labels.</description>
          </item>
        </list>
        <para>To enable single selection mode, disable <see cref="T:yWorks.Controls.Input.MarqueeSelectionInputMode" /> and set <see cref="P:yWorks.Controls.Input.GraphInputMode.MultiSelectionRecognizer" /> to <see cref="F:yWorks.Controls.Input.EventRecognizers.Never" />. Remove <see cref="F:yWorks.Controls.Input.Commands.SelectAll" /> and <see cref="F:yWorks.Controls.Input.Commands.ToggleItemSelection" /> from <see cref="P:yWorks.Controls.Input.GraphInputMode.AvailableCommands" /> and <see cref="F:yWorks.Controls.Input.Commands.ExtendSelectionLeft" />, <see cref="F:yWorks.Controls.Input.Commands.ExtendSelectionRight" />, <see cref="F:yWorks.Controls.Input.Commands.ExtendSelectionUp" />, <see cref="F:yWorks.Controls.Input.Commands.ExtendSelectionDown" />, <see cref="F:yWorks.Controls.Input.Commands.SelectToPageUp" /> and <see cref="F:yWorks.Controls.Input.Commands.SelectToPageDown" /> from <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" />.<see cref="P:yWorks.Controls.Input.NavigationInputMode.AvailableCommands" />. An example can be found in <c>Demo.yFiles.Graph.Input.SingleSelection</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeDropInputMode" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.#ctor">
      <summary>
        <para>Creates a new instance that is not bound to an existing graph or selection, initially.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Graph.IGraph" /> and <see cref="T:yWorks.Controls.IGraphSelection" /> instances are obtained later from the <see cref="T:yWorks.Controls.Input.IInputModeContext" /> once this mode gets <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see> in a suitable canvas control.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateMoveViewportInputMode" />
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.OrthogonalEdgeEditingContext">
      <summary>
        <para>Gets or sets the orthogonal edge editing context.</para>
      </summary>
      <remarks>
        <para>The default value is <c>null</c>.</para>
      </remarks>
      <value>
        <para>The orthogonal edge editing context.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.OrthogonalBendRemoval">
      <summary>
        <para>Gets or sets the policy that controls whether removing bends from an orthogonal edge will keep the edge orthogonal.</para>
      </summary>
      <remarks>
        <para>By default this feature is enabled automatically if an <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.OrthogonalEdgeEditingContext" /> is set.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.OrthogonalEdgeEditingContext" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.SnapToGrid(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode)">
      <summary>
        <para>Snaps the node to the grid using the <see cref="T:yWorks.Controls.Input.IGridConstraintProvider`1" /> for <see cref="T:yWorks.Graph.INode" />s queried from the given context.</para>
      </summary>
      <remarks>
        <para>This method is called by this instance whenever new nodes are created using the UI.</para>
      </remarks>
      <param name="context" />
      <param name="node" />
      <seealso cref="M:yWorks.Controls.Input.MultiplexingInputMode.CreateChildInputModeContext" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ChildInputModeContextLookup(System.Type)">
      <param name="type" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.IReparentNodeHandler" /> that is used for moving nodes out of group nodes or into other group nodes.</para>
      </summary>
      <remarks>
        <para>This setting has no effect if reparenting nodes is generally disallowed by setting <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReparentNodes" /> to <c>false</c>.</para>
        <para>Child input modes will use this <see cref="T:yWorks.Controls.Input.IReparentNodeHandler" /> as well, since it is added to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ChildInputModeContextLookup(System.Type)" />.</para>
        <para>If not already initialized, the factory method <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateReparentNodeHandler" /> will be called on first access. Upon changes, the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnReparentNodeHandlerChanged(yWorks.Controls.Input.IReparentNodeHandler,yWorks.Controls.Input.IReparentNodeHandler)" /> method will be called.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReparentNodes" />
      <seealso cref="T:yWorks.Controls.Input.ReparentNodeHandler" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnReparentNodeHandlerChanged(yWorks.Controls.Input.IReparentNodeHandler,yWorks.Controls.Input.IReparentNodeHandler)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateReparentNodeHandler">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.HitTester">
      <summary>
        <para>Gets or sets the hitTester property.</para>
      </summary>
      <remarks>
        <para>The enumerator will be queried for hit tests if the user clicks on the canvas.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.PasteSelectableItems">
      <summary>
        <para>Gets or sets which types of items should be selected after <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.Paste" /> or <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DuplicateSelection" />.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldSelectAfterPaste(yWorks.Graph.IModelItem)" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.SmartPasteSelection" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.SmartPasteSelection">
      <summary>
        <para>Gets or sets whether nodes, edges, labels, and ports should only be selected after <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.Paste" /> or <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DuplicateSelection" /> if they were selected when they were initially copied into the clipboard.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>. Disabling this feature will select all <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.PasteSelectableItems" /> after a paste or duplicate operation.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldSelectAfterPaste(yWorks.Graph.IModelItem)" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.PasteSelectableItems" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.MovableItems">
      <summary>
        <para>Gets or sets which types of items should be movable using the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode" /> or <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode" /> respectively in case of labels.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldMove(yWorks.Graph.IModelItem)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.DeletableItems">
      <summary>
        <para>Gets or sets which types of items may be deleted using the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DeleteSelection" /> action.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldDelete(yWorks.Graph.IModelItem)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.DeletablePredicate">
      <summary>
        <para>Gets or sets a predicate that is queried to determine whether an <see cref="T:yWorks.Graph.IModelItem" /> can be deleted or not.</para>
      </summary>
      <remarks>
        <para>This allows to further restrict which items are deletable, compared to <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.DeletableItems" />. If this property is set to <c>null</c> the effect is the same as a predicate that always returns <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.LabelEditableItems">
      <summary>
        <para>Gets or sets which types of items may have their <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnEditLabel">labels edited</see>.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.LabelOwner" />|<see cref="F:yWorks.Graph.GraphItemTypes.Label" />, which allows for editing the labels of <see cref="T:yWorks.Graph.ILabelOwner" />s, and existing <see cref="T:yWorks.Graph.ILabel" />s.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldEditLabel(yWorks.Graph.IModelItem)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateHandleInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnHandleInputModeChanged(yWorks.Controls.Input.HandleInputMode,yWorks.Controls.Input.HandleInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateHandleInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of HandleInputMode</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.ShowHandleItems">
      <summary>
        <para>Gets or sets which types of items should have their <see cref="T:yWorks.Controls.Input.IHandle" />s shown.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldShowHandles(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.RequeryHandles">
      <summary>
        <para>Trigger a reevaluation of all visible handles</para>
      </summary>
      <remarks>
        <para>This method is called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ShowHandleItems" /> property is changed.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnHandleInputModeChanged(yWorks.Controls.Input.HandleInputMode,yWorks.Controls.Input.HandleInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldAddLabel(yWorks.Graph.IModelItem)">
      <summary>
        <para>Predicate that determines whether a label may be added interactively to <paramref name="item" /></para>
      </summary>
      <remarks>
        <para>This is overridden if the item has a <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> that returns <c>false</c> for its <see cref="M:yWorks.Controls.Input.IEditLabelHelper.OnLabelAdding(yWorks.Controls.Input.LabelEditingEventArgs)" /> method.</para>
      </remarks>
      <param name="item">
        <para>The item to query</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff a label may be added</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.UseCurrentItemForCommands">
      <summary>
        <para>Gets or sets a value indicating whether to use the <see cref="P:yWorks.Controls.GraphControl.CurrentItem" /> as a fallback for the commands if no item is provided in the parameter and the current selection is empty.</para>
      </summary>
      <remarks>
        <para>This applies to the following commands:</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.AddLabel" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.EditLabel" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.AdjustGroupNodeSize" />
          </item>
        </list>
      </remarks>
      <value>
        <para>
          <c>true</c> if the current item should be used as a fallback; <c>false</c> otherwise, which is the default.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustGroupNodeSizes">
      <summary>
        <para>
          <see cref="M:yWorks.Graph.GroupedGraphExtensions.AdjustGroupNodeLayout(yWorks.Graph.IGraph,yWorks.Graph.INode)">Adjusts the size</see> of the selected group nodes.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustGroupNodeSize(System.Collections.Generic.IEnumerable{yWorks.Graph.INode})" /> with the <see cref="P:yWorks.Controls.IGraphSelection.SelectedNodes">currently selected nodes</see>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustGroupNodeSize(System.Collections.Generic.IEnumerable{yWorks.Graph.INode})" />
      <seealso cref="F:yWorks.Controls.Input.Commands.AdjustGroupNodeSize" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustGroupNodeSize(System.Collections.Generic.IEnumerable{yWorks.Graph.INode})">
      <summary>
        <para>
          <see cref="M:yWorks.Graph.GroupedGraphExtensions.AdjustGroupNodeLayout(yWorks.Graph.IGraph,yWorks.Graph.INode)">Adjusts the size</see> of the group nodes in the enumerable.</para>
      </summary>
      <remarks>
        <para>This action is executed in response to the <see cref="F:yWorks.Controls.Input.Commands.AdjustGroupNodeSize" /> if <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowAdjustGroupNodeSize" /> is set to <c>true</c>.</para>
      </remarks>
      <param name="nodes">
        <para>The nodes to adjust their sizes.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.Paste">
      <summary>
        <para>Pastes the current clipboard contents.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.PasteAtLocation(yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.PasteAtLocation(yWorks.Geometry.PointD)">
      <summary>
        <para>Pastes the current clipboard contents at the given location.</para>
      </summary>
      <remarks>
        <para>The location is at the center of the bounds of the items that are pasted. This method reconfigures <see cref="P:yWorks.Graph.GraphClipboard.PasteDelta" /> and calls <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.Paste" />.</para>
      </remarks>
      <param name="location">
        <para>The location at which the center of the clipboard's contents should be positioned.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.DuplicateSelection">
      <summary>
        <para>Duplicates the selected elements.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.PasteDelta">
      <summary>
        <para>Gets or sets the offset for paste operation if clipboard operations are enabled.</para>
      </summary>
      <remarks>
        <para>Default is (15, 15).</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.Cut">
      <summary>
        <para>Cuts and inserts the currently selected elements to the clipboard.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.Undo">
      <summary>
        <para>Delegates to the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="T:yWorks.Graph.UndoEngine" />'s <see cref="M:yWorks.Graph.UndoEngine.Undo" /> method.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.Redo">
      <summary>
        <para>Delegates to the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="T:yWorks.Graph.UndoEngine" />'s <see cref="M:yWorks.Graph.UndoEngine.Redo" /> method.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.UngroupSelection">
      <summary>
        <para>Makes each of the currently selected nodes a direct child of the root group.</para>
      </summary>
      <remarks>
        <para>The default shortcut for this is Ctrl+U.</para>
      </remarks>
      <seealso cref="F:yWorks.Controls.Input.Commands.UngroupSelection" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.GroupSelection">
      <summary>
        <para>Creates a new group for all of the currently selected elements.</para>
      </summary>
      <remarks>
        <para>This method will also clear the selection and select the newly created group node.</para>
        <para>The default shortcut for this is Ctrl+G.</para>
      </remarks>
      <returns>
        <para>The newly created group node or <c>null</c>.</para>
      </returns>
      <seealso cref="F:yWorks.Controls.Input.Commands.GroupSelection" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.ClearSelection" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabel">
      <summary>
        <para>Gets or sets a value determining whether the <see cref="F:yWorks.Controls.Input.Commands.EditLabel" /> command should be handled.</para>
      </summary>
      <remarks>
        <para>If this flag is set to <c>true</c> pressing F2 will start the label editor. By default this feature is enabled.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabel(yWorks.Graph.ILabel)" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnEditLabel" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabelOnDoubleClick">
      <summary>
        <para>Gets or sets a value determining whether double-clicking should start label editing.</para>
      </summary>
      <remarks>
        <para>If enabled, double-clicking an item will automatically execute the <see cref="F:yWorks.Controls.Input.Commands.EditLabel" /> command.</para>
        <para>This setting has no effect if label editing is generally disallowed by setting <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabel" /> to <c>false</c>.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabel" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowAddLabel">
      <summary>
        <para>Gets or sets a value determining whether the <see cref="F:yWorks.Controls.Input.Commands.AddLabel" /> command should be handled.</para>
      </summary>
      <remarks>
        <para>If this flag is set to <c>true</c> pressing Shift+F2 will start the label editor. By default this feature is enabled.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateLabel(yWorks.Graph.ILabelOwner)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnEditLabel">
      <summary>
        <para>Callback that is invoked if the F2 key is pressed and <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabel" /> is set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>This method determines the label to edit and delegates to either <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabel(yWorks.Graph.ILabel)" /> or <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateLabel(yWorks.Graph.ILabelOwner)" /> if no label could be found.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnAddLabel">
      <summary>
        <para>Callback that is invoked if the shift+F2 key is pressed and <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowAddLabel" /> is set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>This method determines the label owner to add to and delegates to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateLabel(yWorks.Graph.ILabelOwner)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateLabel(yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Interactively creates a new label for the provided label owner.</para>
      </summary>
      <remarks>
        <para>This method will invoke the text editor that will let the user edit the text of the label. If the user commits the label text the label will be added to the label owner.</para>
        <para>The text that the user enters may be <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.ValidateLabelText">validated</see> before the label is actually added.</para>
        <para>This method works nearly identical to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AddLabel(yWorks.Graph.ILabelOwner)" />. The only difference is when either the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdding" /> event is handled, or <paramref name="owner" /> has an <see cref="T:yWorks.Controls.Input.IEditLabelHelper" />, and via those instead of adding a label an existing one should be edited. This method will do nothing instead of editing an existing label or adding a new one in that case.</para>
      </remarks>
      <param name="owner">
        <para>The item to create a new label for.</para>
      </param>
      <returns>
        <para>A future of the label that will be notified of the newly created label or a <c>null</c> if the creation was canceled.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnLabelAdded(yWorks.Graph.LabelEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdded" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance that contains the <see cref="T:yWorks.Graph.ILabel" /> that has been added.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdded">
      <summary>
        <para>Occurs when this mode has triggered the addition of an <see cref="T:yWorks.Graph.ILabel" />, for instance, in response to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateLabel(yWorks.Graph.ILabelOwner)" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabel(yWorks.Graph.ILabel)">
      <summary>
        <para>Starts editing the given label.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="T:yWorks.Controls.Input.TextEditorInputMode" /> to display an editor to edit the label. The text that the user enters may be <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.ValidateLabelText">validated</see> before the label is actually edited.</para>
        <para>The label to edit can be a <see cref="T:yWorks.Graph.SimpleLabel" />, which will be edited as usual, except that the label text changes will be written directly back into the instance.</para>
        <para>This method will raise the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelEditing" /> event and query the <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> for the label and its owner, but will ignore the result except for the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.TextEditorInputModeConfigurator" /> property on the <see cref="T:yWorks.Controls.Input.LabelEditingEventArgs" />. Thus editing a label via this method cannot be prevented by event handlers or <see cref="T:yWorks.Controls.Input.IEditLabelHelper" />s.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnLabelTextEdited(yWorks.Graph.ILabel,System.String)" />
      <param name="label">
        <para>The label to edit.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.LabelTextEditingStarted">
      <summary>
        <para>Occurs when the actual label editing process is about to start.</para>
      </summary>
      <remarks>
        <para>This allows to customize the label editing process.</para>
      </remarks>
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.ValidateLabelText" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnLabelTextEditingStarted(yWorks.Graph.LabelEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelTextEditingStarted" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Graph.LabelEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.LabelTextEditingCanceled">
      <summary>
        <para>Occurs when the actual label editing process is canceled.</para>
      </summary>
      <remarks>
        <para>This allows to unconfigure temporary customizations for the actual label editing process.</para>
      </remarks>
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.ValidateLabelText" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnLabelTextEditingCanceled(yWorks.Graph.LabelEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelTextEditingCanceled" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Graph.LabelEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnLabelTextEdited(yWorks.Graph.ILabel,System.String)">
      <summary>
        <para>Called when the text of a label has been <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabel(yWorks.Graph.ILabel)">edited</see>.</para>
      </summary>
      <remarks>
        <para>This method <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.ValidateLabelText">validates the label text</see> and if successful calls <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.SetLabelText(yWorks.Graph.ILabel,System.String)" />.</para>
      </remarks>
      <param name="label">
        <para>The label that was edited.</para>
      </param>
      <param name="text">
        <para>The new text.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnValidateLabelText(yWorks.Controls.Input.LabelTextValidatingEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.ValidateLabelText" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.LabelTextValidatingEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.ValidateLabelText">
      <summary>
        <para>Occurs when a label that is about to be <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AddLabel(yWorks.Graph.ILabelOwner)">added</see> or <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabel(yWorks.Graph.ILabel)">edited</see>.</para>
      </summary>
      <remarks>
        <para>This event that can be used to validate the label text before inserting/updating the actual label.</para>
        <para>Note that in the case of <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AddLabel(yWorks.Graph.ILabelOwner)" /> the <see cref="P:yWorks.Controls.Input.LabelTextValidatingEventArgs.Label" /> is not part of the current graph but only a dummy instance.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnValidateLabelText(yWorks.Controls.Input.LabelTextValidatingEventArgs)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.AddLabel(yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Adds a new label to the given item interactively.</para>
      </summary>
      <remarks>
        <para>This will activate the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.TextEditorInputMode" /> to let the user interactively enter the label's text and unless the user cancels label creation the returned <see cref="T:yWorks.Utils.Future`1" /> will contain the label.</para>
        <para>The text that the user enters may be <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.ValidateLabelText">validated</see> before the label is actually added.</para>
        <para>This method works nearly identical to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateLabel(yWorks.Graph.ILabelOwner)" />. The only difference is when either the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdding" /> event is handled, or <paramref name="owner" /> has an <see cref="T:yWorks.Controls.Input.IEditLabelHelper" />, and via those instead of adding a label an existing one should be edited. This method will edit that label instead of adding a new one.</para>
      </remarks>
      <param name="owner">
        <para>The item to add a label to.</para>
      </param>
      <returns>
        <para>A future of the label that will be notified of the newly created label or a <c>null</c> if the creation was canceled.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CloseLabelEditor(System.Boolean)">
      <summary>
        <para>Closes the label editor if it is currently open.</para>
      </summary>
      <param name="cancel">
        <para>Whether to cancel the editor and discard changes.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.SetLabelText(yWorks.Graph.ILabel,System.String)">
      <summary>
        <para>Sets the label's text after it has been <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabel(yWorks.Graph.ILabel)">edited</see>.</para>
      </summary>
      <remarks>
        <para>Depending on <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AutoRemoveEmptyLabels" /> it will either set the label's text or remove it from the graph. Also this method will query the label's <see cref="P:yWorks.Graph.ILabel.Owner" /> for an <see cref="T:yWorks.Controls.Input.INodeSizeConstraintProvider" /> if the owner is an <see cref="T:yWorks.Graph.INode" /> and will make sure that the size constraints are still kept if the <see cref="P:yWorks.Graph.ILabel.PreferredSize" /> changes due to the edit by calling <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustToSizeConstraints(yWorks.Graph.INode)" />.</para>
      </remarks>
      <param name="label">
        <para>The label to set the text or remove.</para>
      </param>
      <param name="text">
        <para>The new text.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.LabelTextChanged">
      <summary>
        <para>Occurs when this mode has triggered the edit of an <see cref="T:yWorks.Graph.ILabel" />, for instance, in response to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabel(yWorks.Graph.ILabel)" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnLabelTextChanged(yWorks.Graph.LabelEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelTextChanged" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance that contains the <see cref="T:yWorks.Graph.ILabel" /> that has changed the text.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustToSizeConstraints(yWorks.Graph.INode)">
      <summary>
        <para>Adjusts the node's <see cref="P:yWorks.Graph.INode.Layout" /> to adhere to possible <see cref="T:yWorks.Controls.Input.INodeSizeConstraintProvider">size constraints</see>.</para>
      </summary>
      <remarks>
        <para>This method will use the <see cref="T:yWorks.Controls.Input.INodeSizeConstraintProvider" /> for <see cref="T:yWorks.Graph.INode" /> that can be found in their <see cref="T:yWorks.Graph.ILookup" /> to make sure they are still valid. The actual work of this method will be delegated to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.SetNodeLayout(yWorks.Graph.INode,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="node">
        <para>The node to possibly adjust the size of.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.SetNodeLayout(yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <summary>
        <para>Updates the bounds of the node.</para>
      </summary>
      <remarks>
        <para>This method differs from a simple call to <see cref="M:yWorks.Graph.IGraph.SetNodeLayout(yWorks.Graph.INode,yWorks.Geometry.RectD)" /> in a number of ways:</para>
        <list type="bullet">
          <item>An undo unit is enqueued.</item>
          <item>The node is reshaped interactively using the <see cref="T:yWorks.Controls.Input.IReshapeHandler" /> implementation found in its lookup. This enables correctly adjusting e.g. affected orthogonal edges and parent group nodes.</item>
          <item>
            <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustContentRect" /> is called.</item>
        </list>
      </remarks>
      <param name="node">
        <para>The node to reshape.</para>
      </param>
      <param name="layout">
        <para>The new node layout.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.DeleteSelection">
      <summary>
        <para>This method deletes the currently selected elements.</para>
      </summary>
      <remarks>
        <para>If the <see cref="T:yWorks.Controls.GraphSelection" /> is non-empty this implementation triggers the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletingSelection" /> event, possibly a number of <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" /> events, and a final <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DeleteSelection" /> event. Note that <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" /> will not be called for items that are removed implicitly, e.g. if the event is triggered for a node, its labels, ports, and adjacent edges will not be reported separately.</para>
      </remarks>
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletingSelection" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedSelection" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnDeletingSelection(yWorks.Controls.Input.SelectionEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletingSelection" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.SelectionEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnDeletedItem(yWorks.Utils.ItemEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" /> event.</para>
      </summary>
      <param name="args">
        <para>The instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnDeletedSelection(yWorks.Controls.Input.SelectionEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedSelection" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.SelectionEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.DeletingSelection">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DeleteSelection" /> method starts its work and will be followed by any number of <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" /> events and finalized by a <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedSelection" /> event.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.DeleteSelection" />
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem">
      <summary>
        <para>Occurs when an item has been deleted interactively by this mode.</para>
      </summary>
      <remarks>
        <para>Note that this event will not be triggered for items that are removed implicitly, e.g. if the event is triggered for a node, its labels, ports, and adjacent edges will not necessarily be reported separately. In order to be notified of any removal events, the <see cref="T:yWorks.Graph.IGraph" /> events should be used instead.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedSelection">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DeleteSelection" /> method has deleted the selection after all selected items have been removed.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.DeleteSelection" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldDelete(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback method that determines whether the given item should be deleted during <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DeleteSelection" />.</para>
      </summary>
      <remarks>
        <para>This implementation uses and honors the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.DeletableItems" /> and <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.DeletablePredicate" /> properties.</para>
      </remarks>
      <param name="item">
        <para>The item.</para>
      </param>
      <returns>
        <para>Whether to delete that item.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldEditLabel(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback method that determines whether the label or the labels of the provided item should be edited in response to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnEditLabel" /> or <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnAddLabel" />.</para>
      </summary>
      <param name="item">
        <para>The item.</para>
      </param>
      <returns>
        <para>Whether to edit the label or the labels for that item.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateMoveInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnMoveInputModeChanged(yWorks.Controls.Input.MoveInputMode,yWorks.Controls.Input.MoveInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>40</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldMove(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateMoveInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="T:yWorks.Controls.Input.MoveInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of MoveInputMode</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnMoveInputModeChanged(yWorks.Controls.Input.MoveInputMode,yWorks.Controls.Input.MoveInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnMoveInputModeDragFinished(System.Object,System.EventArgs)">
      <summary>
        <para>Called when <see cref="E:yWorks.Controls.Input.MoveInputMode.DragFinished" /> is triggered.</para>
      </summary>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnMoveInputModeDragCanceled(System.Object,System.EventArgs)">
      <summary>
        <para>Called when <see cref="E:yWorks.Controls.Input.MoveInputMode.DragCanceled" /> is triggered.</para>
      </summary>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateMoveUnselectedInputMode(yWorks.Controls.Input.EventRecognizer)">
      <summary>
        <para>Helper method that can be used to create a <see cref="T:yWorks.Controls.Input.MoveInputMode" /> instance that can be used to move unselected model items.</para>
      </summary>
      <remarks>
        <para>In order to use this mode, the created instance should be installed in a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> like this but using a smaller <see cref="P:yWorks.Controls.Input.IInputMode.Priority">priority</see> value than the <see cref="P:yWorks.Controls.Input.IInputMode.Priority">priority</see> of the mode that is <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode">installed by default</see>.</para>
      </remarks>
      <param name="recognizer">
        <para>Use this instance to make this mode work under certain conditions only. <c>null</c> for default behavior, one of the <see cref="T:yWorks.Controls.Input.KeyEventRecognizers" /> constants, e.g. for alternate behavior.</para>
      </param>
      <returns>
        <para>A <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode" /> instance that uses the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> instances of the items that are hit at the position of the cursor, regardless of their selection state.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AdjustContentRectPolicy">
      <summary>
        <para>Gets or sets a property that determines whether this instance should automatically adjust the <see cref="P:yWorks.Controls.CanvasControl.ContentRect" /> if the graph changes.</para>
      </summary>
      <remarks>
        <para>The <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustContentRect" /> method is called whenever the content changes. The default is <see cref="F:yWorks.Controls.Input.AdjustContentRectPolicy.Union" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustContentRect">
      <summary>
        <para>Updates the <see cref="P:yWorks.Controls.CanvasControl.ContentRect" /> using <see cref="M:yWorks.Controls.CanvasControl.UpdateContentRect(yWorks.Geometry.InsetsD,yWorks.Controls.ICanvasObjectGroup)" /> and <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ContentRectMargins" /></para>
      </summary>
      <remarks>
        <para>This method is called whenever the content changes and takes the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AdjustContentRectPolicy" /> into account.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.ContentRectMargins">
      <summary>
        <para>Gets or sets the margins to use for <see cref="M:yWorks.Controls.CanvasControl.UpdateContentRect(yWorks.Geometry.InsetsD,yWorks.Controls.ICanvasObjectGroup)" /> in <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustContentRect" /> calls.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnGraphSelectionChanged(yWorks.Controls.IGraphSelection,yWorks.Controls.IGraphSelection)">
      <summary>
        <para>Called when the <see cref="T:yWorks.Controls.GraphSelection" /> property changes.</para>
      </summary>
      <remarks>
        <para>This will update the internal state of the modes.</para>
      </remarks>
      <param name="oldSelection">
        <para>The old selection instance.</para>
      </param>
      <param name="newSelection">
        <para>The new selection instance.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.GraphControl">
      <summary>
        <para>Gets the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.GraphControl" /> instance this mode is working on or <c>null</c>.</para>
      </summary>
      <remarks>
        <para>This property is set when this mode is <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" />ed in a <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.GraphControl" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnGraphControlChanged(yWorks.Controls.GraphControl,yWorks.Controls.GraphControl)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.GraphControl" /> property changes.</para>
      </summary>
      <param name="oldGraphControl">
        <para>The old control.</para>
      </param>
      <param name="newGraphControl">
        <para>The new control.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the provided context.</para>
      </summary>
      <param name="context">
        <para>The context to install this mode in and retrieve the graph and selection instance from.</para>
      </param>
      <param name="controller">
        <para>The <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> for this mode.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnConcurrencyControllerDeactivated" />
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnConcurrencyControllerActivated" />
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.SnapContext">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.SnapContext" /> instance that handles interactive snapping of elements during drag operations like movements.</para>
      </summary>
      <remarks>
        <para>Setting this property to a <see cref="T:yWorks.Controls.Input.SnapContext" /> which is <see cref="P:yWorks.Controls.Input.SnapContext.Enabled">disabled</see> will disable snapping, whereas setting it to <c>null</c> will make the child modes use the context from their <see cref="T:yWorks.Controls.Input.IInputModeContext" />s, if available. Upon change the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnSnapContextChanged(yWorks.Controls.Input.SnapContext,yWorks.Controls.Input.SnapContext)" /> method is called, which will as a side effect configure the snap context to display the <see cref="T:yWorks.Controls.Input.SnapResult" />s in the <see cref="T:yWorks.Controls.CanvasControl" />. Default is <c>null</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnSnapContextChanged(yWorks.Controls.Input.SnapContext,yWorks.Controls.Input.SnapContext)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.SnapContext" /> property context changed.</para>
      </summary>
      <param name="oldContext">
        <para>The old snap context.</para>
      </param>
      <param name="newContext">
        <para>The new snap context.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.LabelSnapContext">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.LabelSnapContext" /> instance that handles interactive snapping of <see cref="T:yWorks.Graph.ILabel" />s to their owner during drag operations like movements.</para>
      </summary>
      <remarks>
        <para>Setting this property to <c>null</c> will disable snapping, whereas setting it to <c>null</c> will make the child modes use the context from their <see cref="T:yWorks.Controls.Input.IInputModeContext" />s, if available. Upon change the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnLabelSnapContextChanged(yWorks.Controls.Input.SnapContext,yWorks.Controls.Input.SnapContext)" /> method is called, which will as a side effect configure the snap context to display the <see cref="T:yWorks.Controls.Input.SnapResult" />s in the <see cref="T:yWorks.Controls.CanvasControl" />. Default is <c>null</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnLabelSnapContextChanged(yWorks.Controls.Input.SnapContext,yWorks.Controls.Input.SnapContext)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.LabelSnapContext" /> property context changed.</para>
      </summary>
      <param name="oldContext">
        <para>The old snap context.</para>
      </param>
      <param name="newContext">
        <para>The new snap context.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This mode is responsible for moving labels to another candidate position. If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateMoveLabelInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnMoveLabelInputModeChanged(yWorks.Controls.Input.MoveLabelInputMode,yWorks.Controls.Input.MoveLabelInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>39</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldMove(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnMoveLabelInputModeChanged(yWorks.Controls.Input.MoveLabelInputMode,yWorks.Controls.Input.MoveLabelInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateMoveLabelInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="T:yWorks.Controls.Input.MoveLabelInputMode" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldSelectAfterPaste(yWorks.Graph.IModelItem)">
      <summary>
        <para>Can be overridden to determine which items should be selected after <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.Paste" /> or <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DuplicateSelection" />.</para>
      </summary>
      <remarks>
        <para>This implementation returns <c>true</c> for the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.PasteSelectableItems" /> items.</para>
      </remarks>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether to select the item after <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.Paste" /> or <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DuplicateSelection" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations">
      <summary>
        <para>Gets or sets a value indicating whether grouping operations like <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupSelection">grouping selected nodes</see> or <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReparentNodes">moving nodes into group nodes</see> should be enabled.</para>
      </summary>
      <remarks>
        <para>Setting this property to <c>false</c> effectively disables handling of all grouping <see cref="T:yWorks.Controls.Input.Commands">commands</see>. If this property is set to <c>true</c> the related properties <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupSelection" />, <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowUngroupSelection" />, and <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReparentNodes" /> allow for selectively enabling or disabling only certain grouping operations.</para>
        <para>The default value is <c>false</c>.</para>
      </remarks>
      <value>
        <para>Whether grouping operations are supported by this input mode.</para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupSelection" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowUngroupSelection" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowAdjustGroupNodeSize" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReparentNodes" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupSelection">
      <summary>
        <para>Gets or sets a value determining whether the <see cref="F:yWorks.Controls.Input.Commands.GroupSelection" /> command should be handled.</para>
      </summary>
      <remarks>
        <para>This setting has no effect if grouping operations are generally disallowed by setting <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" /> to <c>false</c>.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.GroupSelection" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowAdjustGroupNodeSize">
      <summary>
        <para>Gets or sets a value determining whether the <see cref="F:yWorks.Controls.Input.Commands.AdjustGroupNodeSize" /> command should be handled.</para>
      </summary>
      <remarks>
        <para>This setting has no effect if grouping operations are generally disallowed by setting <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" /> to <c>false</c>.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustGroupNodeSizes" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustGroupNodeSize(System.Collections.Generic.IEnumerable{yWorks.Graph.INode})" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowUngroupSelection">
      <summary>
        <para>Gets or sets a value determining whether the <see cref="F:yWorks.Controls.Input.Commands.UngroupSelection" /> command should be handled.</para>
      </summary>
      <remarks>
        <para>This setting has no effect if grouping operations are generally disallowed by setting <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" /> to <c>false</c>.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.UngroupSelection" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowClearSelection">
      <summary>
        <para>Gets or sets a value determining whether the <see cref="F:yWorks.Controls.Input.Commands.DeselectAll" /> command should be handled.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowPaste">
      <summary>
        <para>Gets or sets a value determining whether the <see cref="F:yWorks.Controls.Input.Commands.Paste" /> command should be handled.</para>
      </summary>
      <remarks>
        <para>This setting has no effect if clipboard operations are generally disallowed by setting <see cref="P:yWorks.Controls.Input.GraphInputMode.AllowClipboardOperations" /> to <c>false</c>.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowDuplicate">
      <summary>
        <para>Gets or sets a value determining whether the <see cref="F:yWorks.Controls.Input.Commands.Duplicate" /> command should be handled.</para>
      </summary>
      <remarks>
        <para>This setting has no effect if clipboard operations are generally disallowed by setting <see cref="P:yWorks.Controls.Input.GraphInputMode.AllowClipboardOperations" /> to <c>false</c>.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowUndoOperations">
      <summary>
        <para>Gets or sets a value indicating whether undo operations, that is, <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.Undo" /> and <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.Redo" /> should be enabled.</para>
      </summary>
      <remarks>
        <para>Note that even if this feature is enabled, an <see cref="T:yWorks.Graph.UndoEngine">undo engine</see> needs to be available in the <see cref="P:yWorks.Controls.Input.InputModeBase.InputModeContext" />in order to work.</para>
        <para>Setting this property to <c>false</c> effectively disables handling of the commands <see cref="F:yWorks.Controls.Input.Commands.Undo" /> and <see cref="F:yWorks.Controls.Input.Commands.Redo" />.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.Undo" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.Redo" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReparentNodes">
      <summary>
        <para>Gets or sets a value indicating whether moving nodes out of group nodes or into other group nodes is allowed.</para>
      </summary>
      <remarks>
        <para>If set to <c>false</c> the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler" /> will effectively be disabled and not called anymore for reparenting operations.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReparentToNonGroupNodes">
      <summary>
        <para>Gets or sets a value indicating whether moving nodes into <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">non-group nodes</see> is allowed to convert them into group nodes.</para>
      </summary>
      <remarks>
        <para>If <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReparentNodes">reparenting nodes is allowed</see> in general and this property is enabled, users may reparent nodes not only to groups and folders but also to non-group nodes. Still, the decision about the final acceptance of the reparenting and the actual execution are delegated to the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler" />.</para>
        <para>This setting has no effect if grouping operations are generally disallowed by setting <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" /> to <c>false</c>.</para>
        <para>The default value is <c>false</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations" />
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.NodeReparented">
      <summary>
        <para>Occurs when a node has been reparented interactively.</para>
      </summary>
      <remarks>
        <para>This is triggered whenever the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler" />'s <see cref="M:yWorks.Controls.Input.IReparentNodeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Graph.INode)" /> method has been called to reparent a node interactively.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnNodeReparented(yWorks.Graph.NodeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.NodeReparented" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Graph.NodeEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.ReparentNodeHandler" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.DoubleClick(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Actually performs a double-click on the given item.</para>
      </summary>
      <param name="item">
        <para>The item that has been double-clicked.</para>
      </param>
      <param name="args">
        <para>The original event arguments for the click. Setting its <see cref="P:yWorks.Controls.Input.ClickEventArgs.Handled" /> property to <c>true</c> will indicate that the double-click was handled and events on other items in the same location are no longer raised.</para>
      </param>
      <remarks>
        <para>This will raise the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftDoubleClicked" /> and <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightDoubleClicked" /> (depending on the button), and <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" /> events. If neither event was handled, label editing will be started, if <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabelOnDoubleClick" /> is <c>true</c></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateNode(yWorks.Geometry.PointD)">
      <summary>
        <para>Creates a node given a certain click point.</para>
      </summary>
      <remarks>
        <para>This implementation delegates to the current <see cref="T:yWorks.Controls.Input.NodeCreationCallback" /> or simply returns <c>null</c> if there is no such callback or <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowCreateNode" /> yields <c>false</c>. Finally, it tries to <see cref="M:yWorks.Controls.Input.GraphInputMode.SetCurrentItem(yWorks.Graph.IModelItem)">set the node as the current item</see>.</para>
      </remarks>
      <param name="location">
        <para>The point where the mouse had been clicked.</para>
      </param>
      <returns>
        <para>The newly created node or <c>null</c>.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnNodeCreated(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetCurrentItem(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnNodeCreated(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.NodeCreated" /> event.</para>
      </summary>
      <remarks>
        <para>Note that if <see cref="P:yWorks.Controls.Input.NodeDropInputMode.AllowFolderNodeAsParent" /> is set to <c>true</c>, the reported node can actually be part of the <see cref="T:yWorks.Graph.IFoldingView">master graph</see>.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance containing the created node.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.NodeCreated">
      <summary>
        <para>Occurs when this mode has created a node in response to user interaction.</para>
      </summary>
      <remarks>
        <para>This event is triggered if the node is created using a click gesture via <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateNode(yWorks.Geometry.PointD)" />, or via a drag and drop operation that was completed by <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeDropInputMode" />. Note that if <see cref="P:yWorks.Controls.Input.NodeDropInputMode.AllowFolderNodeAsParent" /> is set to <c>true</c>, the reported node can actually be part of the <see cref="T:yWorks.Graph.IFoldingView">master graph</see>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateNode(yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowCreateNode">
      <summary>
        <para>Gets or sets a value determining whether <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateNode(yWorks.Geometry.PointD)">node creation</see> by clicking on an empty canvas location is enabled.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeCreator" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateNode(yWorks.Geometry.PointD)" />
      <remarks>
        <para>To disable node creation via drag and drop gestures, the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeDropInputMode" /> must be disabled, too. However, it is disabled by default.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowCreateBend">
      <summary>
        <para>Gets or sets a value determining whether <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode">bend creation</see> should be <see cref="P:yWorks.Controls.Input.CreateBendInputMode.Enabled">enabled</see>.</para>
      </summary>
      <remarks>
        <para>This property delegates to <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode" />'s <see cref="P:yWorks.Controls.Input.CreateBendInputMode.Enabled" /> property.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowCreateEdge">
      <summary>
        <para>Gets or sets a value determining whether <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode">edge creation</see> should be <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Enabled">enabled</see>.</para>
      </summary>
      <remarks>
        <para>This property delegates to <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode" />'s <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.Enabled" /> property.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseSelectedEdges">
      <summary>
        <para>Reverses the selected edges.</para>
      </summary>
      <remarks>
        <para>This implementation invokes <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdges(System.Collections.Generic.IEnumerable{yWorks.Graph.IEdge})" /> providing the <see cref="T:yWorks.Controls.GraphSelection">selected edges</see>.</para>
        <para>The edges will only be reversed if <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldReverseEdge(yWorks.Graph.IEdge)" /> returns <c>true</c> for each edge.</para>
        <para>For each edge an <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.EdgePortsChanged" /> event will be dispatched.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdges(System.Collections.Generic.IEnumerable{yWorks.Graph.IEdge})">
      <summary>
        <para>Reverses the given edges.</para>
      </summary>
      <remarks>
        <para>The edges will only be reversed if <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReverseEdge" /> is set to <c>true</c> and <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldReverseEdge(yWorks.Graph.IEdge)" /> returns <c>true</c> for the edge.</para>
        <para>For each edge a <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.EdgePortsChanged" /> event will be dispatched.</para>
      </remarks>
      <seealso cref="F:yWorks.Controls.Input.Commands.ReverseEdge" />
      <param name="edges" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdge(yWorks.Graph.IEdge)">
      <summary>
        <para>Reverses the given edges.</para>
      </summary>
      <remarks>
        <para>The edge will only be reversed if <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReverseEdge" /> is set to <c>true</c> and <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldReverseEdge(yWorks.Graph.IEdge)" /> returns <c>true</c> for the edge. A <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.EdgePortsChanged" /> event will be dispatched after the edge has been reversed.</para>
      </remarks>
      <param name="edge" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldReverseEdge(yWorks.Graph.IEdge)">
      <summary>
        <para>Callback which determines whether the given edge should be reversed by <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdge(yWorks.Graph.IEdge)" />, <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdges(System.Collections.Generic.IEnumerable{yWorks.Graph.IEdge})" />, or <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdges(System.Collections.Generic.IEnumerable{yWorks.Graph.IEdge})" />.</para>
      </summary>
      <remarks>
        <para>This implementation returns the value of <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReverseEdge" />.</para>
      </remarks>
      <param name="edge">
        <para>The edge which should be reversed.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge should be reversed.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AllowReverseEdge">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="F:yWorks.Controls.Input.Commands.ReverseEdge" /> command should be handled.</para>
      </summary>
      <remarks>
        <para>If set to <c>false</c> the methods <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdge(yWorks.Graph.IEdge)" />, <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdges(System.Collections.Generic.IEnumerable{yWorks.Graph.IEdge})" />, and <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseSelectedEdges" /> do nothing.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnEdgePortsChanged(yWorks.Graph.EdgeEventArgs)">
      <summary>
        <para>Callback to be invoked after an edge's source and/or target ports have been changed as the result of an input gesture.</para>
      </summary>
      <remarks>
        <para>Dispatches the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.EdgePortsChanged" /> event.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.Graph.EdgeEventArgs" /> for the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.EdgePortsChanged" />.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.EdgePortsChanged">
      <summary>
        <para>Occurs after an edge's source and/or target ports have been changed as the result of an input gesture.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.EdgeEventArgs" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseSelectedEdges" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdges(System.Collections.Generic.IEnumerable{yWorks.Graph.IEdge})" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.ReverseEdge(yWorks.Graph.IEdge)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.NodeCreator">
      <summary>
        <para>Gets or sets the callback that is responsible for creating a new node, for instance, in response to a mouse click.</para>
      </summary>
      <remarks>
        <para>A <c>null</c> value will disable node creation using mouse clicks, just as setting <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowCreateNode" /> to <c>false</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateNode(yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ClickCreateNode(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Creates a node on click.</para>
      </summary>
      <remarks>
        <para>This method is only called if no item has been hit and <see cref="M:yWorks.Controls.Input.GraphInputMode.ClickClearSelection(yWorks.Controls.Input.IInputModeContext)" /> returned <c>false</c>.</para>
      </remarks>
      <param name="context">
        <para>The context where the click appeared.</para>
      </param>
      <param name="location">
        <para>The point where the mouse had been clicked.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if a node was successfully created, <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabelOnDoubleClick(yWorks.Graph.IModelItem)">
      <summary>
        <para>Starts label editing by executing <see cref="F:yWorks.Controls.Input.Commands.EditLabel"></see>.</para>
      </summary>
      <remarks>
        <para>The method should return whether the request was satisfied.</para>
      </remarks>
      <param name="item">
        <para>The item whose label or the label itself that should be edited upon the double click gesture.</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff the request was handled.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.DoubleClick(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabelOnDoubleClick" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.SelectNodeAndSelfloopBends(yWorks.Graph.INode)">
      <summary>
        <para>Selects the node and possible bends of selfloop edges.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" /> for the node and all adjacent self loop bends.</para>
      </remarks>
      <param name="node">
        <para>The node to select.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.Initialize">
      <summary>
        <para>Initializes this mode by <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">adding</see> all of the minor modes that are used by this mode to this instance.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectionInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ContextMenuInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.MouseHoverInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ItemHoverInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.MoveViewportInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.WaitInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode" />
      <seealso cref="T:yWorks.Controls.Input.KeyboardInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.TextEditorInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeDropInputMode" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.TextEditorInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.TextEditorInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateTextEditorInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnTextEditorInputModeChanged(yWorks.Controls.Input.TextEditorInputMode,yWorks.Controls.Input.TextEditorInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>100</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnTextEditorInputModeChanged(yWorks.Controls.Input.TextEditorInputMode,yWorks.Controls.Input.TextEditorInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.TextEditorInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateTextEditorInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.TextEditorInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.TextEditorInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of TextEditorInputMode</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateCreateEdgeInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnCreateEdgeInputModeChanged(yWorks.Controls.Input.CreateEdgeInputMode,yWorks.Controls.Input.CreateEdgeInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>45</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnCreateEdgeInputModeChanged(yWorks.Controls.Input.CreateEdgeInputMode,yWorks.Controls.Input.CreateEdgeInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateCreateEdgeInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateEdgeInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of CreateEdgeInputMode</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AutoRemoveEmptyLabels">
      <summary>
        <para>Gets or sets a value indicating whether this mode should automatically <see cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)">remove labels</see> from the graph when a label text has been edited and the label text is empty.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if empty labels should be removed after text editing; otherwise, <c>false</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.AutoSelectSelfloopBends">
      <summary>
        <para>Gets or sets a property that determines whether clicking on a node should automatically select all bends of self loops adjacent to that node.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickSelectableItems" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.HideLabelDuringEditing">
      <summary>
        <para>Gets or sets a property that determines whether the label should be hidden while it is edited.</para>
      </summary>
      <remarks>
        <para>If enabled, any selection, focus, and highlight visualizations of the label are hidden along with the label visualization itself.</para>
        <para>Even if enabled, the label <b>text</b> is still visible in the <see cref="P:yWorks.Controls.Input.TextEditorInputMode.TextBox" />.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateCreateBendInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnCreateBendInputModeChanged(yWorks.Controls.Input.CreateBendInputMode,yWorks.Controls.Input.CreateBendInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>42</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnCreateBendInputModeChanged(yWorks.Controls.Input.CreateBendInputMode,yWorks.Controls.Input.CreateBendInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnCreateBendInputModeBendCreated(System.Object,yWorks.Utils.ItemEventArgs{yWorks.Graph.IBend})">
      <summary>
        <para>Callback that is called as soon as <see cref="T:yWorks.Controls.Input.CreateBendInputMode" /> created a new bend.</para>
      </summary>
      <remarks>
        <para>This method selects the bend and starts the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode" /> using the handle for the newly created bend. The bend is created using the hit edge's <see cref="T:yWorks.Controls.Input.IBendCreator" /> implementation, as obtained from the edge's <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> and calls <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.DragBend(yWorks.Graph.IBend)" />. If the subsequent drag is canceled by the user, this call will remove the bend again.</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.DragBend(yWorks.Graph.IBend)">
      <summary>
        <para>Initiates the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode" /> to drag the given bend.</para>
      </summary>
      <param name="bend">
        <para>The bend to drag.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnCreateBendInputModeBendCreated(System.Object,yWorks.Utils.ItemEventArgs{yWorks.Graph.IBend})" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateCreateBendInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.CreateBendInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <c>CreateBendInputMode</c></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.NodeDropInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeDropInputMode" /> property that is responsible for handling drag and drop operations of nodes onto the Canvas.</para>
      </summary>
      <remarks>
        <para>The mode by default is <see cref="P:yWorks.Controls.Input.DropInputMode.Enabled">disabled</see> and needs to be enabled to work, first. If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateNodeDropInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnNodeDropInputModeChanged(yWorks.Controls.Input.NodeDropInputMode,yWorks.Controls.Input.NodeDropInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>70</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.CreateNodeDropInputMode">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeDropInputMode" /> lazily the first time the property is accessed.</para>
      </summary>
      <returns>
        <para>A plain new instance of the <see cref="T:yWorks.Controls.Input.NodeDropInputMode" /> type, which is initially <see cref="P:yWorks.Controls.Input.DropInputMode.Enabled">disabled</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnNodeDropInputModeChanged(yWorks.Controls.Input.NodeDropInputMode,yWorks.Controls.Input.NodeDropInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeDropInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnNodeDropInputModeNodeCreated(System.Object,yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.NodeDropInputMode" />'s <see cref="E:yWorks.Controls.Input.ItemDropInputMode`1.ItemCreated" /> event is triggered.</para>
      </summary>
      <remarks>
        <para>This implementation <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustContentRect">adjusts the content rect</see>, triggers the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.NodeCreated" /> event and tries to set the newly created node as the <see cref="M:yWorks.Controls.Input.GraphInputMode.SetCurrentItem(yWorks.Graph.IModelItem)">current item</see>.</para>
      </remarks>
      <param name="sender">
        <para>The sender.</para>
      </param>
      <param name="e">
        <para>The event argument instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldShowHandles(yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether to show the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HandleInputMode">handles</see> for the given item.</para>
      </summary>
      <param name="item">
        <para>The item to check</para>
      </param>
      <returns>
        <para>Whether to show the item based on the setting of the corresponding <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.ShowHandleItems" />, property.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldMove(yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether or not moving the item is allowed.</para>
      </summary>
      <remarks>
        <para>This predicate determines whether an item can be moved by <b>any</b> appropriate input mode, e.g by default it also evaluates to <c>true</c> for <see cref="T:yWorks.Graph.ILabel" />s which are moved by <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode" /> instead of <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode" />.</para>
        <para>This implementation returns the result of the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.MovableItems" /> property for the given item.</para>
      </remarks>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether or not moving the item is allowed.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.MovableItems" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.MoveLabelInputMode" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphEditorInputMode.Waiting">
      <summary>
        <para>Gets or sets whether the <see cref="T:yWorks.Controls.Input.WaitInputMode" /> should be waiting.</para>
      </summary>
      <remarks>
        <para>This property just delegates to <see cref="P:yWorks.Controls.Input.WaitInputMode.Waiting" />.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdding">
      <summary>
        <para>Occurs when a label is about to be added.</para>
      </summary>
      <remarks>
        <para>Event handlers for this event can customize the behavior for adding a new label extensively. Adding a label can be forbidden entirely, or the properties of the added label can be changed, by setting the appropriate properties on the <see cref="T:yWorks.Controls.Input.LabelEditingEventArgs" />. It is even possible to forbid adding a label, but edit an existing one instead.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnLabelAdding(yWorks.Controls.Input.LabelEditingEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdding" /> event.</para>
      </summary>
      <remarks>
        <para>Invoking the event handlers stops once one event marks the <paramref name="args" /> as handled.</para>
      </remarks>
      <param name="args">
        <para>The event arguments.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphEditorInputMode.LabelEditing">
      <summary>
        <para>Occurs when a label is about to be edited.</para>
      </summary>
      <remarks>
        <para>Event handlers for this event can customize the behavior for editing an existing label. Editing can be forbidden entirely, or redirected to a different label, even on a different owner. In case editing existing labels is unwanted, event handlers can also specify that instead of editing a label, a new one should be added.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphEditorInputMode.OnLabelEditing(yWorks.Controls.Input.LabelEditingEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelEditing" /> event.</para>
      </summary>
      <remarks>
        <para>Invoking the event handlers stops once one event marks the <paramref name="args" /> as handled.</para>
      </remarks>
      <param name="args">
        <para>The event arguments.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.GraphInputMode">
      <summary>
        <para>Abstract base class for <see cref="T:yWorks.Controls.Input.GraphViewerInputMode" /> and <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />.</para>
      </summary>
      <remarks>
        <para>This class is not supposed to and in fact cannot be extended from user code. It only exists to provide common functionality to the two aforementioned input modes. If customizations are wanted or needed both <see cref="T:yWorks.Controls.Input.GraphViewerInputMode" /> and <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> can be extended.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.Graph">
      <summary>
        <para>Gets the graph instance from the <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.InputModeContext" />.</para>
      </summary>
      <value>
        <para>The graph to use, which can be <c>null</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.GraphSelection">
      <summary>
        <para>Gets the graph selection from the <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.InputModeContext" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.CreateSelectionEventArgs(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Helper method that yields a suitably configured <see cref="T:yWorks.Controls.Input.SelectionEventArgs`1" /> using the <see cref="P:yWorks.Controls.Input.GraphInputMode.GraphSelection" /> for this input mode.</para>
      </summary>
      <param name="context">
        <para>An input mode context that is available in the <see cref="T:yWorks.Controls.Input.SelectionEventArgs`1" />.</para>
        <para>Can be <c>null</c> in which case a new context for this instance is created automatically.</para>
      </param>
      <returns>
        <para>A selection event argument that is configured for this instance.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.ClickHitTestOrder">
      <summary>
        <para>Gets or sets the order of the types of items that should be used to determine what item has been clicked or tapped.</para>
      </summary>
      <remarks>
        <para>Change this field to adjust which items will be <see cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)">selected</see> if there are multiple items at a given location. The default order is</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.Bend" />
          </item>
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.EdgeLabel" />
          </item>
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.Edge" />
          </item>
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.Node" />
          </item>
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.NodeLabel" />
          </item>
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.Port" />
          </item>
        </list>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickSelectableItems" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.SelectableItems" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.FindItems(yWorks.Geometry.PointD,yWorks.Graph.GraphItemTypes[],System.Predicate{yWorks.Graph.IModelItem})" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.DoubleClickHitTestOrder">
      <summary>
        <para>Gets or sets the order of the types of items that should be used to determine what item has been double-clicked or double-tapped.</para>
      </summary>
      <remarks>
        <para>Change this field to adjust which items will be considered when <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked">double-clicked</see> if there are multiple items at a given location. The default order is</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.EdgeLabel" />
          </item>
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.NodeLabel" />
          </item>
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.Bend" />
          </item>
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.Edge" />
          </item>
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.Node" />
          </item>
          <item>
            <see cref="F:yWorks.Graph.GraphItemTypes.Port" />
          </item>
        </list>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickSelectableItems" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.SelectableItems" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.FindItems(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Graph.GraphItemTypes[],System.Predicate{yWorks.Graph.IModelItem})" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.DetailSelectionRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that will be queried to decide if a click should select the item that is currently visible under the mouse cursor, without giving more important items higher priority.</para>
      </summary>
      <remarks>
        <para>If the recognizer determines that the user wanted to use the detail clicking behavior, the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HitTester" /> will be queried for the given item and the first item that is returned will be considered a hit. Otherwise all hit items are examined and are prioritized by item type. E.g. by default clicking on a node will select the node, even if there is a node label which has been clicked at the same point. If detail selection is recognized, the label will be selected.</para>
        <para>The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.ShiftPressed" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.CyclicSelectionRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that will be queried to decide if a click should cycle through all the items that are currently under the mouse cursor.</para>
      </summary>
      <remarks>
        <para>If the recognizer determines that the user wanted to use the cyclic click selection behavior, the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HitTester" /> will be queried for the given item and previously reported items will be ignored. E.g. if multiple nodes are overlapping each other, clicking on them will report the first item for the first click, the second one for the second click and so on. If all elements have been reported previously, the first one is going to be reported again. If the order of the elements at the clicked location changes, the cyclic selection is restarted anew.</para>
        <para>The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.AltPressed" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.MultiSelectionRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that will be queried to decide if a click is deemed a multi selection gesture.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlPressed" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.ClickableItems">
      <summary>
        <para>Gets or sets which types of items should be reported through the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked">item click events</see>.</para>
      </summary>
      <remarks>
        <para>This also affects taps.</para>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.ShouldClick(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ShouldClick(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback predicate method that is used to determine whether the given <paramref name="item" /> can be <see cref="M:yWorks.Controls.Input.GraphInputMode.Click(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)">clicked</see>.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickableItems" /> value to determine whether the item should be clicked. Note that this method will not be called for items that don't match <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickableItems" /> for performance reasons.</para>
      </remarks>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether the item should be <see cref="M:yWorks.Controls.Input.GraphInputMode.Click(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)">clicked</see> in response to a <see cref="E:yWorks.Controls.Input.ClickInputMode.Clicked">detected mouse click</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ShouldDoubleClick(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback predicate method that is used to determine whether the given <paramref name="item" /> can be <see cref="M:yWorks.Controls.Input.GraphInputMode.DoubleClick(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)">double clicked</see>.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:yWorks.Controls.Input.GraphInputMode.ShouldClick(yWorks.Graph.IModelItem)" /> method to determine whether the item should be double clicked. Note that this method will not be called for items that don't match <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickableItems" /> for performance reasons.</para>
      </remarks>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether the item should be <see cref="M:yWorks.Controls.Input.GraphInputMode.DoubleClick(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)">double clicked</see> in response to a <see cref="E:yWorks.Controls.Input.ClickInputMode.DoubleClicked">detected double click</see>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.FocusableItems">
      <summary>
        <para>Gets or sets the items that can be given focus via the <see cref="M:yWorks.Controls.Input.GraphInputMode.SetCurrentItem(yWorks.Graph.IModelItem)" /> method.</para>
      </summary>
      <remarks>
        <para>The focusable items. The default is <see cref="F:yWorks.Graph.GraphItemTypes.Node" /></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ShouldFocus(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback that determines whether the provided <see cref="T:yWorks.Graph.IModelItem" /> should be <see cref="M:yWorks.Controls.Input.GraphInputMode.SetCurrentItem(yWorks.Graph.IModelItem)">set to the current item</see>.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.GraphInputMode.FocusableItems" /> property to determine whether the item can be set to the current item. It also honors the <see cref="P:yWorks.Controls.Input.GraphInputMode.IgnoreVoidStyles" /> property.</para>
      </remarks>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether to set the item as the current item.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.SelectableItems">
      <summary>
        <para>Gets or sets which types of items should be selectable at all.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.SelectablePredicate">
      <summary>
        <para>Gets or sets a predicate that is queried to determine whether a given <see cref="T:yWorks.Graph.IModelItem" /> is selectable.</para>
      </summary>
      <remarks>
        <para>This allows to further restrict which items are selectable, compared to <see cref="P:yWorks.Controls.Input.GraphInputMode.SelectableItems" />. If this property is set to <c>null</c> the effect is the same as a predicate that always returns <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ShouldSelectItem(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback predicate method that is used as a broad classification whether an item can generally be selected.</para>
      </summary>
      <remarks>
        <para>This implementation uses and honors the <see cref="P:yWorks.Controls.Input.GraphInputMode.SelectableItems" />, <see cref="P:yWorks.Controls.Input.GraphInputMode.IgnoreVoidStyles" /> and <see cref="P:yWorks.Controls.Input.GraphInputMode.SelectablePredicate" /> properties. This method is by default also called by <see cref="M:yWorks.Controls.Input.GraphInputMode.ShouldClickSelect(yWorks.Graph.IModelItem)" /> and <see cref="M:yWorks.Controls.Input.GraphInputMode.ShouldMarqueeSelect(yWorks.Graph.IModelItem)" />, so turning selection off here also turns it off in other places.</para>
      </remarks>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the item is selectable in general, <c>false</c> if not.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.ClickSelectableItems">
      <summary>
        <para>Gets or sets which types of items should be selectable by mouse clicks.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.ShouldClickSelect(yWorks.Graph.IModelItem)" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ShouldClickSelect(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback predicate method that is used to determine whether the given <paramref name="item" /> should be selected when <see cref="M:yWorks.Controls.Input.GraphInputMode.Click(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)">clicked with the primary mouse button</see>.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickSelectableItems" /> value to determine whether the item should be selected. Note that this method will not be called for items that don't match <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickSelectableItems" /> and <see cref="P:yWorks.Controls.Input.GraphInputMode.SelectableItems" /> for performance reasons.</para>
      </remarks>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether the item should be selected in response to a <see cref="E:yWorks.Controls.Input.ClickInputMode.LeftClicked">detected mouse click with the primary button</see>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectableItems">
      <summary>
        <para>Gets or sets which types of items should be selected during <see cref="M:yWorks.Controls.Input.GraphInputMode.MarqueeSelect(yWorks.Geometry.RectD)">marquee selections</see>.</para>
      </summary>
      <remarks>
        <para>The default is a combination of <see cref="F:yWorks.Graph.GraphItemTypes.Node" />, <see cref="F:yWorks.Graph.GraphItemTypes.Edge" />, and <see cref="F:yWorks.Graph.GraphItemTypes.Bend" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.ShouldMarqueeSelect(yWorks.Graph.IModelItem)" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ShouldMarqueeSelect(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback method used by <see cref="M:yWorks.Controls.Input.GraphInputMode.MarqueeSelect(yWorks.Geometry.RectD)" /> that takes <see cref="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectableItems" /> and <see cref="M:yWorks.Controls.Input.GraphInputMode.ShouldSelectItem(yWorks.Graph.IModelItem)" /> into account.</para>
      </summary>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether to possibly marquee select the item.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.IgnoreVoidStyles">
      <summary>
        <para>Gets or sets a value indicating whether void styles (<see cref="T:yWorks.Graph.Styles.VoidNodeStyle" />, <see cref="T:yWorks.Graph.Styles.VoidEdgeStyle" />, <see cref="T:yWorks.Graph.Styles.VoidLabelStyle" />, and <see cref="T:yWorks.Graph.Styles.VoidPortStyle" />) should be ignored when selecting or focusing items.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if void styles should be ignored for selection and focus; <c>false</c> otherwise. Default is <c>true</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.ContextMenuInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphInputMode.ContextMenuInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphInputMode.CreateContextMenuInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphInputMode.OnContextMenuInputModeChanged(yWorks.Controls.Input.ContextMenuInputMode,yWorks.Controls.Input.ContextMenuInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>60</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.CreateContextMenuInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphInputMode.ContextMenuInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphInputMode.ContextMenuInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of ContextMenuInputMode</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnContextMenuInputModeChanged(yWorks.Controls.Input.ContextMenuInputMode,yWorks.Controls.Input.ContextMenuInputMode)">
      <summary>
        <para>Called when the <see cref="T:yWorks.Controls.Input.ContextMenuInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.ContextMenuItems">
      <summary>
        <para>Gets or sets the types of items a context menu should be queried for.</para>
      </summary>
      <remarks>
        <para>The items for which a context menu should be <see cref="E:yWorks.Controls.Input.GraphInputMode.PopulateItemContextMenu">queried</see>. The default value is <see cref="F:yWorks.Graph.GraphItemTypes.Node" />|<see cref="F:yWorks.Graph.GraphItemTypes.Edge" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ShouldPopulateContextMenu(yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether for the given item a context menu should be queried.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.GraphInputMode.ContextMenuItems" /> property to determine whether a context menu should be queried for the given item.</para>
      </remarks>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether to raise a <see cref="E:yWorks.Controls.Input.GraphInputMode.PopulateItemContextMenu" /> event for the given item.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnPopulateItemContextMenu(yWorks.Controls.Input.PopulateItemContextMenuEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.PopulateItemContextMenu" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.PopulateItemContextMenuEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.PopulateItemContextMenu">
      <summary>
        <para>Occurs when the <see cref="T:yWorks.Controls.Input.ContextMenuInputMode">context menu</see> over an item is about to be opened to determine the contents of the <see cref="P:yWorks.Controls.Input.ContextMenuInputMode.Menu" />.</para>
      </summary>
      <remarks>
        <para>This method will only be called for items that match the <see cref="P:yWorks.Controls.Input.GraphInputMode.ContextMenuItems" /> type.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.MouseHoverInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphInputMode.MouseHoverInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphInputMode.CreateMouseHoverInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphInputMode.OnMouseHoverInputModeChanged(yWorks.Controls.Input.MouseHoverInputMode,yWorks.Controls.Input.MouseHoverInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>100</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnMouseHoverInputModeChanged(yWorks.Controls.Input.MouseHoverInputMode,yWorks.Controls.Input.MouseHoverInputMode)">
      <summary>
        <para>Called when the <see cref="T:yWorks.Controls.Input.MouseHoverInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.CreateMouseHoverInputMode">
      <summary>
        <para>Factory method for the <see cref="T:yWorks.Controls.Input.MouseHoverInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="T:yWorks.Controls.Input.MouseHoverInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="T:yWorks.Controls.Input.MouseHoverInputMode" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.ToolTipItems">
      <summary>
        <para>Gets or sets the types of the items that should be queried a tool tip for.</para>
      </summary>
      <remarks>
        <para>The items for which a tool tip text should be <see cref="E:yWorks.Controls.Input.GraphInputMode.QueryItemToolTip">queried</see>. The default value is <see cref="F:yWorks.Graph.GraphItemTypes.Node" />|<see cref="F:yWorks.Graph.GraphItemTypes.Edge" />|<see cref="F:yWorks.Graph.GraphItemTypes.Label" />|<see cref="F:yWorks.Graph.GraphItemTypes.Port" />|.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ShouldQueryToolTip(yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether for the given item a tool tip should be queried.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.GraphInputMode.ToolTipItems" /> property to determine whether tool tip should be queried for the given item.</para>
      </remarks>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>Whether to raise a <see cref="E:yWorks.Controls.Input.GraphInputMode.QueryItemToolTip" /> event for the given item.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnQueryItemToolTip(yWorks.Controls.Input.QueryItemToolTipEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.QueryItemToolTip" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.QueryItemToolTipEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.QueryItemToolTip">
      <summary>
        <para>Occurs when the mouse is <see cref="T:yWorks.Controls.Input.MouseHoverInputMode">hovering</see> over an item to determine the tool tip to display.</para>
      </summary>
      <remarks>
        <para>This method will only be called for items that match the <see cref="P:yWorks.Controls.Input.GraphInputMode.ToolTipItems" /> type.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.ClickInputMode">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.ClickInputMode" /> that is used by this instance to determine clicks.</para>
      </summary>
      <remarks>
        <para>Whenever the mode detects a <see cref="E:yWorks.Controls.Input.ClickInputMode.Clicked">click</see>, this mode will use the <see cref="T:yWorks.Controls.Input.IHitTester`1" /> from the <see cref="P:yWorks.Controls.Input.MultiplexingInputMode.InputModeContext" /> to determine the items being hit. If they match the <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickableItems" /> type, the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" /> event will be triggered. If they <see cref="M:yWorks.Controls.Input.GraphInputMode.ShouldFocus(yWorks.Graph.IModelItem)" />, the item will be <see cref="M:yWorks.Controls.Input.GraphInputMode.SetCurrentItem(yWorks.Graph.IModelItem)">set as the current item</see>.</para>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphInputMode.CreateClickInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphInputMode.OnClickInputModeChanged(yWorks.Controls.Input.ClickInputMode,yWorks.Controls.Input.ClickInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>10</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.OnItemClicked(yWorks.Controls.Input.ItemClickedEventArgs{yWorks.Graph.IModelItem})" />
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.CreateClickInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickInputMode" /> property.</para>
        <para>This implementation <see cref="P:yWorks.Controls.Input.ClickInputMode.ActiveButtons">activates</see> both <see cref="F:System.Windows.Forms.MouseButtons.Left" /> and <see cref="F:System.Windows.Forms.MouseButtons.Right" /></para>
      </remarks>
      <returns>
        <para>a new instance of ClickInputMode</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnClickInputModeChanged(yWorks.Controls.Input.ClickInputMode,yWorks.Controls.Input.ClickInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.Click(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Actually performs the click on the given item.</para>
      </summary>
      <remarks>
        <para>This will raise the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftClicked" />, <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightClicked" /> (depending on the button), and <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" /> events. If either event is unhandled by all its event handlers the item will be <see cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)">selected</see> and <see cref="M:yWorks.Controls.Input.GraphInputMode.SetCurrentItem(yWorks.Graph.IModelItem)">focused</see>. Before selection <see cref="M:yWorks.Controls.Input.GraphInputMode.ClearSelection">the current selection will be cleared</see>, unless the <see cref="P:yWorks.Controls.Input.GraphInputMode.MultiSelectionRecognizer" /> is triggered.</para>
      </remarks>
      <param name="item">
        <para>The item that has been clicked.</para>
      </param>
      <param name="args">
        <para>The original event arguments for the click. Setting its <see cref="P:yWorks.Controls.Input.ClickEventArgs.Handled" /> property to <c>true</c> will indicate that the click was handled. By default this happens when the clicked item is either selected or focused.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.HandleClickHandler(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IModelItem,yWorks.Geometry.PointD)">
      <summary>
        <para>Called by <see cref="M:yWorks.Controls.Input.GraphInputMode.Click(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)" /> to query the <paramref name="item" /> for a <see cref="T:yWorks.Controls.Input.IClickHandler" /> in its <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> and handle it appropriately.</para>
      </summary>
      <remarks>
        <para>This method will query the <see cref="T:yWorks.Controls.Input.IClickHandler" /> and check whether the click occurred inside the <see cref="P:yWorks.Controls.Input.IClickHandler.HitTestable">button's bounds</see>, and if so, will <see cref="M:yWorks.Controls.Input.IClickHandler.OnClicked(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">invoke the action</see> and return <c>true</c>.</para>
      </remarks>
      <param name="context">
        <para>The context for the click.</para>
      </param>
      <param name="item">
        <para>The item that has been clicked.</para>
      </param>
      <param name="location" />
      <returns>
        <para>Whether the action has been invoked and handling should be stopped.</para>
      </returns>
      <seealso cref="T:yWorks.Controls.Input.IClickHandler" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.Click(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.DoubleClick(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Actually performs a double-click on the given item.</para>
      </summary>
      <remarks>
        <para>This will raise the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftDoubleClicked" /> and <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightDoubleClicked" /> (depending on the button), and <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" /> events.</para>
      </remarks>
      <param name="item">
        <para>The item that has been double-clicked.</para>
      </param>
      <param name="args">
        <para>The original event arguments for the click. Setting its <see cref="P:yWorks.Controls.Input.ClickEventArgs.Handled" /> property to <c>true</c> will indicate that the double-click was handled and events on other items in the same location are no longer raised.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnItemClicked(yWorks.Controls.Input.ItemClickedEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" /> event.</para>
      </summary>
      <remarks>
        <para>This implementation will stop the event propagation as soon as an event handler has set the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c>.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.ItemClickedEventArgs`1" /> instance that contains the item that has been clicked.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnItemLeftClicked(yWorks.Controls.Input.ItemClickedEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftClicked" /> event.</para>
      </summary>
      <remarks>
        <para>This implementation will stop the event propagation as soon as an event handler has set the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c>.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.ItemClickedEventArgs`1" /> instance that contains the item that has been clicked.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnItemRightClicked(yWorks.Controls.Input.ItemClickedEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightClicked" /> event.</para>
      </summary>
      <remarks>
        <para>This implementation will stop the event propagation as soon as an event handler has set the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c>.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.ItemClickedEventArgs`1" /> instance that contains the item that has been clicked.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnItemDoubleClicked(yWorks.Controls.Input.ItemClickedEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" /> event.</para>
      </summary>
      <remarks>
        <para>This implementation will stop the event propagation as soon as an event handler has set the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c>.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.ItemClickedEventArgs`1" /> instance that contains the item that has been double clicked.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnItemLeftDoubleClicked(yWorks.Controls.Input.ItemClickedEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftDoubleClicked" /> event.</para>
      </summary>
      <remarks>
        <para>This implementation will stop the event propagation as soon as an event handler has set the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c>.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.ItemClickedEventArgs`1" /> instance that contains the item that has been double clicked.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnItemRightDoubleClicked(yWorks.Controls.Input.ItemClickedEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightDoubleClicked" /> event.</para>
      </summary>
      <remarks>
        <para>This implementation will stop the event propagation as soon as an event handler has set the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c>.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.ItemClickedEventArgs`1" /> instance that contains the item that has been double clicked.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnCanvasClicked(yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.CanvasClicked" /> event.</para>
      </summary>
      <remarks>
        <para>This implementation will stop the event propagation as soon as an event handler has set the <see cref="P:yWorks.Controls.Input.ClickEventArgs.Handled" /> property to <c>true</c>.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.ClickEventArgs" /> instance that contains the information about the click.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.ItemClicked">
      <summary>
        <para>Occurs when an item has been clicked.</para>
      </summary>
      <remarks>
        <para>If one of the event handlers sets the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c> the event will not be propagated anymore.</para>
        <para>Button-specific events (<see cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftClicked" /> and <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightClicked" />) will be raised before this event. If one of those is marked <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> this event will not be raised anymore.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickableItems" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightClicked" />
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.ItemLeftClicked">
      <summary>
        <para>Occurs when an item has been left clicked.</para>
      </summary>
      <remarks>
        <para>This event will be raised before the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" /> event. If one of the event handlers sets the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c> the event will not be propagated anymore. This also means that the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" /> event will not be raised in that case.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickableItems" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftDoubleClicked" />
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.ItemRightClicked">
      <summary>
        <para>Occurs when an item has been right clicked.</para>
      </summary>
      <remarks>
        <para>This event will be raised before the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" /> event. If one of the event handlers sets the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c> the event will not be propagated anymore. This also means that the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" /> event will not be raised in that case.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickableItems" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightDoubleClicked" />
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked">
      <summary>
        <para>Occurs when an item has been double clicked.</para>
      </summary>
      <remarks>
        <para>If one of the event handlers sets the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c> the event will not be propagated anymore.</para>
        <para>Depending on the value of the <see cref="P:yWorks.Controls.Input.ClickInputMode.DoubleClickPolicy" /> property of <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickInputMode" /> this event may be preceded by no, one, or two <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" /> events (as well as the corresponding button-specific event).</para>
        <para>Button-specific events (<see cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftDoubleClicked" /> and <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightDoubleClicked" />) will be raised before this event. If one of those is marked <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> this event will not be raised anymore.</para>
      </remarks>
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickableItems" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftDoubleClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightDoubleClicked" />
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.ItemLeftDoubleClicked">
      <summary>
        <para>Occurs when an item has been left double clicked.</para>
      </summary>
      <remarks>
        <para>This event will be raised before the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" /> event. If one of the event handlers sets the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c> the event will not be propagated anymore. This also means that the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" /> event will not be raised in that case.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickableItems" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightDoubleClicked" />
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.ItemRightDoubleClicked">
      <summary>
        <para>Occurs when an item has been right double clicked.</para>
      </summary>
      <remarks>
        <para>This event will be raised before the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" /> event. If one of the event handlers sets the <see cref="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled" /> property to <c>true</c> the event will not be propagated anymore. This also means that the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" /> event will not be raised in that case.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickableItems" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" />
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftDoubleClicked" />
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.CanvasClicked">
      <summary>
        <para>Occurs when the empty canvas area has been clicked.</para>
      </summary>
      <remarks>
        <para>If one of the event handlers sets the <see cref="P:yWorks.Controls.Input.ClickEventArgs.Handled" /> property to <c>true</c> the event will not be propagated anymore.</para>
      </remarks>
      <seealso cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectionInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectionInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphInputMode.CreateMarqueeSelectionInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphInputMode.OnMarqueeSelectionInputModeChanged(yWorks.Controls.Input.MarqueeSelectionInputMode,yWorks.Controls.Input.MarqueeSelectionInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>50</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.CreateMarqueeSelectionInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectionInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectionInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of MarqueeSelectionInputMode</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnMarqueeSelectionInputModeChanged(yWorks.Controls.Input.MarqueeSelectionInputMode,yWorks.Controls.Input.MarqueeSelectionInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectionInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This mode is responsible for navigating and traversing the elements in the <see cref="T:yWorks.Graph.IGraph" />. If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphInputMode.CreateNavigationInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphInputMode.OnNavigationInputModeChanged(yWorks.Controls.Input.NavigationInputMode,yWorks.Controls.Input.NavigationInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>55</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.CreateNavigationInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of NavigationInputMode</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnNavigationInputModeChanged(yWorks.Controls.Input.NavigationInputMode,yWorks.Controls.Input.NavigationInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ClickClearSelection(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Clears the selection on click if <see cref="P:yWorks.Controls.CanvasControl.LastMouse2DEvent">the click</see> is not recognized by <see cref="P:yWorks.Controls.Input.GraphInputMode.MultiSelectionRecognizer" />.</para>
      </summary>
      <remarks>
        <para>This method is only called if no item has been hit and at least one item is currently selected.</para>
        <para>This will use the <see cref="M:yWorks.Controls.Input.GraphInputMode.ClearSelection" /> method to deselect all items.</para>
      </remarks>
      <param name="context">
        <para>The context where the click appeared</para>
      </param>
      <returns>
        <para>Whether the selection has been cleared by this method.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ClearSelection">
      <summary>
        <para>Clears the selection on the current <see cref="P:yWorks.Controls.Input.GraphInputMode.GraphSelection" />.</para>
      </summary>
      <remarks>
        <para>This implementation may be overridden for customizations. All it does is call <see cref="M:yWorks.Controls.ISelectionModel`1.Clear" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.SetCurrentItem(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback that is used by this instance to set the current item on the <see cref="M:yWorks.Controls.Input.NavigationInputMode.SetCurrentItem(yWorks.Graph.IModelItem)">NavigationInputMode</see></para>
      </summary>
      <param name="item">
        <para>The item to set as the new "current" item.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)">
      <summary>
        <para>Uses the <see cref="P:yWorks.Controls.Input.GraphInputMode.GraphSelection" /> to select the given item.</para>
      </summary>
      <param name="item">
        <para>The item to set the selection state on.</para>
      </param>
      <param name="selected">
        <para>The new selection state.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.MarqueeSelect(yWorks.Geometry.RectD)">
      <summary>
        <para>Performs marquee-selection with the given rectangle.</para>
      </summary>
      <remarks>
        <para>It delegates directly to the <see cref="M:yWorks.Controls.Input.GraphInputMode.MarqueeSelect(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /> overload internally.</para>
      </remarks>
      <param name="marqueeRectangle">
        <para>The selection rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.MarqueeSelect(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Performs marquee-selection with the given rectangle.</para>
      </summary>
      <remarks>
        <para>This method is called internally when either the <see cref="M:yWorks.Controls.Input.GraphInputMode.MarqueeSelect(yWorks.Geometry.RectD)" /> method is called or the user performs a marquee-selection gesture via <see cref="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectionInputMode" />.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="marqueeRectangle">
        <para>The selection rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.MarqueeSelect(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,System.Collections.Generic.IEnumerable{yWorks.Graph.IModelItem},System.Predicate{yWorks.Graph.IModelItem})">
      <summary>
        <para>Selects the given elements in the editor inside the provided marquee-selection rectangle.</para>
      </summary>
      <remarks>
        <para>This implementation iterates over the items and queries them for an implementation of <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> using their <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />. This instance will be used to determine whether the item should be selected.</para>
        <para>This method is, in the default implementation, only called with individual item types in <paramref name="items" />.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="marqueeRectangle">
        <para>The rectangle in world coordinates.</para>
      </param>
      <param name="items">
        <para>The items to iterate over.</para>
      </param>
      <param name="predicate">
        <para>The predicate that determines whether the provided item should be tested at all. May be <c>null</c>.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.MarqueeSelect(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.SelectAll">
      <summary>
        <para>Clears the current selection and selects all nodes and bends in this graph.</para>
      </summary>
      <remarks>
        <para>By default, this method will be called in response to a Ctrl+A key press recognized by <see cref="P:yWorks.Controls.Input.GraphInputMode.KeyboardInputMode" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.ClearSelection" />
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" />
      <seealso cref="F:yWorks.Controls.Input.Commands.SelectAll" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.SelectableItems" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.IgnoreVoidStyles" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnMultiSelectionStarted(yWorks.Controls.Input.SelectionEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.MultiSelectionStarted" /> event.</para>
      </summary>
      <param name="args" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnMultiSelectionFinished(yWorks.Controls.Input.SelectionEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphInputMode.MultiSelectionFinished" /> event.</para>
      </summary>
      <param name="args" />
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.MultiSelectionStarted">
      <summary>
        <para>Occurs when a single or multi select operation has been started.</para>
      </summary>
      <remarks>
        <para>The event is <b>not</b> triggered for the individual selection operations that constitute a multi selection operation.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.GraphInputMode.MultiSelectionFinished">
      <summary>
        <para>Occurs when a single or multi select operation has been finished.</para>
      </summary>
      <remarks>
        <para>The event is <b>not</b> triggered for the individual selection operations that constitute a multi selection operation.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.WaitInputMode">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.WaitInputMode" /> that is provided by this instance for those who need to make use of it.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphInputMode.CreateWaitInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphInputMode.OnWaitInputModeChanged(yWorks.Controls.Input.WaitInputMode,yWorks.Controls.Input.WaitInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>-1</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.WaitInputMode.Waiting" />
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.CreateWaitInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphInputMode.WaitInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphInputMode.WaitInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="P:yWorks.Controls.Input.GraphInputMode.WaitInputMode" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnWaitInputModeChanged(yWorks.Controls.Input.WaitInputMode,yWorks.Controls.Input.WaitInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphInputMode.WaitInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.ItemHoverInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphInputMode.ItemHoverInputMode" /> that is provided by this instance for those who need to make use of it.</para>
      </summary>
      <remarks>
        <para>Note that initially the <see cref="P:yWorks.Controls.Input.ItemHoverInputMode.HoverItems" /> property is set to <see cref="F:yWorks.Graph.GraphItemTypes.None" />, which effectively disables the functionality of the mode initially. In order to get the mode to fire events, the property should be set to a corresponding value.</para>
        <para>If the backing field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphInputMode.CreateItemHoverInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphInputMode.OnItemHoverInputModeChanged(yWorks.Controls.Input.ItemHoverInputMode,yWorks.Controls.Input.ItemHoverInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>55</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.CreateItemHoverInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphInputMode.ItemHoverInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphInputMode.ItemHoverInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="P:yWorks.Controls.Input.GraphInputMode.ItemHoverInputMode" /> with the <see cref="P:yWorks.Controls.Input.ItemHoverInputMode.HoverItems" /> property set to <see cref="F:yWorks.Graph.GraphItemTypes.None" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnItemHoverInputModeChanged(yWorks.Controls.Input.ItemHoverInputMode,yWorks.Controls.Input.ItemHoverInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphInputMode.ItemHoverInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.MoveViewportInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphInputMode.MoveViewportInputMode" /> associated with this instance.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.GraphInputMode.CreateMoveViewportInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.GraphInputMode.OnMoveViewportInputModeChanged(yWorks.Controls.Input.MoveViewportInputMode,yWorks.Controls.Input.MoveViewportInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>39</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.CreateMoveViewportInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.GraphInputMode.MoveViewportInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.GraphInputMode.MoveViewportInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="P:yWorks.Controls.Input.GraphInputMode.MoveViewportInputMode" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnMoveViewportInputModeChanged(yWorks.Controls.Input.MoveViewportInputMode,yWorks.Controls.Input.MoveViewportInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphInputMode.MoveViewportInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.KeyboardInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.GraphInputMode.KeyboardInputMode" />.</para>
      </summary>
      <remarks>
        <para>By default this input mode has a priority of <c>0</c>.</para>
      </remarks>
      <value>
        <para>The <see cref="P:yWorks.Controls.Input.GraphInputMode.KeyboardInputMode" />.</para>
      </value>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnKeyboardInputModeChanged(yWorks.Controls.Input.KeyboardInputMode,yWorks.Controls.Input.KeyboardInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.GraphInputMode.KeyboardInputMode" /> changed.</para>
      </summary>
      <param name="oldMode">
        <para>The old <see cref="P:yWorks.Controls.Input.GraphInputMode.KeyboardInputMode" />.</para>
      </param>
      <param name="newMode">
        <para>The new <see cref="P:yWorks.Controls.Input.GraphInputMode.KeyboardInputMode" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.CreateKeyboardInputMode">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Controls.Input.GraphInputMode.KeyboardInputMode" /> instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.AvailableCommands">
      <summary>
        <para>Gets a collection of commands that this input mode will handle.</para>
      </summary>
      <remarks>
        <para>This collection can be modified by removing commands to prevent the input mode from handling them. Previously removed commands can also be re-added again to enable them again. However, the input mode will never handle commands that weren't in the initial collection. Adding those will do nothing.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphInputMode.AllowClipboardOperations">
      <summary>
        <para>Gets or sets a property that determines whether clipboard operations with the usual shortcuts are enabled on the canvas.</para>
      </summary>
      <remarks>
        <para>Default value is <c>true</c></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.Copy">
      <summary>
        <para>Copies the currently selected elements to the clipboard.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ShouldInstallCommand(yWorks.Controls.ICommand)">
      <summary>
        <para>Callback method that is used to determine which of the built-in <see cref="T:yWorks.Controls.ICommand" />s to install.</para>
      </summary>
      <remarks>
        <para>This implementation unconditionally returns <c>true</c>, subclasses may override this method to adjust the behavior.</para>
      </remarks>
      <param name="command">
        <para>The command to install.</para>
      </param>
      <returns>
        <para>Whether to install this command.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.FindItems(yWorks.Geometry.PointD,yWorks.Graph.GraphItemTypes[],System.Predicate{yWorks.Graph.IModelItem})">
      <summary>
        <para>Used as a callback to find the items hit underneath a certain point.</para>
      </summary>
      <param name="location">
        <para>The location to test.</para>
      </param>
      <param name="tests">
        <para>An array of <see cref="T:yWorks.Graph.GraphItemTypes" /> values that encode for which model items the hit test should be performed for prioritizing.</para>
      </param>
      <param name="filter">
        <para>The predicate that can be used to filter the results. May be <c>null</c>.</para>
      </param>
      <returns>
        <para>An enumerable over the items that have been found for the location.</para>
      </returns>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HitTester" /> to determine the hit items.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.FindItems(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Graph.GraphItemTypes[],System.Predicate{yWorks.Graph.IModelItem})">
      <summary>
        <para>Used as a callback to find the items hit underneath a certain point.</para>
      </summary>
      <param name="context">
        <para>The context to use for to the <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> callback.</para>
      </param>
      <param name="location">
        <para>The location to test.</para>
      </param>
      <param name="tests">
        <para>An array of <see cref="T:yWorks.Graph.GraphItemTypes" /> values that encode for which model items the hit test should be performed for prioritizing.</para>
      </param>
      <param name="filter">
        <para>The predicate that can be used to filter the results. May be <c>null</c>.</para>
      </param>
      <returns>
        <para>An enumerable over the items that have been found for the location.</para>
      </returns>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.HitTester" /> to determine the hit items.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.Initialize">
      <summary>
        <para>Initializes this mode by <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">adding</see> all of the minor modes that are used by this mode to this instance.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ClickInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectionInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ContextMenuInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.NavigationInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.MouseHoverInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.ItemHoverInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.MoveViewportInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphInputMode.WaitInputMode" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.ChildInputModeContextLookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <param name="context" />
      <param name="controller" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnConcurrencyControllerActivated" />
    <member name="M:yWorks.Controls.Input.GraphInputMode.OnConcurrencyControllerDeactivated" />
    <member name="T:yWorks.Controls.Input.GraphSnapContext">
      <summary>
        <para>Concrete <see cref="T:yWorks.Controls.Input.SnapContext" /> implementation which handles snapping movement for <see cref="T:yWorks.Graph.IGraph" /> items.</para>
      </summary>
      <remarks>
        <para>This class provides a set of properties that determine the way snapping operations are being performed in the context of <see cref="T:yWorks.Graph.IGraph" />s. <see cref="T:yWorks.Controls.Input.IPositionHandler" /> implementations and the like can use the following idiom to retrieve instances of this class:</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.GraphEditorInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.SnapContext" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.#ctor">
      <summary>
        <para>Creates a new instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.CleanUp">
      <summary>
        <para>Disposes of all previously temporarily collected state and clears the <see cref="P:yWorks.Controls.Input.SnapContext.SnapResults" /> collection.</para>
      </summary>
      <remarks>
        <para>Subclasses should make sure to call the base implementation as their last operation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Called by <see cref="T:yWorks.Controls.Input.IInputMode" /> implementations when an interactive drag is started.</para>
      </summary>
      <param name="context">
        <para>The context in which the interactive drag is started.</para>
      </param>
      <param name="originalLocation">
        <para>The original location of the mouse.</para>
      </param>
      <remarks>
        <para>Initializes the list of nodes to be moved. Called by the wrapping position handler on initialization of a drag action.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <para>If this context is already <see cref="P:yWorks.Controls.Input.SnapContext.IsInitialized">initialized</see>.</para>
      </exception>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.FixedNodes">
      <summary>
        <para>Gets the nodes that stay fixed for the current edit.</para>
      </summary>
      <value>
        <para>The fixed nodes.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.DragInitialized">
      <summary>
        <para>Collects a list of snap lines.</para>
      </summary>
      <remarks>
        <para>This method has been overridden to collect the snap lines for all fixed graph elements and <see cref="P:yWorks.Controls.Input.GraphSnapContext.CropSnapLines">crop</see> them after collection.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.OnCollectSnapLines(yWorks.Controls.Input.CollectGraphSnapLinesEventArgs)" />
      <seealso cref="P:yWorks.Controls.Input.GraphSnapContext.CropSnapLines" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.OnCollectSnapLines(yWorks.Controls.Input.CollectGraphSnapLinesEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.GraphSnapContext.CollectSnapLines" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.GraphSnapContext.CollectSnapLines">
      <summary>
        <para>Occurs every time this instance has been <see cref="M:yWorks.Controls.Input.SnapContext.DragInitialized">initialized</see> to collect <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s.</para>
      </summary>
      <remarks>
        <para>Event handlers should add snap lines to the caller using the methods provided by <see cref="T:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.AddItemToBeReshaped(yWorks.Graph.IModelItem)">
      <summary>
        <para>Adds an item which will be reshaped.</para>
      </summary>
      <param name="item">
        <para>The item to be reshaped.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.CollectEdgeSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect <see cref="P:yWorks.Controls.Input.GraphSnapContext.FixedSegmentSnapLines">fixed snap lines</see> for edge segments.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.ISnapLineProvider" />
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.CollectFixedSegmentSnapLines(yWorks.Controls.Input.CollectGraphSnapLinesEventArgs)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.CollectNodeSizes">
      <summary>
        <para>Gets or sets whether this instance should collect the sizes of fixed nodes.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.CollectSameSizeEntries" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.CollectNodeSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect <see cref="P:yWorks.Controls.Input.GraphSnapContext.FixedNodeSnapLines">fixed snap lines</see> for nodes.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.ISnapLineProvider" />
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.CollectFixedNodeSnapLines(yWorks.Controls.Input.CollectGraphSnapLinesEventArgs)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.CollectPortSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect <see cref="P:yWorks.Controls.Input.GraphSnapContext.FixedPortSnapLines">fixed snap lines</see> for ports.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.ISnapLineProvider" />
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.CollectFixedPortSnapLines(yWorks.Controls.Input.CollectGraphSnapLinesEventArgs)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.SnapBendAdjacentSegments">
      <summary>
        <para>Gets or sets whether this context will automatically snap the movements of bends so that the two adjacent segments become horizontally or vertically oriented.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.SnapPortAdjacentSegments">
      <summary>
        <para>Gets or sets whether this context will automatically snap the movements of nodes so that the first and last segments of edges become orthogonal.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.SnapSegmentsToSnapLines">
      <summary>
        <para>Gets or sets whether this context will automatically snap orthogonal edge segments to snap lines.</para>
      </summary>
      <remarks>
        <para>The default is true.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.SnapBendsToSnapLines">
      <summary>
        <para>Gets or sets whether this context will automatically snap the bends to snap lines.</para>
      </summary>
      <remarks>
        <para>The default is false.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.SnapNodesToSnapLines">
      <summary>
        <para>Gets or sets whether <see cref="T:yWorks.Controls.Input.INodeSnapResultProvider" /> implementations should snap nodes to snap lines.</para>
      </summary>
      <remarks>
        <para>The default is true.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.NodeToNodeDistance">
      <summary>
        <para>Gets or sets the preferred distance between node borders.</para>
      </summary>
      <remarks>
        <para>This will influence the creation of the node snap lines. For each fixed node there will be snap lines on the borders of the node itself and around the node at the specified distance.</para>
        <para>The default is 0.0d which disables distant snap lines around the nodes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.NodeToEdgeDistance">
      <summary>
        <para>Gets or sets the preferred distance between node borders and edge segments.</para>
      </summary>
      <remarks>
        <para>This will influence the creation of the node snap lines. For each fixed node there will be snap lines on the borders of the node itself and around the node at the specified distance to which orthogonal edge segments can snap.</para>
        <para>The default is -1.0d which disables distant snap lines around the nodes for edge segments.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.EdgeToEdgeDistance">
      <summary>
        <para>Gets or sets the preferred distance between edges.</para>
      </summary>
      <remarks>
        <para>This will influence the creation of the segment snap lines. For each orthogonally oriented fixed segment there will be snap lines on the segment itself and to both sides of the segment at the specified distance.</para>
        <para>The default is 0.0d which disables parallel snap lines.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.SnapOrthogonalMovement">
      <summary>
        <para>Gets or sets whether this context will automatically snap the movement in such a way that the overall move gesture is constrained to the horizontal or vertical axis.</para>
      </summary>
      <remarks>
        <para>The default is false.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.CollectNodePairCenterSnapLines">
      <summary>
        <para>Gets or sets whether this instance will try to align the centers of adjacent nodes so that their centers are equally far away from each other.</para>
      </summary>
      <remarks>
        <para>Note that this will only make a difference for differently sized nodes.</para>
        <para>By default this feature is turned off, so that the instance will try to distribute nodes evenly, so that there is the same spacing between their borders, not between their centers.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.CollectNodePairSnapLines">
      <summary>
        <para>Gets or sets a value indicating whether this instance will collect pairs of adjacent nodes and add snapping logic so that moved nodes will snap so that the distances to the adjacent nodes are equal.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if pairs of nodes should be collected for additional snap lines; <c>false</c> otherwise. The default is <c>true</c></para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.CollectNodePairSegmentSnapLines">
      <summary>
        <para>Gets or sets a value indicating whether this instance will collect pairs of adjacent nodes and add snapping logic so that moved edge segments will snap so that the distances to the adjacent nodes are equal.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if pairs of nodes should be collected for additional edge snap lines; <c>false</c> otherwise. The default is <c>true</c></para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.GridSnapType">
      <summary>
        <para>Gets or sets the type of the grid snapping that should be performed.</para>
      </summary>
      <remarks>
        <para>Determines which grid elements an object should snap to.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.GraphSnapContext.NodeGridConstraintProvider" />
      <seealso cref="P:yWorks.Controls.Input.GraphSnapContext.BendGridConstraintProvider" />
      <seealso cref="P:yWorks.Controls.Input.GraphSnapContext.PortGridConstraintProvider" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.GridSnapDistance">
      <summary>
        <para>Gets or sets the GridSnapDistance.</para>
      </summary>
      <remarks>
        <para>The maximum distance between the current mouse coordinates and the coordinates to which the mouse will snap. The distance is interpreted in view coordinates.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.NodeGridConstraintProvider">
      <summary>
        <para>Gets or sets the grid constraint provider for the <see cref="T:yWorks.Graph.INode" />s.</para>
      </summary>
      <value>
        <para>The node grid constraint provider, or <c>null</c> if none is set.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.BendGridConstraintProvider">
      <summary>
        <para>Gets or sets the grid constraint provider for the <see cref="T:yWorks.Graph.IBend" />s.</para>
      </summary>
      <value>
        <para>The bend grid constraint provider, or <c>null</c> if none is set.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.PortGridConstraintProvider">
      <summary>
        <para>Gets or sets the grid constraint provider for the <see cref="T:yWorks.Graph.IPort" />s.</para>
      </summary>
      <value>
        <para>The port grid constraint provider, or <c>null</c> if none is set.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.SnapLineExtension">
      <summary>
        <para>Gets or sets the amount by which snap lines that are induced by existing edge segments and node borders are being extended.</para>
      </summary>
      <remarks>
        <para>The default is <c>40.0d</c>, this value will be used to extend the ends of the snap lines.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.CropSnapLines">
      <summary>
        <para>Gets or sets a value indicating whether to crop the snap lines at obstacles.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.AddNodeToBeMoved(yWorks.Controls.Input.MovementInfo)">
      <summary>
        <para>Adds <see cref="T:yWorks.Controls.Input.MovementInfo" /> representing an <see cref="T:yWorks.Graph.INode" /> that will be considered for the next drag gesture.</para>
      </summary>
      <remarks>
        <para>The default <see cref="T:yWorks.Controls.Input.IPositionHandler" /> of an <see cref="T:yWorks.Graph.INode" /> calls this method in its <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> method so snap results are calculated when this node is repositioned. Custom <see cref="T:yWorks.Controls.Input.IPositionHandler" /> implementations can add infos created by <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfo(yWorks.Graph.INode)" />.</para>
      </remarks>
      <param name="info">
        <para>The <see cref="T:yWorks.Controls.Input.MovementInfo" /> representing the node to be moved. Can be created with <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfo(yWorks.Graph.INode)" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.AddBendToBeMoved(yWorks.Controls.Input.MovementInfo)">
      <summary>
        <para>Adds <see cref="T:yWorks.Controls.Input.MovementInfo" /> representing an <see cref="T:yWorks.Graph.IBend" /> that will be considered for the next drag gesture.</para>
      </summary>
      <remarks>
        <para>The default <see cref="T:yWorks.Controls.Input.IHandle" /> of an <see cref="T:yWorks.Graph.IBend" /> calls this method in its <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> method so snap results are calculated when this bend is repositioned. Custom <see cref="T:yWorks.Controls.Input.IHandle" /> implementations can add infos created by <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfo(yWorks.Graph.IBend)" />.</para>
      </remarks>
      <param name="info">
        <para>The <see cref="T:yWorks.Controls.Input.MovementInfo" /> representing the bend to be moved. Can be created with <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfo(yWorks.Graph.IBend)" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.AddPortToBeMoved(yWorks.Controls.Input.MovementInfo)">
      <summary>
        <para>Adds <see cref="T:yWorks.Controls.Input.MovementInfo" /> representing an <see cref="T:yWorks.Graph.IPort" /> that will be considered for the next drag gesture.</para>
      </summary>
      <remarks>
        <para>The default <see cref="T:yWorks.Controls.Input.IHandle" /> of an <see cref="T:yWorks.Graph.IPort" /> calls this method in its <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> method so snap results are calculated for this port. Custom <see cref="T:yWorks.Controls.Input.IHandle" /> implementations can add infos created by <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfo(yWorks.Graph.IPort)" />.</para>
      </remarks>
      <param name="info">
        <para>The <see cref="T:yWorks.Controls.Input.MovementInfo" /> representing the port to be moved. Can be created with <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfo(yWorks.Graph.IPort)" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.AddEdgeEndToBeMoved(yWorks.Controls.Input.MovementInfo,System.Boolean)">
      <summary>
        <para>Adds <see cref="T:yWorks.Controls.Input.MovementInfo" /> representing the end of an <see cref="T:yWorks.Graph.IEdge" /> that will be considered for the next drag gesture.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Controls.Input.IHandle" /> returned by the default <see cref="T:yWorks.Controls.Input.IEdgePortHandleProvider" /> of an <see cref="T:yWorks.Graph.IEdge" /> calls this method in its <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> method so snap results are calculated when reparenting this edge end. Custom <see cref="T:yWorks.Controls.Input.IHandle" /> implementations can call <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfos(yWorks.Graph.IEdge)" /> and add the first or last <see cref="T:yWorks.Controls.Input.MovementInfo" /> of the returned list.</para>
      </remarks>
      <param name="info">
        <para>The <see cref="T:yWorks.Controls.Input.MovementInfo" /> representing the edge end to be reparented. Can be created with <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfos(yWorks.Graph.IEdge)" />.</para>
      </param>
      <param name="sourceEnd">
        <para>
          <c>true</c> if the <paramref name="info" /> represents the source end of the edge.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfos(yWorks.Graph.IEdge)">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.Input.MovementInfo">movement information</see> for the provided edge.</para>
      </summary>
      <remarks>
        <para>The result describes the shape of the edge and the reshaping behavior of the geometry. The first element in the enumerable is the source end of the edge, followed by bend like elements and the target side. Note that it cannot in general be assumed <see cref="P:yWorks.Controls.Input.MovementInfo.MovedItem" /> of the first and last element is either a <see cref="T:yWorks.Graph.IPort" /> or <see cref="T:yWorks.Graph.IEdge" />, also items in between may not necessarily be bound to <see cref="T:yWorks.Graph.IBend" />s and therefore their <see cref="P:yWorks.Controls.Input.MovementInfo.MovedItem" /> can be of a different type than <see cref="T:yWorks.Graph.IBend" />.</para>
      </remarks>
      <param name="edge">
        <para>The edge to obtain the movement information of.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Utils.IListEnumerable`1" /> of <see cref="T:yWorks.Controls.Input.MovementInfo" />s items that describe the geometry of the edge being modified.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfo(yWorks.Graph.IBend)">
      <summary>
        <para>Gets the movement info for the given bend.</para>
      </summary>
      <remarks>
        <para>This is either the info passed to <see cref="M:yWorks.Controls.Input.GraphSnapContext.AddBendToBeMoved(yWorks.Controls.Input.MovementInfo)" /> or a dynamically created instance if no specific one had been registered.</para>
      </remarks>
      <param name="bend">
        <para>The bend to obtain the info for.</para>
      </param>
      <returns>
        <para>An instance of <see cref="T:yWorks.Controls.Input.MovementInfo" /> that describes the movement of the bend.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfo(yWorks.Graph.INode)">
      <summary>
        <para>Gets the movement info for the given node.</para>
      </summary>
      <remarks>
        <para>This is either the info passed to <see cref="M:yWorks.Controls.Input.GraphSnapContext.AddNodeToBeMoved(yWorks.Controls.Input.MovementInfo)" /> or another, dynamically created instance, if no specific one had been registered.</para>
      </remarks>
      <param name="node">
        <para>The node to obtain the info for.</para>
      </param>
      <returns>
        <para>An instance of <see cref="T:yWorks.Controls.Input.MovementInfo" /> that describes the movement of the node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfo(yWorks.Graph.IPort)">
      <summary>
        <para>Gets the movement info for the given port.</para>
      </summary>
      <remarks>
        <para>This is either the info passed to <see cref="M:yWorks.Controls.Input.GraphSnapContext.AddNodeToBeMoved(yWorks.Controls.Input.MovementInfo)" /> or another, dynamically created instance, if no specific one had been registered.</para>
      </remarks>
      <param name="port">
        <para>The port to obtain the info for.</para>
      </param>
      <returns>
        <para>An instance of <see cref="T:yWorks.Controls.Input.MovementInfo" /> that describes the movement of the port.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.CollectFixedSegmentSnapLines(yWorks.Controls.Input.CollectGraphSnapLinesEventArgs)">
      <summary>
        <para>Collects snap lines for edge segments.</para>
      </summary>
      <remarks>
        <para>Delegates to the <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> implementation in the lookup of the <see cref="T:yWorks.Graph.IEdge" />. This implementation should then make us of <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfos(yWorks.Graph.IEdge)" /> to determine what segments are fixed.</para>
      </remarks>
      <param name="args" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.CollectFixedNodeSnapLines(yWorks.Controls.Input.CollectGraphSnapLinesEventArgs)">
      <summary>
        <para>Collects the <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s for the nodes which are not moving.</para>
      </summary>
      <remarks>
        <para>Delegates to the <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> implementation in the lookup of the <see cref="T:yWorks.Graph.INode" />.</para>
      </remarks>
      <param name="args" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.CollectFixedPortSnapLines(yWorks.Controls.Input.CollectGraphSnapLinesEventArgs)">
      <summary>
        <para>Collects the <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s for the ports which are not moving.</para>
      </summary>
      <remarks>
        <para>Delegates to the <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> implementation in the lookup of the <see cref="T:yWorks.Graph.IPort" />.</para>
      </remarks>
      <param name="args" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.CollectVisibleNodePairs">
      <summary>
        <para>Finds pairs of nodes that are visually adjacent to create <see cref="P:yWorks.Controls.Input.GraphSnapContext.CollectNodePairCenterSnapLines">center</see> and <see cref="P:yWorks.Controls.Input.GraphSnapContext.CollectNodePairSnapLines">same distance</see> snap lines.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.CollectSameSizeEntries">
      <summary>
        <para>Collects all node widths and heights in the collections <see cref="M:yWorks.Controls.Input.GraphSnapContext.FindSameWidthEntries(System.Double,System.Double,System.Double)" /> and <see cref="M:yWorks.Controls.Input.GraphSnapContext.FindSameHeightEntries(System.Double,System.Double,System.Double)" />.</para>
      </summary>
      <remarks>
        <para>This method will only be called if <see cref="P:yWorks.Controls.Input.GraphSnapContext.CollectNodeSizes" /> is enabled and delegates to <see cref="M:yWorks.Controls.Input.GraphSnapContext.AddSameHeightEntry(yWorks.Geometry.RectD)" /> and <see cref="M:yWorks.Controls.Input.GraphSnapContext.AddSameWidthEntry(yWorks.Geometry.RectD)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.AddSameHeightEntry(yWorks.Geometry.RectD)">
      <summary>
        <para>Adds an entry for the same-height-snapping.</para>
      </summary>
      <remarks>
        <para>During <see cref="P:yWorks.Controls.Input.SnapContext.IsInitializing">initialization</see> this method can be used to register entries that can later be retrieved using the <see cref="M:yWorks.Controls.Input.GraphSnapContext.FindSameHeightEntries(System.Double,System.Double,System.Double)" /> method. The rectangle will be used to obtain the height value and will also be used for the visualization of the snap result.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to obtain the height value from. This rectangle will be used for the snap result visualization.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.AddSameWidthEntry(yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.AddSameWidthEntry(yWorks.Geometry.RectD)">
      <summary>
        <para>Adds an entry for the same-width-snapping.</para>
      </summary>
      <remarks>
        <para>During <see cref="P:yWorks.Controls.Input.SnapContext.IsInitializing">initialization</see> this method can be used to register entries that can later be retrieved using the <see cref="M:yWorks.Controls.Input.GraphSnapContext.FindSameWidthEntries(System.Double,System.Double,System.Double)" /> method. The rectangle will be used to obtain the width value and will also be used for the visualization of the snap result.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to obtain the width value from. This rectangle will be used for the snap result visualization.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.AddSameHeightEntry(yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.FindSameWidthEntries(System.Double,System.Double,System.Double)">
      <summary>
        <para>Finds the entries (<see cref="T:yWorks.Geometry.RectD" />s) that have been registered using the <see cref="M:yWorks.Controls.Input.GraphSnapContext.AddSameWidthEntry(yWorks.Geometry.RectD)" /> previously that best match the given constraints.</para>
      </summary>
      <param name="size">
        <para>The size to find the closest set of identical sizes.</para>
      </param>
      <param name="maxSize">
        <para>The maximum allowed size.</para>
      </param>
      <param name="minSize">
        <para>The minimum allowed size.</para>
      </param>
      <returns>
        <para>The set of rectangles that have been added previously using <see cref="M:yWorks.Controls.Input.GraphSnapContext.AddSameWidthEntry(yWorks.Geometry.RectD)" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.FindSameHeightEntries(System.Double,System.Double,System.Double)">
      <summary>
        <para>Finds the entries (<see cref="T:yWorks.Geometry.RectD" />s) that have been registered using the <see cref="M:yWorks.Controls.Input.GraphSnapContext.AddSameHeightEntry(yWorks.Geometry.RectD)" /> previously that best match the given constraints.</para>
      </summary>
      <param name="size">
        <para>The size to find the closest set of identical sizes.</para>
      </param>
      <param name="maxSize">
        <para>The maximum allowed size.</para>
      </param>
      <param name="minSize">
        <para>The minimum allowed size.</para>
      </param>
      <returns>
        <para>The set of rectangles that have been added previously using <see cref="M:yWorks.Controls.Input.GraphSnapContext.AddSameHeightEntry(yWorks.Geometry.RectD)" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.FixedNodeSnapLines">
      <summary>
        <para>Gets the collection of <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s for fixed nodes.</para>
      </summary>
      <remarks>
        <para>This collection is only available if <see cref="P:yWorks.Controls.Input.SnapContext.IsInitialized" /> is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.GetFixedNodeSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.FixedSegmentSnapLines">
      <summary>
        <para>Gets the collection of <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s for fixed segments.</para>
      </summary>
      <remarks>
        <para>This collection is only available if <see cref="P:yWorks.Controls.Input.SnapContext.IsInitialized" /> is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.GetFixedSegmentSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.FixedPortSnapLines">
      <summary>
        <para>Gets the collection of <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s to which ports should be snapping.</para>
      </summary>
      <remarks>
        <para>This collection is only available if <see cref="P:yWorks.Controls.Input.SnapContext.IsInitialized" /> is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.GetFixedPortSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)" />
    </member>
    <member name="P:yWorks.Controls.Input.GraphSnapContext.AdditionalSnapLines">
      <summary>
        <para>Gets the collection of additional <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s.</para>
      </summary>
      <remarks>
        <para>This collection is only available if <see cref="P:yWorks.Controls.Input.SnapContext.IsInitialized" /> is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphSnapContext.GetAdditionalSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.GetFixedNodeSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)">
      <summary>
        <para>Gets a subset of <see cref="P:yWorks.Controls.Input.GraphSnapContext.FixedNodeSnapLines" /> that matches the given <paramref name="orientation" />, <paramref name="snapType" /> and intersects with the provided <paramref name="area" />.</para>
      </summary>
      <param name="orientation">
        <para>The orientation of the lines to return.</para>
      </param>
      <param name="snapType">
        <para>The snap type to be included.</para>
      </param>
      <param name="area">
        <para>The area to test for intersection.</para>
      </param>
      <returns>
        <para>An enumerable of the snap lines that match the provided criteria.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.GetFixedSegmentSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)">
      <summary>
        <para>Gets a subset of <see cref="P:yWorks.Controls.Input.GraphSnapContext.FixedSegmentSnapLines" /> that matches the given <paramref name="orientation" />, <paramref name="snapType" /> and intersects with the provided <paramref name="area" />.</para>
      </summary>
      <param name="orientation">
        <para>The orientation of the lines to return.</para>
      </param>
      <param name="snapType">
        <para>The snap type to be included.</para>
      </param>
      <param name="area">
        <para>The area to test for intersection.</para>
      </param>
      <returns>
        <para>An enumerable of the snap lines that match the provided criteria.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.GetFixedPortSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)">
      <summary>
        <para>Gets a subset of <see cref="P:yWorks.Controls.Input.GraphSnapContext.FixedPortSnapLines" /> that matches the given <paramref name="orientation" />, <paramref name="snapType" /> and intersects with the provided <paramref name="area" />.</para>
      </summary>
      <param name="orientation">
        <para>The orientation of the lines to return.</para>
      </param>
      <param name="snapType">
        <para>The snap type to be included.</para>
      </param>
      <param name="area">
        <para>The area to test for intersection.</para>
      </param>
      <returns>
        <para>An enumerable of the snap lines that match the provided criteria.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.GetAdditionalSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)">
      <summary>
        <para>Gets a subset of <see cref="P:yWorks.Controls.Input.GraphSnapContext.AdditionalSnapLines" /> that matches the given <paramref name="orientation" />, <paramref name="snapType" /> and intersects with the provided <paramref name="area" />.</para>
      </summary>
      <param name="orientation">
        <para>The orientation of the lines to return.</para>
      </param>
      <param name="snapType">
        <para>The snap type to be included.</para>
      </param>
      <param name="area">
        <para>The area to test for intersection.</para>
      </param>
      <returns>
        <para>An enumerable of the snap lines that match the provided criteria.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.AddOrthogonalSegment(yWorks.Controls.Input.MovementInfo,yWorks.Controls.Input.MovementInfo)">
      <summary>
        <para>Adds an orthogonally moved segment to this context for which this instance will automatically collect <see cref="T:yWorks.Controls.Input.SnapResult" />s and provide a default visualization.</para>
      </summary>
      <remarks>
        <para>This method can be called during initialization to collect orthogonal segments that should be tested against <see cref="P:yWorks.Controls.Input.GraphSnapContext.FixedSegmentSnapLines" /> and <see cref="P:yWorks.Controls.Input.GraphSnapContext.AdditionalSnapLines" />.</para>
      </remarks>
      <param name="start">
        <para>The starting point of the manipulated segment.</para>
      </param>
      <param name="end">
        <para>The end point of the manipulated segment.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.GraphSnapContext.WrapContext(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="T:yWorks.Controls.Input.MoveTypes">
      <summary>
        <para>Describes the type of the movement of a point during an edit in the context of <see cref="T:yWorks.Controls.Input.GraphSnapContext" />.</para>
      </summary>
      <remarks>
        <para>This is a flagged enumeration.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.GraphSnapContext" />
      <seealso cref="T:yWorks.Controls.Input.MovementInfo" />
    </member>
    <member name="F:yWorks.Controls.Input.MoveTypes.Fixed">
      <summary>
        <para>The element does not move at all during the edit.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveTypes.LinearMoveX">
      <summary>
        <para>The element moves linearly with the mouse in horizontal direction.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveTypes.LinearMoveY">
      <summary>
        <para>The element moves linearly with the mouse in vertical direction.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveTypes.LinearMove">
      <summary>
        <para>The element moves linearly with the mouse in both directions.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveTypes.ArbitraryMoveX">
      <summary>
        <para>The element moves in horizontal direction but not linearly/predictably with the mouse.</para>
      </summary>
      <remarks>
        <para>A typical example is a port whose position is adjusted during a resize of its owning node.</para>
        <para>Elements which do not move linearly with the mouse cannot snap to a defined position.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.MoveTypes.ArbitraryMoveY">
      <summary>
        <para>The element moves in vertical direction but not linearly/predictably with the mouse.</para>
      </summary>
      <remarks>
        <para>A typical example is a port whose position is adjusted during a resize of its owning node.</para>
        <para>Elements which do not move linearly with the mouse cannot snap to a defined position.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.MoveTypes.ArbitraryMove">
      <summary>
        <para>The element moves in both directions but not linearly/predictably with the mouse.</para>
      </summary>
      <remarks>
        <para>A typical example is a port whose position is adjusted during a resize of its owning node.</para>
        <para>Elements which do not move linearly with the mouse cannot snap to a defined position.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.MoveTypes.MovementX">
      <summary>
        <para>The bitwise combination of <see cref="F:yWorks.Controls.Input.MoveTypes.LinearMoveX" /> and <see cref="F:yWorks.Controls.Input.MoveTypes.ArbitraryMoveX" /></para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveTypes.MovementY">
      <summary>
        <para>The bitwise combination of <see cref="F:yWorks.Controls.Input.MoveTypes.LinearMoveY" /> and <see cref="F:yWorks.Controls.Input.MoveTypes.ArbitraryMoveY" /></para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.MovementInfo">
      <summary>
        <para>A helper class that is used in the context of <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> to describe the movement of entities during the edit process.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MovementInfo.#ctor(yWorks.Geometry.PointD,yWorks.Controls.Input.MoveTypes,yWorks.Graph.IModelItem)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.MovementInfo" /> class.</para>
      </summary>
      <param name="originalLocation">
        <para>The original location.</para>
      </param>
      <param name="moveType">
        <para>The type of the move.</para>
      </param>
      <param name="movedItem">
        <para>The item that is being moved.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.MovementInfo.MovedItem">
      <summary>
        <para>Gets the item that is being moved.</para>
      </summary>
      <value>
        <para>The moved item.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MovementInfo.HorizontalAnchor">
      <summary>
        <para>Gets or sets the horizontal movement info to which this info is anchored horizontally.</para>
      </summary>
      <remarks>
        <para>This info can be declared to be implicitly anchored to another info. Method <see cref="M:yWorks.Controls.Input.MovementInfo.MovesHorizontallySynchronizedWith(yWorks.Controls.Input.MovementInfo)" /> will try to match against the anchors to determine if two infos are moving synchronized.</para>
      </remarks>
      <value>
        <para>The horizontal anchor or <c>null</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MovementInfo.VerticalAnchor">
      <summary>
        <para>Gets or sets the vertical movement info to which this info is anchored vertically.</para>
      </summary>
      <remarks>
        <para>This info can be declared to be implicitly anchored to another info. Method <see cref="M:yWorks.Controls.Input.MovementInfo.MovesVerticallySynchronizedWith(yWorks.Controls.Input.MovementInfo)" /> will try to match against the anchors to determine if two infos are moving synchronized.</para>
      </remarks>
      <value>
        <para>The vertical anchor or <c>null</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MovementInfo.OriginalLocation">
      <summary>
        <para>Gets the original location of the element at the time the editing started.</para>
      </summary>
      <value>
        <para>The original location.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MovementInfo.CurrentLocation">
      <summary>
        <para>Gets the current location as a live point.</para>
      </summary>
      <value>
        <para>The current location.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.MovementInfo.MoveType">
      <summary>
        <para>Gets or sets the type of the movement for this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MovementInfo.MovesVerticallySynchronizedWith(yWorks.Controls.Input.MovementInfo)">
      <summary>
        <para>Determines whether this instances moves synchronized with the provided info.</para>
      </summary>
      <param name="info">
        <para>The info to check.</para>
      </param>
      <returns>
        <para>Whether this info and the given info move vertically synchronized.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.MovementInfo.VerticalAnchor" />
    </member>
    <member name="M:yWorks.Controls.Input.MovementInfo.MovesHorizontallySynchronizedWith(yWorks.Controls.Input.MovementInfo)">
      <summary>
        <para>Determines whether this instances moves synchronized with the provided info.</para>
      </summary>
      <param name="info">
        <para>The info to check.</para>
      </param>
      <returns>
        <para>Whether this info and the given info move horizontally synchronized.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.MovementInfo.HorizontalAnchor" />
    </member>
    <member name="P:yWorks.Controls.Input.MovementInfo.IsVerticallyFixed">
      <summary>
        <para>Gets a value indicating whether the y coordinate of the item is fixed during the move operation.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MovementInfo.IsHorizontallyFixed">
      <summary>
        <para>Gets a value indicating whether the x coordinate of the item is fixed during the move operation.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.MovementInfo.GetX(System.Double)">
      <summary>
        <para>Gets the new x coordinate of the element if the mouse has been moved by <paramref name="dx" /> during the gesture.</para>
      </summary>
      <remarks>
        <para>This takes the <see cref="P:yWorks.Controls.Input.MovementInfo.MoveType" /> and <see cref="P:yWorks.Controls.Input.MovementInfo.OriginalLocation" /> into account.</para>
      </remarks>
      <param name="dx">
        <para>The delta x coordinate.</para>
      </param>
      <returns>
        <para>The new x coordinate.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.MovementInfo.GetY(System.Double)">
      <summary>
        <para>Gets the new y coordinate of the element if the mouse has been moved by <paramref name="dy" /> during the gesture.</para>
      </summary>
      <remarks>
        <para>This takes the <see cref="P:yWorks.Controls.Input.MovementInfo.MoveType" /> and <see cref="P:yWorks.Controls.Input.MovementInfo.OriginalLocation" /> into account.</para>
      </remarks>
      <param name="dy">
        <para>The delta y coordinate.</para>
      </param>
      <returns>
        <para>The new y coordinate.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.GraphViewerInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> implementation for use in a <see cref="T:yWorks.Controls.GraphControl" /> to assign to the <see cref="P:yWorks.Controls.CanvasControl.InputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This mode can be used in a viewer-centric application where there is no need to modify the <see cref="T:yWorks.Graph.IGraph" /> but browsing of the graph should be convenient. This mode allows for <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked">clicking on items using the mouse</see>, <see cref="E:yWorks.Controls.Input.GraphInputMode.QueryItemToolTip">displaying tool tips for items</see>, <see cref="E:yWorks.Controls.Input.GraphInputMode.PopulateItemContextMenu">showing a context menu</see>, <see cref="T:yWorks.Controls.Input.NavigationInputMode">allowing for easy navigation and traversal</see>, <see cref="T:yWorks.Controls.Input.MoveViewportInputMode">moving the view port</see>, and <see cref="P:yWorks.Controls.Input.GraphInputMode.MarqueeSelectableItems">optionally doing marquee selection</see>. Also <see cref="T:yWorks.Controls.Input.ItemHoverInputMode" /> can be used to get notified of the elements that the mouse is hovering over.</para>
        <para>Due to the viewer-centric nature of this input mode, collapsing and expanding groups is disabled per default. To enable this feature, set <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowCollapseGroup" /> and <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowExpandGroup" /> to <c>true</c>.</para>
        <para>This input mode manages a set of specialized input modes, each handling a specific part of the interaction with the graph. The following list details those along with their default <see cref="P:yWorks.Controls.Input.IInputMode.Priority">priorities</see>. Lower priorities come earlier when handing events.</para>
        <list type="bullet">
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.WaitInputMode" /> (−1)</term>
            <description>Disables this input mode when layouts or animations run.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.KeyboardInputMode" /> (0)</term>
            <description>Handles commands and arbitrary keyboard shortcuts.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.ClickInputMode" /> (10)</term>
            <description>Handles mouse clicks and double-clicks.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.MarqueeSelectionInputMode" /> (30)</term>
            <description>Allows dragging a rectangle to select items within it.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.MoveViewportInputMode" /> (39)</term>
            <description>Allows panning the viewport.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.ItemHoverInputMode" /> (55)</term>
            <description>Provides events to indicate that the mouse pointer hovers over an item.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.NavigationInputMode" /> (55)</term>
            <description>Provides general navigation facilities, such as navigating from one item to another with the arrow keys.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.ContextMenuInputMode" /> (60)</term>
            <description>Handles querying the context menu contents based on a location as well as preparing the menu for display.</description>
          </item>
          <item>
            <term>
              <see cref="T:yWorks.Controls.Input.MouseHoverInputMode" /> (100)</term>
            <description>Handles tool tips.</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GraphViewerInputMode.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.GraphViewerInputMode" /> class.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.GraphViewerInputMode.CreateMarqueeSelectionInputMode" />
    <member name="M:yWorks.Controls.Input.GraphViewerInputMode.CreateNavigationInputMode" />
    <member name="T:yWorks.Controls.Input.IClickHandler">
      <summary>
        <para>A simple interface that can be used to react to clicks on regions of <see cref="T:yWorks.Graph.Styles.INodeStyle" />s etc.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Controls.Input.GraphInputMode" /> will query the <see cref="T:yWorks.Graph.IModelItem" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method for this interface if it has detected <see cref="M:yWorks.Controls.Input.GraphInputMode.Click(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)" />s. If the item yields an instance of this interface and the click was recognized by the <see cref="P:yWorks.Controls.Input.IClickHandler.HitTestable" />, then <see cref="M:yWorks.Controls.Input.IClickHandler.OnClicked(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">is invoked</see>.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.GraphInputMode" />
      <seealso cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator" />
    </member>
    <member name="P:yWorks.Controls.Input.IClickHandler.HitTestable">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.Input.IHitTestable" /> that can be used to to check if <see cref="M:yWorks.Controls.Input.IClickHandler.OnClicked(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> should be invoked.</para>
      </summary>
      <returns>
        <para>A hit testable that can determine whether <see cref="M:yWorks.Controls.Input.IClickHandler.OnClicked(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> should be invoked by a given click.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IClickHandler.OnClicked(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Called by the framework to indicate that the <see cref="T:yWorks.Graph.IModelItem" /> has been clicked by the user at the specified <paramref name="location" />.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.GraphInputMode.Click(yWorks.Graph.IModelItem,yWorks.Controls.Input.ClickEventArgs)" /> for the <see cref="T:yWorks.Graph.IModelItem" />s that yielded an instance of this interface.</para>
      </remarks>
      <param name="context">
        <para>The context to use for the click operation.</para>
      </param>
      <param name="location">
        <para>The location of the click</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.IEdgePortHandleProvider">
      <summary>
        <para>An interface for classes that can yield <see cref="T:yWorks.Controls.Input.IHandle" /> implementations for the <see cref="P:yWorks.Graph.IEdge.SourcePort">source</see> and <see cref="P:yWorks.Graph.IEdge.TargetPort">target</see> ends of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </summary>
      <remarks>
        <para>This interface will be queried by the default implementation of the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> that is in the lookup of an <see cref="T:yWorks.Graph.IEdge" />. It is recommended to use this interface instead of the more generic <see cref="T:yWorks.Controls.Input.IHandleProvider" /> interface, because other generic code can then use this interface to gain access to a specific <see cref="T:yWorks.Controls.Input.IHandle" /> more easily.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IEdgePortHandleProvider.GetHandle(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean)">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.Input.IHandle" /> implementation for one end of the provided <paramref name="edge" />.</para>
      </summary>
      <param name="context">
        <para>The context in which the handle will be used.</para>
      </param>
      <param name="edge">
        <para>The edge for which an handle is needed.</para>
      </param>
      <param name="sourceHandle">
        <para>if set to <c>true</c> the handle for the source side/port should be returned.</para>
      </param>
      <returns>
        <para>The handle to use for the provided side or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.IEditLabelHelper">
      <summary>
        <para>Helper interface to customize interactive label editing.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface can be put into the <see cref="T:yWorks.Graph.ILookup" /> of <see cref="T:yWorks.Graph.ILabelOwner" />s and <see cref="T:yWorks.Graph.ILabel" />s so that it is possible to tweak the behavior on a case by case basis.</para>
        <para>Conceptually, in most cases, implementations of this interface behaves like an additional event handler for <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdding" /> and <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelEditing" />. If no event handler handled those events, an <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> will be queried from the <see cref="T:yWorks.Graph.ILookup" /> and the unhandled event arguments passed to the respective methods.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.EditLabelHelper" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.CreateLabel(yWorks.Graph.ILabelOwner)" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.EditLabel(yWorks.Graph.ILabel)" />
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.AddLabel(yWorks.Graph.ILabelOwner)" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdding" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelEditing" />
    </member>
    <member name="M:yWorks.Controls.Input.IEditLabelHelper.OnLabelAdding(yWorks.Controls.Input.LabelEditingEventArgs)">
      <summary>
        <para>Helper method that will be called when trying to add a label to an <see cref="T:yWorks.Graph.ILabelOwner" />.</para>
      </summary>
      <remarks>
        <para>Implementations of this method can set the <see cref="P:yWorks.Graph.ILabel.Style" />, <see cref="P:yWorks.Graph.ILabel.LayoutParameter" />, <see cref="P:yWorks.Graph.ILabel.PreferredSize" />, and <see cref="P:yWorks.Graph.ITagOwner.Tag" /> for newly-added labels by setting the appropriate properties on <paramref name="args" />.</para>
        <para>Setting the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Cancel" /> property on <paramref name="args" /> to <c>true</c> will disallow label creation.</para>
      </remarks>
      <param name="args">
        <para>The original event arguments.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IEditLabelHelper.OnLabelEditing(yWorks.Controls.Input.LabelEditingEventArgs)" />
    </member>
    <member name="M:yWorks.Controls.Input.IEditLabelHelper.OnLabelEditing(yWorks.Controls.Input.LabelEditingEventArgs)">
      <summary>
        <para>Helper method that will be called when trying to edit a label.</para>
      </summary>
      <remarks>
        <para>This method can be called for editing labels for an <see cref="T:yWorks.Graph.ILabelOwner" />, in which case the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Label" /> property on <paramref name="args" /> will be <c>null</c>, but the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Owner" /> property will be non-<c>null</c>. It can also be called for editing a specific label, in which case the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Label" /> property on <paramref name="args" /> will be non-<c>null</c>, and the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Owner" /> property will be set to the label's owner.</para>
        <para>Implementations of this method can set a specific label to be edited, by setting the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Label" /> property of the <paramref name="args" /> to an existing label instance. This label does not need to belong to the same owner that is queried for. Setting the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Label" /> property to <c>null</c> will not edit an existing label, but instead add a new one on the <see cref="T:yWorks.Graph.ILabelOwner" /> set in the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Owner" /> property.</para>
        <para>When a new label is added, the properties <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Style" />, <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.LayoutParameter" />, <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.PreferredSize" />, and <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Tag" /> are used for the newly-created label, just as in <see cref="M:yWorks.Controls.Input.IEditLabelHelper.OnLabelAdding(yWorks.Controls.Input.LabelEditingEventArgs)" />.</para>
        <para>Setting the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Cancel" /> property on <paramref name="args" /> to <c>true</c> will disallow label editing and creation.</para>
      </remarks>
      <param name="args">
        <para>The original event arguments.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IEditLabelHelper.OnLabelAdding(yWorks.Controls.Input.LabelEditingEventArgs)" />
    </member>
    <member name="T:yWorks.Controls.Input.ILabelSnapContextHelper">
      <summary>
        <para>Provides the snap lines and the snap results to the <see cref="T:yWorks.Controls.Input.LabelSnapContext" /> during dragging of labels.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.LabelSnapContext" />
      <seealso cref="P:yWorks.Graph.LabelDecorator.LabelSnapContextHelperDecorator" />
    </member>
    <member name="M:yWorks.Controls.Input.ILabelSnapContextHelper.AddSnapLines(yWorks.Controls.Input.LabelSnapContext,yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)">
      <summary>
        <para>Called during <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">initialization</see> of a <paramref name="label" /> dragging to add <see cref="T:yWorks.Controls.Input.SnapLine">snap lines</see> to which the label can potentially snap to the <paramref name="snapContext" />.</para>
      </summary>
      <param name="snapContext">
        <para>The snap context which manages the snap lines and the settings. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="inputModeContext">
        <para>The context of the input mode that handles the dragging.</para>
      </param>
      <param name="label">
        <para>The label that is dragged.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ILabelSnapContextHelper.CollectSnapResults(yWorks.Controls.Input.LabelSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.IOrientedRectangle,yWorks.Graph.ILabel)">
      <summary>
        <para>Called while the given <paramref name="label" /> is <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">dragged</see> to add <see cref="T:yWorks.Controls.Input.SnapResult">snap results</see> for the <see cref="T:yWorks.Controls.Input.SnapLine">snap lines</see> provided by the <paramref name="context" />.</para>
      </summary>
      <param name="context">
        <para>The snap context which manages the snap lines and the settings.</para>
      </param>
      <param name="args">
        <para>The event argument to obtain the necessary information from and <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">add results to</see>.</para>
      </param>
      <param name="suggestedLayout">
        <para>The <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see> of the label that would be used without snapping.</para>
      </param>
      <param name="label">
        <para>The label that is dragged.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.INodeSizeConstraintProvider">
      <summary>
        <para>An interface used by implementations that provide various size constraints for <see cref="T:yWorks.Graph.INode" />s.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.NodeSizeConstraintProvider" />
    </member>
    <member name="M:yWorks.Controls.Input.INodeSizeConstraintProvider.GetMinimumSize(yWorks.Graph.INode)">
      <summary>
        <para>Returns the minimum size allowed for the given <paramref name="node" />.</para>
      </summary>
      <param name="node">
        <para>The node to return the minimum size for.</para>
      </param>
      <returns>
        <para>The minimum size or <see cref="F:yWorks.Geometry.SizeD.Empty" /> if there is no constraint on the size.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.INodeSizeConstraintProvider.GetMaximumSize(yWorks.Graph.INode)">
      <summary>
        <para>Returns the maximum size allowed for the given <paramref name="node" />.</para>
      </summary>
      <param name="node">
        <para>The node to return the maximum size for.</para>
      </param>
      <returns>
        <para>The maximum size or <see cref="F:yWorks.Geometry.SizeD.Infinite" /> if there is no constraint on the size.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.INodeSizeConstraintProvider.GetMinimumEnclosedArea(yWorks.Graph.INode)">
      <summary>
        <para>Returns the minimum area that needs to be enclosed by the given <paramref name="node" />.</para>
      </summary>
      <param name="node">
        <para>The node to return the area for.</para>
      </param>
      <returns>
        <para>The area to enclose or <see cref="F:yWorks.Geometry.RectD.Empty" /> if there is no constraint on the size due to an enclosed area.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.NodeSizeConstraintProvider">
      <summary>
        <para>A simple default implementation of <see cref="T:yWorks.Controls.Input.INodeSizeConstraintProvider" /></para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSizeConstraintProvider.#ctor(yWorks.Geometry.ISize,yWorks.Geometry.ISize,yWorks.Geometry.IRectangle)">
      <summary>
        <para>Creates a new instance using the provided size instances as the initial values.</para>
      </summary>
      <remarks>
        <para>Not specifing the minimumEnclosedArea will set it to <see cref="F:yWorks.Geometry.RectD.Empty" />.</para>
      </remarks>
      <param name="minimumSize">
        <para>The <see cref="P:yWorks.Controls.Input.NodeSizeConstraintProvider.MinimumSize" />.</para>
      </param>
      <param name="maximumSize">
        <para>The <see cref="P:yWorks.Controls.Input.NodeSizeConstraintProvider.MaximumSize" />.</para>
      </param>
      <param name="minimumEnclosedArea">
        <para>The <see cref="P:yWorks.Controls.Input.NodeSizeConstraintProvider.MinimumEnclosedArea" />.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.NodeSizeConstraintProvider.MaximumSize">
      <summary>
        <para>Gets or sets the instance to return by <see cref="M:yWorks.Controls.Input.NodeSizeConstraintProvider.GetMaximumSize(yWorks.Graph.INode)" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.NodeSizeConstraintProvider.MinimumEnclosedArea">
      <summary>
        <para>Gets or sets the instance to return by <see cref="M:yWorks.Controls.Input.NodeSizeConstraintProvider.GetMinimumEnclosedArea(yWorks.Graph.INode)" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.NodeSizeConstraintProvider.MinimumSize">
      <summary>
        <para>Gets or sets the instance to return by <see cref="M:yWorks.Controls.Input.NodeSizeConstraintProvider.GetMinimumSize(yWorks.Graph.INode)" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSizeConstraintProvider.GetMinimumSize(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Controls.Input.NodeSizeConstraintProvider.GetMaximumSize(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Controls.Input.NodeSizeConstraintProvider.GetMinimumEnclosedArea(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="T:yWorks.Controls.Input.IOrthogonalEdgeHelper">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Controls.Input.OrthogonalEdgeEditingContext" /> and the like that can be decorated to the <see cref="T:yWorks.Graph.ILookup" /> of <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </summary>
      <remarks>
        <para>This interface is for editing edges in such a way that their path stays orthogonal, i.e. all of the segments are oriented either horizontally or vertically.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.GetOrthogonalEdgeHelper(yWorks.Graph.IEdge)" />
    </member>
    <member name="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.GetSegmentOrientation(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Int32)">
      <summary>
        <para>Gets the declared orientation of the given segment at the provided edge.</para>
      </summary>
      <remarks>
        <para>The orientation cannot always be inferred from the current geometry: If a segment has a zero length it is unclear what orientation it should have, also a segment could be accidentally orthogonally oriented, while in fact it is considered <see cref="F:yWorks.Controls.Input.SegmentOrientation.NonOrthogonal" />.</para>
      </remarks>
      <param name="context">
        <para>The input mode context in which the orientation is needed.</para>
      </param>
      <param name="edge">
        <para>The edge to inspect.</para>
      </param>
      <param name="segmentIndex">
        <para>The index of the segment.</para>
      </param>
      <returns>
        <para>The declared orientation of the segment.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.ShouldMoveEndImplicitly(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean)">
      <summary>
        <para>Determines whether this end of the provided edge can be moved in the input mode context.</para>
      </summary>
      <remarks>
        <para>This information is required to determine whether an edge's first or last segment needs to be split or the adjacent edge end can be moved along with the other end of the segment.</para>
      </remarks>
      <param name="context">
        <para>The input mode context in which the segment is edited.</para>
      </param>
      <param name="edge">
        <para>The edge to inspect.</para>
      </param>
      <param name="sourceEnd">
        <para>if set to <c>true</c> the source end of the edge is queried, otherwise the target end.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the end of the edge can be moved for the specified input mode context; <c>false</c> otherwise, in which case the corresponding segment needs to be split to keep the segment orientation orthogonal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.ShouldEditOrthogonally(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge)">
      <summary>
        <para>Determines whether the provided edge should be edited orthogonally in the specified input mode context.</para>
      </summary>
      <remarks>
        <para>If this method returns <c>false</c>, the other methods will not be queried at all.</para>
      </remarks>
      <param name="context">
        <para>The input mode context in which the edge is about to be edited.</para>
      </param>
      <param name="edge">
        <para>The edge to inspect.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge should be orthogonally edited in the specified input mode context; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.CleanUpEdge(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that is invoked after the provided edge has been edited orthogonally.</para>
      </summary>
      <remarks>
        <para>This callback can be used to remove unused bends and finalize the orthogonal edge editing gesture.</para>
      </remarks>
      <param name="context">
        <para>The input mode context which edited the edge.</para>
      </param>
      <param name="graph">
        <para>The graph to use for modifying the edge instance.</para>
      </param>
      <param name="edge">
        <para>The edge to clean up the path.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.IReparentNodeHandler">
      <summary>
        <para>Interface used for implementations that recognize, approve and disapprove node reparenting gestures, as well as actually performs the reparenting.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface are queried from the <see cref="T:yWorks.Controls.Input.IInputModeContext" /> by code that wants to reparent a node. Specifically this is used by default to reparent nodes during the <see cref="T:yWorks.Controls.Input.MoveInputMode">dragging of nodes</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IReparentNodeHandler.IsReparentGesture(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode)">
      <summary>
        <para>Determines whether the current gesture that can be determined through the context is a reparent gesture.</para>
      </summary>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="node">
        <para>The node that will possibly be reparented.</para>
      </param>
      <returns>
        <para>Whether this is a reparenting gesture.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IReparentNodeHandler.ShouldReparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode)">
      <summary>
        <para>Determines whether the user may detach the given node from its current parent in order to reparent it.</para>
      </summary>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="node">
        <para>The node that is about to be detached from its current parent.</para>
      </param>
      <returns>
        <para>Whether the node may be detached and reparented.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IReparentNodeHandler.IsValidParent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Determines whether the provided node may be reparented to a <paramref name="newParent" />.</para>
      </summary>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="node">
        <para>The node that will be reparented.</para>
      </param>
      <param name="newParent">
        <para>The potential new parent or <c>null</c>. Can be a group or a non-group node.</para>
      </param>
      <returns>
        <para>Whether <paramref name="newParent" /> is a valid new parent for <paramref name="node" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IReparentNodeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Performs the actual reparenting after the reparent gesture has been finalized.</para>
      </summary>
      <remarks>
        <para>Implementations should <see cref="M:yWorks.Graph.IGraph.SetParent(yWorks.Graph.INode,yWorks.Graph.INode)">set the parent</see> of <paramref name="node" /> to <paramref name="newParent" />.</para>
      </remarks>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="node">
        <para>The node that will be reparented.</para>
      </param>
      <param name="newParent">
        <para>The potential new parent or <c>null</c>. Can be a group or a non-group node.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.IReparentStripeHandler">
      <summary>
        <para>Interface used for implementations that recognize, approve and disapprove stripe reparenting gestures, as well as actually performs the reparenting.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ReparentStripePositionHandler" />
    </member>
    <member name="M:yWorks.Controls.Input.IReparentStripeHandler.ShouldReparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe)">
      <summary>
        <para>Determines whether the user may detach the given stripe from its current parent in order to reparent it.</para>
      </summary>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="stripe">
        <para>The stripe that is about to be detached from its current parent.</para>
      </param>
      <returns>
        <para>Whether the stripe may be detached and reparented.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IReparentStripeHandler.IsValidParent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,System.Int32,yWorks.Controls.Input.StripeReparentPolicy)">
      <summary>
        <para>Determines whether the provided node may be reparented to a <paramref name="newParent" />.</para>
      </summary>
      <remarks>
        <para>This method is called to determine whether a <see cref="M:yWorks.Controls.Input.IReparentStripeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,System.Int32,yWorks.Controls.Input.StripeReparentPolicy)" /> operation should actually be executed.</para>
      </remarks>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="stripe">
        <para>The stripe that will be reparented.</para>
      </param>
      <param name="newParent">
        <para>The potential new parent.</para>
      </param>
      <param name="index">
        <para>The index where the stripe would be <see cref="M:yWorks.Controls.Input.IReparentStripeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,System.Int32,yWorks.Controls.Input.StripeReparentPolicy)">reparented</see></para>
      </param>
      <param name="reparentPosition">
        <para>Where to place the stripe as a result of the gesture that would be used for the <see cref="M:yWorks.Controls.Input.IReparentStripeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,System.Int32,yWorks.Controls.Input.StripeReparentPolicy)"></see> operation.</para>
      </param>
      <returns>
        <para>Whether <paramref name="newParent" /> is a valid new parent for <paramref name="stripe" /> for the given index and gesture.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IReparentStripeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,System.Int32,yWorks.Controls.Input.StripeReparentPolicy)">
      <summary>
        <para>Performs the actual reparenting after the reparent gesture has been finalized.</para>
      </summary>
      <remarks>
        <para>Implementations should use <see cref="M:yWorks.Graph.ITable.SetParent(yWorks.Graph.IColumn,yWorks.Graph.IColumn,System.Nullable{System.Int32})" /> or <see cref="M:yWorks.Graph.ITable.SetParent(yWorks.Graph.IRow,yWorks.Graph.IRow,System.Nullable{System.Int32})" /> to set the parent of <paramref name="movedStripe" /> to <paramref name="newParent" />.</para>
      </remarks>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="movedStripe">
        <para>The stripe that will be reparented.</para>
      </param>
      <param name="newParent">
        <para>The potential new parent.</para>
      </param>
      <param name="index">
        <para>The index where the stripe should be inserted.</para>
      </param>
      <param name="reparentPosition">
        <para>Where to place the stripe as a result of the gesture that triggered the reparent operation.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.ReparentStripeHandler">
      <summary>
        <para>Default implementation of the <see cref="T:yWorks.Controls.Input.IReparentStripeHandler" /> interface.</para>
      </summary>
      <remarks>
        <para>This implementation allows to specify a maximal nesting depth for reparent operations.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripeHandler.ShouldReparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe)">
      <summary>
        <para>Determines whether the user may detach the given stripe from its current parent in order to reparent it.</para>
      </summary>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="stripe">
        <para>The stripe that is about to be detached from its current parent.</para>
      </param>
      <returns>
        <para>This implementation returns always <c>true</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripeHandler.IsValidParent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,System.Int32,yWorks.Controls.Input.StripeReparentPolicy)">
      <summary>
        <para>Checks the constraints imposed by <see cref="P:yWorks.Controls.Input.ReparentStripeHandler.MaxRowLevel" /> or <see cref="P:yWorks.Controls.Input.ReparentStripeHandler.MaxColumnLevel" /> for a valid gesture.</para>
      </summary>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="stripe">
        <para>The stripe that will be reparented.</para>
      </param>
      <param name="newParent">
        <para>The potential new parent.</para>
      </param>
      <param name="index">
        <para>The index where the stripe would be <see cref="M:yWorks.Controls.Input.ReparentStripeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,System.Int32,yWorks.Controls.Input.StripeReparentPolicy)">reparented</see></para>
      </param>
      <param name="reparentPosition">
        <para>Where to place the stripe as a result of the gesture that would be used for the <see cref="M:yWorks.Controls.Input.ReparentStripeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,System.Int32,yWorks.Controls.Input.StripeReparentPolicy)"></see> operation.</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff the resulting nesting depth is smaller than <see cref="P:yWorks.Controls.Input.ReparentStripeHandler.MaxRowLevel" /> or <see cref="P:yWorks.Controls.Input.ReparentStripeHandler.MaxColumnLevel" />, or if the nesting depth would not increase by the operation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,System.Int32,yWorks.Controls.Input.StripeReparentPolicy)">
      <summary>
        <para>Performs the actual reparenting after the reparent gesture has been finalized.</para>
      </summary>
      <remarks>
        <para>This implementation adjusts the size of the moved and/or the target stripe by calling <see cref="M:yWorks.Controls.Input.ReparentStripeHandler.AdjustSize(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,yWorks.Controls.Input.StripeReparentPolicy,System.Int32,System.Double,System.Double)" /> .</para>
      </remarks>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="stripe">
        <para>The stripe that will be reparented.</para>
      </param>
      <param name="newParent">
        <para>The potential new parent.</para>
      </param>
      <param name="index">
        <para>The index where the stripe should be inserted.</para>
      </param>
      <param name="reparentPosition">
        <para>Where to place the stripe as a result of the gesture that triggered the reparent operation.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripeHandler.AdjustSize(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe,yWorks.Graph.IStripe,yWorks.Controls.Input.StripeReparentPolicy,System.Int32,System.Double,System.Double)">
      <summary>
        <para>Adjust the size of the source or the target stripe.</para>
      </summary>
      <remarks>
        <para>This implementation adjusts the size of <paramref name="stripe" /> to <c>Math.Max(originalStripeSize, originalParentSize)</c> if <paramref name="reparentPosition" /> is an <see cref="F:yWorks.Controls.Input.StripeReparentPolicy.AddChild" /> operation</para>
      </remarks>
      <param name="context">
        <para>The context that provides information about the user input.</para>
      </param>
      <param name="stripe">
        <para>The stripe that will be reparented.</para>
      </param>
      <param name="newParent">
        <para>The potential new parent.</para>
      </param>
      <param name="index">
        <para>The index where the stripe should be inserted.</para>
      </param>
      <param name="reparentPosition">
        <para>Where to place the stripe as a result of the gesture that triggered the reparent operation.</para>
      </param>
      <param name="originalStripeSize">
        <para>The original size of <paramref name="stripe" /></para>
      </param>
      <param name="originalParentSize">
        <para>The original size of <paramref name="newParent" /></para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.ReparentStripeHandler.MaxRowLevel">
      <summary>
        <para>Gets or sets the maximum nesting level the row hierarchy may acquire during a reparent gesture.</para>
      </summary>
      <remarks>
        <para>Note that it is always possible to decrease the nesting depth, even if the resulting depth would still be too high. This allows to interactively reduce an invalid nesting depth in multiple steps. The default value is <see cref="F:System.Int32.MaxValue" />, which effectively means an unlimited nesting depth.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ReparentStripeHandler.MaxColumnLevel">
      <summary>
        <para>Gets or sets the maximum nesting level the column hierarchy may acquire during a reparent gesture.</para>
      </summary>
      <remarks>
        <para>Note that it is always possible to decrease the nesting depth, even if the resulting depth would still be too high. This allows to interactively reduce an invalid nesting depth in multiple steps. The default value is <see cref="F:System.Int32.MaxValue" />, which effectively means an unlimited nesting depth.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.ISnapLineProvider">
      <summary>
        <para>Queried by the <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> to add <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s to its collections during the <see cref="P:yWorks.Controls.Input.SnapContext.IsInitializing">initialization phase</see>.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface are queried by <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> for each item that is not modified during the edit using the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the respective item.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.NodeDecorator.SnapLineProviderDecorator" />
    </member>
    <member name="M:yWorks.Controls.Input.ISnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)">
      <summary>
        <para>Called by the <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> when a <see cref="M:yWorks.Controls.Input.GraphSnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">drag</see> is about to start.</para>
      </summary>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="args">
        <para>The argument to use for adding snap lines.</para>
      </param>
      <param name="item">
        <para>The item to add snap lines for.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.ItemClickedEventArgs`1">
      <summary>
        <para>Provides data for the <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemClicked" />, <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemDoubleClicked" />, <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftClicked" />, <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemLeftDoubleClicked" />, <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightClicked" /> and <see cref="E:yWorks.Controls.Input.GraphInputMode.ItemRightDoubleClicked" /> events.</para>
      </summary>
      <typeparam name="T">
        <para>The type of the item this event carries.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Controls.Input.ItemClickedEventArgs`1.#ctor(`0,yWorks.Geometry.PointD)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.ItemClickedEventArgs`1" /> class.</para>
      </summary>
      <param name="item">
        <para>The item which is the subject of the event.</para>
      </param>
      <param name="location">
        <para>The location of the click.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Controls.Input.ItemClickedEventArgs`1" /> is handled.</para>
      </summary>
      <remarks>
        <para>Setting the event to handled indicates whether the event should be further propagated or whether there has not been any code that actively handled the event to the event source. How this flag is actually being treated depends on the source of the event.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ItemClickedEventArgs`1.Location">
      <summary>
        <para>Gets the location of the click.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.ItemDropInputMode`1">
      <summary>
        <para>A <see cref="T:yWorks.Controls.Input.DropInputMode" /> providing a preview of the dragged item.</para>
      </summary>
      <remarks>
        <para>A dragged <see cref="T:yWorks.Graph.IModelItem" /> is visualized during the drag operation. In addition, this input mode supports snapping of the dragged <see cref="T:yWorks.Graph.IModelItem" /> via the <see cref="T:yWorks.Controls.Input.SnapContext" /> and highlighting the <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.DropTarget" />.</para>
        <para>Highlighting is done via a <see cref="T:yWorks.Controls.HighlightIndicatorManager`1" />.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.ItemDropInputMode`1.ItemCreated">
      <summary>
        <para>Occurs when a new item gets created by this input mode.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ItemDropInputMode`1.ShowPreview">
      <summary>
        <para>Gets or sets whether a preview of the dragged element is displayed during the drag</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ItemDropInputMode`1.SnappingEnabled">
      <summary>
        <para>Gets or sets whether dragged items are snapped.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ItemDropInputMode`1.DisableSnappingRecognizer">
      <summary>
        <para>Gets or sets <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that temporarily disables snapping.</para>
      </summary>
      <value>
        <para>The disable snapping recognizer. The default recognizer checks for a pressed CTRL key.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ItemDropInputMode`1.HighlightDropTarget">
      <summary>
        <para>Gets or sets whether the drop target is highlighted.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ItemDropInputMode`1.SnapContext">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.SnapContext" /> which is used to snap the dragged element during the drag.</para>
      </summary>
      <remarks>
        <para>If set to <c>null</c> (the default) this input mode tries to obtain the <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.SnapContext" /> from the <see cref="T:yWorks.Controls.Input.IInputModeContext" />. To explicitly disable snapping, a <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.SnapContext" /> implementation that does nothing has to be set to this instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ItemDropInputMode`1.SnappedMousePosition">
      <summary>
        <para>Gets the current snapped mouse position during drag operations.</para>
      </summary>
      <remarks>
        <para>The position is returned in world coordinates according to the <see cref="T:yWorks.Controls.CanvasControl" /> into which this input mode is installed. If <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.SnappingEnabled" /> is false, this value corresponds with <see cref="P:yWorks.Controls.Input.DropInputMode.MousePosition" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ItemDropInputMode`1.DropTarget">
      <summary>
        <para>Gets the drop target at <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.SnappedMousePosition" /></para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.ItemDropInputMode`1.HighlightDropTarget" />
    </member>
    <member name="P:yWorks.Controls.Input.ItemDropInputMode`1.DraggedItem">
      <summary>
        <para>Gets the currently dragged <see cref="T:yWorks.Graph.IModelItem" /> instance.</para>
      </summary>
      <remarks>
        <para>This implementation simply tries to cast the <see cref="P:yWorks.Controls.Input.DropInputMode.DropData" /> to the type of the dragged items.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ItemDropInputMode`1.ItemCreator">
      <summary>
        <para>Gets or sets the callback for item creation.</para>
      </summary>
      <remarks>
        <para>Called by method <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.OnDragDropped(yWorks.Controls.Input.InputModeEventArgs)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.#ctor(System.String)">
      <summary>
        <para>Constructs a new instance of class <see cref="T:yWorks.Controls.Input.DropInputMode" /> for the expected data format.</para>
      </summary>
      <remarks>
        <para>Not used in this class. This constructor only exists for usage in child class.</para>
      </remarks>
      <param name="expectedDataFormat" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.#ctor(System.Type)">
      <summary>
        <para>Constructs a new instance of class <see cref="T:yWorks.Controls.Input.DropInputMode" /> for the expected data type.</para>
      </summary>
      <remarks>
        <para>This constructor only exists for usage in child class.</para>
      </remarks>
      <param name="expectedType" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.#ctor">
      <summary>
        <para>Constructs a new instance of class <see cref="T:yWorks.Controls.Input.DropInputMode" /> for the template type.</para>
      </summary>
      <remarks>
        <para>This constructor only exists for usage in child class.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.OnDragEntered(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Called once a drag has entered the canvas.</para>
      </summary>
      <remarks>
        <para>Calls <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.InitializeSnapContext" />, <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.InitializePreview" /> and <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.InitializeDropTarget" />.</para>
      </remarks>
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.InitializeSnapContext">
      <summary>
        <para>Initializes the snapping context.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.OnDragEntered(yWorks.Controls.Input.InputModeEventArgs)" /></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.InitializePreview">
      <summary>
        <para>Initializes the item preview.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.OnDragEntered(yWorks.Controls.Input.InputModeEventArgs)" />. If a preview <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.ShowPreview">shall be displayed</see>, the <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.PreviewGraph">preview graph</see> is initialized and <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.PopulatePreviewGraph(yWorks.Graph.IGraph)" /> is called.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.InitializeDropTarget">
      <summary>
        <para>Initializes the drop target.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ItemDropInputMode`1.PreviewGraph">
      <summary>
        <para>Gets the graph displayed as item preview.</para>
      </summary>
      <value>
        <para>The preview graph or <c>null</c> if no preview is displayed at the moment.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.PopulatePreviewGraph(yWorks.Graph.IGraph)">
      <summary>
        <para>Subclasses shall fill the specified graph that is used to preview the dragged item.</para>
      </summary>
      <param name="previewGraph">
        <para>The preview graph to fill.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.UpdatePreview(yWorks.Graph.IGraph,yWorks.Geometry.PointD)">
      <summary>
        <para>Subclasses shall update the <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.PreviewGraph">preview graph</see> so the dragged item is displayed at the specified <paramref name="dragLocation" />.</para>
      </summary>
      <param name="previewGraph">
        <para>The preview graph to update.</para>
      </param>
      <param name="dragLocation">
        <para>The current drag location.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.UpdateDropTarget(yWorks.Geometry.PointD)">
      <summary>
        <para>Calls <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.GetDropTarget(yWorks.Geometry.PointD)" /> for <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.SnappedMousePosition" /> and sets the returned item as <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.DropTarget" />.</para>
      </summary>
      <remarks>
        <para>If <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.HighlightDropTarget" /> is enabled, the highlight is updated as well.</para>
      </remarks>
      <param name="dragLocation">
        <para>The location to update the drop target for.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.GetDropTarget(yWorks.Geometry.PointD)">
      <summary>
        <para>Returns the drop target at the specified location.</para>
      </summary>
      <remarks>
        <para>The drop target is highlighted, if <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.HighlightDropTarget" /> is enabled. Per default, <c>null</c> is returned.</para>
      </remarks>
      <param name="dragLocation">
        <para>The location to return the drop target for.</para>
      </param>
      <returns>
        <para>The drop target at the specified location or <c>null</c> if no drop target can be found.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.OnDraggedOver(yWorks.Controls.Input.InputModeEventArgs)">
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.OnDragLeft(yWorks.Controls.Input.InputModeEventArgs)">
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.OnDragDropped(yWorks.Controls.Input.InputModeEventArgs)">
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.OnItemCreated(yWorks.Utils.ItemEventArgs{`0})">
      <summary>
        <para>Called whenever a new item is created</para>
      </summary>
      <param name="args" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.CollectSnapResults(System.Object,yWorks.Controls.Input.CollectSnapResultsEventArgs)">
      <summary>
        <para>Callback registered on the <see cref="T:yWorks.Controls.Input.SnapContext" /> that collects <see cref="T:yWorks.Controls.Input.SnapResult" />s for the dragged element.</para>
      </summary>
      <remarks>
        <para>The default implementation doesn't collect any snap results.</para>
      </remarks>
      <param name="source">
        <para>The <see cref="T:yWorks.Controls.Input.SnapContext" /> this callback is registered at.</para>
      </param>
      <param name="args">
        <para>The arguments describing the movement <see cref="T:yWorks.Controls.Input.SnapResult" />s shall be collected for.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.SetDragLocation(yWorks.Geometry.PointD)">
      <summary>
        <para>Sets the <see cref="M:yWorks.Controls.Input.DropInputMode.SetDragLocation(yWorks.Geometry.PointD)">drag location</see> and calls <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.UpdatePreview(yWorks.Graph.IGraph,yWorks.Geometry.PointD)" /> to update the layout of item preview based on the mouse coordinates and the results of the <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.SnapContext" />.</para>
      </summary>
      <param name="location" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.OnConcurrencyControllerDeactivated" />
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.Cleanup">
      <summary>
        <para>Cleanup method that calls <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.CleanupSnapContext" />, <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.CleanupPreview" /> and <see cref="M:yWorks.Controls.Input.ItemDropInputMode`1.CleanupDropTarget" />.</para>
      </summary>
      <remarks>
        <para>This method should be called for cleanup actions after a drag/drop gesture has been finished or canceled.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.CleanupPreview">
      <summary>
        <para>Cleans up the item preview.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.CleanupSnapContext">
      <summary>
        <para>Cleans up the snap context.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ItemDropInputMode`1.CleanupDropTarget">
      <summary>
        <para>Cleans up the drop target and its highlighting.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.DropCreationCallback`1">
      <summary>
        <para>Callback for creating a copy of the dragged item in graph at the specified location.</para>
      </summary>
      <param name="context">
        <para>The context for which the item should be created.</para>
      </param>
      <param name="graph">
        <para>The <see cref="T:yWorks.Graph.IGraph">Graph</see> in which to create the item.</para>
      </param>
      <param name="draggedItem">
        <para>The item that was dragged and should therefore be created.</para>
      </param>
      <param name="dropTarget">
        <para>The <see cref="T:yWorks.Graph.IModelItem" /> on which the item is dropped.</para>
      </param>
      <param name="dropLocation">
        <para>The location the item should be created.</para>
      </param>
      <typeparam name="T">
        <para>The type of the item being dropped.</para>
      </typeparam>
      <returns>
        <para>The <see cref="T:yWorks.Graph.IModelItem">item</see> that has been created, or <c>null</c> if no item should be created.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.ItemHoverInputMode">
      <summary>
        <para>An input mode for use in a <see cref="T:yWorks.Controls.GraphControl" /> that fires events when the mouse enters or leaves the visualization of a <see cref="T:yWorks.Graph.IModelItem">graph item</see>.</para>
      </summary>
      <remarks>
        <para>This mode can be used to determine when the mouse is being moved from one item to the next.</para>
        <para>This mode is <see cref="P:yWorks.Controls.Input.ItemHoverInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ItemHoverInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.ItemHoverInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.ItemHoverInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.ItemHoverInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.TryStop">
      <summary>
        <para>Overridden to only return <c>true</c> if this instance does not currently <see cref="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">have the input mutex</see>.</para>
      </summary>
      <returns>
        <para>
          <c>true</c> iff this instance does not <see cref="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">own the mutex</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.Cancel" />
    <member name="P:yWorks.Controls.Input.ItemHoverInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.ItemHoverInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.ItemHoverInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.ItemHoverInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Controls.Input.ItemHoverInputMode.HoveredItemChanged">
      <summary>
        <para>Occurs when the item that is being hovered over with the mouse changes.</para>
      </summary>
      <remarks>
        <para>This event is also fired when the mouse pointer leaves an item.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.ItemHoverInputMode" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ItemHoverInputMode.CurrentHoverItem">
      <summary>
        <para>Gets the current item the mouse is hovering over.</para>
      </summary>
      <value>
        <para>The current item or <c>null</c> if the mouse is not hovering over a <see cref="M:yWorks.Controls.Input.ItemHoverInputMode.IsValidHoverItem(yWorks.Graph.IModelItem)">valid</see> item.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ItemHoverInputMode.HoverItems">
      <summary>
        <para>Gets or sets which graph items are considered by this input mode.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.ItemHoverInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.GetHitItemsAt(yWorks.Geometry.PointD)">
      <summary>
        <para>Gets the items that have been hit at the given location.</para>
      </summary>
      <param name="location">
        <para>The location in world coordinates to query.</para>
      </param>
      <returns>
        <para>An enumerable over all items that have been hit at the given location.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.UpdateHover(System.Nullable{yWorks.Geometry.PointD})">
      <summary>
        <para>Forces a reevaluation of the item that the mouse is currently hovering over or at a specific location.</para>
      </summary>
      <remarks>
        <para>This method may be called by code that is aware of the fact that the visualization has changed, but the mouse may not have been moved. By default this implementation will only re-query the items at the mouse location when the mouse has moved. This method can be called to force a reevaluation in other cases.</para>
      </remarks>
      <param name="location">
        <para>The query location.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.ItemHoverInputMode.HoverCursor">
      <summary>
        <para>Gets or sets the cursor to use when the mouse is hovering over a <see cref="M:yWorks.Controls.Input.ItemHoverInputMode.IsValidHoverItem(yWorks.Graph.IModelItem)" /> valid hover item.</para>
      </summary>
      <value>
        <para>The hover cursor or <c>null</c> (the default).</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ItemHoverInputMode.DiscardInvalidItems">
      <summary>
        <para>Gets or sets whether items that have been hit at the current location that are not <see cref="M:yWorks.Controls.Input.ItemHoverInputMode.IsValidHoverItem(yWorks.Graph.IModelItem)">valid items</see> should be ignored or reported as <c>null</c>.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if invalid items should be reported as <c>null</c>; otherwise, <c>false</c>, in which case the hit test enumeration continues to find the next valid item. The default is <c>true</c>.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.ItemHoverInputMode.IsValidHoverItem(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.IsValidHoverItem(yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether the given item is a valid item to be considered for hovering.</para>
      </summary>
      <remarks>
        <para>This implementation checks whether the item is covered by the <see cref="P:yWorks.Controls.Input.ItemHoverInputMode.HoverItems" /> set, only.</para>
      </remarks>
      <param name="item">
        <para>The item to check.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if it is valid to report a hover over the specified item; <c>false</c> otherwise.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.ItemHoverInputMode.DiscardInvalidItems" />
    </member>
    <member name="M:yWorks.Controls.Input.ItemHoverInputMode.OnHoveredItemChanged(yWorks.Controls.Input.HoveredItemChangedEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.ItemHoverInputMode.HoveredItemChanged" /> event.</para>
      </summary>
      <param name="hoveredItemChangedEventArgs">
        <para>The <see cref="T:yWorks.Controls.Input.HoveredItemChangedEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.HoveredItemChangedEventArgs">
      <summary>
        <para>Event argument class containing information about which <see cref="T:yWorks.Graph.IModelItem" /> the mouse is currently hovering over.</para>
      </summary>
      <remarks>
        <para>This event is used by the <see cref="E:yWorks.Controls.Input.ItemHoverInputMode.HoveredItemChanged" /> event. The <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" /> property yields the item that is currently being hovered over or <c>null</c> if the mouse just left an item without hovering over an other one. The <see cref="P:yWorks.Controls.Input.HoveredItemChangedEventArgs.OldItem" /> property provides the previously hovered item.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.HoveredItemChangedEventArgs.#ctor(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.HoveredItemChangedEventArgs" /> class.</para>
      </summary>
      <param name="item">
        <para>The model item, possibly <c>null</c>.</para>
      </param>
      <param name="oldItem">
        <para>The old item, possibly <c>null</c>.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.HoveredItemChangedEventArgs.OldItem">
      <summary>
        <para>Gets or sets the item that was previously hovered, possibly <c>null</c>.</para>
      </summary>
      <seealso cref="P:yWorks.Utils.ItemEventArgs`1.Item" />
    </member>
    <member name="T:yWorks.Controls.Input.LabelEditingEventArgs">
      <summary>
        <para>Event arguments for the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdding" /> and <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelEditing" /> events, as well as the <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> interface.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.LabelEditingEventArgs.Label">
      <summary>
        <para>Gets or sets the label to edit.</para>
      </summary>
      <remarks>
        <para>This can be set to an exiting label to edit a specific one, or set to <c>null</c> to add a new label instead (e.g. for <see cref="T:yWorks.Graph.ILabelOwner" />s that have no label yet).</para>
        <para>If this property is set to <c>null</c>, the properties <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Style" />, <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.PreferredSize" />, <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.LayoutParameter" />, and <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Tag" /> are used for the newly-added label, just like with <see cref="T:yWorks.Controls.Input.LabelEditingEventArgs" />.</para>
        <para>Setting this property implicitly also sets <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelEditingEventArgs.Cancel">
      <summary>
        <para>Gets or sets a value indicating whether the action (adding or editing a label) should be canceled.</para>
      </summary>
      <remarks>
        <para>Setting this property implicitly also sets <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this event has been handled.</para>
      </summary>
      <remarks>
        <para>A handled instance of <see cref="T:yWorks.Controls.Input.LabelEditingEventArgs" /> will not be passed to further event handlers or an <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> instance.</para>
        <para>Setting any of the other properties implicitly also sets this to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelEditingEventArgs.Owner">
      <summary>
        <para>Gets or sets the owner of the label.</para>
      </summary>
      <remarks>
        <para>This property can be <c>null</c> if there is no owner known, e.g. if the event is raised for non-<see cref="T:yWorks.Graph.ILabelOwner" />s. Otherwise it is initially set to the item for which the event is raised.</para>
        <para>Setting this property implicitly also sets <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelEditingEventArgs.Style">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Graph.ILabel.Style" /> of the label to add.</para>
      </summary>
      <remarks>
        <para>Setting this property implicitly also sets <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelEditingEventArgs.PreferredSize">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Graph.ILabel.PreferredSize" /> of the label to add.</para>
      </summary>
      <remarks>
        <para>Setting this property implicitly also sets <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelEditingEventArgs.LayoutParameter">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Graph.ILabel.LayoutParameter" /> of the label to add.</para>
      </summary>
      <remarks>
        <para>Setting this property implicitly also sets <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelEditingEventArgs.Tag">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> of the label to add.</para>
      </summary>
      <remarks>
        <para>Setting this property implicitly also sets <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelEditingEventArgs.TextEditorInputModeConfigurator">
      <summary>
        <para>Gets or sets the configurator for the <see cref="T:yWorks.Controls.Input.TextEditorInputMode" /> for editing the provided label instance.</para>
      </summary>
      <remarks>
        <para>Setting this property implicitly also sets <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.LabelEditingEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabelOwner,yWorks.Graph.ILabel)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.LabelEditingEventArgs" /> class with the given context, owner, and label.</para>
      </summary>
      <param name="context">
        <para>The input mode context to use.</para>
      </param>
      <param name="owner">
        <para>The <see cref="T:yWorks.Graph.ILabelOwner" /> whose label should be edited.</para>
      </param>
      <param name="label">
        <para>The <see cref="T:yWorks.Graph.ILabel" /> that should be edited.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.TextEditorInputModeConfigurationHandler">
      <summary>
        <para>Callback for configuring a <see cref="T:yWorks.Controls.Input.TextEditorInputMode" /> for editing a provided label instance.</para>
      </summary>
      <param name="context">
        <para>The context in which the label is being edited or created.</para>
      </param>
      <param name="mode">
        <para>The mode that will be used for editing the label's text.</para>
      </param>
      <param name="label">
        <para>The label that will be edited or created.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.LabelPositionHandler">
      <summary>
        <para>An implementation of <see cref="T:yWorks.Controls.Input.IPositionHandler" /> that shows the various label position candidates and lets the user move a label to one of those candidate positions.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.LabelPositionHandler.CandidateTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used to represent the rectangular selection.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.LabelPositionHandler.HighlightTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used to represent the rectangular selection.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.#ctor(yWorks.Graph.ILabel)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.LabelPositionHandler" /> class.</para>
      </summary>
      <param name="label">
        <para>The label that shall be moved.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.LabelPositionHandler.CandidateTemplate">
      <summary>
        <para>Gets or sets the template to use for showing candidates.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.LabelPositionHandler.HighlightTemplate">
      <summary>
        <para>Gets or sets the template to use for showing highlighted candidates.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.LabelPositionHandler.Graph">
      <summary>
        <para>Gets the graph instance from the <see cref="T:yWorks.Controls.Input.IInputModeContext" /> that has been passed to the <see cref="M:yWorks.Controls.Input.LabelPositionHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> method.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.LabelPositionHandler.Label">
      <summary>
        <para>Gets the label instance.</para>
      </summary>
      <value>
        <para>The label.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.SetPosition(yWorks.Geometry.PointD)">
      <summary>
        <para>Called by clients to set the position to the given coordinates.</para>
      </summary>
      <param name="location">
        <para>The new location.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.IDragHandler.Location" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.GetParameterCandidates(yWorks.Graph.ILabel)">
      <summary>
        <para>Callback method that gets the candidates for the given label.</para>
      </summary>
      <param name="label">
        <para>The label.</para>
      </param>
      <returns>
        <para>A possibly empty enumerator over possible label parameter candidates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.CreateCandidateDescriptor(yWorks.Controls.Input.IInputModeContext,System.Boolean)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> to display the given candidate position.</para>
      </summary>
      <param name="context">
        <para>The context for which the descriptor is created.</para>
      </param>
      <param name="highlight">
        <para>Whether to highlight the paintable. This will be <c>true</c> for the current position and <c>false</c> for the others.</para>
      </param>
      <returns>
        <para>An implementation that will render the given candidate.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.SetLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Actually applies the given parameter at the end of the gesture.</para>
      </summary>
      <param name="label">
        <para>The label to set the parameter for.</para>
      </param>
      <param name="layoutParameter">
        <para>The new parameter.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.UseParameterFinder(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Determines whether to use a <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder" /> to find the best candidate.</para>
      </summary>
      <param name="context">
        <para>The context that is currently being used - may be <c>null</c> if the method is called without context.</para>
      </param>
      <returns />
      <remarks>
        <para>This implementation returns <c>true</c> if the <see cref="P:yWorks.Controls.Input.LabelPositionHandler.UseFinder" /> property is <c>true</c> and the control key is pressed.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelPositionHandler.UseFinder">
      <summary>
        <para>Gets or sets a property that determines whether the handler may use a <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder" /> to assign arbitrary positions.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.LabelPositionHandler.UseParameterFinder(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.GetDistance(yWorks.Geometry.IOrientedRectangle,yWorks.Geometry.PointD)">
      <summary>
        <para>Calculates a distance value between a candidate rectangle and the mouse location.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle candidate.</para>
      </param>
      <param name="location">
        <para>The mouse location.</para>
      </param>
      <returns>
        <para>A value indicating the closeness of the mouse to the rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelPositionHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="T:yWorks.Controls.Input.LabelSnapContext">
      <summary>
        <para>Manages interactive snapping of <see cref="T:yWorks.Graph.ILabel" />s to their owner during drag operations like movements.</para>
      </summary>
      <remarks>
        <para>This class provides a set of properties to customize the snapping behavior. <see cref="T:yWorks.Controls.Input.IPositionHandler" /> implementations and similar classes can use the following idiom to get an instance of this class:</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.MoveLabelInputMode" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.SnapContext" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContext.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.LabelSnapContext" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.CollectInitialLocationSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect snap lines for the initial position of a label.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance should collect snap lines for the initial position of a label; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.CollectNodeShapeSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect six snap lines, two through the center and four through the border sides of the label owner.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance should collect snap lines through the border and center of the label owner; otherwise, <c>false</c>.</para>
      </value>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.CollectOwnNodeDistanceSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect four snap lines in parallel to the owner's borders at the initial label distance.</para>
      </summary>
      <remarks>
        <para>Note that the label snaps to these snap lines with the side that is closer to the node's border. That way, snapping to such a snap line preserves the perceived distance from the node border for both labels inside and outside the node bounds.</para>
        <para>The default is <c>true</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this instance should collect snap lines through the border and center of the label owner; otherwise, <c>false</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.CollectSameOwnerNodeDistanceSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect snap lines in parallel to the border of the label owner at the distance of other node labels of that owner.</para>
      </summary>
      <remarks>
        <para>Note that the label snaps to these snap lines with the side that is closer to the node's border. That way, snapping to such a snap line preserves the perceived distance from the node border for both labels inside and outside the node bounds.</para>
        <para>The default is <c>true</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this instance should collect this kind of snap lines; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.CollectAllNodeDistanceSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect snap lines in parallel to the border of the label owner at the distance of other node labels in the graph.</para>
      </summary>
      <remarks>
        <para>Note that the label snaps to these snap lines with the side that is closer to the node's border. That way, snapping to such a snap line preserves the perceived distance from the node border for both labels inside and outside the node bounds.</para>
        <para>The default is <c>false</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this instance should collect this kind of snap lines; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.CollectEdgePathSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect snap lines on the edge path.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance should collect this kind of snap lines; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.CollectOwnEdgeDistanceSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect two snap lines in parallel to the edge path of the label owner at the initial distance of the edge label.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance should collect this kind of snap lines; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.CollectSameOwnerEdgeDistanceSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect snap lines in parallel to the edge path of the label owner at the distances of all edge labels of that owner.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance should collect this kind of snap lines; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.CollectAllEdgeDistanceSnapLines">
      <summary>
        <para>Gets or sets whether this instance should collect snap lines in parallel to the edge path of the label owner at the distance of other edge labels in the graph.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance should collect this kind of snap lines; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>The default is <c>false</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.SnapNodeLabels">
      <summary>
        <para>Gets or sets whether this context will automatically snap the node labels to snap lines.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if node labels will snap to snap lines; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.SnapEdgeLabels">
      <summary>
        <para>Gets or sets whether this context will automatically snap the edge labels to snap lines.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels will snap to snap lines; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.SnapLineExtension">
      <summary>
        <para>Gets or sets the amount by which snap lines that are induced by existing edge segments are being extended.</para>
      </summary>
      <value>
        <para>The amount by which snap lines that are induced by existing edge segments are being extended.</para>
      </value>
      <remarks>
        <para>The default is <c>40.0d</c>, this value will be used to prolongate the ends of the snap lines.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelSnapContext.SnapLines">
      <summary>
        <para>Gets the collection of the <see cref="T:yWorks.Controls.Input.SnapLine">snap lines</see> that have been <see cref="M:yWorks.Controls.Input.LabelSnapContext.AddSnapLine(yWorks.Controls.Input.SnapLine)">added</see> to this context.</para>
      </summary>
      <remarks>
        <para>This collection is only available if <see cref="P:yWorks.Controls.Input.SnapContext.IsInitialized" /> is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.LabelSnapContext.AddSnapLine(yWorks.Controls.Input.SnapLine)" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContext.AddSnapLine(yWorks.Controls.Input.SnapLine)">
      <summary>
        <para>Adds the given <paramref name="snapLine" /> to the <see cref="P:yWorks.Controls.Input.LabelSnapContext.SnapLines">snap line</see> collection of this context.</para>
      </summary>
      <param name="snapLine">
        <para>The snap line to add.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.GraphSnapContext.AdditionalSnapLines" />
    </member>
    <member name="E:yWorks.Controls.Input.LabelSnapContext.CollectSnapLines">
      <summary>
        <para>Occurs every time this instance has been <see cref="M:yWorks.Controls.Input.SnapContext.DragInitialized">initialized</see> to collect <see cref="T:yWorks.Controls.Input.SnapLine" />s.</para>
      </summary>
      <remarks>
        <para>Event handlers should add snap lines to the caller using the methods provided by <see cref="T:yWorks.Controls.Input.CollectLabelSnapLineEventArgs" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContext.OnCollectSnapLines(yWorks.Controls.Input.CollectLabelSnapLineEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.LabelSnapContext.CollectSnapLines" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectLabelSnapLineEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContext.DragInitialized" />
    <member name="M:yWorks.Controls.Input.LabelSnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContext.HandleMove(yWorks.Geometry.PointD,System.Boolean)">
      <param name="newLocation" />
      <param name="snappingDisabled" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContext.DragFinished(yWorks.Geometry.PointD,System.Boolean)">
      <param name="newLocation" />
      <param name="snappingDisabled" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContext.CleanUp" />
    <member name="M:yWorks.Controls.Input.LabelSnapContext.WrapContext(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="T:yWorks.Controls.Input.CollectLabelSnapLineEventArgs">
      <summary>
        <para>The event arguments used by <see cref="T:yWorks.Controls.Input.LabelSnapContext" /> to collect custom snap lines for each drag.</para>
      </summary>
      <seealso cref="E:yWorks.Controls.Input.LabelSnapContext.CollectSnapLines" />
    </member>
    <member name="M:yWorks.Controls.Input.CollectLabelSnapLineEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext,System.Collections.Generic.ICollection{yWorks.Controls.Input.SnapLine})">
      <summary>
        <para>Creates a new instance of this class.</para>
      </summary>
      <param name="context">
        <para>The context this event is being used in.</para>
      </param>
      <param name="snapLines">
        <para>The snap lines collection to add to.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.CollectLabelSnapLineEventArgs.AddSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)">
      <summary>
        <para>Adds the given snap line to the snap line collection of this class.</para>
      </summary>
      <param name="snapLine">
        <para>the snap line to add.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.LabelSnapContextHelper">
      <summary>
        <para>The default label snap context helper that provides the snap lines and the snap results to the <see cref="T:yWorks.Controls.Input.LabelSnapContext" /> during dragging of labels.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.LabelSnapContext" />
      <seealso cref="P:yWorks.Graph.LabelDecorator.LabelSnapContextHelperDecorator" />
    </member>
    <member name="F:yWorks.Controls.Input.LabelSnapContextHelper.Instance">
      <summary>
        <para>Returns the static shared instance of this class.</para>
      </summary>
      <remarks>
        <para>Since this implementation does not carry any state, this instance can safely be used even in multi-threaded environments.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContextHelper.AddSnapLines(yWorks.Controls.Input.LabelSnapContext,yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)">
      <summary>
        <para>Called during <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">initialization</see> of a <paramref name="label" /> dragging to add <see cref="T:yWorks.Controls.Input.SnapLine">snap lines</see> to which the label can potentially snap to the <paramref name="snapContext" />.</para>
      </summary>
      <param name="snapContext">
        <para>The snap context which manages the snap lines and the settings. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="inputModeContext">
        <para>The context of the input mode that handles the dragging.</para>
      </param>
      <param name="label">
        <para>The label that is dragged.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContextHelper.AddInitialLocationSnapLines(yWorks.Controls.Input.LabelSnapContext,yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)">
      <summary>
        <para>Adds two snap line for the initial center location of the label, one in the direction of the up vector, the other orthogonal to that direction.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.LabelSnapContextHelper.AddSnapLines(yWorks.Controls.Input.LabelSnapContext,yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)" /> to add the snap lines for the initial position label location.</para>
      </remarks>
      <param name="snapContext">
        <para>The snap context which manages the snap lines and the settings. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="inputModeContext">
        <para>The context of the input mode that handles the dragging.</para>
      </param>
      <param name="label">
        <para>The label that is dragged.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContextHelper.AddNodeShapeSnapLines(yWorks.Controls.Input.LabelSnapContext,yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)">
      <summary>
        <para>Adds snap lines to the <paramref name="snapContext" /> that are parallel to the owner node's border at particular distances.</para>
      </summary>
      <remarks>
        <para>The corresponding settings of the <paramref name="snapContext" /> specify which snap lines are actually created.</para>
      </remarks>
      <param name="snapContext">
        <para>The snap context which manages the snap lines and the settings. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="inputModeContext">
        <para>The context of the input mode that handles the dragging.</para>
      </param>
      <param name="label">
        <para>The node label that is dragged.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContextHelper.AddEdgePathSnapLines(yWorks.Controls.Input.LabelSnapContext,yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)">
      <summary>
        <para>Adds snap lines to the <paramref name="snapContext" /> that are parallel to the path segments of the owner edge at particular distances.</para>
      </summary>
      <remarks>
        <para>The corresponding settings of the <paramref name="snapContext" /> specify which snap lines are actually created.</para>
      </remarks>
      <param name="snapContext">
        <para>The snap context which manages the snap lines and the settings. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="inputModeContext">
        <para>The context of the input mode that handles the dragging.</para>
      </param>
      <param name="label">
        <para>The edge label that is dragged.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContextHelper.AddEdgePathSnapLines(yWorks.Controls.Input.LabelSnapContext,yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel,System.Double)">
      <summary>
        <para>Adds snap lines to the <paramref name="snapContext" /> that are parallel to the path segments of the owner edge at the given distance.</para>
      </summary>
      <remarks>
        <para>This method is not used by this class to create its snap lines. Instead, it can be called by custom sub-classes to create this kind of snap lines.</para>
      </remarks>
      <param name="snapContext">
        <para>The snap context which manages the snap lines and the settings. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="inputModeContext">
        <para>The context of the input mode that handles the dragging.</para>
      </param>
      <param name="label">
        <para>The edge label that is dragged.</para>
      </param>
      <param name="distance">
        <para>The distance of the added snap lines from the edge path.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.LabelSnapContextHelper.CollectSnapResults(yWorks.Controls.Input.LabelSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.IOrientedRectangle,yWorks.Graph.ILabel)">
      <param name="context" />
      <param name="args" />
      <param name="suggestedLayout" />
      <param name="label" />
    </member>
    <member name="T:yWorks.Controls.Input.LabelTextValidatingEventArgs">
      <summary>
        <para>Event arguments for the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.ValidateLabelText" /> event.</para>
      </summary>
      <remarks>
        <para>Event handlers can set the <see cref="P:yWorks.Controls.Input.LabelTextValidatingEventArgs.Cancel" /> property to <c>true</c> to cancel label editing if validation failed, or set the <see cref="P:yWorks.Controls.Input.LabelTextValidatingEventArgs.NewText" /> property to a changed, validated value.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelTextValidatingEventArgs.Label">
      <summary>
        <para>Gets the label that is being edited.</para>
      </summary>
      <remarks>
        <para>Note that the label might not belong to a graph if it is a dummy for a label that is about to be created.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.LabelTextValidatingEventArgs.NewText">
      <summary>
        <para>Gets or sets the new text to use for the label.</para>
      </summary>
      <value>
        <para>The new text.</para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.LabelTextValidatingEventArgs.Cancel" />
    </member>
    <member name="M:yWorks.Controls.Input.LabelTextValidatingEventArgs.#ctor(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel,System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.LabelTextValidatingEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="label">
        <para>The label.</para>
      </param>
      <param name="newText">
        <para>The initial new text as entered by the user.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.LabelTextValidatingEventArgs.Cancel">
      <summary>
        <para>Gets or sets a value indicating whether the edit should be canceled.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the new text is not valid and should not be used for the edit; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.Input.MoveLabelInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> that can be used to drag a <see cref="T:yWorks.Graph.ILabel" /> in a <see cref="T:yWorks.Controls.GraphControl" />.</para>
      </summary>
      <remarks>
        <para>This implementation shows the possible candidate positions for a given label and allows the user to drag the label to one of these positions.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.MoveLabelInputMode.#ctor">
      <summary>
        <para>Creates a new instance that will move labels in the graph retrieved from the <see cref="P:yWorks.Controls.Input.MoveInputMode.InputModeContext" />.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.MoveLabelInputMode.Graph" />
    </member>
    <member name="M:yWorks.Controls.Input.MoveLabelInputMode.CreateLabelHitTestable">
      <summary>
        <para>Creates the hit testable that will be used to determine whether this mode may be activated.</para>
      </summary>
      <remarks>
        <para>This implementation returns an instance that delegates to <see cref="M:yWorks.Controls.Input.MoveLabelInputMode.IsValidLabelHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />.</para>
      </remarks>
      <returns>
        <para>A hit testable.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.MoveLabelInputMode.IsValidLabelHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Determines whether or not a valid label has been hit at the specified position.</para>
      </summary>
      <remarks>
        <para>This implementation calls <see cref="M:yWorks.Controls.Input.MoveLabelInputMode.GetHitLabel(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> to find the label at the specified location. If a label is hit, the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> is created by <see cref="M:yWorks.Controls.Input.MoveLabelInputMode.CreateLabelPositionHandler(yWorks.Graph.ILabel)" />.</para>
      </remarks>
      <param name="context">
        <para>The context for the hit test.</para>
      </param>
      <param name="location">
        <para>The coordinates for the hit test.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if a valid label is hit and the label moving should be started here. Otherwise, <c>false</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.MoveLabelInputMode.GetHitLabel(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Looks for a label that has been hit at the specified position.</para>
      </summary>
      <remarks>
        <para>This implementation checks the <see cref="P:yWorks.Controls.Input.MoveLabelInputMode.GraphSelection" /> to see if there is exactly one selected label. This label is returned if it is hit by the mouse and <see cref="M:yWorks.Controls.Input.MoveLabelInputMode.ShouldMove(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)" /> returns <c>true</c>. Otherwise, <c>null</c> is returned.</para>
      </remarks>
      <param name="context">
        <para>The context for the hit test.</para>
      </param>
      <param name="location">
        <para>The coordinates for the hit test.</para>
      </param>
      <returns>
        <para>The label hit at the given location or <c>null</c>.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.MoveLabelInputMode.IsValidLabelHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Controls.Input.MoveLabelInputMode.ShouldMove(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)" />
    </member>
    <member name="M:yWorks.Controls.Input.MoveLabelInputMode.ShouldMove(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILabel)">
      <summary>
        <para>Determines whether or not a label is allowed to be moved.</para>
      </summary>
      <remarks>
        <para>This implementation returns <c>false</c> if the parent input mode <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.ShouldMove(yWorks.Graph.IModelItem)">forbids</see> moving the label. Overriding implementations should query this implementation as base if this feature is desired.</para>
      </remarks>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="label">
        <para>The label to be checked.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the label is allowed to move.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.MoveLabelInputMode.GetHitLabel(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.Input.MoveLabelInputMode.CreateLabelPositionHandler(yWorks.Graph.ILabel)">
      <summary>
        <para>Creates the <see cref="T:yWorks.Controls.Input.IPositionHandler">position handler</see> for the given label used in <see cref="M:yWorks.Controls.Input.MoveLabelInputMode.IsValidLabelHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />.</para>
      </summary>
      <remarks>
        <para>First, this implementation checks for a position handler in the label's <see cref="T:yWorks.Graph.ILookup">lookup</see>. If this fails, it creates a new label position handler for the given label.</para>
      </remarks>
      <param name="label">
        <para>The label to create a position handler for.</para>
      </param>
      <returns>
        <para>A position handler for the given label.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.MoveLabelInputMode.OnDragStarting(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Registers the <see cref="P:yWorks.Controls.Input.MoveInputMode.PositionHandler" /> created during the last <see cref="M:yWorks.Controls.Input.MoveLabelInputMode.CreateLabelPositionHandler(yWorks.Graph.ILabel)" /> call.</para>
      </summary>
      <param name="inputModeEventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.MoveLabelInputMode.OnDragCanceled(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Clears the <see cref="P:yWorks.Controls.Input.MoveInputMode.PositionHandler" /> property.</para>
      </summary>
      <param name="inputModeEventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.MoveLabelInputMode.OnDragFinished(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Clears the <see cref="P:yWorks.Controls.Input.MoveInputMode.PositionHandler" /> property.</para>
      </summary>
      <param name="inputModeEventArgs" />
    </member>
    <member name="P:yWorks.Controls.Input.MoveLabelInputMode.UseLabelModelParameterFinder">
      <summary>
        <para>Gets or sets a value indicating whether or not using the <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder" /> to assign new label model parameters is allowed.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c></para>
        <para>This property has no effect if an <see cref="T:yWorks.Controls.Input.IPositionHandler" /> is available in the label's <see cref="T:yWorks.Graph.ILookup">lookup</see>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.MoveLabelInputMode.CreateLabelPositionHandler(yWorks.Graph.ILabel)" />
    </member>
    <member name="P:yWorks.Controls.Input.MoveLabelInputMode.MovedLabel">
      <summary>
        <para>Gets the label that is currently moved or <c>null</c> if there is no such label.</para>
      </summary>
      <remarks>
        <para>The value of this property is not <c>null</c> only if this mode is currently active and performs a move operation, that is between the <see cref="E:yWorks.Controls.Input.MoveInputMode.DragStarting" /> and the <see cref="E:yWorks.Controls.Input.MoveInputMode.DragFinished" /> event handlers.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.MoveLabelInputMode.GraphSelection">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.IGraphSelection" /> this mode is acting upon.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.MoveLabelInputMode.Graph">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.IGraph" /> this mode is acting upon.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.NavigationInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.IInputMode" /> that can <see cref="M:yWorks.Controls.Input.NavigationInputMode.MoveTo(yWorks.Controls.Input.MoveFocusDirection)">navigate</see> an <see cref="T:yWorks.Graph.IGraph" /> displayed in a <see cref="P:yWorks.Controls.Input.NavigationInputMode.GraphControl" />.</para>
      </summary>
      <remarks>
        <para>This mode is <see cref="P:yWorks.Controls.Input.NavigationInputMode.Exclusive" /> by default.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.Exclusive">
      <summary>
        <para>Gets or sets a value indicating whether this mode will be the only one running when it has the mutex.</para>
      </summary>
      <remarks>
        <para>The value of this property will be delegated to the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Exclusive" /> property of the <see cref="P:yWorks.Controls.Input.NavigationInputMode.Controller" />.</para>
        <para>If this mode is marked as exclusive and has the mutex, all other modes <see cref="M:yWorks.Controls.Input.MultiplexingInputMode.Add(yWorks.Controls.Input.IInputMode)">added</see> to the same <see cref="T:yWorks.Controls.Input.MultiplexingInputMode" /> will be deactivated. Otherwise it will always run concurrently with all other modes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.Enabled">
      <summary>
        <para>Gets or sets the enabled state of this input mode.</para>
      </summary>
      <remarks>
        <para>Clients can use this property to disable or reenable this instance. This will set the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Enabled">Enabled</see> property of the installed <see cref="P:yWorks.Controls.Input.NavigationInputMode.Controller" /> so a disabled instance should never try to acquire the input mutex.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.TryStop">
      <summary>
        <para>Overridden to only return <c>true</c> if this instance does not currently <see cref="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">have the input mutex</see>.</para>
      </summary>
      <returns>
        <para>
          <c>true</c> iff this instance does not <see cref="M:yWorks.Controls.Input.ConcurrencyController.HasMutex">own the mutex</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.Cancel" />
    <member name="P:yWorks.Controls.Input.NavigationInputMode.Controller">
      <summary>
        <para>Gets the installed <see cref="P:yWorks.Controls.Input.NavigationInputMode.Controller" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnConcurrencyControllerActivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been activated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnConcurrencyControllerDeactivated">
      <summary>
        <para>Called after the <see cref="P:yWorks.Controls.Input.ConcurrencyController.Active" /> property of the installed <see cref="T:yWorks.Controls.Input.ConcurrencyController" /> has been set to <c>false</c>.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been deactivated.</para>
        <para>Overriding implementations should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnStopped">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.NavigationInputMode.TryStop" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been stopped.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnCanceled">
      <summary>
        <para>Called after <see cref="M:yWorks.Controls.Input.NavigationInputMode.Cancel" /> has been called.</para>
      </summary>
      <remarks>
        <para>Can be overridden in subclasses to perform additional actions after the mode has been canceled.</para>
        <para>This implementation does nothing.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.NavigableItems">
      <summary>
        <para>Gets or sets the item types that can be navigated to by this mode.</para>
      </summary>
      <value>
        <para>The navigable items.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ShouldNavigateTo(yWorks.Graph.IModelItem)" />
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.SelectableItems">
      <summary>
        <para>Gets the types of the items that should be selectable by this instance.</para>
      </summary>
      <remarks>
        <para>The selectable items. The default value is <see cref="F:yWorks.Graph.GraphItemTypes.Node" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.AutoGroupNodeAlignmentPolicy">
      <summary>
        <para>Gets or sets the the location that should be kept fixed if toggling a group node state.</para>
      </summary>
      <remarks>
        <para>Default value is <see cref="F:yWorks.Controls.Input.NodeAlignmentPolicy.None" /></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ExpandGroup(yWorks.Graph.INode)" />
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.CollapseGroup(yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <summary>
        <para>Installs this mode into the given context that is provided by the canvas.</para>
      </summary>
      <remarks>
        <para>In general a mode can only be installed into a single canvas at all times.</para>
        <para>This method is called to initialize this instance. Subclasses should override this method to register the corresponding event handler delegates for the various input events they need to register with.</para>
        <para>Overriding implementations should call the base implementation, first.</para>
      </remarks>
      <param name="context">
        <para>The context that this instance shall be installed into. The same instance will be passed to this instance during <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />. A reference to the context may be kept and queried during the time the mode is installed.</para>
      </param>
      <param name="controller">
        <para>The <see cref="P:yWorks.Controls.Input.NavigationInputMode.Controller" /> for this mode.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Uninstalls this mode from the given context.</para>
      </summary>
      <remarks>
        <para>This code should clean up all changes made to the canvas in the <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> method. After a mode has been uninstalled it can be installed again into the same or another canvas.</para>
        <para>Overriding implementations should call the base implementation after their own code.</para>
      </remarks>
      <param name="context">
        <para>The context to deregister from. This is the same instance that had been passed to <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> during installation.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.GraphControl">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.NavigationInputMode.GraphControl" /> this mode acts on.</para>
      </summary>
      <value>
        <para>The <see cref="P:yWorks.Controls.Input.NavigationInputMode.GraphControl" />.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.NavigationInputMode" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.AvailableCommands">
      <summary>
        <para>Gets the list of commands that are available in this instance.</para>
      </summary>
      <remarks>
        <para>By default, all supported commands are available</para>
        <para>Removing commands from this collection also removes the command bindings registered by this instance.</para>
        <para>Add supported commands to make them available in this instance.</para>
        <para>Supported commands are</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveLeft" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveRight" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveUp" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveDown" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveToPageUp" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveToPageDown" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveFocusBack" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveFocusForward" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveFocusUp" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveFocusDown" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveFocusPageUp" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.MoveFocusPageDown" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ExtendSelectionLeft" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ExtendSelectionRight" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ExtendSelectionUp" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ExtendSelectionDown" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.SelectToPageUp" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.SelectToPageDown" />
          </item>
        </list>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.UseCurrentItemForCommands">
      <summary>
        <para>Gets or sets a value indicating whether to use the <see cref="P:yWorks.Controls.GraphControl.CurrentItem" /> as a fallback for the commands if no item is provided in the parameter and the current selection is empty.</para>
      </summary>
      <remarks>
        <para>This applies to the following commands:</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.EnterGroup" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ExpandGroup" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.CollapseGroup" />
          </item>
          <item>
            <see cref="F:yWorks.Controls.Input.Commands.ToggleExpansionState" />
          </item>
        </list>
      </remarks>
      <value>
        <para>
          <c>true</c> if the current item should be used as a fallback; <c>false</c> otherwise, which is the default.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.GraphSelection">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.IGraphSelection" /> this mode operates on.</para>
      </summary>
      <value>
        <para>The graph selection.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.Graph">
      <summary>
        <para>Gets or sets the graph this mode operates on.</para>
      </summary>
      <value>
        <para>The graph.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.EnterGroup(yWorks.Graph.INode)">
      <summary>
        <para>This method allows for entering a group node so that the currently displayed <see cref="T:yWorks.Graph.IFoldingView" />'s <see cref="P:yWorks.Graph.IFoldingView.LocalRoot" /> will be reset to the provided node.</para>
      </summary>
      <remarks>
        <para>It is possible to both use a local group node that is part of the currently displayed <see cref="P:yWorks.Controls.Input.NavigationInputMode.Graph" /> as the <paramref name="node" /> argument, as well as an item that belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> to allow for switching to group nodes which are currently not being displayed in this view.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ShouldEnterGroup(yWorks.Graph.INode)" />
      <seealso cref="P:yWorks.Controls.Input.NavigationInputMode.AllowEnterGroup" />
      <seealso cref="T:yWorks.Graph.FoldingManager" />
      <param name="node">
        <para>The node that needs to be either part of the current graph, or part of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.AdjustContentRect">
      <summary>
        <para>Callback that adjusts the <see cref="P:yWorks.Controls.CanvasControl.ContentRect" /> to encompass all elements.</para>
      </summary>
      <remarks>
        <para>This implementation will try to delegate to <see cref="M:yWorks.Controls.Input.GraphEditorInputMode.AdjustContentRect" /> if it can find the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> in the <see cref="P:yWorks.Controls.Input.NavigationInputMode.InputModeContext" />, otherwise the <see cref="F:yWorks.Controls.Input.Commands.FitGraphBounds" /> command is executed.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ExitGroup">
      <summary>
        <para>Exits the current <see cref="P:yWorks.Graph.IFoldingView.LocalRoot" /> of the currently displayed <see cref="T:yWorks.Graph.IFoldingView">view</see> and shows the contents of the parent container.</para>
      </summary>
      <remarks>
        <para>This method will also <see cref="M:yWorks.Controls.Input.GraphInputMode.ClearSelection">clear the selection</see> and <see cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)">select</see> the exited group node.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.FoldingManager" />
      <seealso cref="P:yWorks.Controls.Input.NavigationInputMode.AllowExitGroup" />
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ShouldExitGroup" />
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ShouldEnterGroup(yWorks.Graph.INode)">
      <summary>
        <para>Predicate method that decides whether it is allowed to <see cref="M:yWorks.Controls.Input.NavigationInputMode.EnterGroup(yWorks.Graph.INode)">enter</see> the specific group node.</para>
      </summary>
      <remarks>
        <para>This implementation yields the value of <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowEnterGroup" />.</para>
      </remarks>
      <param name="node">
        <para>The group node to enter.</para>
      </param>
      <returns>
        <para>Whether to enter the group or not.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.AllowEnterGroup">
      <summary>
        <para>Gets or sets a value that determines whether it is allowed to <see cref="M:yWorks.Controls.Input.NavigationInputMode.EnterGroup(yWorks.Graph.INode)">enter group nodes</see> via the <see cref="F:yWorks.Controls.Input.Commands.EnterGroup" />.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ShouldEnterGroup(yWorks.Graph.INode)" />
      <seealso cref="T:yWorks.Graph.FoldingManager" />
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.AllowCollapseGroup">
      <summary>
        <para>Gets or sets a value that determines whether it is allowed to collapse group nodes via the <see cref="F:yWorks.Controls.Input.Commands.CollapseGroup" />.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.CollapseGroup(yWorks.Graph.INode)" />
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ShouldCollapseGroup(yWorks.Graph.INode)" />
      <seealso cref="T:yWorks.Graph.FoldingManager" />
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.AllowExpandGroup">
      <summary>
        <para>Gets or sets a value that determines whether it is allowed to <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExpandGroup(yWorks.Graph.INode)">expand group nodes</see> via the <see cref="F:yWorks.Controls.Input.Commands.ExpandGroup" />.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ShouldExpandGroup(yWorks.Graph.INode)" />
      <seealso cref="T:yWorks.Graph.FoldingManager" />
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.AllowExitGroup">
      <summary>
        <para>Gets or sets a value that determines whether it is allowed to <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExitGroup">exit the current group node</see> via the <see cref="F:yWorks.Controls.Input.Commands.ExitGroup" />.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ShouldExitGroup" />
      <seealso cref="T:yWorks.Graph.FoldingManager" />
    </member>
    <member name="P:yWorks.Controls.Input.NavigationInputMode.FitContentAfterGroupActions">
      <summary>
        <para>Gets or sets a value that determines whether <see cref="M:yWorks.Controls.CanvasControl.FitContent" /> should be triggered after a group navigation action.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ShouldExitGroup">
      <summary>
        <para>Predicate method that decides whether it is allowed to <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExitGroup">exit</see> the current group node.</para>
      </summary>
      <remarks>
        <para>This implementation yields the value of <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowExitGroup" />.</para>
      </remarks>
      <returns>
        <para>Whether to exit the current group or not.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ExpandGroup(yWorks.Graph.INode)">
      <summary>
        <para>
          <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)">Expands</see> the given group node to show the contents of the collapsed group node in this <see cref="T:yWorks.Graph.IFoldingView" />.</para>
      </summary>
      <param name="groupNode">
        <para>The group node to expand</para>
      </param>
      <seealso cref="T:yWorks.Graph.FoldingManager" />
      <seealso cref="P:yWorks.Controls.Input.NavigationInputMode.AllowExpandGroup" />
    </member>
    <member name="E:yWorks.Controls.Input.NavigationInputMode.GroupCollapsing">
      <summary>
        <para>Occurs before a group will be <see cref="M:yWorks.Controls.Input.NavigationInputMode.CollapseGroup(yWorks.Graph.INode)">Collapsed</see>.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.NavigationInputMode.GroupCollapsed">
      <summary>
        <para>Occurs whenever a group has been <see cref="M:yWorks.Controls.Input.NavigationInputMode.CollapseGroup(yWorks.Graph.INode)">Collapsed</see>.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.NavigationInputMode.GroupExpanding">
      <summary>
        <para>Occurs before a group will be <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExpandGroup(yWorks.Graph.INode)">Expanded</see>.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.NavigationInputMode.GroupExpanded">
      <summary>
        <para>Occurs whenever a group has been <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExpandGroup(yWorks.Graph.INode)">Expanded</see>.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.NavigationInputMode.GroupEntering">
      <summary>
        <para>Occurs before a group will be <see cref="M:yWorks.Controls.Input.NavigationInputMode.EnterGroup(yWorks.Graph.INode)">Entered</see>.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.NavigationInputMode.GroupEntered">
      <summary>
        <para>Occurs whenever a group has been <see cref="M:yWorks.Controls.Input.NavigationInputMode.EnterGroup(yWorks.Graph.INode)">Entered</see>.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.NavigationInputMode.GroupExiting">
      <summary>
        <para>Occurs before a group will be <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExitGroup">Exited</see>.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.NavigationInputMode.GroupExited">
      <summary>
        <para>Occurs whenever a group has been <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExitGroup">Exited</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnGroupCollapsed(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.NavigationInputMode.GroupCollapsed" /> event.</para>
      </summary>
      <param name="argument">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnGroupExpanded(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.NavigationInputMode.GroupExpanded" /> event.</para>
      </summary>
      <param name="argument">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnGroupEntered(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.NavigationInputMode.GroupEntered" /> event.</para>
      </summary>
      <param name="argument">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnGroupExited(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.NavigationInputMode.GroupExited" /> event.</para>
      </summary>
      <param name="argument">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnGroupCollapsing(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.NavigationInputMode.GroupCollapsing" /> event.</para>
      </summary>
      <param name="argument">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnGroupExpanding(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.NavigationInputMode.GroupExpanding" /> event.</para>
      </summary>
      <param name="argument">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnGroupEntering(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.NavigationInputMode.GroupEntering" /> event.</para>
      </summary>
      <param name="argument">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.OnGroupExiting(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.NavigationInputMode.GroupExiting" /> event.</para>
      </summary>
      <param name="argument">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ShouldExpandGroup(yWorks.Graph.INode)">
      <summary>
        <para>Predicate method that decides whether it is allowed to <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExpandGroup(yWorks.Graph.INode)">expand</see> the given group node.</para>
      </summary>
      <remarks>
        <para>This implementation yields the value of <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowExpandGroup" />.</para>
      </remarks>
      <returns>
        <para>Whether to expand the given group or not.</para>
      </returns>
      <param name="node" />
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ShouldToggleExpansionState(yWorks.Graph.INode)">
      <summary>
        <para>Predicate method that decides whether it is allowed to <see cref="M:yWorks.Controls.Input.NavigationInputMode.ToggleExpansionState(yWorks.Graph.INode)">toggle</see> the collapsed state of the given group node.</para>
      </summary>
      <remarks>
        <para>This implementation uses <see cref="M:yWorks.Controls.Input.NavigationInputMode.ShouldExpandGroup(yWorks.Graph.INode)" /> and <see cref="M:yWorks.Controls.Input.NavigationInputMode.ShouldCollapseGroup(yWorks.Graph.INode)" /> respectively.</para>
      </remarks>
      <returns>
        <para>Whether to expand the given group or not.</para>
      </returns>
      <param name="node" />
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.CollapseSelection">
      <summary>
        <para>Performs <see cref="M:yWorks.Controls.Input.NavigationInputMode.CollapseGroup(yWorks.Graph.INode)" /> for all <see cref="P:yWorks.Controls.IGraphSelection.SelectedNodes" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ExpandSelection">
      <summary>
        <para>Performs <see cref="M:yWorks.Controls.Input.NavigationInputMode.ExpandGroup(yWorks.Graph.INode)" /> for all <see cref="P:yWorks.Controls.IGraphSelection.SelectedNodes" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.EnterSelectedGroup">
      <summary>
        <para>Performs <see cref="M:yWorks.Controls.Input.NavigationInputMode.EnterGroup(yWorks.Graph.INode)" /> for the first valid <see cref="P:yWorks.Controls.IGraphSelection.SelectedNodes" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.CollapseGroup(yWorks.Graph.INode)">
      <summary>
        <para>
          <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">Collapses</see> the given group node to hide the contents of the group node from this <see cref="T:yWorks.Graph.IFoldingView" />.</para>
      </summary>
      <param name="groupNode">
        <para>The group node to collapse.</para>
      </param>
      <seealso cref="T:yWorks.Graph.FoldingManager" />
      <seealso cref="P:yWorks.Controls.Input.NavigationInputMode.AllowCollapseGroup" />
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.AdjustGroupNodeLocation(System.Boolean,yWorks.Graph.INode)">
      <summary>
        <para>Adjust the group node location according to the value of <see cref="P:yWorks.Controls.Input.NavigationInputMode.AutoGroupNodeAlignmentPolicy" />.</para>
      </summary>
      <param name="collapse">
        <para>
          <c>true</c> iff the node has just been collapsed.</para>
      </param>
      <param name="groupNode">
        <para>The node that has changed its state.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ToggleExpansionState(yWorks.Graph.INode)">
      <summary>
        <para>Toggles the <see cref="M:yWorks.Graph.IFoldingView.IsExpanded(yWorks.Graph.INode)">expanded/collapsed</see> state for the given group node in the <see cref="T:yWorks.Graph.IFoldingView" />.</para>
      </summary>
      <param name="groupNode">
        <para>The group node to toggle the state for.</para>
      </param>
      <seealso cref="T:yWorks.Graph.FoldingManager" />
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ShouldCollapseGroup(yWorks.Graph.INode)">
      <summary>
        <para>Predicate method that decides whether it is allowed to <see cref="M:yWorks.Controls.Input.NavigationInputMode.CollapseGroup(yWorks.Graph.INode)">collapse</see> the given group node.</para>
      </summary>
      <remarks>
        <para>This implementation returns the value of <see cref="P:yWorks.Controls.Input.NavigationInputMode.AllowCollapseGroup" />.</para>
      </remarks>
      <returns>
        <para>Whether to collapse the given group or not.</para>
      </returns>
      <param name="groupNode" />
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.SetGraphControl(yWorks.Controls.GraphControl)">
      <summary>
        <para>Sets the <see cref="P:yWorks.Controls.Input.NavigationInputMode.GraphControl" /> to use for the various actions.</para>
      </summary>
      <remarks>
        <para>This will register or unregister the commands for the control. This method is called in response to <see cref="M:yWorks.Controls.Input.NavigationInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)" /> and <see cref="M:yWorks.Controls.Input.NavigationInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </remarks>
      <param name="graphControl">
        <para>The control to use or <c>null</c>.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.MoveTo(yWorks.Controls.Input.MoveFocusDirection)">
      <summary>
        <para>Moves the focus into the given direction, setting the selection to the new element.</para>
      </summary>
      <param name="direction">
        <para>The direction to move the focus and selection.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ExtendSelectionTo(yWorks.Controls.Input.MoveFocusDirection)">
      <summary>
        <para>Moves the focus into the given direction, extending the selection to the new element.</para>
      </summary>
      <param name="direction">
        <para>The direction to move the focus and extend the selection.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.MoveFocusTo(yWorks.Controls.Input.MoveFocusDirection)">
      <summary>
        <para>Moves the focus into the given direction, not changing the current selection.</para>
      </summary>
      <param name="direction">
        <para>The direction to move the focus.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.SetCurrentItem(yWorks.Controls.GraphControl,yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback that actually sets the current item property.</para>
      </summary>
      <param name="graphControl">
        <para>The <see cref="P:yWorks.Controls.Input.NavigationInputMode.GraphControl" /> to set the current item of.</para>
      </param>
      <param name="item">
        <para>The item to set.</para>
      </param>
      <returns>
        <para>Whether the operation was actually performed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.SetCurrentItem(yWorks.Graph.IModelItem)">
      <summary>
        <para>Sets the "current" item to the given one.</para>
      </summary>
      <param name="item">
        <para>The item to set as the current item.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.SetCurrentItem(yWorks.Controls.GraphControl,yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.SelectItem(yWorks.Controls.GraphControl,yWorks.Graph.IModelItem,System.Boolean)">
      <summary>
        <para>Callback that selects the given item.</para>
      </summary>
      <param name="graphControl">
        <para>The <see cref="P:yWorks.Controls.Input.NavigationInputMode.GraphControl" />.</para>
      </param>
      <param name="item">
        <para>The item to select.</para>
      </param>
      <param name="extendSelection">
        <para>if set to <c>true</c> the current selection is extended otherwise it is cleared beforehand.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ClearSelection" />
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.SelectCurrentItem">
      <summary>
        <para>Selects the <see cref="P:yWorks.Controls.GraphControl.CurrentItem" /> current item.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Controls.Input.NavigationInputMode.SelectItem(yWorks.Controls.GraphControl,yWorks.Graph.IModelItem,System.Boolean)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ClearSelection">
      <summary>
        <para>Clears the selection in the <see cref="P:yWorks.Controls.Input.NavigationInputMode.GraphControl" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ShouldNavigateTo(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback predicate method that determines whether a given model item should be navigated to.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.NavigationInputMode.NavigableItems" /> property to determine whether the <paramref name="item" /> can be navigated to.</para>
      </remarks>
      <param name="item">
        <para>The model item.</para>
      </param>
      <returns>
        <para>Whether the item should be considered for navigational commands.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.NavigationInputMode.ShouldSelect(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback predicate method that determines whether a given model item should be selected.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.NavigationInputMode.SelectableItems" /> property to determine whether the <paramref name="item" /> should be selected.</para>
      </remarks>
      <param name="item">
        <para>The model item.</para>
      </param>
      <returns>
        <para>Whether the item should be selected by the navigational commands.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.MoveFocusDirection">
      <summary>
        <para>Enumeration used by <see cref="T:yWorks.Controls.Input.NavigationInputMode" /> to determine the direction of the search for items to navigate to.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.NavigationInputMode" />
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.MoveTo(yWorks.Controls.Input.MoveFocusDirection)" />
    </member>
    <member name="F:yWorks.Controls.Input.MoveFocusDirection.None">
      <summary>
        <para>No direction.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveFocusDirection.Left">
      <summary>
        <para>In the direction of the negative x Axis.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveFocusDirection.Right">
      <summary>
        <para>In the direction of the positive x Axis.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveFocusDirection.Up">
      <summary>
        <para>In the direction of the negative y Axis.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveFocusDirection.Down">
      <summary>
        <para>In the direction of the positive y Axis.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveFocusDirection.Parent">
      <summary>
        <para>In the direction of the <see cref="M:yWorks.Graph.IGraph.SetParent(yWorks.Graph.INode,yWorks.Graph.INode)">parent</see> in the grouped graph.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MoveFocusDirection.Child">
      <summary>
        <para>In the direction of the <see cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)">children</see> in the grouped graph.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.NodeAlignmentPolicy">
      <summary>
        <para>Enumeration defining different node alignment policies for automatic node resizing operations.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.NavigationInputMode" />
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ExpandGroup(yWorks.Graph.INode)" />
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.CollapseGroup(yWorks.Graph.INode)" />
      <seealso cref="M:yWorks.Controls.Input.NavigationInputMode.ToggleExpansionState(yWorks.Graph.INode)" />
    </member>
    <member name="F:yWorks.Controls.Input.NodeAlignmentPolicy.None">
      <summary>
        <para>Don't fix any specific point.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeAlignmentPolicy.Center">
      <summary>
        <para>Fix the center point.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeAlignmentPolicy.TopLeft">
      <summary>
        <para>Fix the upper left corner.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeAlignmentPolicy.BottomLeft">
      <summary>
        <para>Fix the lower left corner.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeAlignmentPolicy.TopRight">
      <summary>
        <para>Fix the upper right corner.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeAlignmentPolicy.BottomRight">
      <summary>
        <para>Fix the lower right corner.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeAlignmentPolicy.TopCenter">
      <summary>
        <para>Fix the uppermost center.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeAlignmentPolicy.BottomCenter">
      <summary>
        <para>Fix the lowermost center.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeAlignmentPolicy.CenterLeft">
      <summary>
        <para>Fix the left center.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeAlignmentPolicy.CenterRight">
      <summary>
        <para>Fix the right center.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.NodeDropInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.ItemDropInputMode`1" /> specialized to drag'n'drop <see cref="T:yWorks.Graph.INode" />s.</para>
      </summary>
      <remarks>
        <para>A dragged <see cref="T:yWorks.Graph.INode" /> is visualized during the drag operation. The input mode does also support snapping of the dragged <see cref="T:yWorks.Graph.INode" /> via the <see cref="T:yWorks.Controls.Input.SnapContext" />. When the <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.DraggedItem">dragged node</see> is dropped, This mode can can drag nodes onto <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">group</see> and optional <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">folder nodes</see> and automatically add the node to the corresponding group node in the hierarchy. In this case the <see cref="P:yWorks.Controls.Input.NodeDropInputMode.IsValidParentPredicate" /> will be queried if the dropped upon node is actually a valid parent.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NodeDropInputMode.#ctor(System.String)">
      <summary>
        <para>Constructs a new instance of class <see cref="T:yWorks.Controls.Input.DropInputMode" /> for the expected data format.</para>
      </summary>
      <remarks>
        <para>Not used in this class. This constructor only exists for usage in child class.</para>
      </remarks>
      <param name="expectedDataFormat" />
    </member>
    <member name="M:yWorks.Controls.Input.NodeDropInputMode.#ctor(System.Type)">
      <summary>
        <para>Constructs a new instance of class <see cref="T:yWorks.Controls.Input.DropInputMode" /> for the expected data type.</para>
      </summary>
      <remarks>
        <para>Not used in this class since data type is always <see cref="T:yWorks.Graph.INode" />. This constructor only exists for usage in child class.</para>
      </remarks>
      <param name="expectedType" />
    </member>
    <member name="M:yWorks.Controls.Input.NodeDropInputMode.#ctor">
      <summary>
        <para>Constructs a new instance of class <see cref="T:yWorks.Controls.Input.NodeDropInputMode" /> for the type <see cref="T:yWorks.Graph.INode" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.NodeDropInputMode.IsGroupNodePredicate">
      <summary>
        <para>Gets or sets the callback for testing whether a <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.DraggedItem">dragged node</see> should be created as a <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">group node</see>.</para>
      </summary>
      <remarks>
        <para>The default implementation returns <c>false</c> always. Can be set to a different value to implement custom group node detection.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.NodeDropInputMode.IsValidParentPredicate">
      <summary>
        <para>Gets or sets the callback for testing whether an existing node in the graph can be used as a valid parent node in the context of grouping.</para>
      </summary>
      <remarks>
        <para>The default implementation returns <c>true</c> always. Can be set to a different value to implement custom group node detection. Note that the node passed to the predicate may be <c>null</c> to indicate that the node will be placed at the root of the hierarchy.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.NodeDropInputMode.AllowNonGroupNodeAsParent" />
      <seealso cref="P:yWorks.Controls.Input.NodeDropInputMode.AllowFolderNodeAsParent" />
    </member>
    <member name="M:yWorks.Controls.Input.NodeDropInputMode.AdjustEffect(System.Windows.Forms.DragEventArgs)">
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.Input.NodeDropInputMode.PopulatePreviewGraph(yWorks.Graph.IGraph)">
      <param name="previewGraph" />
    </member>
    <member name="M:yWorks.Controls.Input.NodeDropInputMode.CreateNode(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.IModelItem,yWorks.Geometry.RectD)">
      <summary>
        <para>Creates the node in the graph after it's been dropped.</para>
      </summary>
      <remarks>
        <para>This method is called by the <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.ItemCreator" /> that is set as default on this class.</para>
      </remarks>
      <param name="context">
        <para>The context for which the node should be created.</para>
      </param>
      <param name="graph">
        <para>The <see cref="T:yWorks.Graph.IGraph">Graph</see> in which to create the item.</para>
      </param>
      <param name="node">
        <para>The node that was dragged and should therefore be created.</para>
      </param>
      <param name="dropTarget">
        <para>The <see cref="T:yWorks.Graph.IModelItem" /> on which the node is dropped.</para>
      </param>
      <param name="layout">
        <para>The bounds of the new node.</para>
      </param>
      <returns>
        <para>a newly created node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.NodeDropInputMode.GetDropTarget(yWorks.Geometry.PointD)">
      <param name="dragLocation" />
    </member>
    <member name="P:yWorks.Controls.Input.NodeDropInputMode.AllowFolderNodeAsParent">
      <summary>
        <para>Gets or sets a value indicating whether nodes can be dropped on <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> folder nodes.</para>
      </summary>
      <remarks>
        <para>If this property is set to <c>true</c>, dropping nodes on collapsed folder nodes will create the node inside the folder node in the master graph. In that case the <see cref="E:yWorks.Controls.Input.ItemDropInputMode`1.ItemCreated" /> event will yield the node in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master graph</see>. The node will not be <see cref="M:yWorks.Graph.IGraph.Contains(yWorks.Graph.IModelItem)">contained</see> in the currently visible graph. By default this feature is disabled. In any case the <see cref="P:yWorks.Controls.Input.NodeDropInputMode.IsValidParentPredicate" /> will be queried additionally if the node is a valid parent.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if folder node parents are allowed; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.NodeDropInputMode.AllowNonGroupNodeAsParent">
      <summary>
        <para>Gets or sets a value indicating whether nodes can be dropped onto nodes that are no <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">group nodes</see>.</para>
      </summary>
      <remarks>
        <para>If this property is enabled, dropping a node on a non-group node will effectively convert the non-group node to a real group node. By default this feature is disabled. In any case the <see cref="P:yWorks.Controls.Input.NodeDropInputMode.IsValidParentPredicate" /> will be queried additionally if the node is a valid parent.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if non-group node parents are allowed as valid drop targets; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.NodeDropInputMode.UpdatePreview(yWorks.Graph.IGraph,yWorks.Geometry.PointD)">
      <param name="previewGraph" />
      <param name="dragLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.NodeDropInputMode.GetNodeLayout(yWorks.Geometry.PointD,yWorks.Geometry.SizeD)">
      <summary>
        <para>Calculates the layout of the new node.</para>
      </summary>
      <remarks>
        <para>In this implementation the mouse location is used as center of the node. Can be overridden in child class to implement a different layout.</para>
      </remarks>
      <param name="mouseLocation">
        <para>Current mouse position</para>
      </param>
      <param name="size">
        <para>Size of the node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Geometry.RectD" /> with the given size and the mouse location as center.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.NodeDropInputMode.CollectSnapResults(System.Object,yWorks.Controls.Input.CollectSnapResultsEventArgs)">
      <param name="source" />
      <param name="args" />
    </member>
    <member name="T:yWorks.Controls.Input.OrthogonalEdgeEditingContext">
      <summary>
        <para>A helper class that can be used to interactively reshape orthogonal edge paths.</para>
      </summary>
      <remarks>
        <para>This class will be queried from the <see cref="T:yWorks.Controls.Input.IInputModeContext" /> of implementations of <see cref="T:yWorks.Controls.Input.IPositionHandler" />, <see cref="T:yWorks.Controls.Input.IHandle" />, and <see cref="T:yWorks.Controls.Input.IReshapeHandler" /> that support orthogonal editing of edges.</para>
        <para>In a first step, the edit (which is a movement of one or more <see cref="T:yWorks.Graph.IPort" />s, <see cref="T:yWorks.Graph.IBend" />s, <see cref="T:yWorks.Graph.IEdge">edge ends</see>, or <see cref="T:yWorks.Graph.IPortOwner" />s) is being <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">initialized</see> before anything has been changed. Then, client code that seeks to modify the graph, uses the methods <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddExplicitlyMovedBend(yWorks.Controls.Input.MovementInfo)" />, <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddMovedEdgeEnd(yWorks.Controls.Input.MovementInfo,System.Boolean)" />, <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddMovedPort(yWorks.Controls.Input.MovementInfo)" />, and <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddTransformedPortOwner(yWorks.Graph.IPortOwner)" />. In the next step, the <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragInitialized">drag is being initialized</see> and all affected edges will be <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.PrepareEdgePaths(yWorks.Graph.IGraph)">prepared</see> so that the editing will not destroy the orthogonality. Interested editors now get the chance to register and negotiate <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddImplicitlyMovedBend(yWorks.Controls.Input.MovementInfo)">implicitly moved</see> bends. Then the actual editing is performed and the edit is either <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CancelDrag">canceled</see>, in which case the <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.RemoveAddedBends(yWorks.Graph.IGraph,System.Collections.Generic.IEnumerable{yWorks.Graph.IBend})">added bends are removed</see> or the edit is <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragFinished">finished</see> and the affected edges are being <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanUp">cleaned up</see>.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.IOrthogonalEdgeHelper" />
      <seealso cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Enabled" />
      <seealso cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.MovePorts" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.OrthogonalEdgeEditingContext" /> class that is initially <see cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Enabled" />.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanedUp">
      <summary>
        <para>Occurs when the recent edit operation has been cleaned up.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanUp" />
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.OnCleanedUp(yWorks.Controls.Input.InputModeEventArgs)" />
    </member>
    <member name="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initializing">
      <summary>
        <para>Occurs when the edit is about to be initialized.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.OnInitializing(yWorks.Controls.Input.InputModeEventArgs)" />
    </member>
    <member name="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initialized">
      <summary>
        <para>Occurs when the edit has been initialized.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragInitialized" />
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.OnInitialized(yWorks.Controls.Input.InputModeEventArgs)" />
    </member>
    <member name="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.IsInitializing">
      <summary>
        <para>Gets or sets a value indicating whether this instance is currently initializing.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance is <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initializing" /> but not yet <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initialized" />; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Enabled">
      <summary>
        <para>Gets or sets a value indicating whether orthogonal edge editing is enabled at all.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if orthogonal edge editing is enabled at all; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.IsOrthogonallyEditedEdge(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge)" />
      <seealso cref="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.ShouldEditOrthogonally(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge)" />
    </member>
    <member name="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.MovePorts">
      <summary>
        <para>Gets or sets a value indicating ports are allowed to be moved at all.</para>
      </summary>
      <value>
        <para>
          <c>true</c> (the default) if bends adjacent to ports should try to move the port to stay perpendicular to the bend, <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.ShouldMoveEndImplicitly(yWorks.Graph.IEdge,System.Boolean)" />
      <seealso cref="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.ShouldMoveEndImplicitly(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean)" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanUp">
      <summary>
        <para>Performs clean up procedures.</para>
      </summary>
      <remarks>
        <para>This is called in response to <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CancelDrag" /> and <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragFinished" /> as well as initially during <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Called by client code when a drag is started about to be started.</para>
      </summary>
      <remarks>
        <para>This code needs to be called before any of the <see cref="T:yWorks.Controls.Input.IDragHandler" /> implementations are initialized so that they can then register the items they are going to modify with this instance. After this method has been called, the handlers that perform the actual edit need to be initialized and as soon as this has been done, <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragInitialized" /> should be called.</para>
      </remarks>
      <param name="context">
        <para>The context in which the edit is going to be performed.</para>
      </param>
      <exception cref="T:System.InvalidOperationException">
        <para>If this context is already <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initialized" /> or currently <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initializing" />.</para>
      </exception>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragInitialized" />
    </member>
    <member name="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CurrentInputModeContext">
      <summary>
        <para>Gets the current input mode context that is in effect for the current edit.</para>
      </summary>
      <value>
        <para>The current input mode context, which is only available if this instance is <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initializing" /> or <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initialized" />.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.OnCleanedUp(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanedUp" /> event.</para>
      </summary>
      <param name="eventArgs">
        <para>The <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragFinished">
      <summary>
        <para>Called when a drag has been successfully finished.</para>
      </summary>
      <remarks>
        <para>This method will perform the necessary clean up and <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanupEdgePaths(yWorks.Graph.IGraph)">clean up edge paths</see>.</para>
      </remarks>
      <seealso cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanedUp" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanupEdgePaths(yWorks.Graph.IGraph)">
      <summary>
        <para>Called after a successfully <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragFinished">finished drag</see> to clean up artifacts of modified edges.</para>
      </summary>
      <param name="graph">
        <para>The graph.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanUpEdgePath(yWorks.Graph.IGraph,yWorks.Graph.IEdge)" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanUpEdgePath(yWorks.Graph.IGraph,yWorks.Graph.IEdge)">
      <summary>
        <para>Cleans up the edge's path after a successfully <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragFinished">finished drag</see>.</para>
      </summary>
      <remarks>
        <para>This implementations delegates to the <see cref="T:yWorks.Controls.Input.IOrthogonalEdgeHelper" />'s <see cref="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.CleanUpEdge(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.IEdge)" /> method.</para>
      </remarks>
      <param name="graph">
        <para>The graph in which the edge resides.</para>
      </param>
      <param name="edge">
        <para>The modified edge.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.GetOrthogonalEdgeHelper(yWorks.Graph.IEdge)" />
    </member>
    <member name="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.IsInitialized">
      <summary>
        <para>Gets or sets whether the context is initialized.</para>
      </summary>
      <remarks>
        <para>The context is initialized between the calls to <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> and <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragFinished" /> or <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CancelDrag" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CancelDrag">
      <summary>
        <para>Called by client edit code when a drag has been canceled.</para>
      </summary>
      <remarks>
        <para>Resets all internal state lists and sets <see cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.IsInitialized" /> back to <c>false</c>. Also <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.RemoveAddedBends(yWorks.Graph.IGraph,System.Collections.Generic.IEnumerable{yWorks.Graph.IBend})">temporarily added bends are removed</see> and <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CleanedUp" /> will be triggered.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.RemoveAddedBends(yWorks.Graph.IGraph,System.Collections.Generic.IEnumerable{yWorks.Graph.IBend})">
      <summary>
        <para>Removes previously <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.RegisterAddedBend(yWorks.Graph.IBend)">registered</see> added bends.</para>
      </summary>
      <param name="graph">
        <para>The graph to use for removing the bends.</para>
      </param>
      <param name="addedBends">
        <para>The added bends.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddedBends" />
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.RegisterAddedBend(yWorks.Graph.IBend)" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragInitialized">
      <summary>
        <para>Needs to be called by client editing code after <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" /> has been called and all <see cref="T:yWorks.Controls.Input.IDragHandler" />s have been initialized.</para>
      </summary>
      <remarks>
        <para>This method will update the <see cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.IsInitializing" /> and <see cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.IsInitialized" /> properties accordingly and will <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.PrepareEdgePaths(yWorks.Graph.IGraph)">prepare</see> the edge paths. Finally, the <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initialized" /> event is raised so that registered handlers can perform their post-initialization process.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.PrepareEdgePaths(yWorks.Graph.IGraph)">
      <summary>
        <para>Called during <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragInitialized" /> to prepare the edge paths for orthogonal editing.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains the edges to be edited.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.PrepareOrthogonalEdge(yWorks.Graph.IGraph,yWorks.Graph.IEdge,yWorks.Utils.IListEnumerable{yWorks.Controls.Input.SegmentOrientation},yWorks.Utils.IListEnumerable{yWorks.Controls.Input.MovementInfo})" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.PrepareOrthogonalEdge(yWorks.Graph.IGraph,yWorks.Graph.IEdge,yWorks.Utils.IListEnumerable{yWorks.Controls.Input.SegmentOrientation},yWorks.Utils.IListEnumerable{yWorks.Controls.Input.MovementInfo})">
      <summary>
        <para>Helper method that inspects and prepares an orthogonal edge for the upcoming edit process.</para>
      </summary>
      <remarks>
        <para>This method inspects an edge and possibly inserts new bends into an edge to assure that during editing the orthogonality won't be lost.</para>
      </remarks>
      <param name="graph">
        <para>The graph to use for modifying the bends.</para>
      </param>
      <param name="edge">
        <para>The edge to inspect.</para>
      </param>
      <param name="orientations">
        <para>The orientations of the segments - the array is of length (edge.Bends.Count + 1).</para>
      </param>
      <param name="infos">
        <para>The <see cref="T:yWorks.Controls.Input.MovementInfo" /> instances for the source end, the bends, and the target end. This array contains <see cref="T:yWorks.Controls.Input.MovementInfo" /> instances representing either edge ends or ports at the first and last position and <see cref="T:yWorks.Controls.Input.MovementInfo" />s or <c>null</c> entries for the bends. The length thus is (edge.Bends.Count + 2) and <c>null</c> entries indicate that there is no information about the movement (in case the bend will only be moved implicitly later, if at all).</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.RegisterAddedBend(yWorks.Graph.IBend)">
      <summary>
        <para>Can be used by subclasses during <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.PrepareOrthogonalEdge(yWorks.Graph.IGraph,yWorks.Graph.IEdge,yWorks.Utils.IListEnumerable{yWorks.Controls.Input.SegmentOrientation},yWorks.Utils.IListEnumerable{yWorks.Controls.Input.MovementInfo})" /> to register added bends that can later be <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.RemoveAddedBends(yWorks.Graph.IGraph,System.Collections.Generic.IEnumerable{yWorks.Graph.IBend})">removed</see> in case the operation is canceled.</para>
      </summary>
      <remarks>
        <para>This method will only record the addition of bends if this instance is <see cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.IsInitialized">initialized</see> or <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initializing">still initializing</see>.</para>
      </remarks>
      <param name="bend">
        <para>The bend that has been added to guarantee orthogonality.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddedBends">
      <summary>
        <para>Gets the previously <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.RegisterAddedBend(yWorks.Graph.IBend)">registered added</see> bends.</para>
      </summary>
      <value>
        <para>An enumerable over the bends that have been added previously using <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.RegisterAddedBend(yWorks.Graph.IBend)" />.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.GetMovementInfos(yWorks.Graph.IEdge)">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.Input.MovementInfo">movement infos</see> that describe the orthogonal path of the edge.</para>
      </summary>
      <param name="edge">
        <para>The edge to obtain the infos for.</para>
      </param>
      <returns>
        <para>An array that contains for the first entry the source end of the edge, then all bends and then as the final entry the target end of the edge. For the bends, this can be be <c>null</c> values if nothing is known about the bend, yet.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.OnInitialized(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initialized" /> event.</para>
      </summary>
      <param name="eventArgs">
        <para>The <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initialized" />
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.DragInitialized" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.OnInitializing(yWorks.Controls.Input.InputModeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initializing" /> event.</para>
      </summary>
      <param name="eventArgs">
        <para>The <see cref="T:yWorks.Controls.Input.InputModeEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="E:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Initializing" />
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.IsOrthogonallyEditedEdge(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback that can be used by <see cref="T:yWorks.Controls.Input.IDragHandler" />s and the like to determines whether the given edge is orthogonally edited edge in the specified input mode context.</para>
      </summary>
      <remarks>
        <para>This implementation will always yield <c>false</c> if it is <see cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Enabled">disabled</see>. Otherwise <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.GetOrthogonalEdgeHelper(yWorks.Graph.IEdge)" /> will be used to delegate the query to <see cref="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.ShouldEditOrthogonally(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge)" />.</para>
      </remarks>
      <param name="context">
        <para>The input mode context which is editing the edge.</para>
      </param>
      <param name="edge">
        <para>The edge that will be edited.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this edge should be orthogonally edited for the specified input mode context; <c>false</c> otherwise.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Enabled" />
      <seealso cref="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.ShouldEditOrthogonally(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge)" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.ShouldMoveEndImplicitly(yWorks.Graph.IEdge,System.Boolean)">
      <summary>
        <para>Callback that can be used by <see cref="T:yWorks.Controls.Input.IDragHandler" />s and the like to determines whether the specified end of the provided <paramref name="edge" /> should be moved implicitly.</para>
      </summary>
      <remarks>
        <para>If an item is next to the end of an edge and the last segment should be kept orthogonal, this may only be possible if the end of the edge is moved, too. This can be achieved by moving the edge to another <see cref="T:yWorks.Graph.IPort" />, or by moving the port instance itself. This depends on the implementation of the <see cref="T:yWorks.Controls.Input.IEdgePortHandleProvider" /> for the given edge. This implementation will delegate to the <see cref="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.ShouldMoveEndImplicitly(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean)" /> method of the <see cref="T:yWorks.Controls.Input.IOrthogonalEdgeHelper" /> instance returned by <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.GetOrthogonalEdgeHelper(yWorks.Graph.IEdge)" /> unless the side of the edge is connected to an <see cref="T:yWorks.Graph.IPortOwner" /> instance that is marked as <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddTransformedPortOwner(yWorks.Graph.IPortOwner)">transformed</see> during the edit.</para>
      </remarks>
      <param name="edge">
        <para>The edge for which it should be determined whether the edge end can be moved.</para>
      </param>
      <param name="sourceSide">
        <para>if set to <c>true</c> the source side of the end is queried, else the target side.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified side of the edge can be moved; <c>false</c> otherwise, in which case the segment should be split to maintain orthogonality.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.GetOrthogonalEdgeHelper(yWorks.Graph.IEdge)" />
      <seealso cref="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.ShouldMoveEndImplicitly(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean)" />
      <seealso cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.MovePorts" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.GetOrthogonalEdgeHelper(yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that gets the <see cref="T:yWorks.Controls.Input.IOrthogonalEdgeHelper" /> instance associated with the given edge.</para>
      </summary>
      <remarks>
        <para>This implementation obtains the helper instance from the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the edge.</para>
      </remarks>
      <param name="edge">
        <para>The edge to obtain the helper instance for.</para>
      </param>
      <returns>
        <para>The helper instance to use or <c>null</c>, in which case the default behavior will be used.</para>
      </returns>
      <seealso cref="T:yWorks.Controls.Input.OrthogonalEdgeHelper" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.GetSegmentOrientation(yWorks.Graph.IEdge,System.Int32)">
      <summary>
        <para>Gets the declared segment orientation for the provided segment at the given edge.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.GetOrthogonalEdgeHelper(yWorks.Graph.IEdge)">GetOrthogonalEdgeHelper()</see>.<see cref="M:yWorks.Controls.Input.IOrthogonalEdgeHelper.GetSegmentOrientation(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Int32)">GetSegmentOrientation</see> method to yield the orientation.</para>
      </remarks>
      <param name="edge">
        <para>The edge to determine the orientation of the segment.</para>
      </param>
      <param name="segmentIndex">
        <para>Index of the segment.</para>
      </param>
      <returns>
        <para>The orientation of the segment.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CreateImplicitlyMovedBendInfo(yWorks.Graph.IBend,yWorks.Controls.Input.MovementInfo,yWorks.Controls.Input.MovementInfo)">
      <summary>
        <para>Creates or obtains a previously created <see cref="T:yWorks.Controls.Input.MovementInfo" /> for the provided implicitly moved bend.</para>
      </summary>
      <remarks>
        <para>This method is queried by client <see cref="T:yWorks.Controls.Input.IDragHandler" /> implementations that have been initialized for the current edit that need to move adjacent bends implicitly. Implementations should pass as the parameters the movement information that controls the vertical or horizontal movement of the bend implicitly.</para>
      </remarks>
      <param name="bend">
        <para>The implicitly moved bend.</para>
      </param>
      <param name="verticalAdjacentInfo">
        <para>The movement info that implicitly constrains the vertical movement of the bend or <c>null</c>.</para>
      </param>
      <param name="horizontalAdjacentInfo">
        <para>The movement info that implicitly constrains the horizontal movement of the bend or <c>null</c>.</para>
      </param>
      <returns>
        <para>The info to be used by clients that requested it.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddExplicitlyMovedBend(yWorks.Controls.Input.MovementInfo)">
      <summary>
        <para>Registers the provided bend with this instance so that it will be considered explicitly moved for this edit.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Controls.Input.IDragHandler" /> implementations that are being used to explicitly move a bend during the edit should use this method to register their edit while they are being <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">initialized</see>.</para>
      </remarks>
      <param name="movementInfo">
        <para>The movement info that describes the movement of the bend.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddMovedPort(yWorks.Controls.Input.MovementInfo)">
      <summary>
        <para>Registers the provided port with this instance so that it will be considered explicitly moved for this edit.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Controls.Input.IDragHandler" /> implementations that are being used to explicitly move a bend during the edit should use this method to register their edit while they are being <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">initialized</see>.</para>
      </remarks>
      <param name="movementInfo">
        <para>The movement info that describes the movement of the port.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddImplicitlyMovedBend(yWorks.Controls.Input.MovementInfo)">
      <summary>
        <para>Registers the provided bend as being moved implicitly for this edit.</para>
      </summary>
      <remarks>
        <para>The instance will be returned by <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.CreateImplicitlyMovedBendInfo(yWorks.Graph.IBend,yWorks.Controls.Input.MovementInfo,yWorks.Controls.Input.MovementInfo)" /> and the <see cref="P:yWorks.Controls.Input.MovementInfo.MoveType" /> will be combined with the requested move type.</para>
      </remarks>
      <param name="movementInfo">
        <para>The movement info for the bend.</para>
      </param>
      <returns>
        <para>The info that has been registered with this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddMovedEdgeEnd(yWorks.Controls.Input.MovementInfo,System.Boolean)">
      <summary>
        <para>Registers the provided end of the edge with this instance so that it will be considered explicitly moved for this edit.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Controls.Input.IDragHandler" /> implementations that are being used to explicitly move the end of an edge during the edit should use this method to register their edit while they are being <see cref="M:yWorks.Controls.Input.IDragHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">initialized</see>.</para>
      </remarks>
      <param name="movementInfo">
        <para>The movement info that describes the movement of the end of the edge. The <see cref="P:yWorks.Controls.Input.MovementInfo.MovedItem" /> must be an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </param>
      <param name="sourceEnd">
        <para>
          <c>true</c> if the <paramref name="movementInfo" /> represents the source end of the edge.</para>
      </param>
      <seealso cref="T:yWorks.Controls.Input.IEdgePortHandleProvider" />
    </member>
    <member name="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.TransformedPortOwners">
      <summary>
        <para>Gets the enumeration of <see cref="T:yWorks.Graph.IPortOwner" /> instances that are being transformed during the edit.</para>
      </summary>
      <remarks>
        <para>For elements in the enumerable the attached <see cref="P:yWorks.Graph.IPortOwner.Ports" /> are considered to be moved in an irregular way during the edit.</para>
      </remarks>
      <value>
        <para>The transformed port owners.</para>
      </value>
      <seealso cref="F:yWorks.Controls.Input.MoveTypes.ArbitraryMove" />
    </member>
    <member name="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.LockedPortEdges">
      <summary>
        <para>Gets the enumeration of <see cref="T:yWorks.Graph.IEdge" /> instances whose ports have been locked at source and target end.</para>
      </summary>
      <remarks>
        <para>For elements in the enumerable the end points should not be moved and thus <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.ShouldMoveEndImplicitly(yWorks.Graph.IEdge,System.Boolean)" /> returns false for these edges. Note that this collection is reset for each edit.</para>
      </remarks>
      <value>
        <para>The transformed port owners.</para>
      </value>
      <seealso cref="F:yWorks.Controls.Input.MoveTypes.ArbitraryMove" />
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddTransformedPortOwner(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Adds an <see cref="T:yWorks.Graph.IPortOwner" /> that is being transformed somehow during the edit so that the attached <see cref="P:yWorks.Graph.IPortOwner.Ports">ports</see> will be moved in an irregular (<see cref="F:yWorks.Controls.Input.MoveTypes.ArbitraryMove">non-linear</see>) way.</para>
      </summary>
      <remarks>
        <para>Normally this will be nodes that are being resized or moved in a non-linear way, or edges, whose bends or ports are being changed.</para>
      </remarks>
      <param name="owner">
        <para>The item that will be transformed.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.LockPortMovement(yWorks.Graph.IEdge)">
      <summary>
        <para>Locks the movement of the ports of the edges so that <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.ShouldMoveEndImplicitly(yWorks.Graph.IEdge,System.Boolean)" /> will yield <c>false</c> for the provided edge during the current edit.</para>
      </summary>
      <remarks>
        <para>This state will be reset after the current edit.</para>
      </remarks>
      <param name="edge">
        <para>The edge to lock the ports of.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.LockedPortEdges" />
    </member>
    <member name="T:yWorks.Controls.Input.OrthogonalEdgeEditingPolicy">
      <summary>
        <para>Enumeration defining different policies to enable or disable some aspects of creation or editing of orthogonal edges.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.CreateEdgeInputMode.OrthogonalEdgeCreation" />
      <seealso cref="P:yWorks.Controls.Input.GraphEditorInputMode.OrthogonalBendRemoval" />
    </member>
    <member name="F:yWorks.Controls.Input.OrthogonalEdgeEditingPolicy.Auto">
      <summary>
        <para>Enables orthogonal edge creation or editing for a specific sub-aspect automatically if an <see cref="P:yWorks.Controls.Input.OrthogonalEdgeEditingContext.Enabled" /> <see cref="T:yWorks.Controls.Input.OrthogonalEdgeEditingContext" /> instance is set in the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.OrthogonalEdgeEditingContext">parent input mode</see>.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.OrthogonalEdgeEditingPolicy.Always">
      <summary>
        <para>Enables orthogonal edge creation or editing for a specific sub-aspect of edge creation.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.OrthogonalEdgeEditingPolicy.Never">
      <summary>
        <para>Disables orthogonal edge creation or editing for a specific sub-aspect of edge creation.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.OrthogonalEdgeHelper">
      <summary>
        <para>Default implementation of the <see cref="T:yWorks.Controls.Input.IOrthogonalEdgeHelper" /></para>
      </summary>
      <remarks>
        <para>This class inspects the edges in question and infers the <see cref="T:yWorks.Controls.Input.SegmentOrientation" />s of the segments from the current geometry of the edge path.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeHelper.GetSegmentOrientation(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Int32)">
      <summary>
        <para>Gets the orientation of the given segment by looking at the geometry of the segment.</para>
      </summary>
      <remarks>
        <para>If the segment has a zero length, the adjacent segments will be inspected to infer the orientation such that the orientation toggles between <see cref="F:yWorks.Controls.Input.SegmentOrientation.Vertical" /> and <see cref="F:yWorks.Controls.Input.SegmentOrientation.Horizontal" />.</para>
      </remarks>
      <param name="context">
        <para>The input mode context in which the orientation is needed.</para>
      </param>
      <param name="edge">
        <para>The edge to inspect.</para>
      </param>
      <param name="segmentIndex">
        <para>The index of the segment.</para>
      </param>
      <returns>
        <para>The declared orientation of the segment.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeHelper.ShouldMoveEndImplicitly(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean)">
      <summary>
        <para>Determines whether this end of the provided edge can be moved in the input mode context.</para>
      </summary>
      <remarks>
        <para>This information is required to determine whether an edge's first or last segment needs to be split or the adjacent edge end can be moved along with the other end of the segment.</para>
        <para>The default implementation in this class always returns <c>false</c>.</para>
      </remarks>
      <param name="context">
        <para>The input mode context in which the segment is edited.</para>
      </param>
      <param name="edge">
        <para>The edge to inspect.</para>
      </param>
      <param name="sourceEnd">
        <para>if set to <c>true</c> the source end of the edge is queried, otherwise the target end.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the end of the edge can be moved for the specified input mode context; <c>false</c> otherwise, in which case the corresponding segment needs to be split to keep the segment orientation orthogonal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeHelper.ShouldEditOrthogonally(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge)">
      <summary>
        <para>Determines whether the provided edge should be edited orthogonally in the specified input mode context.</para>
      </summary>
      <remarks>
        <para>If this method returns <c>false</c>, the other methods will not be queried at all.</para>
        <para>The default implementation in this class always returns <c>true</c>.</para>
      </remarks>
      <param name="context">
        <para>The input mode context in which the edge is about to be edited.</para>
      </param>
      <param name="edge">
        <para>The edge to inspect.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge should be orthogonally edited in the specified input mode context; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeHelper.CleanUpEdge(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that is invoked after the provided edge has been edited orthogonally.</para>
      </summary>
      <remarks>
        <para>The default implementation in this class removes duplicate and collinear bends, as well as segments of zero length.</para>
      </remarks>
      <param name="context">
        <para>The input mode context which edited the edge.</para>
      </param>
      <param name="graph">
        <para>The graph to use for modifying the edge instance.</para>
      </param>
      <param name="edge">
        <para>The edge to clean up the path.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalEdgeHelper.CanRemoveBend(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IBend)">
      <summary>
        <para>Returns whether the given bend can be removed.</para>
      </summary>
      <remarks>
        <para>This implementation always returns <c>true</c>.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="bend">
        <para>The bend that is designated for removal.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.PortLocationModelParameterHandle">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.Controls.Input.IHandle" /> that can be used to move an <see cref="T:yWorks.Graph.IPort" /> interactively by assigning new <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" />s to the <see cref="P:yWorks.Graph.IPort.LocationParameter" /></para>
      </summary>
      <remarks>
        <para>This class also provides snapping facilities and can be used in conjunction with both <see cref="T:yWorks.Controls.Input.OrthogonalEdgeEditingContext" />, as well as <see cref="T:yWorks.Controls.Input.GraphSnapContext" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.PortLocationModelParameterHandle.#ctor(yWorks.Graph.IPort)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.PortLocationModelParameterHandle" /> class to change the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> of the given <paramref name="port" /></para>
      </summary>
      <param name="port">
        <para>The port to adjust the location parameter of.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.PortLocationModelParameterHandle.Port">
      <summary>
        <para>Gets the port this instance acts on.</para>
      </summary>
      <value>
        <para>The port.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.PortLocationModelParameterHandle.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.PortLocationModelParameterHandle.GetGraph(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Gets the graph to use for <see cref="M:yWorks.Graph.IGraph.SetPortLocationParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">setting the parameter</see> from the context.</para>
      </summary>
      <param name="context">
        <para>The input mode context to use.</para>
      </param>
      <returns>
        <para>The graph or <c>null</c> if the graph could not be obtained.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphExtensions.GetGraph(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.PortLocationModelParameterHandle.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.PortLocationModelParameterHandle.SetParameter(yWorks.Graph.IGraph,yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <summary>
        <para>Callback method that applies the parameter.</para>
      </summary>
      <param name="graph">
        <para>The graph to use for applying.</para>
      </param>
      <param name="port">
        <para>The port to apply the parameter to.</para>
      </param>
      <param name="locationParameter">
        <para>The new parameter to apply.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortLocationModelParameterHandle.GetNewParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModel,yWorks.Geometry.PointD)">
      <summary>
        <para>Callback method that obtains the new parameter for the given location and port.</para>
      </summary>
      <param name="port">
        <para>The port to obtain a parameter for.</para>
      </param>
      <param name="model">
        <para>The model to use.</para>
      </param>
      <param name="location">
        <para>The new location.</para>
      </param>
      <returns>
        <para>The new parameter to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.PortLocationModelParameterHandle.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.PortLocationModelParameterHandle.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="P:yWorks.Controls.Input.PortLocationModelParameterHandle.Type">
      <summary>
        <para>Gets or sets the type of the handle that can be used by the rendering engine to render types differently.</para>
      </summary>
      <value>
        <para>The type for rendering.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.PortLocationModelParameterHandle.Cursor">
      <summary>
        <para>Gets or sets the cursor to display when the mouse hovers over or drags this handle.</para>
      </summary>
      <value>
        <para>The cursor to display.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.PortLocationModelParameterHandle.GetMoveType(yWorks.Graph.IPort)">
      <summary>
        <para>Determines the type of the movement for the given port.</para>
      </summary>
      <remarks>
        <para>This is used for the <see cref="T:yWorks.Controls.Input.MovementInfo" /> that is passed to the <see cref="M:yWorks.Controls.Input.OrthogonalEdgeEditingContext.AddMovedPort(yWorks.Controls.Input.MovementInfo)" /> method.</para>
      </remarks>
      <param name="port">
        <para>The port to determine the move type for.</para>
      </param>
      <returns>
        <para>This implementation returns <see cref="F:yWorks.Controls.Input.MoveTypes.LinearMove" /> for models of type <see cref="T:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel" /> and <see cref="F:yWorks.Controls.Input.MoveTypes.ArbitraryMove" /> for all others.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.PortLocationModelParameterHandle.CollectSnapResults(System.Object,yWorks.Controls.Input.CollectSnapResultsEventArgs)">
      <summary>
        <para>Called during the drag to collect snap results.</para>
      </summary>
      <remarks>
        <para>This implementation will delegate to the <see cref="T:yWorks.Controls.Input.IPortSnapResultProvider" /> that has been received from the port this instance is bound to.</para>
      </remarks>
      <param name="source">
        <para>The source of the event.</para>
      </param>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectSnapResultsEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.ReparentNodeHandler">
      <summary>
        <para>Simple default implementation of <see cref="T:yWorks.Controls.Input.IReparentNodeHandler" /> that treats shift key presses as reparent gestures and allows for reparenting all nodes.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.ReparentNodeHandler.ReparentRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that will be queried to determine whether the gesture is a reparent gesture.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.ShiftPressed" /></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.ReparentNodeHandler.IsReparentGesture(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentNodeHandler.IsReparentGesture(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode)">
      <param name="context" />
      <param name="node" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentNodeHandler.ShouldReparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode)">
      <param name="context" />
      <param name="node" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentNodeHandler.IsValidParent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Graph.INode)">
      <param name="context" />
      <param name="node" />
      <param name="newParent" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentNodeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Graph.INode)">
      <param name="context" />
      <param name="node" />
      <param name="newParent" />
    </member>
    <member name="T:yWorks.Controls.Input.ReparentStripeInputMode">
      <summary>
        <para>Specialized input mode that is used to reparent a stripe inside an <see cref="T:yWorks.Graph.ITable" /> structure.</para>
      </summary>
      <remarks>
        <para>This implementation delegates most work to an instance of <see cref="T:yWorks.Controls.Input.ReparentStripePositionHandler" /></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripeInputMode.OnDragCanceled(yWorks.Controls.Input.InputModeEventArgs)">
      <param name="inputModeEventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripeInputMode.OnDragStarting(yWorks.Controls.Input.InputModeEventArgs)">
      <param name="inputModeEventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripeInputMode.OnDragFinished(yWorks.Controls.Input.InputModeEventArgs)">
      <param name="inputModeEventArgs" />
    </member>
    <member name="T:yWorks.Controls.Input.ReparentStripePositionHandler">
      <summary>
        <para>Customized <see cref="T:yWorks.Controls.Input.IPositionHandler" /> implementation that moves a stripe in the table hierarchy when the stripe is dragged.</para>
      </summary>
      <remarks>
        <para>This class is used by default by both <see cref="T:yWorks.Controls.Input.ReparentStripeInputMode" /> and <see cref="T:yWorks.Controls.Input.StripeDropInputMode" /> to perform the actual reparenting and insertion.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.#ctor(yWorks.Graph.IStripe)">
      <summary>
        <para>Creates a new instance of this position handler which moves <paramref name="movedStripe" /></para>
      </summary>
      <param name="movedStripe" />
    </member>
    <member name="P:yWorks.Controls.Input.ReparentStripePositionHandler.MovedStripe">
      <summary>
        <para>Allows to query the moved stripe.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.CreateTargetGhostVisualization(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe)">
      <summary>
        <para>Create a visualization for the target region of the reparent gesture.</para>
      </summary>
      <remarks>
        <para>The default implementation uses the return value of <see cref="M:yWorks.Controls.Input.IStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)" /> with type <see cref="F:yWorks.Controls.Input.StripeVisualizationType.DropTarget" />.</para>
      </remarks>
      <param name="context">
        <para>The current input mode context</para>
      </param>
      <param name="stripe">
        <para>The stripe for which the visualization should be created.</para>
      </param>
      <returns>
        <para>A canvas object that is used to visualize the target region.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.ReparentStripePositionHandler.UpdateTargetVisualization(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.ICanvasObject,yWorks.Graph.IStripe,yWorks.Controls.Input.StripeReparentPolicy,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.CreateSourceGhostVisualization(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Create a visualization for the source region of the reparent gesture.</para>
      </summary>
      <remarks>
        <para>The default implementation uses the return value of <see cref="M:yWorks.Controls.Input.IStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)" /> with type <see cref="F:yWorks.Controls.Input.StripeVisualizationType.DragSource" />.</para>
      </remarks>
      <param name="context">
        <para>The current input mode context</para>
      </param>
      <returns>
        <para>A canvas object that is used to visualize the target region.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.ReparentStripePositionHandler.UpdateSourceVisualization(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.ICanvasObject,yWorks.Graph.IStripe,yWorks.Controls.Input.StripeReparentPolicy)" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.UpdateTargetVisualization(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.ICanvasObject,yWorks.Graph.IStripe,yWorks.Controls.Input.StripeReparentPolicy,yWorks.Geometry.RectD)">
      <summary>
        <para>Modifies the target visualization itself.</para>
      </summary>
      <remarks>
        <para>The default implementation only hides <paramref name="targetVisualization" /> iff <paramref name="reparentPosition" /> is <see cref="F:yWorks.Controls.Input.StripeReparentPolicy.Invalid" />.</para>
      </remarks>
      <param name="context">
        <para>The current input mode context.</para>
      </param>
      <param name="targetVisualization">
        <para>The canvas object for the target visualization.</para>
      </param>
      <param name="targetStripe">
        <para>The target for the reparent gesture.</para>
      </param>
      <param name="reparentPosition">
        <para>The mode the describes the results of the reparent gesture.</para>
      </param>
      <param name="targetBounds">
        <para>The current visualization bounds that have been computed with <see cref="M:yWorks.Controls.Input.ReparentStripePositionHandler.UpdateTargetVisualizationBounds(yWorks.Geometry.RectD,yWorks.Controls.Input.StripeReparentPolicy,yWorks.Graph.IStripe)" /></para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.UpdateSourceVisualization(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.ICanvasObject,yWorks.Graph.IStripe,yWorks.Controls.Input.StripeReparentPolicy)">
      <summary>
        <para>Modifies the source visualization itself</para>
      </summary>
      <remarks>
        <para>The default does not change <paramref name="targetVisualization" />.</para>
      </remarks>
      <param name="context">
        <para>The current input mode context.</para>
      </param>
      <param name="targetVisualization">
        <para>The canvas object for the target visualization</para>
      </param>
      <param name="targetStripe">
        <para>The target for the reparent gesture</para>
      </param>
      <param name="reparentPosition">
        <para>Where to place the stripe after reparenting.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.GetTargetSubregion(yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the target stripe subregion at <paramref name="location" /> and its associated owner node.</para>
      </summary>
      <param name="location">
        <para>The hit location.</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Controls.Input.StripeSubregion" /> that lies at <paramref name="location" />, or null if no such region could be found.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.UpdateTargetVisualizationBounds(yWorks.Geometry.RectD,yWorks.Controls.Input.StripeReparentPolicy,yWorks.Graph.IStripe)">
      <summary>
        <para>Updates the visualization bounds for the target visualization depending on the provided values.</para>
      </summary>
      <param name="originalTargetBounds">
        <para>The target bounds prior to this method call.</para>
      </param>
      <param name="reparentPosition">
        <para>Where to place the stripe after the reparenting operations according to the reparent gesture.</para>
      </param>
      <param name="targetStripe">
        <para>The target stripe which has been determined by the input mode.</para>
      </param>
      <returns>
        <para>Updated bounds for the target visualization.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.DetermineGesture(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.IPoint,yWorks.Graph.IStripe,yWorks.Controls.Input.StripeSubregion,yWorks.Geometry.RectD)">
      <summary>
        <para>Determine the reparent gesture that would result from the given parameters.</para>
      </summary>
      <remarks>
        <para>The target region has already been determined by <see cref="M:yWorks.Controls.Input.ReparentStripePositionHandler.GetTargetSubregion(yWorks.Geometry.PointD)" /></para>
      </remarks>
      <param name="context">
        <para>The current input mode context</para>
      </param>
      <param name="location">
        <para>The current drag location</para>
      </param>
      <param name="sourceStripe">
        <para>The stripe that is moved</para>
      </param>
      <param name="targetSubregion">
        <para>The stripe subregion for the target.</para>
      </param>
      <param name="targetBounds">
        <para>The target bounds</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Controls.Input.StripeReparentPolicy" /> that specifies the operation to perform.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="P:yWorks.Controls.Input.ReparentStripePositionHandler.InputModeContext">
      <summary>
        <para>Gets the current <see cref="T:yWorks.Controls.Input.IInputModeContext" /></para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.SetPosition(yWorks.Geometry.PointD)">
      <summary>
        <para>Called by clients to set the position to the given coordinates.</para>
      </summary>
      <param name="location">
        <para>The new location.</para>
      </param>
      <seealso cref="P:yWorks.Controls.Input.IDragHandler.Location" />
    </member>
    <member name="M:yWorks.Controls.Input.ReparentStripePositionHandler.OnStripeChanged(yWorks.Graph.StripeEventArgs)">
      <summary>
        <para>Called whenever a change in the oldTable hierarchy occurs through this position handler</para>
      </summary>
      <param name="args" />
    </member>
    <member name="E:yWorks.Controls.Input.ReparentStripePositionHandler.StripeChanged">
      <summary>
        <para>Occurs when a stripe state is changed by this input mode.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.SegmentOrientation">
      <summary>
        <para>Enumeration for possible orientations of a segment in a (partially) orthogonal edge routing.</para>
      </summary>
      <remarks>
        <para>This class is mainly used by <see cref="T:yWorks.Controls.Input.IOrthogonalEdgeHelper" /> and <see cref="T:yWorks.Controls.Input.OrthogonalEdgeEditingContext" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.SegmentOrientation.Horizontal">
      <summary>
        <para>The segment has a horizontal orientation, which means that the end points should be moved vertically in synch so that the orientation is not destroyed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SegmentOrientation.Vertical">
      <summary>
        <para>The segment has a vertical orientation, which means that the end points should be moved horizontally in synch so that the orientation is not destroyed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SegmentOrientation.NonOrthogonal">
      <summary>
        <para>The segment does not need to be treated especially, both endpoints can be moved independently from each other.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.SnapLine">
      <summary>
        <para>A snap line is a line segment in the world coordinate system to which other items (lines or points) snap during interactive movements.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> and <see cref="T:yWorks.Controls.Input.LabelSnapContext" /> make use of this class to interactively snap moving elements to snap lines.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineFixedLineKey">
      <summary>
        <para>Resource key which determines a snap line having a fixed visualization independent of the <see cref="T:yWorks.Controls.Input.SnapResult" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineEdgeSegmentKey">
      <summary>
        <para>Resource key which determines a snap line with three special locations, for example the start, end and center of an edge segment.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.GridLineFixedLineKey">
      <summary>
        <para>Resource key which determines a grid snap line having a fixed visualization independent of the <see cref="T:yWorks.Controls.Input.SnapResult" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineVariableLineKey">
      <summary>
        <para>Resource key which determines a decorated snap line between the <see cref="P:yWorks.Controls.Input.SnapLine.Coordinates" /> and the snapped coordinates.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineBlankVariableLineKey">
      <summary>
        <para>Resource key which determines a blank line between the <see cref="P:yWorks.Controls.Input.SnapLine.Coordinates" /> and the snapped coordinates.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineExtendedVariableLineKey">
      <summary>
        <para>Resource key which determines a decorated line between the <see cref="P:yWorks.Controls.Input.SnapLine.Coordinates" /> and the snapped coordinates that is extended on both sides.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineFixedDistanceKey">
      <summary>
        <para>Resource key which determines a snap line which lets an item snap in a defined distance to another graph item.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineCenterBetweenBoundsKey">
      <summary>
        <para>Resource key which determines a snap line which lets an item snap in the center between the bounds of two other items.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineCenterBetweenCentersKey">
      <summary>
        <para>Resource key which determines a snap line which lets an item snap in the center between the centers of two other items.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineEqualDistanceBetweenBoundsKey">
      <summary>
        <para>Resource key which determines a snap line which lets an item snap if it has an equal distance to two other items.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineEqualDistanceBetweenCentersKey">
      <summary>
        <para>Resource key which determines a snap line which lets an item snap if it's center has an equal distance to the centers' of two other items.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineEqualWidthKey">
      <summary>
        <para>Resource key which determines the snapping of a resized item if it's new width is equal to another item.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineEqualHeightKey">
      <summary>
        <para>Resource key which determines the snapping of a resized item if it's new height is equal to another item.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapToGridKey">
      <summary>
        <para>Resource key which determines the snapping of an item to a grid position.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLinePenKey">
      <summary>
        <para>Resource key which determines the <see cref="T:System.Drawing.Pen" /> used for the snap line visualization.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLine.SnapLineColorKey">
      <summary>
        <para>Resource key which determines the <see cref="T:System.Drawing.Color" /> used for the snap line visualization.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.SnapLine.#ctor(yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Controls.ResourceKey,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Object,System.Double)">
      <summary>
        <para>Creates a new snap line using the provided attributes.</para>
      </summary>
      <param name="snapType">
        <para>The type of the line that describes how other items will snap to this line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Top" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Left" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Right" />, or <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" />.</para>
      </param>
      <param name="resourceKey">
        <para>A resource key which determines the visual representation of this snap line.</para>
      </param>
      <param name="coordinates">
        <para>The coordinates of the center point of the snap line.</para>
      </param>
      <param name="from">
        <para>The first location that delimits this snap line.</para>
      </param>
      <param name="to">
        <para>The second location that delimits this snap line.</para>
      </param>
      <param name="tag">
        <para>A tag that is associated with this snap line - see <see cref="P:yWorks.Controls.Input.SnapLine.Tag" /> for a typical use of this value.</para>
      </param>
      <param name="weight">
        <para>The weight (importance) of this snap line. If more than one snap line is snapped to, the one with the greater weight will be used.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.SnapLine.SnapType">
      <summary>
        <para>Gets the type of the line that describes how other items will snap to this line.</para>
      </summary>
      <remarks>
        <para>his is one of <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Top" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Left" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Right" />, or <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.SnapLine.Coordinates">
      <summary>
        <para>Gets the coordinates of the center point of the snap line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.SnapLine.Tag">
      <summary>
        <para>Gets the tag that is associated with this snap line.</para>
      </summary>
      <remarks>
        <para>The tag is most commonly used for the <see cref="P:yWorks.Controls.Input.SnapResult.Tag">snap result tag</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.SnapLine.Weight">
      <summary>
        <para>Gets the weight/importance of this snap line.</para>
      </summary>
      <remarks>
        <para>Greater values indicate greater importance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.SnapLine.From">
      <summary>
        <para>Gets or sets the first location that delimits this snap line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.SnapLine.To">
      <summary>
        <para>Gets or sets the second location that delimits this snap line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.SnapLine.ResourceKey">
      <summary>
        <para>Gets the resource key which determines the visual appearance of the snap line.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.OrthogonalSnapLine">
      <summary>
        <para>An orthogonal snap line, in other words, one that is parallel to the x or y axis.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalSnapLine.#ctor(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Controls.ResourceKey,yWorks.Geometry.PointD,System.Object,System.Double)">
      <summary>
        <para>Creates a new snap line using the provided attributes.</para>
      </summary>
      <param name="orientation">
        <para>The orientation of the snap line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Horizontal" /> or <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Vertical" />.</para>
      </param>
      <param name="snapType">
        <para>The type of the line that describes how other items will snap to this line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Top" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Left" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Right" />, or <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" />.</para>
      </param>
      <param name="resourceKey">
        <para>A resource key which determines the visual representation of this snap line.</para>
      </param>
      <param name="coordinates">
        <para>The coordinates of the center point of the snap line.</para>
      </param>
      <param name="tag">
        <para>A tag that is associated with this snap line - see <see cref="P:yWorks.Controls.Input.SnapLine.Tag" /> for a typical use of this value.</para>
      </param>
      <param name="weight">
        <para>The weight (importance) of this snap line. If more than one snap line is snapped to, the one with the greater weight will be used.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.OrthogonalSnapLine.#ctor(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Controls.ResourceKey,yWorks.Geometry.PointD,System.Double,System.Double,System.Object,System.Double)">
      <summary>
        <para>Creates a new snap line using the provided attributes.</para>
      </summary>
      <param name="orientation">
        <para>The orientation of the snap line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Horizontal" /> or <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Vertical" />.</para>
      </param>
      <param name="snapType">
        <para>The type of the line that describes how other items will snap to this line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Top" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Left" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Right" />, or <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" />.</para>
      </param>
      <param name="resourceKey">
        <para>A resource key which determines the visual representation of this snap line.</para>
      </param>
      <param name="coordinates">
        <para>The coordinates of the center point of the snap line.</para>
      </param>
      <param name="from">
        <para>The smaller value of the coordinate that delimits this snap line.</para>
      </param>
      <param name="to">
        <para>The greater value of the coordinate that delimits this snap line.</para>
      </param>
      <param name="tag">
        <para>A tag that is associated with this snap line - see <see cref="P:yWorks.Controls.Input.SnapLine.Tag" /> for a typical use of this value.</para>
      </param>
      <param name="weight">
        <para>The weight (importance) of this snap line. If more than one snap line is snapped to, the one with the greater weight will be used.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.OrthogonalSnapLine.Orientation">
      <summary>
        <para>Gets the orientation of the snap line.</para>
      </summary>
      <remarks>
        <para>This is one of <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Horizontal" /> or <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Vertical" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.NodeBasedSnapLine">
      <summary>
        <para>A specialized <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" /> that stores a <see cref="P:yWorks.Controls.Input.NodeBasedSnapLine.Node" /> as additional information that can be used for the visualization.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.NodeBasedSnapLine.#ctor(yWorks.Graph.INode,yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Controls.ResourceKey,yWorks.Geometry.PointD,System.Object,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.NodeBasedSnapLine" /> class.</para>
      </summary>
      <param name="node">
        <para>The node to assign to <see cref="P:yWorks.Controls.Input.NodeBasedSnapLine.Node" />.</para>
      </param>
      <param name="orientation">
        <para>The orientation of the snap line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Horizontal" /> or <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Vertical" />.</para>
      </param>
      <param name="snapType">
        <para>The type of the line that describes how other items will snap to this line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Top" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Left" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Right" />, or <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" />.</para>
      </param>
      <param name="resourceKey">
        <para>A resource key which determines the visual representation of this snap line.</para>
      </param>
      <param name="coordinates">
        <para>The coordinates of the center point of the snap line.</para>
      </param>
      <param name="tag">
        <para>A tag that is associated with this snap line - see <see cref="P:yWorks.Controls.Input.SnapLine.Tag" /> for a typical use of this value.</para>
      </param>
      <param name="weight">
        <para>The weight (importance) of this snap line. If more than one snap line is snapped to, the one with the greater weight will be used.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeBasedSnapLine.#ctor(yWorks.Graph.INode,yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Controls.ResourceKey,yWorks.Geometry.PointD,System.Double,System.Double,System.Object,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.NodeBasedSnapLine" /> class.</para>
      </summary>
      <param name="node">
        <para>The node to assign to <see cref="P:yWorks.Controls.Input.NodeBasedSnapLine.Node" />.</para>
      </param>
      <param name="orientation">
        <para>The orientation of the snap line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Horizontal" /> or <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Vertical" />.</para>
      </param>
      <param name="snapType">
        <para>The type of the line that describes how other items will snap to this line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Top" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Left" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Right" />, or <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" />.</para>
      </param>
      <param name="resourceKey">
        <para>A resource key which determines the visual representation of this snap line.</para>
      </param>
      <param name="coordinates">
        <para>The coordinates of the center point of the snap line.</para>
      </param>
      <param name="tag">
        <para>A tag that is associated with this snap line - see <see cref="P:yWorks.Controls.Input.SnapLine.Tag" /> for a typical use of this value.</para>
      </param>
      <param name="weight">
        <para>The weight (importance) of this snap line. If more than one snap line is snapped to, the one with the greater weight will be used.</para>
      </param>
      <param name="from">
        <para>The smaller value of the coordinate that delimits this snap line.</para>
      </param>
      <param name="to">
        <para>The greater value of the coordinate that delimits this snap line.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.NodeBasedSnapLine.Node">
      <summary>
        <para>Gets the node that is associated with this snap line.</para>
      </summary>
      <remarks>
        <para>Usually this is the instance that induced this snap line.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.NodePairBasedSnapLine">
      <summary>
        <para>A specialized <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" /> that stores two <see cref="T:yWorks.Graph.INode">nodes</see> as additional information that can be used for the visualization.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.NodePairBasedSnapLine.FirstNode" />
      <seealso cref="P:yWorks.Controls.Input.NodePairBasedSnapLine.SecondNode" />
    </member>
    <member name="M:yWorks.Controls.Input.NodePairBasedSnapLine.#ctor(yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Controls.ResourceKey,yWorks.Geometry.PointD,System.Object,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.NodePairBasedSnapLine" /> class.</para>
      </summary>
      <param name="firstNode">
        <para>The first node to assign to <see cref="P:yWorks.Controls.Input.NodePairBasedSnapLine.FirstNode" />.</para>
      </param>
      <param name="secondNode">
        <para>The second node to assign to <see cref="P:yWorks.Controls.Input.NodePairBasedSnapLine.SecondNode" />.</para>
      </param>
      <param name="orientation">
        <para>The orientation of the snap line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Horizontal" /> or <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Vertical" />.</para>
      </param>
      <param name="snapType">
        <para>The type of the line that describes how other items will snap to this line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Top" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Left" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Right" />, or <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" />.</para>
      </param>
      <param name="resourceKey">
        <para>A resource key which determines the visual representation of this snap line.</para>
      </param>
      <param name="coordinates">
        <para>The coordinates of the center point of the snap line.</para>
      </param>
      <param name="tag">
        <para>A tag that is associated with this snap line - see <see cref="P:yWorks.Controls.Input.SnapLine.Tag" /> for a typical use of this value.</para>
      </param>
      <param name="weight">
        <para>The weight (importance) of this snap line. If more than one snap line is snapped to, the one with the greater weight will be used.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodePairBasedSnapLine.#ctor(yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Controls.ResourceKey,yWorks.Geometry.PointD,System.Double,System.Double,System.Object,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.NodePairBasedSnapLine" /> class.</para>
      </summary>
      <param name="firstNode">
        <para>The first node to assign to <see cref="P:yWorks.Controls.Input.NodePairBasedSnapLine.FirstNode" />.</para>
      </param>
      <param name="secondNode">
        <para>The second node to assign to <see cref="P:yWorks.Controls.Input.NodePairBasedSnapLine.SecondNode" />.</para>
      </param>
      <param name="orientation">
        <para>The orientation of the snap line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Horizontal" /> or <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Vertical" />.</para>
      </param>
      <param name="snapType">
        <para>The type of the line that describes how other items will snap to this line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Top" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Left" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Right" />, or <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" />.</para>
      </param>
      <param name="resourceKey">
        <para>A resource key which determines the visual representation of this snap line.</para>
      </param>
      <param name="coordinates">
        <para>The coordinates of the center point of the snap line.</para>
      </param>
      <param name="tag">
        <para>A tag that is associated with this snap line - see <see cref="P:yWorks.Controls.Input.SnapLine.Tag" /> for a typical use of this value.</para>
      </param>
      <param name="weight">
        <para>The weight (importance) of this snap line. If more than one snap line is snapped to, the one with the greater weight will be used.</para>
      </param>
      <param name="from">
        <para>The smaller value of the coordinate that delimits this snap line.</para>
      </param>
      <param name="to">
        <para>The greater value of the coordinate that delimits this snap line.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.NodePairBasedSnapLine.FirstNode">
      <summary>
        <para>Gets the first node that is associated with this snap line.</para>
      </summary>
      <remarks>
        <para>Usually this is one of the instances that induced this snap line.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.NodePairBasedSnapLine.SecondNode">
      <summary>
        <para>Gets the second node that is associated with this snap line.</para>
      </summary>
      <remarks>
        <para>Usually this is one of the instances that induced this snap line.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.PointBasedSnapLine">
      <summary>
        <para>A specialized <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" /> that stores a <see cref="P:yWorks.Controls.Input.PointBasedSnapLine.Point" /> instance as additional information that can be used for the visualization.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.PointBasedSnapLine.#ctor(yWorks.Geometry.IPoint,yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Controls.ResourceKey,yWorks.Geometry.PointD,System.Object,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.PointBasedSnapLine" /> class.</para>
      </summary>
      <param name="point">
        <para>The point to assign to <see cref="P:yWorks.Controls.Input.PointBasedSnapLine.Point" />.</para>
      </param>
      <param name="orientation">
        <para>The orientation of the snap line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Horizontal" /> or <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Vertical" />.</para>
      </param>
      <param name="snapType">
        <para>The type of the line that describes how other items will snap to this line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Top" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Left" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Right" />, or <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" />.</para>
      </param>
      <param name="resourceKey">
        <para>A resource key which determines the visual representation of this snap line.</para>
      </param>
      <param name="coordinates">
        <para>The coordinates of the center point of the snap line.</para>
      </param>
      <param name="tag">
        <para>A tag that is associated with this snap line - see <see cref="P:yWorks.Controls.Input.SnapLine.Tag" /> for a typical use of this value.</para>
      </param>
      <param name="weight">
        <para>The weight (importance) of this snap line. If more than one snap line is snapped to, the one with the greater weight will be used.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PointBasedSnapLine.#ctor(yWorks.Geometry.IPoint,yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Controls.ResourceKey,yWorks.Geometry.PointD,System.Double,System.Double,System.Object,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.PointBasedSnapLine" /> class.</para>
      </summary>
      <param name="point">
        <para>The point to assign to <see cref="P:yWorks.Controls.Input.PointBasedSnapLine.Point" />.</para>
      </param>
      <param name="orientation">
        <para>The orientation of the snap line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Horizontal" /> or <see cref="F:yWorks.Controls.Input.SnapLineOrientation.Vertical" />.</para>
      </param>
      <param name="snapType">
        <para>The type of the line that describes how other items will snap to this line. This is one of <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Top" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Left" />, <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Right" />, or <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" />.</para>
      </param>
      <param name="resourceKey">
        <para>A resource key which determines the visual representation of this snap line.</para>
      </param>
      <param name="coordinates">
        <para>The coordinates of the center point of the snap line.</para>
      </param>
      <param name="tag">
        <para>A tag that is associated with this snap line - see <see cref="P:yWorks.Controls.Input.SnapLine.Tag" /> for a typical use of this value.</para>
      </param>
      <param name="weight">
        <para>The weight (importance) of this snap line. If more than one snap line is snapped to, the one with the greater weight will be used.</para>
      </param>
      <param name="from">
        <para>The smaller value of the coordinate that delimits this snap line.</para>
      </param>
      <param name="to">
        <para>The greater value of the coordinate that delimits this snap line.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.PointBasedSnapLine.Point">
      <summary>
        <para>Gets the point that is associated with this snap line.</para>
      </summary>
      <remarks>
        <para>Usually this is the instance that induced this snap line.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.EdgeSegmentSnapLine">
      <summary>
        <para>A specialized <see cref="T:yWorks.Controls.Input.SnapLine" /> that is parallel to an edge segment and stores that edge.</para>
      </summary>
      <remarks>
        <para>In addition to the line itself, this class has three special nape locations the represent the source, center and end location of the related edge segment. All snap lines of this type have the <see cref="P:yWorks.Controls.Input.SnapLine.SnapType" /> <see cref="F:yWorks.Controls.Input.SnapLineSnapTypes.Center" /> and the <see cref="P:yWorks.Controls.Input.SnapLine.ResourceKey" /> <see cref="F:yWorks.Controls.Input.SnapLine.SnapLineEdgeSegmentKey" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.EdgeSegmentSnapLine.#ctor(yWorks.Graph.IEdge,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double,System.Int32)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.PointBasedSnapLine" /> class.</para>
      </summary>
      <param name="edge">
        <para>The edge to assign to <see cref="P:yWorks.Controls.Input.EdgeSegmentSnapLine.Edge" />.</para>
      </param>
      <param name="segmentSource">
        <para>The location that represents the source of the related segment on this line. In addition, this location is used as <see cref="P:yWorks.Controls.Input.SnapLine.From" /> location.</para>
      </param>
      <param name="segmentTarget">
        <para>The location that represents the target of the related segment on this line. In addition, this location is used as <see cref="P:yWorks.Controls.Input.SnapLine.To" /> location.</para>
      </param>
      <param name="distance">
        <para>The distance of this snap line from its related edge segment.</para>
      </param>
      <param name="segmentIndex">
        <para>The segment index of the related edge segment.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.EdgeSegmentSnapLine.#ctor(yWorks.Graph.IEdge,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double,System.Int32,System.Object,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.PointBasedSnapLine" /> class.</para>
      </summary>
      <param name="edge">
        <para>The edge to assign to <see cref="P:yWorks.Controls.Input.EdgeSegmentSnapLine.Edge" />.</para>
      </param>
      <param name="from">
        <para>The first location that delimits this snap line.</para>
      </param>
      <param name="to">
        <para>The second location that delimits this snap line.</para>
      </param>
      <param name="segmentSource">
        <para>The location that represents the source of the related segment on this line.</para>
      </param>
      <param name="segmentTarget">
        <para>The location that represents the target of the related segment on this line.</para>
      </param>
      <param name="distance">
        <para>The distance of this snap line from its related edge segment.</para>
      </param>
      <param name="segmentIndex">
        <para>The segment index of the related edge segment.</para>
      </param>
      <param name="tag">
        <para>A tag that is associated with this snap line.</para>
      </param>
      <param name="weight">
        <para>The weight (importance) of this snap line.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLine.Edge">
      <summary>
        <para>Gets the edge that is associated with this snap line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLine.Direction">
      <summary>
        <para>Gets the direction vector of this snap line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLine.Distance">
      <summary>
        <para>Gets the distance of this snap line from its related edge segment.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLine.SegmentIndex">
      <summary>
        <para>Gets the segment index of the related edge segment.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLine.SegmentSource">
      <summary>
        <para>Gets the location that represents the source of the related segment on this line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLine.SegmentTarget">
      <summary>
        <para>Gets the location that represents the target of the related segment on this line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLine.SourceMarker">
      <summary>
        <para>Gets or sets the location of the source marker of this snap line.</para>
      </summary>
      <remarks>
        <para>If this is <c>null</c>, the location of the <see cref="P:yWorks.Controls.Input.EdgeSegmentSnapLine.SegmentSource" /> is marked instead.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLine.TargetMarker">
      <summary>
        <para>Gets or sets the location of the target marker of this snap line.</para>
      </summary>
      <remarks>
        <para>If this is <c>null</c>, the location of the <see cref="P:yWorks.Controls.Input.EdgeSegmentSnapLine.SegmentTarget" /> is marked instead.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.SnapLineOrientation">
      <summary>
        <para>The orientation used by <see cref="P:yWorks.Controls.Input.OrthogonalSnapLine.Orientation">orthogonal snap lines</see>.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineOrientation.Horizontal">
      <summary>
        <para>Constant that describes a horizontal <see cref="T:yWorks.Controls.Input.SnapLineOrientation">orientation</see> of a snap line.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineOrientation.Vertical">
      <summary>
        <para>Constant that describes a vertical <see cref="T:yWorks.Controls.Input.SnapLineOrientation">orientation</see> of a snap line.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.SnapLineSnapTypes">
      <summary>
        <para>The type of a <see cref="P:yWorks.Controls.Input.SnapLine.SnapType">snap line</see>.</para>
      </summary>
      <remarks>
        <para>This is a flaggable enumeration so a snap line can be used for multiple types of snaps.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineSnapTypes.None">
      <summary>
        <para>Describes snap lines to which nothing will snap.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineSnapTypes.Top">
      <summary>
        <para>Describes snap lines to which the top sides of rectangular elements will snap.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineSnapTypes.Bottom">
      <summary>
        <para>Describes snap lines to which the bottom sides of rectangular elements will snap.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineSnapTypes.Left">
      <summary>
        <para>Describes snap lines to which the left sides of rectangular elements will snap.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineSnapTypes.Right">
      <summary>
        <para>Describes snap lines to which the right sides of rectangular elements will snap.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineSnapTypes.Center">
      <summary>
        <para>Describes snap lines to which the center of elements will snap.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineSnapTypes.Vertical">
      <summary>
        <para>Describes vertical snap lines</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineSnapTypes.Horizontal">
      <summary>
        <para>Describes horizontal snap lines</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.SnapLineSnapTypes.All">
      <summary>
        <para>Describes snap lines to which all elements will snap at all sides</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.NodeSnapLineProvider">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> interface that provides <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s for <see cref="T:yWorks.Graph.INode" />s.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> to create snap lines around the geometric border of the node.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)">
      <summary>
        <para>Called by the <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> when a <see cref="M:yWorks.Controls.Input.GraphSnapContext.InitializeDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">drag</see> is about to start.</para>
      </summary>
      <remarks>
        <para>This means that the provided <paramref name="item" />, which can be cast to <see cref="T:yWorks.Graph.INode" /> will not be moved during the edit and thus can contribute to the set of fixed snap lines. This implementation delegates to <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddFixedNodeBorderSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.INode,yWorks.Geometry.RectD)" />, <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddPortSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.INode,yWorks.Geometry.RectD)" />, <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddNodeToNodeSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.INode,yWorks.Geometry.RectD)" />, and <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddCenterSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.INode,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="args">
        <para>The argument to use for adding snap lines.</para>
      </param>
      <param name="item">
        <para>The item to add snap lines for.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapLineProvider.AddPortSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <summary>
        <para>Callback method that is called by <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)" /> the collect snap lines to snap ports to at the provided node.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)" /></para>
      </remarks>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="args">
        <para>The argument to use for adding snap lines.</para>
      </param>
      <param name="node">
        <para>The node to add snap lines for.</para>
      </param>
      <param name="layout">
        <para>The layout of the node to use for adding the snap lines.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapLineProvider.AddFixedNodeBorderSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <summary>
        <para>Callback method that adds the fixed snap lines around the border of the nodes' <paramref name="layout" />.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)" /></para>
      </remarks>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="args">
        <para>The argument to use for adding snap lines.</para>
      </param>
      <param name="node">
        <para>The node to add snap lines for.</para>
      </param>
      <param name="layout">
        <para>The layout of the node to use for adding the snap lines.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapLineProvider.AddCenterSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <summary>
        <para>Callback method that is called by <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)" /> the collect snap lines for the centers of the node.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)" /> and by default used the <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.CreateCenterSnapLine(yWorks.Controls.Input.GraphSnapContext,yWorks.Graph.INode,yWorks.Controls.Input.SnapLineOrientation,yWorks.Geometry.PointD)" /> to add them to the <see cref="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.AddFixedNodeSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)">fixed node</see> and <see cref="M:yWorks.Controls.Input.CollectGraphSnapLinesEventArgs.AddFixedSegmentSnapLine(yWorks.Controls.Input.OrthogonalSnapLine)">fixed segment</see> collections</para>
      </remarks>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="args">
        <para>The argument to use for adding snap lines.</para>
      </param>
      <param name="node">
        <para>The node to add snap lines for.</para>
      </param>
      <param name="layout">
        <para>The layout of the node to use for adding the snap lines.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapLineProvider.CreateCenterSnapLine(yWorks.Controls.Input.GraphSnapContext,yWorks.Graph.INode,yWorks.Controls.Input.SnapLineOrientation,yWorks.Geometry.PointD)">
      <summary>
        <para>Convenience method that creates a snap line for the center of nodes.</para>
      </summary>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="node">
        <para>The node to add snap lines for.</para>
      </param>
      <param name="orientation">
        <para>The snap line orientation.</para>
      </param>
      <param name="location">
        <para>The location of the snap line.</para>
      </param>
      <returns>
        <para>A snap line that other centers can snap to.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapLineProvider.AddNodeToSegmentSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <summary>
        <para>Callback method that adds the fixed snap lines around the node for edge segments to snap to.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)" /> and uses the <see cref="P:yWorks.Controls.Input.GraphSnapContext.NodeToEdgeDistance" /> to determine the location of the segments to add around the <paramref name="layout" />.</para>
      </remarks>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="args">
        <para>The argument to use for adding snap lines.</para>
      </param>
      <param name="node">
        <para>The node to add snap lines for.</para>
      </param>
      <param name="layout">
        <para>The layout of the node to use for adding the snap lines.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapLineProvider.AddNodeToNodeSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <summary>
        <para>Callback method that adds the fixed snap lines around the node for other nodes to snap to using the <see cref="P:yWorks.Controls.Input.GraphSnapContext.NodeToNodeDistance" />.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.NodeSnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)" /> and uses the <see cref="P:yWorks.Controls.Input.GraphSnapContext.NodeToNodeDistance" /> to determine the location of the segments to add around the <paramref name="layout" />.</para>
      </remarks>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="args">
        <para>The argument to use for adding snap lines.</para>
      </param>
      <param name="node">
        <para>The node to add snap lines for.</para>
      </param>
      <param name="layout">
        <para>The layout of the node to use for adding the snap lines.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.EdgeSnapLineProvider">
      <summary>
        <para>Simple implementation of the <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> interface that can be used to add snap lines for orthogonally routed <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </summary>
      <remarks>
        <para>This implementation can be put into the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.EdgeDecorator.SnapLineProviderDecorator" />
    </member>
    <member name="M:yWorks.Controls.Input.EdgeSnapLineProvider.AddSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IModelItem)">
      <summary>
        <para>Adds the snap lines for the given model item to the <paramref name="args" />.</para>
      </summary>
      <remarks>
        <para>This implementation queries the <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetMovementInfos(yWorks.Graph.IEdge)">movement information</see> for the provided edge to determine which edge segments stay fixed. For each fixed segment, it will call <see cref="M:yWorks.Controls.Input.EdgeSnapLineProvider.AddVerticalSegmentSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IEdge,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> or <see cref="M:yWorks.Controls.Input.EdgeSnapLineProvider.AddHorizontalSegmentSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IEdge,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> respectively.</para>
      </remarks>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="item">
        <para>The item to add snap lines for.</para>
      </param>
      <param name="args">
        <para>The argument to use for adding snap lines.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.EdgeSnapLineProvider.AddHorizontalSegmentSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IEdge,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Adds horizontal snap lines for a horizontally oriented fixed segment snap lines.</para>
      </summary>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="edge">
        <para>The edge to add snap lines for.</para>
      </param>
      <param name="segmentStart">
        <para>The start of the segment.</para>
      </param>
      <param name="args">
        <para>The argument to use for adding snap lines.</para>
      </param>
      <param name="segmentEnd">
        <para>The end of the segment.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.EdgeSnapLineProvider.AddVerticalSegmentSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IEdge,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.Input.EdgeSnapLineProvider.AddVerticalSegmentSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IEdge,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Adds vertical snap lines for a vertically oriented fixed segment snap lines.</para>
      </summary>
      <param name="context">
        <para>The context which holds the settings for the snap lines. Note that implementations should not change the state of the context explicitly.</para>
      </param>
      <param name="edge">
        <para>The edge to add snap lines for.</para>
      </param>
      <param name="segmentStart">
        <para>The start of the segment.</para>
      </param>
      <param name="segmentEnd">
        <para>The end of the segment.</para>
      </param>
      <param name="args">
        <para>The argument to use for adding snap lines.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.EdgeSnapLineProvider.AddHorizontalSegmentSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectGraphSnapLinesEventArgs,yWorks.Graph.IEdge,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="T:yWorks.Controls.Input.SnapLineTemplateVisual">
      <summary>
        <para>A Control representing a <see cref="T:yWorks.Controls.Input.SnapResult" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Controls.Input.SnapResult" /> to visualize and the current render context have to be passed to the <see cref="M:yWorks.Controls.Input.SnapLineTemplateVisual.UpdateValues(yWorks.Controls.IRenderContext,yWorks.Controls.Input.SnapResult)" /> method so that any custom properties can be initialized. Some subclasses may have additional information stored as <c>Content</c> that can be used for the visualization.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.SnapLineTemplateVisual.UpdateValues(yWorks.Controls.IRenderContext,yWorks.Controls.Input.SnapResult)">
      <summary>
        <para>Updates the Control using the values of the passed <paramref name="snapResult" /> in the given <paramref name="context" />.</para>
      </summary>
      <param name="context">
        <para>The current render context.</para>
      </param>
      <param name="snapResult">
        <para>The <see cref="T:yWorks.Controls.Input.SnapResult" /> that shall be visualized.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.SnapLineTemplateVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="P:yWorks.Controls.Input.SnapLineTemplateVisual.Pen">
      <summary>
        <para>Gets or sets the main pen to use for rendering the snap line.</para>
      </summary>
      <value>
        <para>The pen, which may be <c>null</c> in which case the <see cref="T:yWorks.Controls.CanvasControl" /> from will be queried for the pen using the <see cref="F:yWorks.Controls.Input.SnapLine.SnapLinePenKey" />.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.SnapLineTemplateVisual.GetPen(yWorks.Controls.IRenderContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.SnapLineTemplateVisual.GetPen(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Gets the pen to use for the rendering.</para>
      </summary>
      <remarks>
        <para>If <see cref="P:yWorks.Controls.Input.SnapLineTemplateVisual.Pen" /> is <c>null</c>, then</para>
      </remarks>
      <param name="context">
        <para>The context to obtain the pen from if <see cref="P:yWorks.Controls.Input.SnapLineTemplateVisual.Pen" /> is <c>null</c>.</para>
      </param>
      <returns>
        <para>The pen to use or <c>null</c>.</para>
      </returns>
      <seealso cref="F:yWorks.Controls.Input.SnapLine.SnapLinePenKey" />
    </member>
    <member name="T:yWorks.Controls.Input.SingleLineSnapLineTemplateVisual">
      <summary>
        <para>Represents the visualization of a <see cref="T:yWorks.Controls.Input.SnapResult" /> that can be visualized using a single snap line.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.SingleLineSnapLineTemplateVisual.UpdateValues(yWorks.Controls.IRenderContext,yWorks.Controls.Input.SnapResult)">
      <param name="context" />
      <param name="result" />
    </member>
    <member name="P:yWorks.Controls.Input.SingleLineSnapLineTemplateVisual.Key">
      <summary>
        <para>Gets the resource key to use for this control.</para>
      </summary>
      <remarks>
        <para>The resource key is set in <see cref="M:yWorks.Controls.Input.SingleLineSnapLineTemplateVisual.UpdateValues(yWorks.Controls.IRenderContext,yWorks.Controls.Input.SnapResult)" />. Subclasses might use this property to get the resource key for this control.</para>
      </remarks>
      <value>
        <para>The value that has been obtained from the <see cref="P:yWorks.Controls.Input.SnapLine.ResourceKey" /> property.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.SingleLineSnapLineTemplateVisual.Size">
      <summary>
        <para>Gets or sets the size to use for rendering this template.</para>
      </summary>
      <value>
        <para>The size. The interpretation of this value depends on the implementation.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.SingleLineSnapLineTemplateVisual.SourcePoint">
      <summary>
        <para>Gets or sets the source point to use for rendering the location indicator of the source point.</para>
      </summary>
      <value>
        <para>The source point.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.SingleLineSnapLineTemplateVisual.TargetPoint">
      <summary>
        <para>Gets or sets the target point to use for rendering the location indicator of the target point.</para>
      </summary>
      <value>
        <para>The source point.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.SingleLineSnapLineTemplateVisual.LineFrom">
      <summary>
        <para>Gets or sets the starting point of the snap line.</para>
      </summary>
      <value>
        <para>The starting point.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.SingleLineSnapLineTemplateVisual.LineTo">
      <summary>
        <para>Gets or sets the end point of the snap line.</para>
      </summary>
      <value>
        <para>The end point.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual">
      <summary>
        <para>A snap line visualization that depicts a fixed distance to a certain obstacle.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.UpdateValues(yWorks.Controls.IRenderContext,yWorks.Controls.Input.SnapResult)">
      <param name="context" />
      <param name="result" />
    </member>
    <member name="P:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.Key">
      <summary>
        <para>Gets the specific resource key that is used for this rendering.</para>
      </summary>
      <remarks>
        <para>The resource key is set in <see cref="M:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.UpdateValues(yWorks.Controls.IRenderContext,yWorks.Controls.Input.SnapResult)" />. Subclasses might use this property to get the resource key for this control.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.Size">
      <summary>
        <para>Gets or sets the size to use for rendering this template.</para>
      </summary>
      <value>
        <para>The size. The interpretation of this value depends on the implementation.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.SourcePoint">
      <summary>
        <para>Gets or sets the source point that induced the snapping.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.TargetPoint">
      <summary>
        <para>Gets or sets the target point that induced the snapping.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.SourceLineFrom">
      <summary>
        <para>Gets or sets the one end of the source line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.SourceLineTo">
      <summary>
        <para>Gets or sets the other end of the source line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.TargetLineFrom">
      <summary>
        <para>Gets or sets the one end of the target line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.TargetLineTo">
      <summary>
        <para>Gets or sets the other end of the target line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.DistanceIndicatorFrom">
      <summary>
        <para>Gets or sets the location of the one end of the distance indicator.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.FixedDistanceSnapLineTemplateVisual.DistanceIndicatorTo">
      <summary>
        <para>Gets or sets the location of the other end of the distance indicator.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual">
      <summary>
        <para>A template the visualizes a snap line that snaps an object between two other objects so that the distances to the enclosing objects are equal.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.UpdateValues(yWorks.Controls.IRenderContext,yWorks.Controls.Input.SnapResult)">
      <param name="context" />
      <param name="result" />
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.Key">
      <summary>
        <para>Gets the specific resource key that is used for this rendering.</para>
      </summary>
      <remarks>
        <para>The resource key is set in <see cref="M:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.UpdateValues(yWorks.Controls.IRenderContext,yWorks.Controls.Input.SnapResult)" />. Subclasses might use this property to get the resource key for this control.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.Size">
      <summary>
        <para>Gets or sets the size to use for rendering this template.</para>
      </summary>
      <value>
        <para>The size. The interpretation of this value depends on the implementation.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.OuterLine1From">
      <summary>
        <para>Gets or sets the location of the one end of the first outer line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.OuterLine1To">
      <summary>
        <para>Gets or sets the location of the one end of the first outer line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.DistanceIndicator1From">
      <summary>
        <para>Gets or sets the location of the one end of first distance indicator.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.DistanceIndicator1To">
      <summary>
        <para>Gets or sets the location of the other end of first distance indicator.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.DistanceIndicator2From">
      <summary>
        <para>Gets or sets the location of the one end of second distance indicator.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.DistanceIndicator2To">
      <summary>
        <para>Gets or sets the location of the other end of second distance indicator.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.InnerLine1From">
      <summary>
        <para>Gets or sets the location of the one end of the first inner line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.InnerLine1To">
      <summary>
        <para>Gets or sets the location of the other end of the first inner line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.InnerLine2From">
      <summary>
        <para>Gets or sets the location of the one end of the second inner line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.InnerLine2To">
      <summary>
        <para>Gets or sets the location of the other end of the second inner line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.OuterLine2From">
      <summary>
        <para>Gets or sets the location of the one end of the second outer line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.InBetweenSnapLineTemplateVisual.OuterLine2To">
      <summary>
        <para>Gets or sets the location of the other end of the second outer line.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual">
      <summary>
        <para>A snap line visualization that shows a line and optionally highlights some special points.</para>
      </summary>
      <remarks>
        <para>The main usage of this class is snapping of an edge label to a edge segment. In this case, this class draws a line parallel to the edge segment and highlights the source, center and target snap points on that line.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual.UpdateValues(yWorks.Controls.IRenderContext,yWorks.Controls.Input.SnapResult)">
      <param name="context" />
      <param name="result" />
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual.Key">
      <summary>
        <para>Gets the resource key to use for this control.</para>
      </summary>
      <remarks>
        <para>The resource key is set in <see cref="M:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual.UpdateValues(yWorks.Controls.IRenderContext,yWorks.Controls.Input.SnapResult)" />. Subclasses might use this property to get the resource key for this control.</para>
      </remarks>
      <value>
        <para>The value that has been obtained from the <see cref="P:yWorks.Controls.Input.SnapLine.ResourceKey" /> property.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual.Size">
      <summary>
        <para>Gets or sets the size to use for rendering this template.</para>
      </summary>
      <value>
        <para>The size. The interpretation of this value depends on the implementation.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual.LineFrom">
      <summary>
        <para>Gets or sets the starting position of the visualizing snap line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual.LineTo">
      <summary>
        <para>Gets or sets the ending position of the visualizing snap line..</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual.SourcePoint">
      <summary>
        <para>Gets or sets a position representing the source element that created the <see cref="T:yWorks.Controls.Input.SnapLine" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual.TargetPoint">
      <summary>
        <para>Gets or sets the snapped point of the moved object that snapped to the <see cref="T:yWorks.Controls.Input.SnapLine" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual.FromPoint">
      <summary>
        <para>Gets or sets the starting position of the visualizing snap line.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.EdgeSegmentSnapLineTemplateVisual.ToPoint">
      <summary>
        <para>Gets or sets the ending position of the visualizing snap line.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.NodeSnapResultProvider">
      <summary>
        <para>The default implementation of the <see cref="T:yWorks.Controls.Input.INodeSnapResultProvider" /> interface.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeSnapResultProvider.Instance">
      <summary>
        <para>Yields the static shared instance of this class.</para>
      </summary>
      <remarks>
        <para>Since this implementation does not carry any state, this instance can safely be used even in multi-threaded environments.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapResultProvider.CollectSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.RectD,yWorks.Graph.INode)">
      <param name="context" />
      <param name="args" />
      <param name="suggestedLayout" />
      <param name="node" />
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapResultProvider.CollectSnapLineSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.RectD,yWorks.Graph.INode)">
      <summary>
        <para>Collects the results for the given layout for all snap lines in question.</para>
      </summary>
      <remarks>
        <para>For each snap line that could be snapped to, this method calls <see cref="M:yWorks.Controls.Input.NodeSnapResultProvider.CollectSnapResults(yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Controls.Input.OrthogonalSnapLine,yWorks.Geometry.RectD,yWorks.Graph.INode)" />.</para>
      </remarks>
      <param name="context">
        <para>The context for which the results are being queried.</para>
      </param>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectSnapResultsEventArgs" /> instance to which the results should be <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">added</see>.</para>
      </param>
      <param name="suggestedLayout">
        <para>The suggested layout of the node.</para>
      </param>
      <param name="node">
        <para>The node that is being dragged.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapResultProvider.CollectSnapResults(yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Controls.Input.OrthogonalSnapLine,yWorks.Geometry.RectD,yWorks.Graph.INode)">
      <summary>
        <para>Verifies whether the node will snap to the given snap line.</para>
      </summary>
      <remarks>
        <para>If the node will snap, a <see cref="T:yWorks.Controls.Input.SnapResult" /> for a <see cref="T:yWorks.Controls.Input.SnapLine" /> will be created and added to the event argument.</para>
      </remarks>
      <param name="args">
        <para>The arguments to add the results to.</para>
      </param>
      <param name="snapLine">
        <para>The snap line to test snapping for.</para>
      </param>
      <param name="suggestedLayout">
        <para>The layout of the node if it would move without snapping.</para>
      </param>
      <param name="node">
        <para>The node that is currently being processed.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapResultProvider.CollectGridSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.RectD,yWorks.Graph.INode)">
      <summary>
        <para>Collects snap results that snap the node to a grid and <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">adds them</see> to the argument.</para>
      </summary>
      <remarks>
        <para>This implementation simply delegates to <see cref="M:yWorks.Controls.Input.NodeSnapResultProvider.AddGridSnapResult(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.PointD,yWorks.Graph.INode)" /> using the center of the <paramref name="suggestedLayout" />.</para>
      </remarks>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="args">
        <para>The arguments to add the results to.</para>
      </param>
      <param name="suggestedLayout">
        <para>The layout of the node if it would move without snapping.</para>
      </param>
      <param name="node">
        <para>The node that is currently being processed.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapResultProvider.AddGridSnapResult(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.PointD,yWorks.Graph.INode)">
      <summary>
        <para>Calculates a <see cref="T:yWorks.Controls.Input.SnapResult" /> and <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">adds it</see> to the argument.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Controls.Input.NodeSnapResultProvider.AddGridSnapResultCore(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.PointD,yWorks.Graph.INode,yWorks.Controls.Input.GridSnapTypes,yWorks.Controls.Input.SnapPolicy,yWorks.Controls.Input.SnapPolicy)" /> using <see cref="P:yWorks.Controls.Input.GraphSnapContext.GridSnapType" /> and <see cref="F:yWorks.Controls.Input.SnapPolicy.ToNearest" /> as the additional arguments. This method snaps the <paramref name="location" /> to the next grid point or grid lines that are determined by <see cref="P:yWorks.Controls.Input.GraphSnapContext.NodeGridConstraintProvider" /> or obtained from the <see cref="P:yWorks.Controls.Input.InputModeEventArgs.Context" />.</para>
      </remarks>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="args">
        <para>The arguments to add the results to.</para>
      </param>
      <param name="location">
        <para>A location in the layout of the suggested layout of the node that will be snapped to a grid point location.</para>
      </param>
      <param name="node">
        <para>The node that is currently being processed.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeSnapResultProvider.AddGridSnapResultCore(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.PointD,yWorks.Graph.INode,yWorks.Controls.Input.GridSnapTypes,yWorks.Controls.Input.SnapPolicy,yWorks.Controls.Input.SnapPolicy)">
      <summary>
        <para>Calculates a <see cref="T:yWorks.Controls.Input.SnapResult" /> and <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">adds it</see> to the argument.</para>
      </summary>
      <remarks>
        <para>This method snaps the <paramref name="location" /> to the next grid point or grid lines that are determined by <see cref="P:yWorks.Controls.Input.GraphSnapContext.NodeGridConstraintProvider" /> or obtained from the <see cref="P:yWorks.Controls.Input.InputModeEventArgs.Context" />.</para>
      </remarks>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="args">
        <para>The arguments to add the results to.</para>
      </param>
      <param name="location">
        <para>A location in the layout of the suggested layout of the node that will be snapped to a grid point location.</para>
      </param>
      <param name="node">
        <para>The node that is currently being processed.</para>
      </param>
      <param name="gridSnapType">
        <para>The type of snapping that should be performed.</para>
      </param>
      <param name="xSnapPolicy">
        <para>How to snap the x coordinate.</para>
      </param>
      <param name="ySnapPolicy">
        <para>How to snap the y coordinate.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.NodeReshapeSnapResultProvider">
      <summary>
        <para>The default implementation of the <see cref="T:yWorks.Controls.Input.INodeReshapeSnapResultProvider" /> interface.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.NodeReshapeSnapResultProvider.Instance">
      <summary>
        <para>A shared singleton instance of this type.</para>
      </summary>
      <remarks>
        <para>Since this type does not carry state this instance can be used in multi-threaded contexts without synchronization.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext)">
      <summary>
        <para>Called when a node is <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">dragged</see> to add <see cref="T:yWorks.Controls.Input.SnapResult" />s for <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s or sizes to which this node can potentially snap during resizing.</para>
      </summary>
      <remarks>
        <para>This implementation delegates to the following methods in order:</para>
        <list type="bullet">
          <item>
            <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectGridSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)" />
          </item>
          <item>
            <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectSameSizeSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)" />
          </item>
          <item>
            <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectSnapLineResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)" />
          </item>
        </list>
      </remarks>
      <param name="context">
        <para>The snap context which manages the snap lines and the settings.</para>
      </param>
      <param name="args">
        <para>The event argument to obtain the context from and add the results to.</para>
      </param>
      <param name="node">
        <para>The node that is being reshaped.</para>
      </param>
      <param name="reshapeContext">
        <para>Carries information about the reshape process.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectSnapLineResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Collects the snap results that makes the node's bounds snap to the <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetFixedNodeSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)">fixed node snap lines</see>.</para>
      </summary>
      <remarks>
        <para>This method ultimately delegates to <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.AddSnaplineSnapResult(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.OrthogonalSnapLine,System.Double,yWorks.Geometry.PointD)" /> to add the results to the event argument. Method <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.GetSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)" /> is used to query the snap lines that will be checked by this method.</para>
      </remarks>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectSnapResultsEventArgs" /> instance containing the event data.</para>
      </param>
      <param name="node">
        <para>The node that is being reshaped.</para>
      </param>
      <param name="reshapeContext">
        <para>The reshape context that contains information about the nature of the resize.</para>
      </param>
      <param name="suggestedLayout">
        <para>The layout of the node as it would be if the mouse location would not be snapped.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.GetSnapLines(yWorks.Controls.Input.GraphSnapContext,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Helper method for method <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectSnapLineResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)" /> that gets all the <see cref="T:yWorks.Controls.Input.SnapLine" /> that should be checked for the currently moved node.</para>
      </summary>
      <remarks>
        <para>This method aggregates the <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetFixedNodeSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)">fixed nodes' snaplines</see> and the <see cref="M:yWorks.Controls.Input.GraphSnapContext.GetAdditionalSnapLines(yWorks.Controls.Input.SnapLineOrientation,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.RectD)">additional snap lines</see> that are relevant to the node.</para>
      </remarks>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="node">
        <para>The node that is being reshaped.</para>
      </param>
      <param name="reshapeContext">
        <para>The reshape context that contains information about the nature of the resize.</para>
      </param>
      <param name="suggestedLayout">
        <para>The layout of the node as it would be if the mouse location would not be snapped.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.AddSnaplineSnapResult(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.OrthogonalSnapLine,System.Double,yWorks.Geometry.PointD)">
      <summary>
        <para>Adds a snap result for a location that snaps the node's bounds to a snap line.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectSnapLineResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)" /> for each snap line snap.</para>
      </remarks>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectSnapResultsEventArgs" /> instance containing the event data.</para>
      </param>
      <param name="node">
        <para>The node that is being reshaped.</para>
      </param>
      <param name="snapLine">
        <para>The snap line to which the node can be snapped</para>
      </param>
      <param name="delta">
        <para>The amount the mouse needs to be moved in order to get to the snapping location.</para>
      </param>
      <param name="snapPoint">
        <para>The point of interest that can be highlighted on the snap line.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectSameSizeSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Collects the snap results that make the node the same size as other elements.</para>
      </summary>
      <remarks>
        <para>This method ultimately delegates to <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.AddSameSizeSnapResult(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.SnapLineOrientation,System.Collections.Generic.IEnumerable{yWorks.Geometry.RectD},System.Double,System.Double)" /> to add the results to the event argument.</para>
      </remarks>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectSnapResultsEventArgs" /> instance containing the event data.</para>
      </param>
      <param name="node">
        <para>The node that is being reshaped.</para>
      </param>
      <param name="reshapeContext">
        <para>The reshape context that contains information about the nature of the resize.</para>
      </param>
      <param name="suggestedLayout">
        <para>The layout of the node as it would be if the mouse location would not be snapped.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectGridSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Collects the snap results for the grid.</para>
      </summary>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectSnapResultsEventArgs" /> instance containing the event data.</para>
      </param>
      <param name="node">
        <para>The node that is being reshaped.</para>
      </param>
      <param name="reshapeContext">
        <para>The reshape context that describes how the node's layout is reshaped.</para>
      </param>
      <param name="suggestedLayout">
        <para>The suggested layout of the node.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.AddGridLineSnapResult(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.SnapLineSnapTypes,yWorks.Geometry.IPoint,System.Double,yWorks.Geometry.PointD,System.Double,System.Double,yWorks.Geometry.PointD)">
      <summary>
        <para>Adds a snap result for a location that snaps to a grid line.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectGridSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)" /> for each grid line snap.</para>
      </remarks>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectSnapResultsEventArgs" /> instance containing the event data.</para>
      </param>
      <param name="node">
        <para>The node that is being reshaped.</para>
      </param>
      <param name="delta">
        <para>The amount the mouse needs to be moved in order to get to the snapping location.</para>
      </param>
      <param name="snappedLocation">
        <para>The location of the mouse that is associated with the grid point.</para>
      </param>
      <param name="snapLineType">
        <para>The type of snap line.</para>
      </param>
      <param name="snapLineLocation">
        <para>The point at which the snap line is anchored.</para>
      </param>
      <param name="from">
        <para>Where the snap line starts.</para>
      </param>
      <param name="to">
        <para>Where the snap line ends.</para>
      </param>
      <param name="snapLinePoint">
        <para>A point of interest on the snap line that can be highlighted.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.AddGridSnapResult(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.IGridConstraintProvider{yWorks.Graph.INode},yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Adds a snap result for a location that snaps to the grid.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectGridSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)" /> for each grid snap.</para>
      </remarks>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectSnapResultsEventArgs" /> instance containing the event data.</para>
      </param>
      <param name="node">
        <para>The node that is being reshaped.</para>
      </param>
      <param name="provider">
        <para>The provider that is associated with the grid snapping.</para>
      </param>
      <param name="gridSnappedPoint">
        <para>The point on the grid that should be highlighted.</para>
      </param>
      <param name="snappedLocation">
        <para>The location of the mouse that is associated with the grid point.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.AddSameSizeSnapResult(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.SnapLineOrientation,System.Collections.Generic.IEnumerable{yWorks.Geometry.RectD},System.Double,System.Double)">
      <summary>
        <para>Adds a snap result for "same size" to the collect event argument.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Controls.Input.NodeReshapeSnapResultProvider.CollectSameSizeSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext,yWorks.Geometry.RectD)" /> for each result found.</para>
      </remarks>
      <param name="context">
        <para>The context in which the snapping is performed.</para>
      </param>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.CollectSnapResultsEventArgs" /> instance containing the event data. This will be used to <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">add</see> the result to.</para>
      </param>
      <param name="node">
        <para>The node that is being reshaped.</para>
      </param>
      <param name="orientation">
        <para>The orientation of the result - indicates whether width or height have been snapped.</para>
      </param>
      <param name="rectangles">
        <para>The rectangles that have the same width or height as the node will - this does not yet includes the rectangle of the node being reshaped.</para>
      </param>
      <param name="finalSize">
        <para>The target size to which the node will snap.</para>
      </param>
      <param name="snapDelta">
        <para>The snap delta that the mouse needs to be moved in order to snap.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.SnapResults">
      <summary>
        <para>Provides factory methods to create various implementations for <see cref="T:yWorks.Controls.Input.SnapResults" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.SnapResults.CreatePointSnapResult(yWorks.Geometry.PointD,System.Double,System.Object,yWorks.Controls.IVisualCreator,yWorks.Controls.Input.SnapTypes)">
      <summary>
        <para>Factory method that creates a <see cref="T:yWorks.Controls.Input.SnapResult" /> that snaps to a given location.</para>
      </summary>
      <param name="location">
        <para>The location to snap to.</para>
      </param>
      <param name="weight">
        <para>The weight to assign to the result.</para>
      </param>
      <param name="tag">
        <para>The tag associated with this result. If more than one result uses the same tag (not <c>null</c>), only the one with the highest <see cref="P:yWorks.Controls.Input.SnapResult.Weight" /> will be rendered.</para>
      </param>
      <param name="visualCreator">
        <para>The visual creator to use.</para>
      </param>
      <param name="snapType">
        <para>The type of the snapping operation to apply.</para>
      </param>
      <returns>
        <para>A result that snaps to the provided location using the provided mode.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.SnapResults.CreateSnapLineSnapResult(System.Double,yWorks.Geometry.PointD,System.Object,yWorks.Controls.Input.SnapLine,yWorks.Geometry.PointD,System.Object)">
      <summary>
        <para>Factory method that creates a <see cref="T:yWorks.Controls.Input.SnapResult" /> which represents a <see cref="T:yWorks.Controls.Input.SnapLine" /> to which the current moved item will potentially snap.</para>
      </summary>
      <param name="weight">
        <para>The weight of this result. The higher the weight, the more important it is.</para>
      </param>
      <param name="delta">
        <para>The value to add to the mouse coordinates to snap to this result.</para>
      </param>
      <param name="tag">
        <para>The tag associated with this result. If more than one result uses the same tag (not <c>null</c>), only the one with the highest <see cref="P:yWorks.Controls.Input.SnapResult.Weight" /> will be rendered.</para>
      </param>
      <param name="snapLine">
        <para>The snap line this class would snap to or <c>null</c> if it doesn't snap to a <c>SnapLine</c>.</para>
      </param>
      <param name="snappedLocation">
        <para>The coordinates at the moved item at which the drawn snap line should end.</para>
      </param>
      <param name="movedObject">
        <para>The moved object for which this result is created.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.SnapResults.CreateResizeSnapResult(System.Double,System.Double,System.Object,System.Collections.Generic.IEnumerable{yWorks.Geometry.IRectangle},System.Double,System.Boolean)">
      <summary>
        <para>Factory method that creates a <see cref="T:yWorks.Controls.Input.SnapResult" /> which snaps to a given size through a resize operation.</para>
      </summary>
      <param name="weight">
        <para>The weight of this result. The higher the weight, the more important it is.</para>
      </param>
      <param name="delta">
        <para>The value to add to the mouse coordinates to snap to this result.</para>
      </param>
      <param name="tag">
        <para>The tag associated with this result. If more than one result uses the same tag (not <c>null</c>), only the one with the highest <see cref="P:yWorks.Controls.Input.SnapResult.Weight" /> will be rendered.</para>
      </param>
      <param name="rectangles">
        <para>The rectangles that have the same width or height as the node will. The rectangle are used for visualization and should include all objects for which a visualization should be displayed. Typically, these are all objects which have the same size and the object which is currently reshaped.</para>
      </param>
      <param name="size">
        <para>The target size to which the resized object will snap.</para>
      </param>
      <param name="horizontal">
        <para>Indicates whether width or height should snap. <c>true</c> if the width should snap.</para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.Controls.Input.SnapResults.CreateLabelSnapResult(yWorks.Graph.LabelModels.ILabelModelParameter,System.Double,yWorks.Geometry.PointD,System.Object,yWorks.Controls.Input.SnapLine,yWorks.Geometry.PointD,System.Object)">
      <summary>
        <para>Factory method that creates a <see cref="T:yWorks.Controls.Input.SnapResult" /> to which a <see cref="T:yWorks.Graph.ILabel" /> will snap, based on the given <paramref name="snapLine" />.</para>
      </summary>
      <param name="layoutParameter">
        <para>The <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> which represents the position to snap to.</para>
      </param>
      <param name="weight">
        <para>The weight of this result. The higher the weight, the more important it is.</para>
      </param>
      <param name="delta">
        <para>The value to add to the mouse coordinates to snap to this result.</para>
      </param>
      <param name="tag">
        <para>The tag associated with this result. If more than one result uses the same tag (not <c>null</c>), only the one with the highest <see cref="P:yWorks.Controls.Input.SnapResult.Weight" /> will be rendered.</para>
      </param>
      <param name="snapLine">
        <para>The snap line this class would snap to or <c>null</c> if it doesn't snap to a <c>SnapLine</c>.</para>
      </param>
      <param name="snappedCoordinates">
        <para>The coordinates at the moved item at which the drawn snap line should end.</para>
      </param>
      <param name="movedObject">
        <para>The moved object for which this result is created.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.StripeDropInputMode">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.ItemDropInputMode`1" /> specialized to drag 'n' drop <see cref="T:yWorks.Graph.IStripe" />s.</para>
      </summary>
      <remarks>
        <para>A dragged <see cref="T:yWorks.Graph.IStripe" /> is optionally visualized during the drag operation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.#ctor">
      <summary>
        <para>Constructs a new instance of class <see cref="T:yWorks.Controls.Input.StripeDropInputMode" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.Cancel" />
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.CreateStripe(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IStripe)">
      <summary>
        <para>Create a new stripe as the result of a drag and drop gesture.</para>
      </summary>
      <remarks>
        <para>This method is called by the <see cref="P:yWorks.Controls.Input.ItemDropInputMode`1.ItemCreator" /> that is set as default on this class.</para>
      </remarks>
      <returns>
        <para>a newly created stripe.</para>
      </returns>
      <param name="newParent">
        <para>The parent for which to create the stripe.</para>
      </param>
      <param name="context">
        <para>The context for which the stripe should be created.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.OnDragDropped(yWorks.Controls.Input.InputModeEventArgs)">
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.OnDragLeft(yWorks.Controls.Input.InputModeEventArgs)">
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.OnDragEntered(yWorks.Controls.Input.InputModeEventArgs)">
      <param name="eventArgs" />
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.PopulatePreviewGraph(yWorks.Graph.IGraph)">
      <param name="previewGraph" />
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.AdjustEffect(System.Windows.Forms.DragEventArgs)">
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.CreatePreviewTable">
      <summary>
        <para>Create a preview version of the table that is temporarily used to show the dragged stripe.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.SetDragLocation(yWorks.Geometry.PointD)">
      <param name="location" />
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.OnStripeCreated(yWorks.Utils.ItemEventArgs{yWorks.Graph.IStripe})">
      <summary>
        <para>Called whenever a new stripe is created</para>
      </summary>
      <param name="args" />
    </member>
    <member name="E:yWorks.Controls.Input.StripeDropInputMode.StripeCreated">
      <summary>
        <para>Occurs when a new stripe gets created by this input mode.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.UpdatePreview(yWorks.Graph.IGraph,yWorks.Geometry.PointD)">
      <param name="previewGraph" />
      <param name="newLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.StripeDropInputMode.GetPreviewTableLayout(yWorks.Geometry.PointD,yWorks.Geometry.SizeD)">
      <summary>
        <para>Calculates the layout of the new table.</para>
      </summary>
      <remarks>
        <para>In this implementation the mouse location is used as center of the table. Can be overridden in child class to implement a different layout.</para>
      </remarks>
      <param name="location">
        <para>Current mouse position</para>
      </param>
      <param name="size">
        <para>Size of the table</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Geometry.RectD" /> with the given size and the mouse location as center.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.StripeReparentPolicy">
      <summary>
        <para>Enumeration for the possible results of a reparent gesture.</para>
      </summary>
      <remarks>
        <para>This enumeration determines where to place the stripe as result of the reparent gesture.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.StripeReparentPolicy.AddChild">
      <summary>
        <para>Add the moved stripe as a new child of the target stripe</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.StripeReparentPolicy.InsertBefore">
      <summary>
        <para>Insert the moved stripe before the target stripe</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.StripeReparentPolicy.InsertAfter">
      <summary>
        <para>Insert the moved stripe after the target stripe</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.StripeReparentPolicy.Invalid">
      <summary>
        <para>The current gesture would result in an invalid operation (such as trying to make a stripe to its own child).</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.TableEditorInputMode">
      <summary>
        <para>Input mode that can be used to interactively edit a table.</para>
      </summary>
      <remarks>
        <para>This mode can either be used as a stand alone input mode, or as a child mode of <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. In that case, some child modes of this implementation are disabled:</para>
        <list type="bullet">
          <item>
            <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ClickInputMode" />
          </item>
          <item>
            <see cref="P:yWorks.Controls.Input.TableEditorInputMode.TextEditorInputMode" />
          </item>
          <item>
            <see cref="P:yWorks.Controls.Input.TableEditorInputMode.KeyboardInputMode" />
          </item>
        </list>
        <para>In addition, the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.StripeSelection">stripe selection</see> is optionally synchronized with the <see cref="P:yWorks.Controls.Input.GraphInputMode.GraphSelection" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.#ctor">
      <summary>
        <para>Default constructor.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.ResizeStripeInputMode">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.ResizeStripeInputMode" /> that is used to change the size of a stripe interactively.</para>
      </summary>
      <remarks>
        <para>The mode by default is <see cref="P:yWorks.Controls.Input.ResizeStripeInputMode.Enabled">enabled</see> with a priority of <c>0</c>. If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateResizeStripeInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.OnResizeStripeInputModeChanged(yWorks.Controls.Input.ResizeStripeInputMode,yWorks.Controls.Input.ResizeStripeInputMode)" /> method will be called.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnResizeStripeInputModeChanged(yWorks.Controls.Input.ResizeStripeInputMode,yWorks.Controls.Input.ResizeStripeInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ResizeStripeInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.CreateResizeStripeInputMode">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ResizeStripeInputMode" /> lazily the first time the property is accessed.</para>
      </summary>
      <returns>
        <para>A plain new instance of the <see cref="T:yWorks.Controls.Input.ResizeStripeInputMode" /> type, which is initially <see cref="P:yWorks.Controls.Input.ResizeStripeInputMode.Enabled">enabled</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.ChildInputModeContextLookup(System.Type)">
      <param name="type" />
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.ReparentStripeHandler">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ReparentStripeHandler" /> property.</para>
      </summary>
      <remarks>
        <para>This handler will be delegated to by an implementation of the <see cref="T:yWorks.Controls.Input.IReparentStripeHandler" /> interface that this class puts into the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.ChildInputModeContextLookup(System.Type)" />. If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateReparentStripeHandler" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.OnReparentStripeHandlerChanged(yWorks.Controls.Input.IReparentStripeHandler,yWorks.Controls.Input.IReparentStripeHandler)" /> method will be called.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.ReparentStripeHandler" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnReparentStripeHandlerChanged(yWorks.Controls.Input.IReparentStripeHandler,yWorks.Controls.Input.IReparentStripeHandler)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ReparentStripeHandler" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldHandler">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newHandler">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.CreateReparentStripeHandler">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ReparentStripeHandler" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ReparentStripeHandler" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="T:yWorks.Controls.Input.IReparentStripeHandler" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.ReparentStripeInputMode">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.ReparentStripeInputMode" /> that is used to change a stripes position in the table hierarchy.</para>
      </summary>
      <remarks>
        <para>The mode by default is <see cref="P:yWorks.Controls.Input.MoveInputMode.Enabled">enabled</see> with a priority of <c>0</c>. If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateReparentStripeInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.OnReparentStripeInputModeChanged(yWorks.Controls.Input.ReparentStripeInputMode,yWorks.Controls.Input.ReparentStripeInputMode)" /> method will be called.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnReparentStripeInputModeChanged(yWorks.Controls.Input.ReparentStripeInputMode,yWorks.Controls.Input.ReparentStripeInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ReparentStripeInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldHandler">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newHandler">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.CreateReparentStripeInputMode">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ReparentStripeInputMode" /> lazily the first time the property is accessed.</para>
      </summary>
      <returns>
        <para>A plain new instance of the <see cref="T:yWorks.Controls.Input.ReparentStripeInputMode" /> type, which is initially <see cref="P:yWorks.Controls.Input.MoveInputMode.Enabled">enabled</see>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.StripeDropInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.StripeDropInputMode" /> property that is responsible for handling drag and drop operations of stripes onto the Canvas.</para>
      </summary>
      <remarks>
        <para>The mode by default is <see cref="P:yWorks.Controls.Input.DropInputMode.Enabled">disabled</see> and needs to be enabled to work, first. If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateStripeDropInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.OnStripeDropInputModeChanged(yWorks.Controls.Input.StripeDropInputMode,yWorks.Controls.Input.StripeDropInputMode)" /> method will be called.</para>
        <para>By default this input mode has a priority of <c>70</c>.</para>
      </remarks>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.CreateStripeDropInputMode">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.StripeDropInputMode" /> lazily the first time the property is accessed.</para>
      </summary>
      <returns>
        <para>A plain new instance of the <see cref="T:yWorks.Controls.Input.StripeDropInputMode" /> type, which is initially <see cref="P:yWorks.Controls.Input.DropInputMode.Enabled">disabled</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnStripeDropInputModeChanged(yWorks.Controls.Input.StripeDropInputMode,yWorks.Controls.Input.StripeDropInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.StripeDropInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.KeyboardInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.KeyboardInputMode" />.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateKeyboardInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.OnKeyboardInputModeChanged(yWorks.Controls.Input.KeyboardInputMode,yWorks.Controls.Input.KeyboardInputMode)" /> method will be called. If the parent <see cref="T:yWorks.Controls.Input.TableEditorInputMode" /> instance is installed as child mode of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance, this mode is <b>not</b> used, since all work is delegated to the parent's <see cref="P:yWorks.Controls.Input.GraphInputMode.KeyboardInputMode" /> instance. This implies that all modifications made to the property value have no effect as long as the parent mode is child of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance.</para>
        <para>By default this input mode has a priority of <c>0</c>.</para>
      </remarks>
      <value>
        <para>The <see cref="P:yWorks.Controls.Input.TableEditorInputMode.KeyboardInputMode" />.</para>
      </value>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.CreateKeyboardInputMode">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.KeyboardInputMode" /> instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnKeyboardInputModeChanged(yWorks.Controls.Input.KeyboardInputMode,yWorks.Controls.Input.KeyboardInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.KeyboardInputMode" /> changed.</para>
      </summary>
      <param name="oldMode">
        <para>The old <see cref="P:yWorks.Controls.Input.TableEditorInputMode.KeyboardInputMode" />.</para>
      </param>
      <param name="newMode">
        <para>The new <see cref="P:yWorks.Controls.Input.TableEditorInputMode.KeyboardInputMode" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.ShouldInstallCommand(yWorks.Controls.ICommand)">
      <summary>
        <para>Callback method that is used by <see cref="M:yWorks.Controls.Input.TableEditorInputMode.OnKeyboardInputModeChanged(yWorks.Controls.Input.KeyboardInputMode,yWorks.Controls.Input.KeyboardInputMode)" /> to determine which of the built-in <see cref="T:yWorks.Controls.ICommand" />s to install.</para>
      </summary>
      <remarks>
        <para>This implementation unconditionally returns <c>true</c>, subclasses may override this method to adjust the behavior.</para>
      </remarks>
      <param name="command">
        <para>The command to install.</para>
      </param>
      <returns>
        <para>Whether to install this command.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.TextEditorInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.TextEditorInputMode" />.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateTextEditorInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.OnTextEditorInputModeChanged(yWorks.Controls.Input.TextEditorInputMode,yWorks.Controls.Input.TextEditorInputMode)" /> method will be called. If the parent <see cref="T:yWorks.Controls.Input.TableEditorInputMode" /> instance is installed as child mode of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance, this mode is <b>not</b> used, since all work is delegated to the parent's <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.TextEditorInputMode" /> instance. This implies that all modifications made to the property value have no effect as long as the parent mode is child of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance.</para>
        <para>By default this input mode has a priority of <c>100</c>.</para>
      </remarks>
      <value>
        <para>The <see cref="P:yWorks.Controls.Input.TableEditorInputMode.TextEditorInputMode" />.</para>
      </value>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnTextEditorInputModeChanged(yWorks.Controls.Input.TextEditorInputMode,yWorks.Controls.Input.TextEditorInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.TextEditorInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.CreateTextEditorInputMode">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.TextEditorInputMode" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.TextEditorInputMode" /> property.</para>
      </remarks>
      <returns>
        <para>a new instance of <see cref="T:yWorks.Controls.Input.TextEditorInputMode" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnEditLabel">
      <summary>
        <para>Callback that is invoked if the F2 key is pressed and <see cref="P:yWorks.Controls.Input.TableEditorInputMode.AllowEditLabel" /> is set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>This method determines the label to edit and delegates to either <see cref="M:yWorks.Controls.Input.TableEditorInputMode.EditLabel(yWorks.Graph.ILabel)" /> or <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateLabel(yWorks.Graph.IStripe)" /> if no label could be found.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnAddLabel">
      <summary>
        <para>Callback that is invoked if the shift+F2 key is pressed and <see cref="P:yWorks.Controls.Input.TableEditorInputMode.AllowAddLabel" /> is set to <c>true</c>.</para>
      </summary>
      <remarks>
        <para>This method determines the label owner to add to and delegates to <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateLabel(yWorks.Graph.IStripe)" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.LabelEditableItems">
      <summary>
        <para>Gets or set a property that determines which types of items may have their <see cref="M:yWorks.Controls.Input.TableEditorInputMode.EditLabel(yWorks.Graph.ILabel)">labels edited</see>.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.StripeTypes.All" /> which allows for editing the labels of all <see cref="T:yWorks.Graph.ILabelOwner" />s, and existing <see cref="T:yWorks.Graph.ILabel" />s.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.TableEditorInputMode.ShouldEditLabel(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.ShouldAddLabel(yWorks.Graph.IModelItem)">
      <summary>
        <para>Predicate that determines whether a label may be added interactively to <paramref name="item" /></para>
      </summary>
      <remarks>
        <para>This is overridden if the item has a <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> that returns <c>false</c> for its <see cref="M:yWorks.Controls.Input.IEditLabelHelper.OnLabelAdding(yWorks.Controls.Input.LabelEditingEventArgs)" /> method.</para>
      </remarks>
      <param name="item">
        <para>The item to query</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff a label may be added</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.ShouldEditLabel(yWorks.Graph.IModelItem)">
      <summary>
        <para>Callback method that determines whether the label or the labels of the provided item should be edited in response to a command or explicit method call to <see cref="M:yWorks.Controls.Input.TableEditorInputMode.EditLabel(yWorks.Graph.ILabel)" /> or <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateLabel(yWorks.Graph.IStripe)" />.</para>
      </summary>
      <param name="item">
        <para>The item.</para>
      </param>
      <returns>
        <para>Whether to edit the label or the labels for that item.</para>
      </returns>
    </member>
    <member name="E:yWorks.Controls.Input.TableEditorInputMode.LabelAdding">
      <summary>
        <para>Occurs when a label is about to be added.</para>
      </summary>
      <remarks>
        <para>Event handlers for this event can customize the behavior for adding a new label extensively. Adding a label can be forbidden entirely, or the properties of the added label can be changed, by setting the appropriate properties on the <see cref="T:yWorks.Controls.Input.LabelEditingEventArgs" />. It is even possible to forbid adding a label, but edit an existing one instead.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnLabelAdding(yWorks.Controls.Input.LabelEditingEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.LabelAdding" /> event.</para>
      </summary>
      <remarks>
        <para>Invoking the event handlers stops once one event marks the <paramref name="args" /> as handled.</para>
      </remarks>
      <param name="args">
        <para>The event arguments.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.TableEditorInputMode.LabelEditing">
      <summary>
        <para>Occurs when a label is about to be edited.</para>
      </summary>
      <remarks>
        <para>Event handlers for this event can customize the behavior for editing an existing label. Editing can be forbidden entirely, or redirected to a different label, even on a different owner. In case editing existing labels is unwanted, event handlers can also specify that instead of editing a label, a new one should be added.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnLabelEditing(yWorks.Controls.Input.LabelEditingEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.LabelEditing" /> event.</para>
      </summary>
      <remarks>
        <para>Invoking the event handlers stops once one event marks the <paramref name="args" /> as handled.</para>
      </remarks>
      <param name="args">
        <para>The event arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnLabelAdded(yWorks.Graph.LabelEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.LabelAdded" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance that contains the <see cref="T:yWorks.Graph.ILabel" /> that has been added.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.TableEditorInputMode.LabelAdded">
      <summary>
        <para>Occurs when this mode has triggered the addition of an <see cref="T:yWorks.Graph.ILabel" />, for instance, in response to <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateLabel(yWorks.Graph.IStripe)" />.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.TableEditorInputMode.LabelTextChanged">
      <summary>
        <para>Occurs when this mode has triggered the edit of an <see cref="T:yWorks.Graph.ILabel" />, for instance, in response to <see cref="M:yWorks.Controls.Input.TableEditorInputMode.EditLabel(yWorks.Graph.ILabel)" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnLabelTextChanged(yWorks.Utils.ItemEventArgs{yWorks.Graph.ILabel})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.LabelTextChanged" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Utils.ItemEventArgs`1" /> instance that contains the <see cref="T:yWorks.Graph.ILabel" /> that has changed the text.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnLabelTextEdited(yWorks.Graph.ILabel,System.String)">
      <summary>
        <para>Called when the text of a label has been <see cref="M:yWorks.Controls.Input.TableEditorInputMode.EditLabel(yWorks.Graph.ILabel)">edited</see>.</para>
      </summary>
      <remarks>
        <para>This method <see cref="E:yWorks.Controls.Input.TableEditorInputMode.ValidateLabelText">validates the label text</see> and if successful sets the label text.</para>
      </remarks>
      <param name="label">
        <para>The label that was edited.</para>
      </param>
      <param name="text">
        <para>The new text.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.TableEditorInputMode.LabelTextEditingStarted">
      <summary>
        <para>Occurs when the actual label editing process is about to start.</para>
      </summary>
      <remarks>
        <para>This allows to customize the actual label editing process further.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.TableEditorInputMode.OnValidateLabelText(yWorks.Controls.Input.LabelTextValidatingEventArgs)" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnLabelTextEditingStarted(yWorks.Graph.LabelEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.LabelTextEditingStarted" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Graph.LabelEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.TableEditorInputMode.LabelTextEditingCanceled">
      <summary>
        <para>Occurs when the actual label editing process is canceled.</para>
      </summary>
      <remarks>
        <para>This allows to revert temporary customizations for the actual label editing process.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.TableEditorInputMode.OnValidateLabelText(yWorks.Controls.Input.LabelTextValidatingEventArgs)" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnLabelTextEditingCanceled(yWorks.Graph.LabelEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.LabelTextEditingCanceled" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Graph.LabelEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnValidateLabelText(yWorks.Controls.Input.LabelTextValidatingEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.ValidateLabelText" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.LabelTextValidatingEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.TableEditorInputMode.ValidateLabelText">
      <summary>
        <para>Occurs after label editing to validate the label text for a label that is about to be added or edited.</para>
      </summary>
      <remarks>
        <para>Note that the <see cref="P:yWorks.Controls.Input.LabelTextValidatingEventArgs.Label" /> may only a dummy instance, i.e. not bound to a live stripe instance.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.TableEditorInputMode.OnValidateLabelText(yWorks.Controls.Input.LabelTextValidatingEventArgs)" />
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.AutoRemoveEmptyLabels">
      <summary>
        <para>Gets or sets a value indicating whether this mode should automatically <see cref="M:yWorks.Graph.ITable.Remove(yWorks.Graph.ILabel)">remove labels</see> from the table when a label text has been edited and the label text is empty.</para>
      </summary>
      <remarks>
        <para>If the <see cref="T:yWorks.Controls.Input.TableEditorInputMode" /> instance is installed as child mode of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance, auto removal is only enabled allowed if both the value of this property and the value of <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AutoRemoveEmptyLabels" /> are <c>true</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if empty labels should be removed after text editing; otherwise, <c>false</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.ClickInputMode">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ClickInputMode" />.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateClickInputMode" /> will be called. Upon change the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.OnClickInputModeChanged(yWorks.Controls.Input.ClickInputMode,yWorks.Controls.Input.ClickInputMode)" /> method will be called. If the parent <see cref="T:yWorks.Controls.Input.TableEditorInputMode" /> instance is installed as child mode of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance, this mode is <b>not</b> used, since all work is delegated to the parent's <see cref="P:yWorks.Controls.Input.GraphInputMode.ClickInputMode" /> instance. This implies that all modifications made to the property value have no effect as long as the parent mode is child of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance.</para>
        <para>By default this input mode has a priority of <c>0</c>.</para>
      </remarks>
      <value>
        <para>The <see cref="P:yWorks.Controls.Input.TableEditorInputMode.TextEditorInputMode" />.</para>
      </value>
      <exception cref="T:System.NotSupportedException">
        <para>If an attempt is made to change the instance while this mode is <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">installed</see>. To exchange a mode, first <see cref="M:yWorks.Controls.Input.IInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)" />, then <see cref="M:yWorks.Controls.Input.IInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">reinstall</see> to ensure that all data is initialized correctly.</para>
      </exception>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnClickInputModeChanged(yWorks.Controls.Input.ClickInputMode,yWorks.Controls.Input.ClickInputMode)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ClickInputMode" /> property value changes and after initialization of the field.</para>
      </summary>
      <param name="oldMode">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newMode">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.CreateClickInputMode">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.KeyboardInputMode" /> instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnClickInputModeClicked(System.Object,yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Callback that gets triggered once <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ClickInputMode" /> triggers the <see cref="E:yWorks.Controls.Input.ClickInputMode.Clicked" /> event.</para>
      </summary>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.ClearSelection">
      <summary>
        <para>Clears the current selection.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Input.TableEditorInputMode.SelectableItems" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.SelectAll">
      <summary>
        <para>Clears the current selection and selects all stripes in all table instances.</para>
      </summary>
      <remarks>
        <para>By default, this method will be called in response to a Ctrl-A-key press recognized by <see cref="P:yWorks.Controls.Input.TableEditorInputMode.KeyboardInputMode" />.</para>
      </remarks>
      <seealso cref="F:yWorks.Controls.Input.Commands.SelectAll" />
      <seealso cref="P:yWorks.Controls.Input.TableEditorInputMode.SelectableItems" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.DeleteSelection">
      <summary>
        <para>This method deletes the currently selected stripes.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.StripeSelection" /> is non-empty this implementation triggers the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.DeletingSelection" /> event, possibly a number of <see cref="E:yWorks.Controls.Input.TableEditorInputMode.DeletedItem" /> events, and a final <see cref="M:yWorks.Controls.Input.TableEditorInputMode.DeleteSelection" /> event.</para>
      </remarks>
      <seealso cref="E:yWorks.Controls.Input.TableEditorInputMode.DeletingSelection" />
      <seealso cref="E:yWorks.Controls.Input.TableEditorInputMode.DeletedItem" />
      <seealso cref="E:yWorks.Controls.Input.TableEditorInputMode.DeletedSelection" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnDeletingSelection(yWorks.Controls.Input.SelectionEventArgs{yWorks.Graph.IStripe})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.DeletingSelection" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.SelectionEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnDeletedItem(yWorks.Utils.ItemEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.DeletedItem" /> event.</para>
      </summary>
      <param name="args">
        <para>The instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnDeletedSelection(yWorks.Controls.Input.SelectionEventArgs{yWorks.Graph.IStripe})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.DeletedSelection" /> event.</para>
      </summary>
      <param name="args">
        <para>The <see cref="T:yWorks.Controls.Input.SelectionEventArgs`1" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="E:yWorks.Controls.Input.TableEditorInputMode.DeletingSelection">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.DeleteSelection" /> method starts its work and will be followed by any number of <see cref="E:yWorks.Controls.Input.TableEditorInputMode.DeletedItem" /> events and finalized by a <see cref="E:yWorks.Controls.Input.TableEditorInputMode.DeletedSelection" /> event.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.TableEditorInputMode.DeleteSelection" />
    </member>
    <member name="E:yWorks.Controls.Input.TableEditorInputMode.DeletedItem">
      <summary>
        <para>Occurs when an item has been deleted interactively by this mode.</para>
      </summary>
    </member>
    <member name="E:yWorks.Controls.Input.TableEditorInputMode.DeletedSelection">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.DeleteSelection" /> method has deleted the selection after all selected items have been removed.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.TableEditorInputMode.DeleteSelection" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.DeleteStripe(yWorks.Graph.IStripe)">
      <summary>
        <para>Deletes a single stripe</para>
      </summary>
      <param name="stripe">
        <para>The stripe to delete.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.DeletableItems">
      <summary>
        <para>Gets or set a property that determines which types of items may be deleted using the <see cref="M:yWorks.Controls.Input.TableEditorInputMode.DeleteSelection" /> action.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.TableEditorInputMode.ShouldDelete(yWorks.Graph.IStripe)" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.ShouldDelete(yWorks.Graph.IStripe)">
      <summary>
        <para>Callback method that determines whether the given item should be deleted during <see cref="M:yWorks.Controls.Input.TableEditorInputMode.DeleteSelection" />.</para>
      </summary>
      <remarks>
        <para>This implementation deletes an item if it is of one of the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.DeletableItems" /> type and if it is not the last stripe of a given type in the table (e.g. the only row or the only column).</para>
      </remarks>
      <param name="stripe">
        <para>The item.</para>
      </param>
      <returns>
        <para>Whether to delete that item.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.SelectableItems">
      <summary>
        <para>Gets or set a property that determines which types of items should be selectable at all.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.StripeTypes.All" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" />
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.ClickSelectableItems">
      <summary>
        <para>Gets or set a property that determines which types of items should be selectable through <see cref="M:yWorks.Controls.Input.TableEditorInputMode.OnClickInputModeClicked(System.Object,yWorks.Controls.Input.ClickEventArgs)">mouse clicks.</see>.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Graph.StripeTypes.All" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphInputMode.SetSelected(yWorks.Graph.IModelItem,System.Boolean)" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.OnClickInputModeDoubleClicked(System.Object,yWorks.Controls.Input.ClickEventArgs)">
      <summary>
        <para>Callback that gets triggered once <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ClickInputMode" /> triggers the <see cref="E:yWorks.Controls.Input.ClickInputMode.DoubleClicked" /> event.</para>
      </summary>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.AllowEditLabel">
      <summary>
        <para>Gets or sets whether the label editor will be automatically invoked if the F2 key is pressed.</para>
      </summary>
      <remarks>
        <para>If the <see cref="T:yWorks.Controls.Input.TableEditorInputMode" /> instance is installed as child mode of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance, editing a label is only allowed if both the value of this property and the value of <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowEditLabel" /> are <c>true</c>. If label editing is allowed, pressing F2 will start the label editor. By default this feature is enabled.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.TableEditorInputMode.EditLabel(yWorks.Graph.ILabel)" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.EditLabel(yWorks.Graph.ILabel)">
      <summary>
        <para>Starts editing of the given label.</para>
      </summary>
      <remarks>
        <para>The label must be bound to an <see cref="T:yWorks.Graph.IStripe" /> instance for this call to succeed.</para>
        <para>This implementation uses the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.TextEditorInputMode" /> to display an editor to edit the label. The text that the user enters may be <see cref="E:yWorks.Controls.Input.TableEditorInputMode.ValidateLabelText">validated</see> before the label is actually edited.</para>
        <para>This method will raise the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.LabelEditing" /> event and query the <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> for the label and its owner, but will ignore the result except for the <see cref="P:yWorks.Controls.Input.LabelEditingEventArgs.TextEditorInputModeConfigurator" /> property on the <see cref="T:yWorks.Controls.Input.LabelEditingEventArgs" />. Thus editing a label via this method cannot be prevented by event handlers or <see cref="T:yWorks.Controls.Input.IEditLabelHelper" />s.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.TableEditorInputMode.OnLabelTextEdited(yWorks.Graph.ILabel,System.String)" />
      <param name="label">
        <para>The label to edit.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.AllowAddLabel">
      <summary>
        <para>Gets or sets whether the label editor will be automatically invoked if the Shift+F2 key is pressed.</para>
      </summary>
      <remarks>
        <para>If the <see cref="T:yWorks.Controls.Input.TableEditorInputMode" /> instance is installed as child mode of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance, adding a label is only allowed if both the value of this property and the value of <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowAddLabel" /> are <c>true</c>. If label adding is allowed, <c>true</c> pressing Shift+F2 will start the label editor. By default this feature is enabled.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateLabel(yWorks.Graph.IStripe)" />
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.CreateLabel(yWorks.Graph.IStripe)">
      <summary>
        <para>Interactively creates a new label for the provided stripe.</para>
      </summary>
      <remarks>
        <para>This method will invoke the text editor that will let the user edit the text of the label. If the user commits the label text the label will be added to the label owner.</para>
        <para>The text that the user enters may be <see cref="E:yWorks.Controls.Input.TableEditorInputMode.ValidateLabelText">validated</see> before the label is actually added.</para>
        <para>This method is similar to <see cref="M:yWorks.Controls.Input.TableEditorInputMode.AddLabel(yWorks.Graph.ILabelOwner)" />. It differs only when either the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.LabelAdding" /> event is handled or the <paramref name="stripe" /> has an <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> requests editing an existing label instead of creating a new one. In both cases, this method will do nothing and neither adds a new label nor edits an existing one.</para>
      </remarks>
      <param name="stripe">
        <para>The item to create a new label for.</para>
      </param>
      <returns>
        <para>A future of the label that will be notified of the newly created label or a <c>null</c> if the creation was canceled.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.AddLabel(yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Adds a new label to the given stripe interactively.</para>
      </summary>
      <remarks>
        <para>This will activate the <see cref="P:yWorks.Controls.Input.TableEditorInputMode.TextEditorInputMode" /> to let the user interactively enter the label's text and unless the user cancels label creation the returned <see cref="T:yWorks.Utils.Future`1" /> will contain the label.</para>
        <para>The text that the user enters may be <see cref="E:yWorks.Controls.Input.TableEditorInputMode.ValidateLabelText">validated</see> before the label is actually added.</para>
        <para>This method is similar to <see cref="M:yWorks.Controls.Input.TableEditorInputMode.CreateLabel(yWorks.Graph.IStripe)" />. It differs only when either the <see cref="E:yWorks.Controls.Input.TableEditorInputMode.LabelAdding" /> event is handled or the <paramref name="owner" /> has an <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> requests editing an existing label instead of creating a new one. In this case, this method will edit that label instead of adding a new one.</para>
      </remarks>
      <param name="owner">
        <para>The item.</para>
      </param>
      <returns>
        <para>A future of the label that will be notified of the newly created label or a <c>null</c> if the creation was canceled.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.MultiSelectionRecognizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that will be queried to decide if a click is deemed a multi selection gesture.</para>
      </summary>
      <remarks>
        <para>The default is <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlPressed" />. If the <see cref="T:yWorks.Controls.Input.TableEditorInputMode" /> instance is installed as child mode of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance, the value of <see cref="P:yWorks.Controls.Input.GraphInputMode.MultiSelectionRecognizer" /> is used instead.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.ClickSelectableRegions">
      <summary>
        <para>Gets or sets clicks on which <see cref="T:yWorks.Controls.Input.StripeSubregionTypes" />(s) should toggle a stripe selection state.</para>
      </summary>
      <remarks>
        <para>This is independent to <see cref="P:yWorks.Controls.Input.TableEditorInputMode.ClickSelectableItems" />. By default, only clicks on a stripe <see cref="F:yWorks.Controls.Input.StripeSubregionTypes.Header" /> are handled.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.SynchronizeWithGraphSelection">
      <summary>
        <para>Gets or sets a value indicating whether <see cref="P:yWorks.Controls.Input.TableEditorInputMode.StripeSelection" /> should be synchronized with the <see cref="P:yWorks.Controls.Input.GraphInputMode.GraphSelection" /> if this instance is installed as a child of a <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> instance.</para>
      </summary>
      <remarks>
        <para>This feature needs to be disabled temporarily if the <see cref="P:yWorks.Controls.GraphControl.Selection" /> is changed.</para>
        <para>By default, this feature is enabled.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.AllowMixedSelection">
      <summary>
        <para>Gets or sets whether to allow mixed selections of graph elements and table elements</para>
      </summary>
      <remarks>
        <para>Default is <c>true</c>. Changing this property only has an effetc if <see cref="P:yWorks.Controls.Input.TableEditorInputMode.SynchronizeWithGraphSelection" /> is enabled.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.Uninstall(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="P:yWorks.Controls.Input.TableEditorInputMode.StripeSelection">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.IStripeSelection">selected stripes</see></para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.CreateStripeSelection">
      <summary>
        <para>Create a new instance of <see cref="T:yWorks.Controls.IStripeSelection" /> the first time property <see cref="P:yWorks.Controls.Input.TableEditorInputMode.StripeSelection" /> is accessed.</para>
      </summary>
      <remarks>
        <para>By default, the <see cref="P:yWorks.Controls.IStripeSelection.AllowMixedSelection" /> property is <c>false</c>.</para>
      </remarks>
      <returns>
        <para>A new <see cref="T:yWorks.Controls.IStripeSelection" /> instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.FindStripe(yWorks.Geometry.PointD,yWorks.Graph.StripeTypes,yWorks.Controls.Input.StripeSubregionTypes,System.Predicate{yWorks.Controls.Input.StripeSubregion})">
      <summary>
        <para>Used as a callback to find the items underneath a certain point.</para>
      </summary>
      <param name="location">
        <para>The location to test.</para>
      </param>
      <param name="stripeTypes">
        <para>An enumeration value of <see cref="T:yWorks.Graph.StripeTypes" /> to specify the stripe type.</para>
      </param>
      <param name="subregionTypes">
        <para>An enumeration value of <see cref="T:yWorks.Controls.Input.StripeSubregionTypes" /> to further restrict the stripe region.</para>
      </param>
      <param name="filter">
        <para>Additional predicate to further restrict the hit test results.</para>
      </param>
      <returns>
        <para>The stripe subregions that have been found for the location or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.FindStripes(yWorks.Geometry.PointD,yWorks.Graph.StripeTypes,yWorks.Controls.Input.StripeSubregionTypes,System.Predicate{yWorks.Controls.Input.StripeSubregion})">
      <summary>
        <para>Used as a callback to find the items underneath a certain point.</para>
      </summary>
      <param name="location">
        <para>The location to test.</para>
      </param>
      <param name="stripeTypes">
        <para>An enumeration value of <see cref="T:yWorks.Graph.StripeTypes" /> to specify the stripe type.</para>
      </param>
      <param name="subregionTypes">
        <para>An enumeration value of <see cref="T:yWorks.Controls.Input.StripeSubregionTypes" /> to further restrict the stripe region.</para>
      </param>
      <param name="filter">
        <para>Additional predicate to further restrict the hit test results.</para>
      </param>
      <returns>
        <para>The stripe subregions that have been found for the location.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.InsertChild(yWorks.Graph.IStripe,System.Int32,System.Nullable{System.Double})">
      <summary>
        <para>Convenience method that inserts a new stripe as child of <paramref name="owner" /></para>
      </summary>
      <remarks>
        <para>This method automatically resizes the table node and moves all content in neighboring stripes accordingly. The stripe is created with an initial <paramref name="size" /> and otherwise the default settings of the table where <paramref name="owner" /> belongs to. If <paramref name="size" /> is entered as <c>0</c>, the owners default size is used.</para>
      </remarks>
      <param name="owner">
        <para>The parent of the new stripe.</para>
      </param>
      <param name="index">
        <para>The index where to insert the new stripe.</para>
      </param>
      <param name="size">
        <para>The initial size of the stripe</para>
      </param>
      <returns>
        <para>A new stripe at the given index.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.Initialize" />
    <member name="M:yWorks.Controls.Input.TableEditorInputMode.Install(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.ConcurrencyController)">
      <param name="context" />
      <param name="controller" />
    </member>
    <member name="T:yWorks.Controls.Input.TableReshapeHandler">
      <summary>
        <para>
          <see cref="T:yWorks.Controls.Input.IReshapeHandler" /> implementation that constrains node resizes so that minimum size constraints of an associated <see cref="T:yWorks.Graph.ITable" /> are satisfied and which resizes the outer <see cref="T:yWorks.Graph.IStripe" />s of such a table when the node is resized.</para>
      </summary>
      <remarks>
        <para>The constraints are applied in addition to any constraints imposed by the <see cref="T:yWorks.Controls.Input.IReshapeHandler" /> which is wrapped by this implementation.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.TableReshapeHandler.CoreHandler">
      <summary>
        <para>Gets the core reshape handler wrapped by this instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.TableReshapeHandler.TableNode">
      <summary>
        <para>Gets the node this handler is used for.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.TableReshapeHandler.Table">
      <summary>
        <para>Gets the table used for additional constraints.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.TableReshapeHandler.#ctor(yWorks.Controls.Input.IReshapeHandler,yWorks.Graph.INode,yWorks.Graph.ITable)">
      <summary>
        <para>Creates a new instance of this Handler which wraps an existing instance of <paramref name="coreHandler" /> and uses <paramref name="table" /> for additional constraints.</para>
      </summary>
      <remarks>
        <para>In addition, <paramref name="table" />'s outer stripes are resized if necessary.</para>
        <para>
          <paramref name="table" /> should be associated to <paramref name="tableNode" /></para>
      </remarks>
      <param name="coreHandler">
        <para>The handler that is wrapped by this instance.</para>
      </param>
      <param name="tableNode">
        <para>The node for which this handler is used</para>
      </param>
      <param name="table">
        <para>The table that is used for additional constraints.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.TableReshapeHandler.InitializeReshape(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.TableReshapeHandler.HandleReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="originalBounds" />
      <param name="newBounds" />
    </member>
    <member name="M:yWorks.Controls.Input.TableReshapeHandler.CancelReshape(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="originalBounds" />
    </member>
    <member name="M:yWorks.Controls.Input.TableReshapeHandler.ReshapeFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="originalBounds" />
      <param name="newBounds" />
    </member>
    <member name="T:yWorks.GraphML.KeyType">
      <summary>
        <para>Enumeration for the allowed data types of a graphml attribute.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyType.Int">
      <summary>
        <para>Identifier for attribute of type <c>int</c>.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyType.Long">
      <summary>
        <para>Identifier for attribute of type <c>long</c>.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyType.Float">
      <summary>
        <para>Identifier for attribute of type <c>float</c>.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyType.Double">
      <summary>
        <para>Identifier for attribute of type <c>double</c>.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyType.String">
      <summary>
        <para>Identifier for attribute of type <c>string</c> that denotes simple string content as opposed to <see cref="F:yWorks.GraphML.KeyType.Complex" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyType.Boolean">
      <summary>
        <para>Identifier for attribute of type <c>boolean</c>.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyType.Complex">
      <summary>
        <para>Identifier for arbitrary complex xml content</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.KeyScope">
      <summary>
        <para>Enumeration for the possible scopes of a graphml attribute.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyScope.All">
      <summary>
        <para>Unscoped for key definition</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyScope.Node">
      <summary>
        <para>Node-Scope for key definition.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyScope.Edge">
      <summary>
        <para>Edge-Scope for key definition.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyScope.Graph">
      <summary>
        <para>Graph-Scope for key definition.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyScope.Port">
      <summary>
        <para>Port-Scope for key definition.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.KeyScope.Graphml">
      <summary>
        <para>Graphml-Scope for key definition.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.GraphMLIOHandler">
      <summary>
        <para>Class for reading/writing graphs from/to GraphML format.</para>
      </summary>
      <remarks>
        <para>For more information about the GraphML file format please refer to the <a href="http://graphml.graphdrawing.org/primer/graphml-primer.html" target="_blank">GraphML Primer</a>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.GraphMLIOHandler.WriteXMLSchema">
      <summary>
        <para>Gets or sets whether schema descriptions should be written.</para>
      </summary>
      <value>
        <para>Default is <c>true</c></para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.GraphMLIOHandler.WriteSharedReferences">
      <summary>
        <para>Gets or sets whether to support object sharing on output.</para>
      </summary>
      <remarks>
        <para>If enabled, multiple object references will be correctly represented in the output document, otherwise, each object reference will be serialized independently.</para>
        <para>
          <b>Note: Reading</b> of shared references is always supported</para>
      </remarks>
      <value>
        <para>Default value is <c>true</c></para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.GraphMLIOHandler.ClearGraphBeforeRead">
      <summary>
        <para>Gets or sets whether to clear an existing graph instance before reading</para>
      </summary>
      <remarks>
        <para>If set to<c>true</c>, an existing graph instance will be cleared before the graph is read into this instance, otherwise the loaded graph will be merged into the existing one.</para>
      </remarks>
      <value>
        <para>Default value is <c>true</c></para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.GraphML.GraphMLIOHandler" />.</para>
      </summary>
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.OverrideResolveReference">
      <summary>
        <para>Occurs before inline references are evaluated.</para>
      </summary>
      <remarks>
        <para>Subscribe to this event to customize resolving of GraphML object references. This event is fired before the framework tries to resolve internal references and can therefore be used to override internal references, for example.</para>
      </remarks>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.ResolveReference" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.ResolveReference">
      <summary>
        <para>Occurs after references are evaluated.</para>
      </summary>
      <remarks>
        <para>Subscribe to this event to customize resolving of GraphML object references. This event is fired when the framework could not resolve an object reference by an internal one.</para>
      </remarks>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.OverrideResolveReference" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.QueryReferenceId">
      <summary>
        <para>Occurs when a reference is queried.</para>
      </summary>
      <remarks>
        <para>This event can be used to provide names of external or internal references for objects.</para>
        <para>The reference targets are not serialized to the GraphML file if they are set to <see cref="F:yWorks.GraphML.GraphMLReferenceType.External" />. To resolve these references when parsing, you typically have to subscribe to the <see cref="E:yWorks.GraphML.GraphMLIOHandler.ResolveReference" /> event.</para>
      </remarks>
      <seealso cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceId" />
      <seealso cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceType" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnResolveReference(yWorks.GraphML.ResolveReferenceEventArgs)">
      <summary>
        <para>Fires the <see cref="E:yWorks.GraphML.GraphMLIOHandler.ResolveReference" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments that get passed to the <see cref="E:yWorks.GraphML.GraphMLIOHandler.ResolveReference" /> event.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnOverrideResolveReference(yWorks.GraphML.ResolveReferenceEventArgs)">
      <summary>
        <para>Fires the <see cref="E:yWorks.GraphML.GraphMLIOHandler.OverrideResolveReference" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments that get passed to the <see cref="E:yWorks.GraphML.GraphMLIOHandler.OverrideResolveReference" /> event.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnQueryReferenceId(yWorks.GraphML.QueryReferenceIdEventArgs)">
      <summary>
        <para>Fires the <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryReferenceId" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments that get passed to the <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryReferenceId" /> event.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLWriter.OnQueryReferenceId(yWorks.GraphML.QueryReferenceIdEventArgs)" />
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>args</c> is null.</para>
      </exception>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddNamespace(System.String,System.String)">
      <summary>
        <para>Adds a namespace to the header of a GraphML file.</para>
      </summary>
      <param name="namespaceURI">
        <para>The namespace URI</para>
      </param>
      <param name="shortName">
        <para>The namespace prefix</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddSchemaLocation(System.String,System.String)">
      <summary>
        <para>Adds a schema location to the header of a GraphML file.</para>
      </summary>
      <param name="schemaNamespace">
        <para>The namespace URI for this schema location</para>
      </param>
      <param name="schemaLocation">
        <para>The schema location</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.Write(yWorks.Graph.IGraph,System.IO.Stream,System.Text.Encoding)">
      <summary>
        <para>Writes the given graph object to the output stream creating a GraphML file.</para>
      </summary>
      <param name="graph">
        <para>The Graph object that is to be written to a GraphML file.</para>
      </param>
      <param name="os">
        <para>The output stream where the output is written.</para>
      </param>
      <param name="encoding">
        <para>The encoding that should be used for writing</para>
      </param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>graph</c> is null.</para>
      </exception>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>os</c> is null.</para>
      </exception>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.Write(yWorks.Graph.IGraph,System.IO.TextWriter)">
      <summary>
        <para>Writes the given graph object to the output writer creating a GraphML file.</para>
      </summary>
      <param name="graph">
        <para>The Graph object that is to be written to a GraphML file.</para>
      </param>
      <param name="os">
        <para>The text writer where the output is written.</para>
      </param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>graph</c> is null.</para>
      </exception>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>os</c> is null.</para>
      </exception>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.Write(yWorks.Graph.IGraph,System.String)">
      <summary>
        <para>Writes the given graph object to a GraphML file with a given filename.</para>
      </summary>
      <param name="graph">
        <para>The Graph object that is to be written to a GraphML file.</para>
      </param>
      <param name="filename">
        <para>The filename where the output is written.</para>
      </param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>graph</c> is null.</para>
      </exception>
      <exception cref="T:System.ArgumentException">
        <para>Need a non-empty filename</para>
      </exception>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddOutputMapper``2(System.String,yWorks.Graph.IMapper{``0,``1})">
      <summary>
        <para>Register a <see cref="T:yWorks.Graph.IMapper`2" /> instance for use as an output data source</para>
      </summary>
      <remarks>
        <para>This methods creates and configures the necessary handler itself</para>
      </remarks>
      <typeparam name="TModelItem">
        <para>The type of the mapper keys</para>
      </typeparam>
      <typeparam name="TValue">
        <para>The type of the mapper values</para>
      </typeparam>
      <param name="name">
        <para>The name of the attribute</para>
      </param>
      <param name="mapper">
        <para>the mapper that serves as data source</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddOutputMapper``2(System.String,System.String,yWorks.Graph.IMapper{``0,``1},System.EventHandler{yWorks.GraphML.HandleSerializationEventArgs},yWorks.GraphML.KeyType)">
      <summary>
        <para>Register a <see cref="T:yWorks.Graph.IMapper`2" /> instance for use as an output data source.</para>
      </summary>
      <remarks>
        <para>This method uses a custom <see cref="T:System.EventHandler`1" /> for the actual serialization.</para>
        <para>This methods creates and configures the necessary handler itself.</para>
      </remarks>
      <typeparam name="TModelItem">
        <para>The type of the mapper keys</para>
      </typeparam>
      <typeparam name="TValue">
        <para>The type of the mapper values</para>
      </typeparam>
      <param name="name">
        <para>The name of the attribute</para>
      </param>
      <param name="uri">
        <para>The URI to add to the key definition to disambiguate keys.</para>
      </param>
      <param name="mapper">
        <para>the mapper that serves as data source</para>
      </param>
      <param name="serializationCallback">
        <para>custom serialization callback.</para>
      </param>
      <param name="declaredKeyType">
        <para>The key type to write in the declaration.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddRegistryOutputMapper(System.String,System.Object)">
      <summary>
        <para>Use a registered <see cref="T:yWorks.Graph.IMapper`2" /> instance as source for the given GraphML attribute.</para>
      </summary>
      <remarks>
        <para>The type arguments of the mapper are determined automatically.</para>
      </remarks>
      <param name="name">
        <para>The GraphML name of the attribute</para>
      </param>
      <param name="tag">
        <para>The tag name of the mapper in the <see cref="T:yWorks.Graph.IMapperRegistry" /></para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddRegistryOutputMapper(System.String,System.String,System.Object,System.EventHandler{yWorks.GraphML.HandleSerializationEventArgs})">
      <summary>
        <para>Use a registered <see cref="T:yWorks.Graph.IMapper`2" /> instance as source for the given GraphML attribute.</para>
      </summary>
      <remarks>
        <para>The type arguments of the mapper are determined automatically.</para>
      </remarks>
      <param name="name">
        <para>The GraphML name of the attribute</para>
      </param>
      <param name="uri">
        <para>The optional URI of the attribute</para>
      </param>
      <param name="tag">
        <para>The tag name of the mapper in the <see cref="T:yWorks.Graph.IMapperRegistry" /></para>
      </param>
      <param name="serializationCallback">
        <para>An optional serialization handler</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddRegistryOutputMapper``2(System.String,System.Object)">
      <summary>
        <para>Use a registered <see cref="T:yWorks.Graph.IMapper`2" /> instance as source for the given GraphML attribute.</para>
      </summary>
      <param name="name">
        <para>The GraphML name of the attribute</para>
      </param>
      <param name="tag">
        <para>The tag name of the mapper in the <see cref="T:yWorks.Graph.IMapperRegistry" /></para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddRegistryOutputMapper``2(System.String,System.String,System.Object,System.EventHandler{yWorks.GraphML.HandleSerializationEventArgs},yWorks.GraphML.KeyType)">
      <summary>
        <para>Use a registered <see cref="T:yWorks.Graph.IMapper`2" /> instance as source for the given GraphML attribute.</para>
      </summary>
      <param name="name">
        <para>The GraphML name of the attribute</para>
      </param>
      <param name="uri">
        <para>The URI to add to the key definition to disambiguate keys.</para>
      </param>
      <param name="tag">
        <para>The tag name of the mapper in the <see cref="T:yWorks.Graph.IMapperRegistry" /></para>
      </param>
      <param name="serializationCallback">
        <para>custom serialization callback.</para>
      </param>
      <param name="declaredKeyType">
        <para>The key type to write in the declaration.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateMapperOutputHandler``2(System.String,yWorks.Graph.IMapper{``0,``1},System.EventHandler{yWorks.GraphML.HandleSerializationEventArgs})">
      <summary>
        <para>Convenience factory method that can create an instance of several predefined <see cref="T:yWorks.GraphML.IOutputHandler" /> implementations that match the provided <typeparamref name="TKey" /> and <typeparamref name="TData" />.</para>
      </summary>
      <typeparam name="TKey">
        <para>The type of the mapper keys</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the mapper entries</para>
      </typeparam>
      <param name="name">
        <para>The name of the graphml attribute</para>
      </param>
      <param name="mapper">
        <para>The mapper to use.</para>
      </param>
      <param name="serializationCallback">
        <para>Optional serialization callback for complex data.</para>
      </param>
      <returns>
        <para>A suitable <see cref="T:yWorks.GraphML.MapperOutputHandler`2" /> implementation</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateGraphMLWriter(yWorks.Graph.IGraph)">
      <summary>
        <para>Create and configure a new <see cref="T:yWorks.GraphML.GraphMLWriter" /> that is used for writing <paramref name="graph" />.</para>
      </summary>
      <remarks>
        <para>This method is called for each write process. It delegates the configuration of the writer to <see cref="M:yWorks.GraphML.GraphMLIOHandler.ConfigureGraphMLWriter(yWorks.GraphML.GraphMLWriter,yWorks.Graph.IGraph)" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph that will be written.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.GraphML.GraphMLWriter" /> instance that is configured for <paramref name="graph" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureGraphMLWriter(yWorks.GraphML.GraphMLWriter,yWorks.Graph.IGraph)">
      <summary>
        <para>Configures a given <see cref="T:yWorks.GraphML.GraphMLWriter" /> that is used for writing <paramref name="graph" />.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.GraphML.GraphMLIOHandler.CreateGraphMLWriter(yWorks.Graph.IGraph)" />.</para>
      </remarks>
      <param name="writer">
        <para>The writer to configure</para>
      </param>
      <param name="graph">
        <para>The graph that will be written.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnWritten(yWorks.GraphML.WriteEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.Written" /> event.</para>
      </summary>
      <remarks>
        <para>This method is called just after the writing finishes and after <see cref="E:yWorks.GraphML.IWriteEvents.DocumentWritten" /> is called.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.GraphML.WriteEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.Written" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.Written">
      <summary>
        <para>Occurs when the writing of a document has been finished.</para>
      </summary>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.OnWritten(yWorks.GraphML.WriteEventArgs)" />
      <seealso cref="E:yWorks.GraphML.GraphMLWriter.Written" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnWriting(yWorks.GraphML.WriteEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.Writing" /> event.</para>
      </summary>
      <remarks>
        <para>This method is called just before the writing starts and before <see cref="E:yWorks.GraphML.IWriteEvents.DocumentWriting" /> is called.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.GraphML.WriteEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.Writing" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.Writing">
      <summary>
        <para>Occurs when the writing of a document is just about to begin.</para>
      </summary>
      <remarks>
        <para>This event can be used to register to the fine-grained events available in the <see cref="P:yWorks.GraphML.WriteEventArgs.Context" />'s <see cref="P:yWorks.GraphML.IWriteContext.WriteEvents" /> and to configure the writing process on a per write case.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.OnWriting(yWorks.GraphML.WriteEventArgs)" />
      <seealso cref="E:yWorks.GraphML.GraphMLWriter.Writing" />
    </member>
    <member name="P:yWorks.GraphML.GraphMLIOHandler.SerializationPropertyOverrides">
      <summary>
        <para>Gets the mapper for the overrides of the serialization properties.</para>
      </summary>
      <remarks>
        <para>Using this mapper <see cref="M:yWorks.GraphML.IWriteContext.GetSerializationProperty``1(yWorks.GraphML.TypedKey{``0})">serialization properties</see> can be specified.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.ConfigureSerializationPropertyOverrides(yWorks.GraphML.GraphMLWriter)" />
    </member>
    <member name="P:yWorks.GraphML.GraphMLIOHandler.DeserializationPropertyOverrides">
      <summary>
        <para>Gets the mapper for the overrides of the deserialization properties.</para>
      </summary>
      <remarks>
        <para>Using this mapper <see cref="M:yWorks.GraphML.IParseContext.GetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0})">deserialization properties</see> can be specified.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.ConfigureDeserializationPropertyOverrides(yWorks.GraphML.GraphMLParser)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateDefaultValueSerializerContext(System.Object,System.ComponentModel.IContainer,System.ComponentModel.PropertyDescriptor)">
      <summary>
        <para>Creates the default value serializer context and returns it.</para>
      </summary>
      <remarks>
        <para>This factory method can be used to provide custom <see cref="T:System.Windows.Markup.ValueSerializer" />s in cases where no <see cref="T:System.Windows.Markup.ValueSerializerAttribute" /> can be used.</para>
      </remarks>
      <returns>
        <para>An implementation of the <see cref="T:System.Windows.Markup.IValueSerializerContext" /> interface.</para>
      </returns>
      <param name="instance" />
      <param name="container" />
      <param name="property" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureLookup(yWorks.Graph.IGraph,yWorks.GraphML.GraphMLWriter)">
      <summary>
        <para>Configure the lookup map of <paramref name="writer" />.</para>
      </summary>
      <remarks>
        <para>This method is called for each write process.</para>
      </remarks>
      <param name="graph">
        <para>The graph that will be written.</para>
      </param>
      <param name="writer">
        <para>The writer to configure.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLWriter.SetLookup``1(``0)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureSerializationProperties(yWorks.Graph.IGraph,yWorks.GraphML.GraphMLWriter)">
      <summary>
        <para>Configure important serialization properties from properties of <see cref="T:yWorks.GraphML.GraphMLIOHandler" />.</para>
      </summary>
      <remarks>
        <para>This method is called for each write process.</para>
      </remarks>
      <param name="graph">
        <para>The graph to write.</para>
      </param>
      <param name="writer">
        <para>The writer to configure.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLWriter.SetSerializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureSerializationPropertyOverrides(yWorks.GraphML.GraphMLWriter)">
      <summary>
        <para>Configures the <see cref="P:yWorks.GraphML.GraphMLIOHandler.SerializationPropertyOverrides">serialization property overrides</see> for the given writer.</para>
      </summary>
      <remarks>
        <para>This method is called for each write process.</para>
      </remarks>
      <param name="writer">
        <para>The writer to set the serialization properties.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureDeserializationPropertyOverrides(yWorks.GraphML.GraphMLParser)">
      <summary>
        <para>Configures the <see cref="P:yWorks.GraphML.GraphMLIOHandler.DeserializationPropertyOverrides">deserialization property overrides</see> for the given parser.</para>
      </summary>
      <remarks>
        <para>This method is called for each parse process.</para>
      </remarks>
      <param name="parser">
        <para>The parser to set the deserialization properties.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateXamlNameMapper">
      <summary>
        <para>Configure mappings from CLR to XML names.</para>
      </summary>
      <remarks>
        <para>This implementation scans all loaded assemblies for <see cref="T:System.Windows.Markup.XmlnsDefinitionAttribute" />s and returns a suitable instance of <see cref="T:yWorks.GraphML.IXamlNameMapper" />.</para>
        <para>This method is called for each read or write process.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddXamlNamespaceMapping(System.String,System.String,System.Type)">
      <summary>
        <para>Add a namespace mapping between a fully qualified XML name (consisting of <paramref name="xmlNamespace" /> and <paramref name="tagName" /> and a type.</para>
      </summary>
      <remarks>
        <para>Either of <paramref name="xmlNamespace" /> or <paramref name="tagName" /> may be <c>null</c>, meaning that the default rules for determining the namespace and/or tag name of <paramref name="type" /> are used.</para>
        <para>This is used both for writing and parsing objects.</para>
      </remarks>
      <param name="xmlNamespace">
        <para>The XML namespace that corresponds to <paramref name="type" />. If <c>null</c>, the namespace will be determined based on the C# namespace that contains <paramref name="type" /></para>
      </param>
      <param name="tagName">
        <para>The XML tag name that corresponds to <paramref name="type" />. If <c>null</c>, the name will be determined from the type name automatically.</para>
      </param>
      <param name="type">
        <para>The type that is mapped to the fully qualified XML name.</para>
      </param>
      <seealso cref="T:yWorks.GraphML.IXamlNameMapper" />
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.CreateXamlNameMapper" />
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.AddXamlNamespaceMapping(System.String,System.String,System.Type)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddXamlNamespaceMapping(System.String,System.String,System.Reflection.Assembly)">
      <summary>
        <para>Add a namespace mapping between an XML namespace and a CLR namespace.</para>
      </summary>
      <remarks>
        <para>This is used both for writing and parsing objects.</para>
      </remarks>
      <param name="xmlNamespace">
        <para>The XML namespace that corresponds to <paramref name="clrNamespaceName" />.</para>
      </param>
      <param name="clrNamespaceName">
        <para>The module that is mapped to the namespace.</para>
      </param>
      <param name="assembly">
        <para>The assembly which contains the namespace to map.</para>
      </param>
      <seealso cref="T:yWorks.GraphML.IXamlNameMapper" />
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.CreateXamlNameMapper" />
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.AddXamlNamespaceMapping(System.String,System.String,System.Type)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddXamlNamespaceMapping(System.String,System.Type)">
      <summary>
        <para>Add a namespace mapping between an XML namespace and the CLR namespace that contains the given <paramref name="type" />.</para>
      </summary>
      <remarks>
        <para>This is used both for writing and parsing objects.</para>
      </remarks>
      <param name="xmlNamespace">
        <para>The XML namespace that corresponds to <paramref name="type" />'s containing namespace.</para>
      </param>
      <param name="type">
        <para>The type whose containing namespace is mapped to the XML namespace.</para>
      </param>
      <seealso cref="T:yWorks.GraphML.IXamlNameMapper" />
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.CreateXamlNameMapper" />
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.AddXamlNamespaceMapping(System.String,System.String,System.Type)" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.QueryType">
      <summary>
        <para>Occurs when a type is queried.</para>
      </summary>
      <remarks>
        <para>This event can be used to override type resolution for XML names in XAML.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.QueryTypeEventArgs" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.QueryName">
      <summary>
        <para>Occurs when a name is queried.</para>
      </summary>
      <remarks>
        <para>This event can be used to override name mappings to XML names in XAML.</para>
        <para>If the event handler determines that it map resolve <see cref="P:yWorks.GraphML.QueryNameEventArgs.Type" /> to a xml name, it should place the result into the <see cref="P:yWorks.GraphML.QueryNameEventArgs.Result" /> property and thus mark the event as <see cref="P:yWorks.GraphML.QueryNameEventArgs.Handled" />.</para>
        <para>It is valid to provide only part of the XML name by setting the other part to null. In that case, the default name determination rules are used for that part.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateXMLWriter(System.IO.TextWriter)">
      <summary>
        <para>Factory method that creates and configures a suitable <see cref="T:yWorks.GraphML.IXmlWriter" /> implementation that can write the graph to the given <see cref="T:System.IO.TextWriter" /> with the given settings.</para>
      </summary>
      <remarks>
        <para>This method is called for each write process. The <see cref="T:yWorks.GraphML.IXmlWriter" /> implementation is used by default for all low-level write operations.</para>
      </remarks>
      <param name="os">
        <para>The serialization destination</para>
      </param>
      <returns>
        <para>A suitable <see cref="T:yWorks.GraphML.IXmlWriter" /> instance for the serialization</para>
      </returns>
      <seealso cref="P:yWorks.GraphML.IWriteContext.Writer" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateXMLWriter(System.IO.Stream,System.Text.Encoding)">
      <summary>
        <para>Factory method that creates and configures a suitable <see cref="T:yWorks.GraphML.IXmlWriter" /> implementation that can write the graph to the given <see cref="T:System.IO.Stream" /> with the given settings.</para>
      </summary>
      <remarks>
        <para>This method is called for each write process. The <see cref="T:yWorks.GraphML.IXmlWriter" /> implementation is used by default for all low-level write operations.</para>
      </remarks>
      <param name="os">
        <para>The serialization destination</para>
      </param>
      <returns>
        <para>A suitable <see cref="T:yWorks.GraphML.IXmlWriter" /> instance for the serialization</para>
      </returns>
      <param name="encoding">
        <para>The encoding of the stream</para>
      </param>
      <seealso cref="P:yWorks.GraphML.IWriteContext.Writer" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureXMLWriter(yWorks.GraphML.IXmlWriter)">
      <summary>
        <para>Configure <paramref name="writer" />.</para>
      </summary>
      <remarks>
        <para>This method is called for each write process.</para>
        <para>This implementation does nothing.</para>
      </remarks>
      <param name="writer">
        <para>The writer to configure.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureSchemaLocations(yWorks.GraphML.GraphMLWriter)">
      <summary>
        <para>Configures <paramref name="writer" /> to use the schema locations set with <see cref="M:yWorks.GraphML.GraphMLIOHandler.AddSchemaLocation(System.String,System.String)" />.</para>
      </summary>
      <remarks>
        <para>This method is called for each write process.</para>
      </remarks>
      <param name="writer">
        <para>The writer to configure.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureNamespaces(yWorks.GraphML.GraphMLWriter)">
      <summary>
        <para>Configures <paramref name="writer" /> to use the namespace declarations set with <see cref="M:yWorks.GraphML.GraphMLIOHandler.AddNamespace(System.String,System.String)" />.</para>
      </summary>
      <remarks>
        <para>In addition to the namespace declarations provided with <see cref="M:yWorks.GraphML.GraphMLIOHandler.AddNamespace(System.String,System.String)" />, the default <see cref="T:yWorks.GraphML.GraphMLWriter" /> implementation also automatically places all namespace declarations that have occurred</para>
        <para>This method is called for each write process.</para>
      </remarks>
      <param name="writer">
        <para>The writer to configure.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureOutputHandlers(yWorks.Graph.IGraph,yWorks.GraphML.GraphMLWriter)">
      <summary>
        <para>Configures default event handlers for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event.</para>
      </summary>
      <remarks>
        <para>This implementation configures several output handlers for the standard yFiles.NET GraphML attributes (styles, folding state, labels, geometry).</para>
        <para>This method is called for each write process.</para>
      </remarks>
      <param name="graph">
        <para>The graph that will be written.</para>
      </param>
      <param name="writer">
        <para>The writer that should be configured.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterNodeStyleOutputHandler(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Predefined output handler that writes node styles.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterGraphSettingsOutputHandler(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Predefined output handler that writes the settings of a graph.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event.</para>
      </remarks>
      <seealso cref="F:yWorks.GraphML.SerializationProperties.DisableGraphSettings" />
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterTagOutputHandler(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Predefined output handler that writes <see cref="T:yWorks.Graph.ITagOwner" /> tags.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterNodeLayoutOutputHandler(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Predefined output handler that writes node layouts.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterNodeLabelsOutputHandler(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Predefined output handler that writes node labels.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterEdgeLabelsOutputHandler(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Predefined output handler that writes edge labels.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterEdgeStyleOutputHandler(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Predefined output handler that writes edge styles.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterEdgeBendsOutputHandler(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Predefined output handler that writes edge bends.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterPortStyleOutputHandler(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Predefined output handler that writes port styles.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterPortLocationOutputHandler(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Predefined output handler that writes port locations.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureSerializationHandlers(yWorks.Graph.IGraph,yWorks.GraphML.GraphMLWriter)">
      <summary>
        <para>Configures the predefined handlers for the <see cref="E:yWorks.GraphML.GraphMLWriter.HandleSerialization" /> event.</para>
      </summary>
      <remarks>
        <para>This method is called for each write process.</para>
      </remarks>
      <param name="graph">
        <para>The graph that will be written.</para>
      </param>
      <param name="writer">
        <para>The writer to configure.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleTextConvertibleSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of instances that can be serialized through a <see cref="T:System.Windows.Markup.ValueSerializer" />.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> iff <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> can be converted to a string with a <see cref="T:System.Windows.Markup.ValueSerializer" />. This serializer is only called from element property syntax and is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleEnumSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization for enums.</para>
      </summary>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleReferenceHandleSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:yWorks.GraphML.IReferenceHandle" /> instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> iff <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is a <see cref="T:yWorks.GraphML.IReferenceHandle" /> instance. This handler is registered by default and should not be removed if <see cref="P:yWorks.GraphML.GraphMLIOHandler.WriteSharedReferences" /> is enabled.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleListSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:System.Collections.IEnumerable" /> instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> iff <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is an <see cref="T:System.Collections.IEnumerable" /> instance. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleArraySerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of arrays.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> iff <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is an array. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleTypeSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of Types.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> iff <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is an array. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleTypeExtensionSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of TypeExtensions.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> iff <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is an array. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleMarkupExtensionBasedSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:System.Windows.Markup.MarkupExtension" /> convertible instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> iff <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> can be converted to a <see cref="T:System.Windows.Markup.MarkupExtension" /> instance. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleXamlSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of complex objects that are not handled by other callbacks.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> iff <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is not a <c>null</c> reference. This handler is registered by default and uses <see cref="T:yWorks.GraphML.XamlSerializer" /> to create XAML output.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandlePenSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:System.Drawing.Pen" /> instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> if <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is a <see cref="T:System.Drawing.Pen" /> instance. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleColorSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:System.Drawing.Color" /> instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> if <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is a <see cref="T:System.Drawing.Color" /> instance. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleBitmapImageSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:System.Drawing.Bitmap" /> instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> if <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is a <see cref="T:System.Drawing.Pen" /> instance. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleMetafileSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:System.Drawing.Imaging.Metafile" /> instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> if <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is a <see cref="T:System.Drawing.Pen" /> instance. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleHatchBrushSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> if <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is a <see cref="T:System.Drawing.Drawing2D.HatchBrush" /> instance. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleLinearGradientBrushSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> if <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is a <see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" /> instance. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleSolidBrushSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:System.Drawing.SolidBrush" /> instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> if <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is a <see cref="T:System.Drawing.SolidBrush" /> instance. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleTextureBrushSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <see cref="T:System.Drawing.TextureBrush" /> instances.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> if <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is a <see cref="T:System.Drawing.TextureBrush" /> instance. This handler is registered by default.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleNullSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Handle the serialization of <c>null</c> references.</para>
      </summary>
      <remarks>
        <para>This sets <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> to <c>true</c> iff <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> is a <c>null</c> reference. This handler is registered by default and is only used to write <c>null</c> references in XML element syntax.</para>
      </remarks>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnGraphMLWriterHandleSerialization(System.Object,yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Event handler for the <see cref="E:yWorks.GraphML.GraphMLWriter.HandleSerialization" /> event.</para>
      </summary>
      <remarks>
        <para>This event handler is used to propagate the <see cref="E:yWorks.GraphML.GraphMLWriter.HandleSerialization" /> event to subscribers of <see cref="E:yWorks.GraphML.GraphMLIOHandler.HandleSerialization" />. This implementation just calls <see cref="M:yWorks.GraphML.GraphMLIOHandler.OnHandleSerialization(yWorks.GraphML.HandleSerializationEventArgs)" />, which in turn raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.HandleSerialization" /> event.</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnGraphMLWriterQueryOutputHandlers(System.Object,yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Event handler for the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event.</para>
      </summary>
      <remarks>
        <para>This event handler is used to propagate the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event to subscribers of <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryOutputHandlers" />. This implementation just calls <see cref="M:yWorks.GraphML.GraphMLIOHandler.OnQueryOutputHandlers(yWorks.GraphML.QueryOutputHandlersEventArgs)" />, which in turn raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryOutputHandlers" /> event.</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.HandleSerialization">
      <summary>
        <para>Occurs when XML content is about to be serialized.</para>
      </summary>
      <remarks>
        <para>Subscribe to this event to provide custom serialization handling for XML content.</para>
        <para>The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called earlier.</para>
        <para>The current item is provided by <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" />.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.QueryOutputHandlers">
      <summary>
        <para>Occurs when a GraphML attribute is about to be written.</para>
      </summary>
      <remarks>
        <para>Subscribe to this event to dynamically register one or more <see cref="T:yWorks.GraphML.IOutputHandler" /> instance(s) for a given GraphML attribute key definition.</para>
        <para>The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called earlier.</para>
        <para>If you want to register an <see cref="T:yWorks.GraphML.IOutputHandler" /> for this GraphML attribute, you can add the handler with <see cref="M:yWorks.GraphML.QueryOutputHandlersEventArgs.AddOutputHandler(yWorks.GraphML.IOutputHandler)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnHandleSerialization(yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.HandleSerialization" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments for the <see cref="E:yWorks.GraphML.GraphMLIOHandler.HandleSerialization" /> event.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnQueryOutputHandlers(yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryOutputHandlers" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments for the <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryOutputHandlers" /> event.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.IO.Stream)">
      <summary>
        <para>Reads GraphML content from the given input stream and populates the Graph object.</para>
      </summary>
      <param name="graph">
        <para>The Graph object that is to be populated with nodes and edges as read from the stream.</para>
      </param>
      <param name="stream">
        <para>The input stream that holds the GraphML file to be read.</para>
      </param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>stream</c> is null.</para>
      </exception>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>graph</c> is null.</para>
      </exception>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.Xml.Linq.XDocument)">
      <summary>
        <para>Read GraphML from an existing XML document.</para>
      </summary>
      <param name="graph">
        <para>The Graph object that is to be populated with nodes and edges as read from the document.</para>
      </param>
      <param name="document">
        <para>The XML document.</para>
      </param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>doc</c> is null.</para>
      </exception>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>graph</c> is null.</para>
      </exception>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.IO.TextReader)">
      <summary>
        <para>Reads GraphML content from the given reader and populates the Graph object.</para>
      </summary>
      <param name="graph">
        <para>The Graph object that is to be populated with nodes and edges as read from <paramref name="reader" />.</para>
      </param>
      <param name="reader">
        <para>The input stream that holds the GraphML file to be read.</para>
      </param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>reader</c> is null.</para>
      </exception>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>graph</c> is null.</para>
      </exception>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.String)">
      <summary>
        <para>Reads a GraphML file from the given GraphML file and populates the <see cref="T:yWorks.Graph.IGraph" /> object.</para>
      </summary>
      <param name="graph">
        <para>The Graph object that is to be populated with nodes and edges as read from the GraphML file.</para>
      </param>
      <param name="filename">
        <para>The name of the file to be read.</para>
      </param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>filename</c> is null.</para>
      </exception>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>graph</c> is null.</para>
      </exception>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateMapperInputHandler``2(yWorks.Graph.IMapper{``0,``1},System.EventHandler{yWorks.GraphML.HandleDeserializationEventArgs})">
      <summary>
        <para>Convenience factory method that can create an instance of several predefined <see cref="T:yWorks.GraphML.IInputHandler" /> implementations that match the provided <typeparamref name="TKey" /> and <typeparamref name="TData" />.</para>
      </summary>
      <typeparam name="TKey">
        <para>The type of the mapper keys</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the mapper entries</para>
      </typeparam>
      <param name="mapper">
        <para>The mapper to use.</para>
      </param>
      <param name="deserializationCallback">
        <para>Optional deserialization callback for complex data.</para>
      </param>
      <returns>
        <para>A suitable <see cref="T:yWorks.GraphML.MapperInputHandler`2" /> implementation</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddInputMapper``2(System.String,yWorks.Graph.IMapper{``0,``1})">
      <summary>
        <para>Register a <see cref="T:yWorks.Graph.IMapper`2" /> instance for use as an input data target.</para>
      </summary>
      <remarks>
        <para>This methods creates and configures the necessary handler itself.</para>
      </remarks>
      <typeparam name="TKey">
        <para>The type of the mapper keys</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the mapper values</para>
      </typeparam>
      <param name="name">
        <para>The name of the attribute</para>
      </param>
      <param name="mapper">
        <para>the mapper that serves as data source</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddInputMapper``2(System.Predicate{System.Xml.Linq.XElement},yWorks.Graph.IMapper{``0,``1},System.EventHandler{yWorks.GraphML.HandleDeserializationEventArgs})">
      <summary>
        <para>Register a <see cref="T:yWorks.Graph.IMapper`2" /> instance for use as an input data target.</para>
      </summary>
      <remarks>
        <para>This method uses a custom <see cref="T:System.EventHandler`1" /> for the actual deserialization.</para>
        <para>This methods creates and configures the necessary handler itself.</para>
      </remarks>
      <typeparam name="TKey">
        <para>The type of the mapper keys</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the mapper values</para>
      </typeparam>
      <param name="keyDefinitionPredicate">
        <para>The predicate function that will determine whether to create an <see cref="T:yWorks.GraphML.IInputHandler" /> for the given key definition.</para>
      </param>
      <param name="mapper">
        <para>the mapper that serves as data source</para>
      </param>
      <param name="deserializationCallback">
        <para>custom deserialization callback.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddInputMapperFuture``2(System.String)">
      <summary>
        <para>Create a <see cref="T:yWorks.Utils.Future`1" /> instance that wraps an <see cref="T:yWorks.Graph.IMapper`2" /> for use as an input data target.</para>
      </summary>
      <remarks>
        <para>The return value will only contain a value if a matching GraphML attribute has been read, which can be queried with <see cref="P:yWorks.Utils.Future`1.HasValue" /> This methods creates and configures the necessary handler itself.</para>
      </remarks>
      <typeparam name="TKey">
        <para>The type of the mapper keys</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the mapper values</para>
      </typeparam>
      <param name="name">
        <para>The name of the attribute</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Utils.Future`1" /> instance that wraps an <see cref="T:yWorks.Graph.IMapper`2" /> that actually holds the data.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddInputMapperFuture``2(System.Predicate{System.Xml.Linq.XElement},System.EventHandler{yWorks.GraphML.HandleDeserializationEventArgs})">
      <summary>
        <para>Create a <see cref="T:yWorks.Utils.Future`1" /> instance that wraps an <see cref="T:yWorks.Graph.IMapper`2" /> for use as an input data target.</para>
      </summary>
      <remarks>
        <para>The return value will only contain a value if a matching GraphML attribute has been read, which can be queried with <see cref="P:yWorks.Utils.Future`1.HasValue" /> This methods creates and configures the necessary handler itself.</para>
      </remarks>
      <typeparam name="TKey">
        <para>The type of the mapper keys</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the mapper values</para>
      </typeparam>
      <param name="deserializationCallback">
        <para>custom deserialization callback.</para>
      </param>
      <param name="keyDefinitionPredicate">
        <para>The predicate function that will determine whether to create an <see cref="T:yWorks.GraphML.IInputHandler" /> for the given key definition.</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Utils.Future`1" /> instance that wraps an <see cref="T:yWorks.Graph.IMapper`2" /> that actually holds the data.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddInputHandlerFactory(System.Predicate{System.Xml.Linq.XElement},yWorks.GraphML.IGenericInputHandlerFactory)">
      <summary>
        <para>Create a <see cref="T:yWorks.Utils.Future`1" /> instance that wraps an <see cref="T:yWorks.GraphML.IInputHandler" /> that is dynamically created by <paramref name="factory" />.</para>
      </summary>
      <remarks>
        <para>The return value will only contain a value if a matching GraphML attribute has been read, which can be queried with <see cref="P:yWorks.Utils.Future`1.HasValue" />. The validity is determined by <paramref name="keyDefinitionPredicate" />. This methods creates and configures the necessary handler itself.</para>
      </remarks>
      <param name="keyDefinitionPredicate">
        <para>The predicate that matches the key definition.</para>
      </param>
      <param name="factory">
        <para>A factory to create <see cref="T:yWorks.GraphML.IInputHandler" /> instances.</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Utils.Future`1" /> instance that wraps an <see cref="T:yWorks.GraphML.IInputHandler" /> that actually parses the data.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddRegistryInputMapper``2(System.String)">
      <summary>
        <para>Create a <see cref="T:yWorks.Utils.Future`1" /> instance that wraps an <see cref="T:yWorks.GraphML.IInputHandler" /> that stores the data in an <see cref="T:yWorks.Graph.IMapper`2" /> that will be <see cref="M:yWorks.GraphML.GraphMLIOHandler.CreateMapper``2(yWorks.GraphML.IParseContext,System.Object)">created</see> in the graph's <see cref="T:yWorks.Graph.IMapperRegistry" />.</para>
      </summary>
      <remarks>
        <para>The return value will only contain a value if a matching GraphML attribute has been read, which can be queried with <see cref="P:yWorks.Utils.Future`1.HasValue" />. The attribute must be registered under the attribute name <paramref name="name" />. This methods creates and configures the necessary handler itself and <see cref="M:yWorks.GraphML.GraphMLIOHandler.CreateMapper``2(yWorks.GraphML.IParseContext,System.Object)">creates</see> an <see cref="T:yWorks.Graph.IMapper`2" /> in the <see cref="T:yWorks.Graph.IMapperRegistry" /> with name <paramref name="name" />.</para>
      </remarks>
      <param name="name">
        <para>The name of the GraphML attribute and the key in the <see cref="T:yWorks.Graph.IMapperRegistry" />.</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Utils.Future`1" /> instance that wraps an <see cref="T:yWorks.Graph.IMapper`2" /> that actually holds the data.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.AddRegistryInputMapper``2(System.Object,System.Predicate{System.Xml.Linq.XElement},System.EventHandler{yWorks.GraphML.HandleDeserializationEventArgs})">
      <summary>
        <para>Create a <see cref="T:yWorks.Utils.Future`1" /> instance that wraps an <see cref="T:yWorks.GraphML.IInputHandler" /> that stores the data in an <see cref="T:yWorks.Graph.IMapper`2" /> that will be <see cref="M:yWorks.GraphML.GraphMLIOHandler.CreateMapper``2(yWorks.GraphML.IParseContext,System.Object)">created</see> in the graph's <see cref="T:yWorks.Graph.IMapperRegistry" />.</para>
      </summary>
      <remarks>
        <para>The return value will only contain a value if a matching GraphML attribute has been read, which can be queried with <see cref="P:yWorks.Utils.Future`1.HasValue" />. This methods creates and configures the necessary handler itself and <see cref="M:yWorks.GraphML.GraphMLIOHandler.CreateMapper``2(yWorks.GraphML.IParseContext,System.Object)">creates</see> an <see cref="T:yWorks.Graph.IMapper`2" /> in the <see cref="T:yWorks.Graph.IMapperRegistry" /> with name <paramref name="tag" />.</para>
      </remarks>
      <param name="tag">
        <para>The name of the key in the <see cref="T:yWorks.Graph.IMapperRegistry" />.</para>
      </param>
      <param name="keyDefinitionPredicate">
        <para>A predicate to determine whether the key definition is valid.</para>
      </param>
      <param name="deserializationCallback">
        <para>The custom deserialization callback, can be <c>null</c> which will result in default deserialization.</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Utils.Future`1" /> instance that wraps an <see cref="T:yWorks.Graph.IMapper`2" /> that actually holds the data.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateMapper``2(yWorks.GraphML.IParseContext,System.Object)">
      <summary>
        <para>Callback used by <see cref="M:yWorks.GraphML.GraphMLIOHandler.AddRegistryInputMapper``2(System.String)" /> and its overloads to creates the mapper instance.</para>
      </summary>
      <remarks>
        <para>This method creates the mapper instance, unless there is an existing mapper in the target graph with a matching type. In this case the existing mapper is returned. In all other cases a new mapper will be created using <see cref="M:yWorks.Graph.MapperRegistryExtensions.CreateWeakMapper``2(yWorks.Graph.IMapperRegistry,System.Object)" /> and returned. If a mapper is already registered with the same <paramref name="registryTag" /> but wrong types it will be replaced.</para>
      </remarks>
      <typeparam name="TKey">
        <para>The type of the keys.</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the data.</para>
      </typeparam>
      <param name="context" />
      <param name="registryTag">
        <para>The tag for the mapper in the registry.</para>
      </param>
      <returns>
        <para>The mapper instance to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.MatchesName(System.Xml.Linq.XElement,System.String)">
      <summary>
        <para>Checks whether the <c>name</c> attribute in <paramref name="definition" /> matches <paramref name="name" /></para>
      </summary>
      <param name="definition">
        <para>The key definition to check</para>
      </param>
      <param name="name">
        <para>The name that should be matched</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the name attribute in <paramref name="definition" /> matches <paramref name="name" /></para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.MatchesUri(System.Xml.Linq.XElement,System.String)">
      <summary>
        <para>Checks whether the <c>uri</c> attribute in <paramref name="definition" /> matches <paramref name="uri" /></para>
      </summary>
      <param name="definition">
        <para>The key definition to check</para>
      </param>
      <param name="uri">
        <para>The uri that should be matched</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the uri attribute in <paramref name="definition" /> matches <paramref name="uri" /></para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.MatchesType(System.Xml.Linq.XElement,yWorks.GraphML.KeyType)">
      <summary>
        <para>Checks whether the <c>type</c> attribute in <paramref name="definition" /> matches <paramref name="type" /></para>
      </summary>
      <param name="definition">
        <para>The key definition to check</para>
      </param>
      <param name="type">
        <para>The type that should be matched</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the type attribute in <paramref name="definition" /> matches <paramref name="type" /></para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.MatchesScope(System.Xml.Linq.XElement,yWorks.GraphML.KeyScope)">
      <summary>
        <para>Checks whether the <c>scope</c> attribute in <paramref name="definition" /> matches <paramref name="scope" /></para>
      </summary>
      <param name="definition">
        <para>The key definition to check</para>
      </param>
      <param name="scope">
        <para>The scope that should be matched</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the scope attribute in <paramref name="definition" /> matches <paramref name="scope" /></para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateGraphElementFactory(yWorks.GraphML.GraphMLParser,yWorks.Graph.IGraph)">
      <summary>
        <para>Create an <see cref="T:yWorks.GraphML.IGraphElementFactory" /> instance that creates the graph elements for the <paramref name="graph" /> instance.</para>
      </summary>
      <remarks>
        <para>This method is called for each parse process.</para>
      </remarks>
      <param name="parser">
        <para>The parser to use.</para>
      </param>
      <param name="graph">
        <para>The graph that is populated.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.GraphML.IGraphElementFactory" /> instance that is configured for the given parameters.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateGraphMLParser(yWorks.Graph.IGraph)">
      <summary>
        <para>Create a suitable instance of <see cref="T:yWorks.GraphML.GraphMLParser" /> that can handle the given graph.</para>
      </summary>
      <remarks>
        <para>This method is called for each parse process.</para>
        <para>It delegates the configuration of the parser to <see cref="M:yWorks.GraphML.GraphMLIOHandler.ConfigureGraphMLParser(yWorks.GraphML.GraphMLParser,yWorks.Graph.IGraph)" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph that should be filled by this instance</para>
      </param>
      <returns>
        <para>a suitable instance of <see cref="T:yWorks.GraphML.GraphMLParser" /> that can handle the given graph</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureGraphMLParser(yWorks.GraphML.GraphMLParser,yWorks.Graph.IGraph)">
      <summary>
        <para>Configures a given instance of <see cref="T:yWorks.GraphML.GraphMLParser" /> that can handle the given graph.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.GraphML.GraphMLIOHandler.CreateGraphMLParser(yWorks.Graph.IGraph)" />.</para>
      </remarks>
      <param name="parser">
        <para>The parser to configure</para>
      </param>
      <param name="graph">
        <para>The graph that should be filled by the parser</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnParsed(yWorks.GraphML.ParseEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.Parsed" /> event.</para>
      </summary>
      <remarks>
        <para>This method is called when the document has been parsed and after <see cref="E:yWorks.GraphML.IParseEvents.DocumentParsed" /> is called.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.GraphML.ParseEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.Parsed" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.Parsed">
      <summary>
        <para>Occurs when the the document has been parsed.</para>
      </summary>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.OnParsed(yWorks.GraphML.ParseEventArgs)" />
      <seealso cref="E:yWorks.GraphML.GraphMLParser.Parsed" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnParsing(yWorks.GraphML.ParseEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.Parsing" /> event.</para>
      </summary>
      <remarks>
        <para>This method is called just before the parsing starts and before <see cref="E:yWorks.GraphML.IParseEvents.DocumentParsing" /> is called.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.GraphML.ParseEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.Parsing" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.Parsing">
      <summary>
        <para>Occurs when the parsing of a document is just about to begin.</para>
      </summary>
      <remarks>
        <para>This event can be used to register to the fine-grained events available in the <see cref="P:yWorks.GraphML.ParseEventArgs.Context" />'s <see cref="P:yWorks.GraphML.IParseContext.ParseEvents" /> and to configure the parsing process on a per parse case.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.OnParsing(yWorks.GraphML.ParseEventArgs)" />
      <seealso cref="E:yWorks.GraphML.GraphMLParser.Parsing" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureLookup(yWorks.GraphML.GraphMLParser)">
      <summary>
        <para>Configures the lookup of the given parser.</para>
      </summary>
      <remarks>
        <para>This method is called for each parse process.</para>
      </remarks>
      <param name="parser">
        <para>The parser to configure.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.CreateXamlPrefixMapper">
      <summary>
        <para>Configure mappings from XML namespaces to prefixes.</para>
      </summary>
      <remarks>
        <para>This implementation scans all loaded assemblies for <see cref="T:System.Windows.Markup.XmlnsPrefixAttribute" />s and returns a suitable instance of <see cref="T:yWorks.GraphML.IXamlPrefixMapper" />.</para>
        <para>This method is called for each write process.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureInputHandlers(yWorks.GraphML.GraphMLParser)">
      <summary>
        <para>Configures default event handlers for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event.</para>
      </summary>
      <remarks>
        <para>This implementation configures several input handlers for the standard yFiles.NET GraphML attributes (styles, folding state, labels, geometry).</para>
        <para>This method is called for each parse process.</para>
      </remarks>
      <param name="parser">
        <para>The parser that should be configured.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterNodeLayoutInputHandler(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Predefined input handler that reads node layouts.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterNodeLabelsInputHandler(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Predefined input handler that reads node labels.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterGraphSettingsInputHandler(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Predefined input handler that reads <see cref="T:yWorks.Graph.IGraph" /> graph default settings.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterEdgeBendsInputHandler(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Predefined input handler that reads edge bends.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterTagInputHandler(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Predefined input handler that reads <see cref="T:yWorks.Graph.ITagOwner" /> tags.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterNodeStyleInputHandler(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Predefined input handler that reads node styles.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterEdgeStyleInputHandler(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Predefined input handler that reads edge styles.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterPortStyleInputHandler(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Predefined input handler that reads port styles.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterPortLocationInputHandler(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Predefined input handler that reads port locations.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.RegisterEdgeLabelsInputHandler(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Predefined input handler that reads edge labels.</para>
      </summary>
      <remarks>
        <para>This handler is by default registered for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.ConfigureDeserializationHandlers(yWorks.Graph.IGraph,yWorks.GraphML.GraphMLParser)">
      <summary>
        <para>Configure the predefined handlers for the <see cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" /> event.</para>
      </summary>
      <remarks>
        <para>Except for text content and primitive types, this implementation delegates all work to <see cref="M:yWorks.GraphML.GraphMLIOHandler.HandleXamlDeserialization(System.Object,yWorks.GraphML.HandleDeserializationEventArgs)" /></para>
        <para>This method is called for each parse process.</para>
      </remarks>
      <param name="graph">
        <para>The graph that will be parsed.</para>
      </param>
      <param name="parser">
        <para>The parser to configure.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.HandlePrimitivesDeserialization(System.Object,yWorks.GraphML.HandleDeserializationEventArgs)" />
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.HandleXamlDeserialization(System.Object,yWorks.GraphML.HandleDeserializationEventArgs)" />
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.HandleTextNodeDeserialization(System.Object,yWorks.GraphML.HandleDeserializationEventArgs)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnGraphMLParserQueryInputHandlers(System.Object,yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Event handler for the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event.</para>
      </summary>
      <remarks>
        <para>This event handler is used to propagate the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event to subscribers of <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryInputHandlers" />. This implementation just calls <see cref="M:yWorks.GraphML.GraphMLIOHandler.OnQueryInputHandlers(yWorks.GraphML.QueryInputHandlersEventArgs)" />, which in turn raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryInputHandlers" /> event.</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnGraphMLParserHandleDeserialization(System.Object,yWorks.GraphML.HandleDeserializationEventArgs)">
      <summary>
        <para>Event handler for the <see cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" /> event.</para>
      </summary>
      <remarks>
        <para>This event handler is used to propagate the <see cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" /> event to subscribers of <see cref="E:yWorks.GraphML.GraphMLIOHandler.HandleDeserialization" />. This implementation just calls <see cref="M:yWorks.GraphML.GraphMLIOHandler.OnHandleDeserialization(yWorks.GraphML.HandleDeserializationEventArgs)" />, which in turn raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.HandleDeserialization" /> event.</para>
      </remarks>
      <param name="sender" />
      <param name="e" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.QueryInputHandlers">
      <summary>
        <para>Occurs when a GraphML attribute is about to be read.</para>
      </summary>
      <remarks>
        <para>Subscribe to this event to dynamically register one or more <see cref="T:yWorks.GraphML.IInputHandler" /> instance(s) for a given GraphML attribute key definition.</para>
        <para>The current key definition is provided by <see cref="P:yWorks.GraphML.QueryInputHandlersEventArgs.KeyDefinition" />. If you want to register an <see cref="T:yWorks.GraphML.IInputHandler" /> for this GraphML attribute, you can add the handler with <see cref="M:yWorks.GraphML.QueryInputHandlersEventArgs.AddInputHandler(yWorks.GraphML.IInputHandler)" /> method. Implementations should also consider the <see cref="P:yWorks.GraphML.QueryInputHandlersEventArgs.Handled" /> property.</para>
      </remarks>
      <seealso cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLIOHandler.HandleDeserialization">
      <summary>
        <para>Occurs when XML content is about to be deserialized.</para>
      </summary>
      <remarks>
        <para>Subscribe to this event to provide custom deserialization handling for XML content.</para>
        <para>The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called earlier.</para>
        <para>The current XML content is provided by <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.XmlNode" />. If you want to return deserialized content, set the value of the <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.Result" /> property.</para>
      </remarks>
      <seealso cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnQueryInputHandlers(yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryInputHandlers" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments for the <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryInputHandlers" /> event.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.OnHandleDeserialization(yWorks.GraphML.HandleDeserializationEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLIOHandler.HandleDeserialization" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments for the <see cref="E:yWorks.GraphML.GraphMLIOHandler.HandleDeserialization" /> event.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandlePrimitivesDeserialization(System.Object,yWorks.GraphML.HandleDeserializationEventArgs)">
      <summary>
        <para>Handle the serialization of primitive types, enums and strings.</para>
      </summary>
      <param name="sender">
        <para>The origin of the event.</para>
      </param>
      <param name="e">
        <para>The event handler arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleTextNodeDeserialization(System.Object,yWorks.GraphML.HandleDeserializationEventArgs)">
      <summary>
        <para>Callback for the <see cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" /> event.</para>
      </summary>
      <param name="source">
        <para>The source of the event.</para>
      </param>
      <param name="args">
        <para>The event arguments.</para>
      </param>
      <seealso cref="T:yWorks.GraphML.HandleDeserializationEventArgs" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLIOHandler.HandleXamlDeserialization(System.Object,yWorks.GraphML.HandleDeserializationEventArgs)">
      <summary>
        <para>Callback for the <see cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" /> event.</para>
      </summary>
      <param name="source">
        <para>The source of the event.</para>
      </param>
      <param name="args">
        <para>The event arguments.</para>
      </param>
      <seealso cref="T:yWorks.GraphML.HandleDeserializationEventArgs" />
    </member>
    <member name="T:yWorks.GraphML.IGenericInputHandlerFactory">
      <summary>
        <para>Interface for factory classes for <see cref="T:yWorks.GraphML.IInputHandler" /> creation.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IGenericInputHandlerFactory.CreateInputHandler``2(yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Create an <see cref="T:yWorks.GraphML.IInputHandler" /> instance based on the given <paramref name="args" />.</para>
      </summary>
      <typeparam name="TKey">
        <para>The key type as inferred by the caller from the GraphML contents.</para>
      </typeparam>
      <typeparam name="TValue">
        <para>The type of the value as inferred by the caller from the GraphML contents.</para>
      </typeparam>
      <param name="args">
        <para>The event argument that is used like in <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryInputHandlers" /></para>
      </param>
      <returns>
        <para>The specific input handler to use.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.ChildParseContext">
      <summary>
        <para>An implementation of <see cref="T:yWorks.GraphML.IParseContext" /> that delegates most calls to a <see cref="P:yWorks.GraphML.ChildParseContext.ParentContext" />, but adds the capability to locally add <see cref="M:yWorks.GraphML.ChildParseContext.Lookup(System.Type)" /> results and <see cref="M:yWorks.GraphML.ChildParseContext.GetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0})">deserialization properties</see></para>
      </summary>
      <remarks>
        <para>Whenever it is necessary to locally modify some context properties, a new instance of this class should be created that wraps an existing one.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.ChildParseContext.SetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)" />
      <seealso cref="M:yWorks.GraphML.ChildParseContext.SetLookup``1(``0)" />
    </member>
    <member name="M:yWorks.GraphML.ChildParseContext.#ctor(yWorks.GraphML.IParseContext,System.Object)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.ChildParseContext" /> class that delegates to the provided context and adds the <paramref name="currentObject" /> to the <see cref="P:yWorks.GraphML.ChildParseContext.ObjectStack" />.</para>
      </summary>
      <param name="parentContext">
        <para>The parent context.</para>
      </param>
      <param name="currentObject">
        <para>The current object to add to the <see cref="P:yWorks.GraphML.ChildParseContext.ObjectStack" /> and return in <see cref="M:yWorks.GraphML.ChildParseContext.GetCurrent``1" />.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.ChildParseContext.#ctor(yWorks.GraphML.IParseContext)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.ChildParseContext" /> class that delegates to the provided context.</para>
      </summary>
      <param name="parentContext">
        <para>The parent context.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.ChildParseContext.ParentContext">
      <summary>
        <para>Gets the parent context.</para>
      </summary>
      <value>
        <para>The parent context.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.ChildParseContext.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.GraphML.ChildParseContext.SetLookup``1(``0)">
      <summary>
        <para>Adds another lookup result to the local lookup override.</para>
      </summary>
      <typeparam name="T">
        <para>The type to use as a key for the lookup.</para>
      </typeparam>
      <param name="value">
        <para>The value to provide for queries to <typeparamref name="T" />.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.ChildParseContext.RemoveLookup``1" />
    </member>
    <member name="M:yWorks.GraphML.ChildParseContext.RemoveLookup``1">
      <summary>
        <para>Removes a local lookup override that has been added using <see cref="M:yWorks.GraphML.ChildParseContext.SetLookup``1(``0)" /></para>
      </summary>
      <typeparam name="T">
        <para>The type key to remove.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.GraphML.ChildParseContext.GetCurrent``1" />
    <member name="M:yWorks.GraphML.ChildParseContext.GetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0})">
      <param name="key" />
    </member>
    <member name="M:yWorks.GraphML.ChildParseContext.SetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)">
      <summary>
        <para>Sets the local deserialization property for the given key to the value.</para>
      </summary>
      <param name="key">
        <para>The key to override.</para>
      </param>
      <param name="value">
        <para>The value.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.ChildParseContext.RemoveDeserializationProperty``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Removes a previously locally <see cref="M:yWorks.GraphML.ChildParseContext.SetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)">set</see> deserialization property.</para>
      </summary>
      <param name="key">
        <para>The key for which the local property override should be removed.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.ChildParseContext.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)">
      <param name="context" />
      <param name="targetNode" />
    </member>
    <member name="T:yWorks.GraphML.CreationProperties">
      <summary>
        <para>A simple mutable implementation of <see cref="T:yWorks.Graph.IMapper`2" /> that is typed for <see cref="T:System.Object" /> keys and values.</para>
      </summary>
      <remarks>
        <para>This class is used by the <see cref="T:yWorks.GraphML.GraphMLParser" /> to store properties of an item before it has been created. An instance of this class can be found in the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the <see cref="T:yWorks.GraphML.IParseContext" /> during the parsing of an item. Custom parsers may populate the dictionary with various properties that can then be used by the <see cref="T:yWorks.GraphML.IGraphElementFactory" /> during the creation of the item.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.IGraphElementFactory" />
      <seealso cref="T:yWorks.GraphML.GraphMLParser" />
    </member>
    <member name="F:yWorks.GraphML.CreationProperties.IsGroupNode">
      <summary>
        <para>Creation property key that tags group node information.</para>
      </summary>
      <remarks>
        <para>Stores values of type <see cref="T:System.Boolean" />.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.IGraphElementFactory.CreateNode(yWorks.GraphML.IParseContext)" />
    </member>
    <member name="F:yWorks.GraphML.CreationProperties.Labels">
      <summary>
        <para>Creation property key that tags label information.</para>
      </summary>
      <remarks>
        <para>Stores values of type <see cref="T:System.Collections.Generic.IEnumerable`1" /> with <see cref="T:yWorks.Graph.ILabel" /> template instances.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.IGraphElementFactory" />
    </member>
    <member name="F:yWorks.GraphML.CreationProperties.Layout">
      <summary>
        <para>Creation property key that tags node layout information.</para>
      </summary>
      <remarks>
        <para>Stores values of type <see cref="T:yWorks.Geometry.RectD" />.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.IGraphElementFactory.CreateNode(yWorks.GraphML.IParseContext)" />
    </member>
    <member name="F:yWorks.GraphML.CreationProperties.Style">
      <summary>
        <para>Creation property key that tags style information.</para>
      </summary>
      <remarks>
        <para>Stores values of type <see cref="T:yWorks.Graph.Styles.INodeStyle" />, <see cref="T:yWorks.Graph.Styles.IEdgeStyle" />, and <see cref="T:yWorks.Graph.Styles.IPortStyle" /> respectively.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.IGraphElementFactory" />
    </member>
    <member name="F:yWorks.GraphML.CreationProperties.Tag">
      <summary>
        <para>Creation property key that tags <see cref="P:yWorks.Graph.ITagOwner.Tag">tag</see> object information.</para>
      </summary>
      <remarks>
        <para>Stores values of type <see cref="T:System.Object" />.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.IGraphElementFactory" />
    </member>
    <member name="F:yWorks.GraphML.CreationProperties.Bends">
      <summary>
        <para>Creation property key that tags bend information.</para>
      </summary>
      <remarks>
        <para>Stores values of type <see cref="T:System.Collections.Generic.IEnumerable`1" /> with <see cref="T:yWorks.Graph.IBend" /> template instances.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.IGraphElementFactory.CreateEdge(yWorks.GraphML.IParseContext,yWorks.Graph.INode,yWorks.Graph.IPort,yWorks.Graph.INode,yWorks.Graph.IPort)" />
    </member>
    <member name="F:yWorks.GraphML.CreationProperties.PortLocationModelParameter">
      <summary>
        <para>Creation property key that tags <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter">port location</see> information.</para>
      </summary>
      <remarks>
        <para>Stores values of type <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" />.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.IGraphElementFactory.AddPort(yWorks.GraphML.IParseContext,yWorks.Graph.IPortOwner)" />
    </member>
    <member name="P:yWorks.GraphML.CreationProperties.Entries">
      <summary>
        <para>Gets all the entries stored by this instance.</para>
      </summary>
      <value>
        <para>The entries.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.CreationProperties.Clear">
      <summary>
        <para>Clears all entries from this property store.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.CreationProperties.RemoveValue(System.Object)">
      <summary>
        <para>Removes the associated entry for the given key</para>
      </summary>
      <param name="key">
        <para>The entry key to remove.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.CreationProperties.Item(System.Object)">
      <summary>
        <para>Gets or sets the value associated with the specified key.</para>
      </summary>
      <value>
        <para>The new value.</para>
      </value>
      <param name="key">
        <para>The key.</para>
      </param>
      <returns>
        <para>The value stored for the key.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.DeserializationNotSupportedException">
      <summary>
        <para>Exception that will be thrown by the <see cref="M:yWorks.GraphML.IParseContext.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> method and the like to indicate that the deserialization failed.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.DeserializationNotSupportedException.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.DeserializationNotSupportedException" /> class.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.DeserializationNotSupportedException.#ctor(System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.DeserializationNotSupportedException" /> class with the given message.</para>
      </summary>
      <param name="message">
        <para>The message.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.DeserializationNotSupportedException.#ctor(System.String,System.Exception)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.DeserializationNotSupportedException" /> class with the given message and inner exception.</para>
      </summary>
      <param name="message">
        <para>The message.</para>
      </param>
      <param name="inner">
        <para>The inner exception.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.DeserializationNotSupportedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.DeserializationNotSupportedException" /> class.</para>
      </summary>
      <param name="info">
        <para>The data for serializing or deserializing the object.</para>
      </param>
      <param name="context">
        <para>The source and destination for the object.</para>
      </param>
    </member>
    <member name="T:yWorks.GraphML.GraphMLParser">
      <summary>
        <para>Core parser class for GraphML.</para>
      </summary>
      <remarks>
        <para>This class allows for low-level customization of the parsing process. Usually, it is used by one of <see cref="T:yWorks.GraphML.GraphMLIOHandler" />'s <c>Read</c> methods which calls one the various <c>Parse</c> method overloads. It should rarely be necessary to use this class directly.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.GraphMLIOHandler" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers">
      <summary>
        <para>Occurs when <see cref="T:yWorks.GraphML.IInputHandler" />s are queried.</para>
      </summary>
      <remarks>
        <para>Subscribe to this event to dynamically register one or more <see cref="T:yWorks.GraphML.IInputHandler" /> instance(s) for a given GraphML attribute key definition.</para>
        <para>The current key definition is provided by <see cref="P:yWorks.GraphML.QueryInputHandlersEventArgs.KeyDefinition" />. If you want to register an <see cref="T:yWorks.GraphML.IInputHandler" /> for this GraphML attribute, you can add the handler with <see cref="M:yWorks.GraphML.QueryInputHandlersEventArgs.AddInputHandler(yWorks.GraphML.IInputHandler)" />.</para>
      </remarks>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.QueryInputHandlers" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLParser.HandleDeserialization">
      <summary>
        <para>Occurs when XML content is about to be deserialized.</para>
      </summary>
      <remarks>
        <para>Subscribe to this event to provide custom deserialization handling for XML content.</para>
        <para>The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called earlier.</para>
        <para>The current XML content is provided by <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.XmlNode" />. If you want to return deserialized content, set the value of the <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.Result" /> property.</para>
      </remarks>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.HandleDeserialization" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.OnQueryInputHandlers(yWorks.GraphML.QueryInputHandlersEventArgs)">
      <summary>
        <para>Fires the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments that get passed to the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.OnQueryInputHandlers(yWorks.GraphML.QueryInputHandlersEventArgs)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.OnHandleDeserialization(yWorks.GraphML.HandleDeserializationEventArgs)">
      <summary>
        <para>Fires the <see cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments that get passed to the <see cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" /> event.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.OnHandleDeserialization(yWorks.GraphML.HandleDeserializationEventArgs)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)">
      <summary>
        <para>Deserialize the content of <paramref name="element" />.</para>
      </summary>
      <remarks>
        <para>Typically, this method is called only indirectly by calls to <see cref="M:yWorks.GraphML.IParseContext.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> or <see cref="M:yWorks.GraphML.ParseContextExtensions.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" />. This implementation calls <see cref="M:yWorks.GraphML.GraphMLParser.OnHandleDeserialization(yWorks.GraphML.HandleDeserializationEventArgs)" />, which in turn raises the <see cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" /> event.</para>
      </remarks>
      <typeparam name="T">
        <para>The desired type of the result.</para>
      </typeparam>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="element">
        <para>The XML content that should be deserialized.</para>
      </param>
      <returns>
        <para>An instance of <typeparamref name="T" /> that is represented by <paramref name="element" />.</para>
      </returns>
      <seealso cref="M:yWorks.GraphML.IParseContext.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" />
      <seealso cref="M:yWorks.GraphML.ParseContextExtensions.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" />
      <seealso cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.GetInputHandlers(yWorks.GraphML.IParseContext,System.Xml.Linq.XElement)">
      <summary>
        <para>Dynamically retrieve all <see cref="T:yWorks.GraphML.IInputHandler" /> instances that process a GraphML attribute with key definition <paramref name="keyDefinition" />.</para>
      </summary>
      <remarks>
        <para>Typically, this method is called only indirectly by the parse process. This implementation calls <see cref="M:yWorks.GraphML.GraphMLParser.OnQueryInputHandlers(yWorks.GraphML.QueryInputHandlersEventArgs)" />, which in turn raises the <see cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" /> event.</para>
      </remarks>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="keyDefinition">
        <para>The key definition element of the GraphML attribute.</para>
      </param>
      <returns>
        <para>A list of <see cref="T:yWorks.GraphML.IInputHandler">IInputHandlers</see> that claim to be responsible for handling the given GraphML attribute.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.Parse(yWorks.Graph.IGraph,System.Xml.Linq.XDocument,yWorks.GraphML.IGraphElementFactory)">
      <summary>
        <para>Parse the XML document <paramref name="document" /> into an <paramref name="graph" /> instance, using <paramref name="elementFactory" /> to create the elements.</para>
      </summary>
      <remarks>
        <para>Typically, this method is called indirectly from <see cref="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.Xml.Linq.XDocument)" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph instance that is populated.</para>
      </param>
      <param name="document">
        <para>The XML document instance to parse.</para>
      </param>
      <param name="elementFactory">
        <para>The <see cref="T:yWorks.GraphML.IGraphElementFactory" /> instance that is used to create the elements.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.Xml.Linq.XDocument)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.Parse(yWorks.Graph.IGraph,System.IO.Stream,yWorks.GraphML.IGraphElementFactory)">
      <summary>
        <para>Parse the input <paramref name="stream" /> into an <paramref name="graph" /> instance, using <paramref name="elementFactory" /> to create the elements.</para>
      </summary>
      <remarks>
        <para>Typically, this method is called indirectly from <see cref="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.IO.Stream)" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph instance that is populated.</para>
      </param>
      <param name="stream">
        <para>The input stream to parse.</para>
      </param>
      <param name="elementFactory">
        <para>The <see cref="T:yWorks.GraphML.IGraphElementFactory" /> instance that is used to create the elements.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.IO.Stream)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.Parse(yWorks.Graph.IGraph,System.IO.TextReader,yWorks.GraphML.IGraphElementFactory)">
      <summary>
        <para>Parse the input <paramref name="reader" /> into an <paramref name="graph" /> instance, using <paramref name="elementFactory" /> to create the elements.</para>
      </summary>
      <remarks>
        <para>Typically, this method is called indirectly from <see cref="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.IO.TextReader)" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph instance that is populated.</para>
      </param>
      <param name="reader">
        <para>The input reader to parse.</para>
      </param>
      <param name="elementFactory">
        <para>The <see cref="T:yWorks.GraphML.IGraphElementFactory" /> instance that is used to create the elements.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.IO.TextReader)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.Parse(yWorks.Graph.IGraph,System.String,yWorks.GraphML.IGraphElementFactory)">
      <summary>
        <para>Parse the input <paramref name="uri" /> into an <paramref name="graph" /> instance, using <paramref name="elementFactory" /> to create the elements.</para>
      </summary>
      <remarks>
        <para>Typically, this method is called indirectly from <see cref="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.IO.TextReader)" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph instance that is populated.</para>
      </param>
      <param name="uri">
        <para>The URI to the input to parse.</para>
      </param>
      <param name="elementFactory">
        <para>The <see cref="T:yWorks.GraphML.IGraphElementFactory" /> instance that is used to create the elements.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.Read(yWorks.Graph.IGraph,System.IO.TextReader)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.CreateParseContext(yWorks.Graph.IGraph)">
      <summary>
        <para>Create the initial <see cref="T:yWorks.GraphML.IParseContext" /> instance.</para>
      </summary>
      <param name="graph">
        <para>The graph that is parsed.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.GraphML.IParseContext" /> instance that is suitable for <paramref name="graph" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.SetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)">
      <summary>
        <para>Set a deserialization property that allows to fine tune the parsing process.</para>
      </summary>
      <param name="key">
        <para>The key for the property.</para>
      </param>
      <param name="value">
        <para>The property value.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.IParseContext.GetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0})" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.RemoveDeserializationProperty``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Remove a deserialization property that has been set by <see cref="M:yWorks.GraphML.GraphMLParser.SetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)" />.</para>
      </summary>
      <param name="key">
        <para>The key for the property.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.IParseContext.GetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0})" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.GetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Retrieve a deserialization property that has been set by <see cref="M:yWorks.GraphML.GraphMLParser.SetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)" />.</para>
      </summary>
      <remarks>
        <para>The return value is automatically converted to type <typeparamref name="T" />.</para>
      </remarks>
      <param name="key">
        <para>The key for the property.</para>
      </param>
      <typeparam name="T">
        <para>The target type of the property.</para>
      </typeparam>
      <seealso cref="M:yWorks.GraphML.IParseContext.GetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0})" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.SetLookup``1(``0)">
      <summary>
        <para>Register an implementation of <typeparamref name="T" /> for use with <see cref="M:yWorks.GraphML.GraphMLParser.Lookup(System.Type)" />.</para>
      </summary>
      <typeparam name="T">
        <para>The type of <paramref name="instance" />.</para>
      </typeparam>
      <param name="instance">
        <para>The implementation of <typeparamref name="T" /> for lookup retrieval.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.RemoveLookup``1">
      <summary>
        <para>Remove an implementation of <typeparamref name="T" /> that has been set with <see cref="M:yWorks.GraphML.GraphMLParser.SetLookup``1(``0)" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.Lookup(System.Type)">
      <summary>
        <para>Dynamically retrieve an instance of <paramref name="type" />.</para>
      </summary>
      <param name="type">
        <para>The type for which an implementation is needed.</para>
      </param>
      <returns>
        <para>An implementation of <paramref name="type" />, or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.OnParsed(yWorks.GraphML.ParseEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLParser.Parsed" /> event.</para>
      </summary>
      <remarks>
        <para>This method is called when the document has been parsed and after <see cref="E:yWorks.GraphML.IParseEvents.DocumentParsed" /> is called.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.GraphML.ParseEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="E:yWorks.GraphML.GraphMLParser.Parsed" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLParser.Parsed">
      <summary>
        <para>Occurs when the the document has been parsed.</para>
      </summary>
      <seealso cref="M:yWorks.GraphML.GraphMLParser.OnParsed(yWorks.GraphML.ParseEventArgs)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParser.OnParsing(yWorks.GraphML.ParseEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLParser.Parsing" /> event.</para>
      </summary>
      <remarks>
        <para>This method is called just before the parsing starts and before <see cref="E:yWorks.GraphML.IParseEvents.DocumentParsing" /> is called.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.GraphML.ParseEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="E:yWorks.GraphML.GraphMLParser.Parsing" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLParser.Parsing">
      <summary>
        <para>Occurs when the parsing of the document is just about to begin.</para>
      </summary>
      <remarks>
        <para>This event can be used to register to the fine-grained events available in the <see cref="P:yWorks.GraphML.ParseEventArgs.Context" />'s <see cref="P:yWorks.GraphML.IParseContext.ParseEvents" /> and the configure the parsing process on a per parse case.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.GraphMLParser.OnParsing(yWorks.GraphML.ParseEventArgs)" />
    </member>
    <member name="T:yWorks.GraphML.HandleDeserializationEventArgs">
      <summary>
        <para>The event arguments used by <see cref="E:yWorks.GraphML.GraphMLIOHandler.HandleDeserialization" /> and <see cref="E:yWorks.GraphML.GraphMLParser.HandleDeserialization" /> to let registered deserialization code perform the deserialization.</para>
      </summary>
      <remarks>
        <para>If the event handler determines that it can deserialize the <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.XmlNode" />, it should place the result into the <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.Result" /> property and thus mark the event as <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.Handled" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.HandleDeserializationEventArgs.#ctor(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject,System.Type)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.HandleDeserializationEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context in which serialization should take place.</para>
      </param>
      <param name="xmlNode">
        <para>The XML element that contains the data to deserialize.</para>
      </param>
      <param name="targetType">
        <para>The required <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.TargetType">target type</see> of the <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.Result" />.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.HandleDeserializationEventArgs.TargetType">
      <summary>
        <para>Gets the type of the resulting instance that is required by the requesting deserializer or <c>null</c> if the target type is not known in advance.</para>
      </summary>
      <value>
        <para>The type of the result.</para>
      </value>
      <seealso cref="M:yWorks.GraphML.IParseContext.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" />
    </member>
    <member name="P:yWorks.GraphML.HandleDeserializationEventArgs.Result">
      <summary>
        <para>Gets or sets the result of the deserialization, which is <c>null</c> initially.</para>
      </summary>
      <remarks>
        <para>Setting this property will automatically set the <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.Handled" /> property to <c>true</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>If the value is not assignable to <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.TargetType" /></para>
      </exception>
    </member>
    <member name="P:yWorks.GraphML.HandleDeserializationEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.GraphML.HandleDeserializationEventArgs" /> is handled.</para>
      </summary>
      <remarks>
        <para>Setting this property to <c>true</c> indicates to the event source that the <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.Result" /> has been assigned and that the event should not be propagated to further listeners.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this event has been handled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.HandleDeserializationEventArgs.Context">
      <summary>
        <para>Gets the context in which the <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.XmlNode" /> shall be deserialized.</para>
      </summary>
      <value>
        <para>The context.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.HandleDeserializationEventArgs.XmlNode">
      <summary>
        <para>Gets the XML node that contains the data to deserialize.</para>
      </summary>
      <value>
        <para>The XML node.</para>
      </value>
    </member>
    <member name="T:yWorks.GraphML.IGraphElementFactory">
      <summary>
        <para>This is the interface for a factory that is used for creating the constituents of an <see cref="T:yWorks.Graph.IGraph" /> that are encountered during the parsing of <see cref="T:yWorks.GraphML.GraphMLParser">GraphML</see></para>
      </summary>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.CreateGraphElementFactory(yWorks.GraphML.GraphMLParser,yWorks.Graph.IGraph)" />
    </member>
    <member name="M:yWorks.GraphML.IGraphElementFactory.CreateNode(yWorks.GraphML.IParseContext)">
      <summary>
        <para>Creates a node for the given context.</para>
      </summary>
      <param name="context">
        <para>The context from which the graph, the <see cref="T:yWorks.GraphML.CreationProperties" />, and the <see cref="P:yWorks.GraphML.IParseContext.ObjectStack" /> can be queried.</para>
      </param>
      <returns>
        <para>A newly created node</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementFactory.CreateEdge(yWorks.GraphML.IParseContext,yWorks.Graph.INode,yWorks.Graph.IPort,yWorks.Graph.INode,yWorks.Graph.IPort)">
      <summary>
        <para>Creates an edge for the given context and the provided source and target nodes or ports.</para>
      </summary>
      <param name="context">
        <para>The context from which the graph, the <see cref="T:yWorks.GraphML.CreationProperties" />, and the <see cref="P:yWorks.GraphML.IParseContext.ObjectStack" /> can be queried.</para>
      </param>
      <param name="sourceNode">
        <para>The source node for the edge.</para>
      </param>
      <param name="sourcePort">
        <para>The source port for the edge, if specified, otherwise <c>null</c>.</para>
      </param>
      <param name="targetNode">
        <para>The target node for the edge.</para>
      </param>
      <param name="targetPort">
        <para>The target port for the edge, if specified, otherwise <c>null</c>.</para>
      </param>
      <returns>
        <para>A newly created edge.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementFactory.AddPort(yWorks.GraphML.IParseContext,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Adds a new port to the given <see cref="T:yWorks.Graph.IPortOwner" />.</para>
      </summary>
      <param name="context">
        <para>The context from which the graph, the <see cref="T:yWorks.GraphML.CreationProperties" />, and the <see cref="P:yWorks.GraphML.IParseContext.ObjectStack" /> can be queried.</para>
      </param>
      <param name="owner">
        <para>The owner of the port.</para>
      </param>
      <returns>
        <para>A newly created port.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.IGraphElementIdAcceptor">
      <summary>
        <para>Interface for classes that can store the GraphML id attribute of GraphML core elements</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementIdAcceptor.StoreId(yWorks.GraphML.IParseContext,yWorks.Graph.IGraph,System.String)">
      <summary>
        <para>Store the value of the id attribute for the given graph.</para>
      </summary>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="graph">
        <para>The current graph element</para>
      </param>
      <param name="id">
        <para>The id of the graph's XML representation</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementIdAcceptor.StoreId(yWorks.GraphML.IParseContext,yWorks.Graph.INode,System.String)">
      <summary>
        <para>Store the value of the id attribute for the given node.</para>
      </summary>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="node">
        <para>The current node element</para>
      </param>
      <param name="id">
        <para>The id of the node's XML representation</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementIdAcceptor.StoreId(yWorks.GraphML.IParseContext,yWorks.Graph.IEdge,System.String)">
      <summary>
        <para>Store the value of the id attribute for the given edge.</para>
      </summary>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="edge">
        <para>The current edge element</para>
      </param>
      <param name="id">
        <para>The id of the edge's XML representation</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementIdAcceptor.StoreId(yWorks.GraphML.IParseContext,yWorks.Graph.IPort,System.String)">
      <summary>
        <para>Store the value of the id attribute for the given port.</para>
      </summary>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="port">
        <para>The current port element</para>
      </param>
      <param name="id">
        <para>The id of the port's XML representation</para>
      </param>
    </member>
    <member name="T:yWorks.GraphML.GraphElementIdAcceptor">
      <summary>
        <para>Simple implementation of <see cref="T:yWorks.GraphML.IGraphElementIdAcceptor" /> and <see cref="T:yWorks.GraphML.IGraphElementIdProvider" /> that stores all ids in <see cref="T:yWorks.Graph.IMapper`2" /> instances.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.GraphElementIdAcceptor.GraphIds">
      <summary>
        <para>Gets a mapping between all GraphML ids for <c>&lt;graph&gt;</c> elements and the corresponding <see cref="T:yWorks.Graph.IGraph" /> instances</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.GraphElementIdAcceptor.NodeIds">
      <summary>
        <para>Gets a mapping between all GraphML ids for <c>&lt;node&gt;</c> elements and the corresponding <see cref="T:yWorks.Graph.INode" /> instances</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.GraphElementIdAcceptor.EdgeIds">
      <summary>
        <para>Gets a mapping between all GraphML ids for <c>&lt;edge&gt;</c> elements and the corresponding <see cref="T:yWorks.Graph.IEdge" /> instances</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.GraphElementIdAcceptor.PortIds">
      <summary>
        <para>Gets a mapping between all GraphML ids for <c>&lt;port&gt;</c> elements and the corresponding <see cref="T:yWorks.Graph.IPort" /> instances</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.GraphElementIdAcceptor.StoreId(yWorks.GraphML.IParseContext,yWorks.Graph.IGraph,System.String)">
      <param name="context" />
      <param name="graph" />
      <param name="id" />
    </member>
    <member name="M:yWorks.GraphML.GraphElementIdAcceptor.StoreId(yWorks.GraphML.IParseContext,yWorks.Graph.INode,System.String)">
      <param name="context" />
      <param name="node" />
      <param name="id" />
    </member>
    <member name="M:yWorks.GraphML.GraphElementIdAcceptor.StoreId(yWorks.GraphML.IParseContext,yWorks.Graph.IEdge,System.String)">
      <param name="context" />
      <param name="edge" />
      <param name="id" />
    </member>
    <member name="M:yWorks.GraphML.GraphElementIdAcceptor.StoreId(yWorks.GraphML.IParseContext,yWorks.Graph.IPort,System.String)">
      <param name="context" />
      <param name="port" />
      <param name="id" />
    </member>
    <member name="M:yWorks.GraphML.GraphElementIdAcceptor.CreateIdProvider(yWorks.GraphML.IGraphElementIdProvider)">
      <summary>
        <para>Factory method to create a default implementation of <see cref="T:yWorks.GraphML.IGraphElementIdProvider" /> that delegates to <paramref name="fallback" /> and uses the values stored by this <see cref="T:yWorks.GraphML.GraphElementIdAcceptor" /> instance, if possible.</para>
      </summary>
      <param name="fallback">
        <para>The fallback.</para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.GraphML.GraphElementIdAcceptor.ResolveNode(yWorks.GraphML.IParseContext,System.String)">
      <param name="context" />
      <param name="id" />
    </member>
    <member name="M:yWorks.GraphML.GraphElementIdAcceptor.ResolveGraph(yWorks.GraphML.IParseContext,System.String)">
      <param name="context" />
      <param name="id" />
    </member>
    <member name="M:yWorks.GraphML.GraphElementIdAcceptor.ResolvePort(yWorks.GraphML.IParseContext,System.String,System.String)">
      <param name="context" />
      <param name="ownerId" />
      <param name="id" />
    </member>
    <member name="M:yWorks.GraphML.GraphElementIdAcceptor.ResolveEdge(yWorks.GraphML.IParseContext,System.String)">
      <param name="context" />
      <param name="id" />
    </member>
    <member name="T:yWorks.GraphML.IGraphElementResolver">
      <summary>
        <para>Interface for classes can resolve graph elements based on their GraphML id attribute(s).</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementResolver.ResolveNode(yWorks.GraphML.IParseContext,System.String)">
      <summary>
        <para>Resolve the GraphML <paramref name="id" /> to an <see cref="T:yWorks.Graph.INode" /> instance.</para>
      </summary>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="id">
        <para>The id that should be resolved.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.INode" /> that is defined by this GraphML <paramref name="id" />, or <c>null</c> if no such node exists yet.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementResolver.ResolveGraph(yWorks.GraphML.IParseContext,System.String)">
      <summary>
        <para>Resolve the GraphML <paramref name="id" /> to an <see cref="T:yWorks.Graph.IGraph" /> instance.</para>
      </summary>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="id">
        <para>The id that should be resolved.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.IGraph" /> that is defined by this GraphML <paramref name="id" />, or <c>null</c> if no such graph exists yet.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementResolver.ResolvePort(yWorks.GraphML.IParseContext,System.String,System.String)">
      <summary>
        <para>Resolve the GraphML <paramref name="id" /> to an <see cref="T:yWorks.Graph.IPort" /> instance.</para>
      </summary>
      <remarks>
        <para>The port owner is specified by the <paramref name="ownerId" /> attribute.</para>
      </remarks>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="ownerId">
        <para>The GraphML id of the port owner.</para>
      </param>
      <param name="id">
        <para>The id that should be resolved.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.IPort" /> that is defined by the GraphML ids, or <c>null</c> if no such port exists yet.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementResolver.ResolveEdge(yWorks.GraphML.IParseContext,System.String)">
      <summary>
        <para>Resolve the GraphML <paramref name="id" /> to an <see cref="T:yWorks.Graph.IEdge" /> instance.</para>
      </summary>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="id">
        <para>The id that should be resolved.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.IEdge" /> that is defined by this GraphML <paramref name="id" />, or <c>null</c> if no such edge exists yet.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.IInputHandler">
      <summary>
        <para>This class defines a handler for key/data elements.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.IInputHandler.Precedence">
      <summary>
        <para>Gets the parse precedence that is associated with this instance.</para>
      </summary>
      <value>
        <para>The parse precedence for this instance.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.IInputHandler.ParseData(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)">
      <summary>
        <para>This method is invoked each time a data element with matching key is processed.</para>
      </summary>
      <param name="context">
        <para>the current parse context.</para>
      </param>
      <param name="node">
        <para>the DOM node representing the data element.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.IInputHandler.ApplyDefault(yWorks.GraphML.IParseContext)">
      <summary>
        <para>This method is invoked when no data tag is defined, and the default value should be applied.</para>
      </summary>
      <param name="context">
        <para>the current parse context.</para>
      </param>
    </member>
    <member name="T:yWorks.GraphML.ParsePrecedence">
      <summary>
        <para>This enumeration defines the valid priorities for <see cref="T:yWorks.GraphML.IInputHandler" /> processing.</para>
      </summary>
      <seealso cref="P:yWorks.GraphML.IInputHandler.Precedence" />
    </member>
    <member name="F:yWorks.GraphML.ParsePrecedence.First">
      <summary>
        <para>The data is parsed as early as possible.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.ParsePrecedence.BeforeOwner">
      <summary>
        <para>The data is parsed before its owner GraphML element.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.ParsePrecedence.BeforeChildren">
      <summary>
        <para>The data is parsed after its owner GraphML element, but before any non-data child content.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.ParsePrecedence.Default">
      <summary>
        <para>Default parse priority.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.ParsePrecedence.AfterChildren">
      <summary>
        <para>The data is parsed after any non-data child content, but before parsing the owner GraphML element is finished.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.ParsePrecedence.AfterOwner">
      <summary>
        <para>The data is parsed directly after parsing the owner GraphML element is finished.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.ParsePrecedence.Last">
      <summary>
        <para>The data is parsed as late as possible.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.IParseContext">
      <summary>
        <para>Interface that defines the context of a GraphML parsing context.</para>
      </summary>
      <remarks>
        <para>All state data that is needed for the parsing of a concrete input should go here, allowing all handlers and deserializers to be implemented stateless.</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.IParseContext.ObjectStack">
      <summary>
        <para>Gets the current nesting of created graphs and graph elements.</para>
      </summary>
      <remarks>
        <para>The list contains the user objects which correspond to the GraphML elements which are ancestors of the current node in the DOM tree.</para>
      </remarks>
      <value>
        <para>A read-only view on the current nesting</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.IParseContext.GetCurrent``1">
      <summary>
        <para>Returns the most current (the last element) within the container hierarchy as it is returned by <see cref="P:yWorks.GraphML.IParseContext.ObjectStack" /> or <c>default(T)</c> if the most current element is not of the desired target type.</para>
      </summary>
      <typeparam name="T">
        <para>The desired target type.</para>
      </typeparam>
      <returns>
        <para>the most current element within the container hierarchy or <c>default(T)</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.GraphML.IParseContext.ParseEvents">
      <summary>
        <para>Gets an implementation of <see cref="T:yWorks.GraphML.IParseEvents" /> that allows to subscribe to various events in the parse process.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.IParseContext.Graph">
      <summary>
        <para>Gets the currently active graph object</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IParseContext.GetDeserializationProperty``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Get a property value that specifies information about how to handle specific cases.</para>
      </summary>
      <param name="key">
        <para>The identifier for the property</para>
      </param>
      <returns>
        <para>The property value, or <c>null</c> if no such property exists.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IParseContext.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)">
      <summary>
        <para>Deserialize the object representation in <paramref name="targetNode" /></para>
      </summary>
      <remarks>
        <para>Client code should usually use the extension method <see cref="M:yWorks.GraphML.ParseContextExtensions.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> instead to ensure the the correct <paramref name="context" /> instance is used.</para>
      </remarks>
      <typeparam name="T">
        <para>The expected return type.</para>
      </typeparam>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="targetNode">
        <para>The XML node that should be deserialized.</para>
      </param>
      <returns>
        <para>The deserialized object from <paramref name="targetNode" /> or an <see cref="T:yWorks.GraphML.DeserializationNotSupportedException" /> if <paramref name="targetNode" /> could not be deserialized.</para>
      </returns>
      <seealso cref="M:yWorks.GraphML.ParseContextExtensions.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" />
    </member>
    <member name="T:yWorks.GraphML.ParseContextExtensions">
      <summary>
        <para>Extension methods for <see cref="T:yWorks.GraphML.IParseContext" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.ParseContextExtensions.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)">
      <summary>
        <para>Deserialize the object representation in <paramref name="targetNode" />.</para>
      </summary>
      <remarks>
        <para>This method calls <see cref="M:yWorks.GraphML.IParseContext.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> with <paramref name="context" /> as first argument and should be used in virtually all cases.</para>
      </remarks>
      <typeparam name="T">
        <para>The desired target type.</para>
      </typeparam>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="targetNode">
        <para>The XML node that should be deserialized.</para>
      </param>
      <returns>
        <para>an instance of <typeparamref name="T" /> or <c>null</c>.</para>
      </returns>
      <seealso cref="M:yWorks.GraphML.IParseContext.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" />
      <exception cref="T:yWorks.GraphML.DeserializationNotSupportedException" />
    </member>
    <member name="T:yWorks.GraphML.IParseEvents">
      <summary>
        <para>The interface of the event trigger class that is used by the <see cref="P:yWorks.GraphML.IParseContext.ParseEvents" /> property.</para>
      </summary>
      <remarks>
        <para>This interface defines the available events that client code can register to during the parsing of <see cref="T:yWorks.GraphML.GraphMLParser">GraphML</see>.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.ParseEventArgs" />
      <seealso cref="T:yWorks.GraphML.GraphMLParser" />
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.DocumentParsing">
      <summary>
        <para>Occurs when the document is about to be parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when the document element has been encountered.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.DocumentParsed">
      <summary>
        <para>Occurs when the document has been parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when the document has been fully parsed.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.NodeParsing">
      <summary>
        <para>Occurs when a node element is about to be parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'node' element has been encountered.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.NodeParsed">
      <summary>
        <para>Occurs after a node element has been fully parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'node' closing tag has been handled.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.EdgeParsing">
      <summary>
        <para>Occurs when an edge element is about to be parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'edge' element has been encountered.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.EdgeParsed">
      <summary>
        <para>Occurs after a edge element has been fully parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'edge' closing tag has been handled.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.PortParsing">
      <summary>
        <para>Occurs when a port element is about to be parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'port' element has been encountered.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.PortParsed">
      <summary>
        <para>Occurs after a port element has been fully parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'port' closing tag has been handled.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.GraphParsing">
      <summary>
        <para>Occurs when a graph element is about to be parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'graph' element has been encountered.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.GraphParsed">
      <summary>
        <para>Occurs after a graph element has been fully parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'graph' closing tag has been handled.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.GraphMLParsing">
      <summary>
        <para>Occurs when the graphml element is about to be parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'graphml' root-element has been encountered.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.GraphMLParsed">
      <summary>
        <para>Occurs after the graphml element has been fully parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'graphml' closing tag has been handled.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.DataParsing">
      <summary>
        <para>Occurs when a data element is about to be parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'data' element has been encountered.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.DataParsed">
      <summary>
        <para>Occurs after a data element has been fully parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'data' element has been handled.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.KeyParsing">
      <summary>
        <para>Occurs when a key element is about to be parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'key' element has been encountered.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IParseEvents.KeyParsed">
      <summary>
        <para>Occurs after a key element has been fully parsed.</para>
      </summary>
      <remarks>
        <para>This event is triggered when a GraphML 'key' element has been handled.</para>
      </remarks>
    </member>
    <member name="T:yWorks.GraphML.ParseEventArgs">
      <summary>
        <para>This is the event argument that is used by the <see cref="T:yWorks.GraphML.IParseEvents" /> interface that can be queried from the <see cref="P:yWorks.GraphML.IParseContext.ParseEvents" /> property.</para>
      </summary>
      <remarks>
        <para>This class holds a reference to the <see cref="P:yWorks.GraphML.ParseEventArgs.Context">parse context</see> and the <see cref="P:yWorks.GraphML.ParseEventArgs.Element" /> that is currently being parsed.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.ParseEventArgs.#ctor(yWorks.GraphML.IParseContext,System.Xml.Linq.XElement)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.ParseEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context to assign to <see cref="P:yWorks.GraphML.ParseEventArgs.Context" />.</para>
      </param>
      <param name="element">
        <para>The XML element to assign to <see cref="P:yWorks.GraphML.ParseEventArgs.Element" />.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.ParseEventArgs.Context">
      <summary>
        <para>Gets the context that is being used for parsing.</para>
      </summary>
      <value>
        <para>The context.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.ParseEventArgs.Element">
      <summary>
        <para>Gets the XML element that is currently parsed.</para>
      </summary>
      <value>
        <para>XML element that is currently parsed.</para>
      </value>
    </member>
    <member name="T:yWorks.GraphML.InputHandlerBase`2">
      <summary>
        <para>An abstract convenience implementation of the <see cref="T:yWorks.GraphML.IInputHandler" /> interface.</para>
      </summary>
      <typeparam name="TKey">
        <para>The type of the key, i.e. the items that are associated with the data in the GraphML.</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the data that is associated with the keys.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.GraphML.InputHandlerBase`2.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.InputHandlerBase`2" /> class.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.GraphML.InputHandlerBase`2.Precedence" /> has an initial value of <see cref="F:yWorks.GraphML.ParsePrecedence.Default" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.InputHandlerBase`2.#ctor(yWorks.GraphML.ParsePrecedence)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.InputHandlerBase`2" /> class.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.GraphML.InputHandlerBase`2.Precedence" /> gets the initial value assigned to <paramref name="precedence" /></para>
      </remarks>
      <param name="precedence">
        <para>The precedence to assign to the <see cref="P:yWorks.GraphML.InputHandlerBase`2.Precedence" /> property.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.InputHandlerBase`2.ParseDefaultValue">
      <summary>
        <para>Gets or sets a value indicating whether the default value in the key definition should be parsed.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the default value should be parsed; <c>false</c> otherwise. The default is <c>true</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.InputHandlerBase`2.DefaultValue">
      <summary>
        <para>Gets or sets the default value that will be applied to the keys where the data attribute is missing.</para>
      </summary>
      <remarks>
        <para>If any default value is set (including <c>null</c>), <see cref="P:yWorks.GraphML.InputHandlerBase`2.DefaultExists" /> is automatically set to true.</para>
      </remarks>
      <value>
        <para>The default value.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.InputHandlerBase`2.DefaultExists">
      <summary>
        <para>Gets a value indicating whether a default value has been set, either through a key definition element or explicitly by assigning a value to the <see cref="P:yWorks.GraphML.InputHandlerBase`2.DefaultValue" /> property.</para>
      </summary>
      <remarks>
        <para>If this property is set to <c>true</c>, the <see cref="M:yWorks.GraphML.InputHandlerBase`2.ApplyDefault(yWorks.GraphML.IParseContext)" /> method will call the <see cref="M:yWorks.GraphML.InputHandlerBase`2.SetValue(yWorks.GraphML.IParseContext,`0,`1)" /> method using the <see cref="P:yWorks.GraphML.InputHandlerBase`2.DefaultValue" /> as the value parameter.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the default value exists; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.InputHandlerBase`2.Precedence">
      <summary>
        <para>Gets or sets the parse precedence that is associated with this handler.</para>
      </summary>
      <value>
        <para>The parse precedence.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.InputHandlerBase`2.ParseData(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)">
      <summary>
        <para>This method is invoked each time a data element with matching key is processed.</para>
      </summary>
      <remarks>
        <para>If the <see cref="M:yWorks.GraphML.IParseContext.GetCurrent``1">current element</see> is of the same type as this <typeparamref name="TKey" />, this method delegates the actual parsing to <see cref="M:yWorks.GraphML.InputHandlerBase`2.ParseDataCore(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> and <see cref="M:yWorks.GraphML.InputHandlerBase`2.SetValue(yWorks.GraphML.IParseContext,`0,`1)" /></para>
      </remarks>
      <param name="context">
        <para>the current parse context.</para>
      </param>
      <param name="node">
        <para>the DOM node representing the data element.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.InputHandlerBase`2.InitializeFromKeyDefinition(yWorks.GraphML.IParseContext,System.Xml.Linq.XElement)">
      <summary>
        <para>Initializes this instance from the GraphML key definition.</para>
      </summary>
      <remarks>
        <para>This implementation looks for the GraphML default element and delegates to <see cref="M:yWorks.GraphML.InputHandlerBase`2.ParseDataCore(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> if a default is found to store the <see cref="P:yWorks.GraphML.InputHandlerBase`2.DefaultValue" />.</para>
      </remarks>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="definition">
        <para>The definition.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.InputHandlerBase`2.ParseDataCore(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)">
      <summary>
        <para>Abstract method callback that actually parses the data.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="node">
        <para>The node that contains the data. This is either the GraphML 'data' element or the 'default' element.</para>
      </param>
      <returns>
        <para>The parsed data.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.InputHandlerBase`2.SetValue(yWorks.GraphML.IParseContext,`0,`1)">
      <summary>
        <para>Abstract method callback that actually stores the value with the keys.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="key">
        <para>The key.</para>
      </param>
      <param name="data">
        <para>The data.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.InputHandlerBase`2.ApplyDefault(yWorks.GraphML.IParseContext)">
      <summary>
        <para>This method is invoked when no data tag is defined, and the default value should be applied.</para>
      </summary>
      <remarks>
        <para>This implementation delegates to <see cref="M:yWorks.GraphML.InputHandlerBase`2.SetValue(yWorks.GraphML.IParseContext,`0,`1)" /> if <see cref="P:yWorks.GraphML.InputHandlerBase`2.DefaultExists">a default exists</see> using the <see cref="P:yWorks.GraphML.InputHandlerBase`2.DefaultValue" />.</para>
      </remarks>
      <param name="context">
        <para>the current parse context.</para>
      </param>
    </member>
    <member name="T:yWorks.GraphML.MapperInputHandler`2">
      <summary>
        <para>An <see cref="T:yWorks.GraphML.IInputHandler" /> implementation that uses an <see cref="T:yWorks.Graph.IMapper`2" /> instance to associate the values with the keys.</para>
      </summary>
      <remarks>
        <para>This implementation can be provided an <see cref="T:yWorks.GraphML.HandleDeserializationEventArgs" />-handler to perform the deserialization. If no such value is provided then the default deserialization is performed.</para>
        <para>The parsed values are stored in a <see cref="T:yWorks.Graph.IMapper`2" />.</para>
      </remarks>
      <typeparam name="TKey">
        <para>The type of the key.</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the value.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.GraphML.MapperInputHandler`2.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.MapperInputHandler`2" /> class that uses the <see cref="T:yWorks.GraphML.IParseContext" /> for deserialization.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.GraphML.IInputHandler.Precedence" /> has an initial value of <see cref="F:yWorks.GraphML.ParsePrecedence.Default" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.MapperInputHandler`2.#ctor(System.EventHandler{yWorks.GraphML.HandleDeserializationEventArgs},System.Type)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.MapperInputHandler`2" /> class that uses the event handler for deserialization and suggests the provided target type for the deserializer.</para>
      </summary>
      <seealso cref="P:yWorks.GraphML.MapperInputHandler`2.DeserializerTargetType" />
      <seealso cref="P:yWorks.GraphML.MapperInputHandler`2.Deserializer" />
      <param name="deserializer" />
      <param name="deserializerTargetType" />
    </member>
    <member name="P:yWorks.GraphML.MapperInputHandler`2.Mapper">
      <summary>
        <para>Gets or sets the mapper to use for storing the data.</para>
      </summary>
      <value>
        <para>The mapper.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.MapperInputHandler`2.OverrideDefaultValue">
      <summary>
        <para>Gets or sets a value indicating whether values that are applied via the <see cref="M:yWorks.GraphML.InputHandlerBase`2.ApplyDefault(yWorks.GraphML.IParseContext)" /> mechanism and are equal to the value that is already present in the mapper will explicitly be overridden in the mapper.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if default values should be overridden in the mapper; <c>false</c> otherwise. By default this is set to <c>false</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.MapperInputHandler`2.UseParentElementForDeserialization">
      <summary>
        <para>Gets or sets whether <see cref="M:yWorks.GraphML.MapperInputHandler`2.GetDeserializationXmlNode(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> returns either the <c>'data'</c>/<c>'default'</c> element itself or its content.</para>
      </summary>
      <remarks>
        <para>The default value is <c>false</c>, meaning that <see cref="M:yWorks.GraphML.MapperInputHandler`2.GetDeserializationXmlNode(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> should return the content of the <c>'data'</c>/<c>'default'</c> node.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.MapperInputHandler`2.GetDeserializationXmlNode(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" />
    </member>
    <member name="P:yWorks.GraphML.MapperInputHandler`2.Deserializer">
      <summary>
        <para>Gets or sets the deserializer.</para>
      </summary>
      <value>
        <para>The deserializer.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.MapperInputHandler`2.DeserializerTargetType">
      <summary>
        <para>Gets or sets the target deserialization type for the <see cref="P:yWorks.GraphML.HandleDeserializationEventArgs.TargetType" /> property.</para>
      </summary>
      <value>
        <para>The target type of the deserialization.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.MapperInputHandler`2.SetValue(yWorks.GraphML.IParseContext,`0,`1)">
      <summary>
        <para>This method uses the <see cref="P:yWorks.GraphML.MapperInputHandler`2.Mapper" /> to associate the data with the key.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="key">
        <para>The key.</para>
      </param>
      <param name="data">
        <para>The data.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.MapperInputHandler`2.ApplyDefault(yWorks.GraphML.IParseContext)">
      <summary>
        <para>Overridden to take the <see cref="P:yWorks.GraphML.MapperInputHandler`2.OverrideDefaultValue" /> property into account.</para>
      </summary>
      <seealso cref="P:yWorks.GraphML.MapperInputHandler`2.OverrideDefaultValue" />
      <seealso cref="M:yWorks.GraphML.InputHandlerBase`2.ApplyDefault(yWorks.GraphML.IParseContext)" />
      <param name="context">
        <para>The context for the parse operation.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.MapperInputHandler`2.ParseDataCore(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)">
      <summary>
        <para>Parses the data using either the <see cref="P:yWorks.GraphML.MapperInputHandler`2.Deserializer" /> or the <see cref="M:yWorks.GraphML.IParseContext.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> call.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="node">
        <para>The node that contains the data. This is either the GraphML <c>'data'</c> element or the <c>'default'</c> element.</para>
      </param>
      <returns>
        <para>The parsed data.</para>
      </returns>
      <seealso cref="M:yWorks.GraphML.MapperInputHandler`2.GetDeserializationXmlNode(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" />
      <exception cref="T:yWorks.GraphML.DeserializationNotSupportedException">
        <para>
          <c>DeserializationNotSupportedException</c> if <see cref="P:yWorks.GraphML.MapperInputHandler`2.Deserializer" /> could not handle the node.</para>
      </exception>
    </member>
    <member name="M:yWorks.GraphML.MapperInputHandler`2.GetDeserializationXmlNode(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)">
      <summary>
        <para>Gets the node to pass to <see cref="P:yWorks.GraphML.MapperInputHandler`2.Deserializer" /> or <see cref="M:yWorks.GraphML.IParseContext.Deserialize``1(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> respectively, given the 'data' or 'default' element from the GraphML.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.GraphML.MapperInputHandler`2.ParseDataCore(yWorks.GraphML.IParseContext,System.Xml.Linq.XObject)" /> to determine the node to pass to the deserialization mechanism.</para>
        <para>This implementation returns <paramref name="node" /> iff <see cref="P:yWorks.GraphML.MapperInputHandler`2.UseParentElementForDeserialization" /> is <c>true</c> (i.e. the <c>'data'</c> or <c>'default'</c> node itself), otherwise the first child of the <paramref name="node" /> that is not a comment or processing instruction.</para>
      </remarks>
      <param name="context">
        <para>The context within which the node is parsed.</para>
      </param>
      <param name="node">
        <para>The 'data' or 'default' node.</para>
      </param>
      <returns>
        <para>The node that should be deserialized.</para>
      </returns>
      <seealso cref="P:yWorks.GraphML.MapperInputHandler`2.UseParentElementForDeserialization" />
    </member>
    <member name="T:yWorks.GraphML.QueryInputHandlersEventArgs">
      <summary>
        <para>Specialized <see cref="T:System.EventArgs" /> that are used for dynamic <see cref="T:yWorks.GraphML.IInputHandler" /> registration.</para>
      </summary>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.QueryInputHandlers" />
      <seealso cref="E:yWorks.GraphML.GraphMLParser.QueryInputHandlers" />
    </member>
    <member name="M:yWorks.GraphML.QueryInputHandlersEventArgs.#ctor(yWorks.GraphML.IParseContext,System.Xml.Linq.XElement,System.Collections.Generic.IList{yWorks.GraphML.IInputHandler})">
      <summary>
        <para>Create a new instance.</para>
      </summary>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="keyDefinition">
        <para>The current key definition</para>
      </param>
      <param name="handlers">
        <para>Stores the registered <see cref="T:yWorks.GraphML.IInputHandler" /> instances.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.QueryInputHandlersEventArgs.AddInputHandler(yWorks.GraphML.IInputHandler)">
      <summary>
        <para>Register an <see cref="T:yWorks.GraphML.IInputHandler" /> instance for the current <see cref="P:yWorks.GraphML.QueryInputHandlersEventArgs.KeyDefinition" />.</para>
      </summary>
      <remarks>
        <para>Calling this method automatically sets <see cref="P:yWorks.GraphML.QueryInputHandlersEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
      <param name="handler" />
    </member>
    <member name="P:yWorks.GraphML.QueryInputHandlersEventArgs.KeyDefinition">
      <summary>
        <para>Gets the key definition of the GraphML attribute.</para>
      </summary>
      <remarks>
        <para>This XML element should be queried to determine if an <see cref="T:yWorks.GraphML.IInputHandler" /> should be registered with <see cref="M:yWorks.GraphML.QueryInputHandlersEventArgs.AddInputHandler(yWorks.GraphML.IInputHandler)" /></para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.QueryInputHandlersEventArgs.Handled">
      <summary>
        <para>Gets or sets whether the current GraphML attribute has been processed.</para>
      </summary>
      <remarks>
        <para>This is automatically set by calling <see cref="M:yWorks.GraphML.QueryInputHandlersEventArgs.AddInputHandler(yWorks.GraphML.IInputHandler)" />, so it should be seldom necessary to set this property manually.</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.QueryInputHandlersEventArgs.Context">
      <summary>
        <para>Gets the <see cref="T:yWorks.GraphML.IParseContext" /> instance that can queried for further information.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.QueryInputHandlersEventArgs.Handlers">
      <summary>
        <para>Gets the <see cref="T:yWorks.GraphML.IInputHandler" />s that have been registered on this event argument instance so far.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.ChildWriteContext">
      <summary>
        <para>An <see cref="T:yWorks.GraphML.IWriteContext" /> implementation for use in the context of <see cref="T:yWorks.GraphML.GraphMLWriter" /> that wraps a given instance and delegates most of the calls to it but allows for modifying <see cref="M:yWorks.GraphML.ChildWriteContext.SetLookup``1(``0)">lookup</see> and <see cref="M:yWorks.GraphML.ChildWriteContext.SetSerializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)">serialization properties</see>.</para>
      </summary>
      <remarks>
        <para>Whenever it is necessary to locally modify some context properties, a new instance of this class should be created that wraps an existing one.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.ChildWriteContext.#ctor(yWorks.GraphML.IWriteContext,System.Object)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.ChildWriteContext" /> class that delegates to the provided context and returns the given value in <see cref="M:yWorks.GraphML.ChildWriteContext.GetCurrent``1" />.</para>
      </summary>
      <param name="parentContext">
        <para>The parent context to delegate calls to.</para>
      </param>
      <param name="currentObject">
        <para>The current object to return in <see cref="M:yWorks.GraphML.ChildWriteContext.GetCurrent``1" />.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.ChildWriteContext.#ctor(yWorks.GraphML.IWriteContext)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.ChildWriteContext" /> class that delegates to the given parent context.</para>
      </summary>
      <param name="parentContext">
        <para>The parent context.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.ChildWriteContext.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.GraphML.ChildWriteContext.SetLookup``1(``0)">
      <summary>
        <para>Adds another lookup result to the local lookup override.</para>
      </summary>
      <typeparam name="T">
        <para>The type to use as a key for the lookup.</para>
      </typeparam>
      <param name="value">
        <para>The value to provide for queries to <typeparamref name="T" />.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.ChildWriteContext.RemoveLookup``1" />
    </member>
    <member name="M:yWorks.GraphML.ChildWriteContext.RemoveLookup``1">
      <summary>
        <para>Removes a local lookup override that has been added using <see cref="M:yWorks.GraphML.ChildWriteContext.SetLookup``1(``0)" /></para>
      </summary>
      <typeparam name="T">
        <para>The type key to remove.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.GraphML.ChildWriteContext.GetCurrent``1" />
    <member name="P:yWorks.GraphML.ChildWriteContext.ParentContext">
      <summary>
        <para>Gets the parent context to which most calls are delegated.</para>
      </summary>
      <value>
        <para>The parent context.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.ChildWriteContext.Writer">
      <summary>
        <para>Gets or sets the writer.</para>
      </summary>
      <remarks>
        <para>If a <c>null</c> writer is set, this implementation will delegate to the <see cref="P:yWorks.GraphML.ChildWriteContext.ParentContext" />'s <see cref="P:yWorks.GraphML.IWriteContext.Writer" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.ChildWriteContext.GetSerializationProperty``1(yWorks.GraphML.TypedKey{``0})">
      <param name="key" />
    </member>
    <member name="M:yWorks.GraphML.ChildWriteContext.SetSerializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)">
      <summary>
        <para>Sets the local serialization property for the given key to the value.</para>
      </summary>
      <param name="key">
        <para>The key to override.</para>
      </param>
      <param name="value">
        <para>The value.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.ChildWriteContext.RemoveSerializationProperty``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Removes a previously locally <see cref="M:yWorks.GraphML.ChildWriteContext.SetSerializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)">set</see> serialization property.</para>
      </summary>
      <param name="key">
        <para>The key for which the local property override should be removed.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.ChildWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)">
      <param name="context" />
      <param name="item" />
    </member>
    <member name="T:yWorks.GraphML.GraphMLWriter">
      <summary>
        <para>Core writer class for GraphML.</para>
      </summary>
      <remarks>
        <para>This class allows for low-level customization of the writing process. Usually, it is used by one of <see cref="T:yWorks.GraphML.GraphMLIOHandler" />'s <c>Write</c> methods which calls one the various <c>Write</c> method overloads. It should rarely be necessary to use this class directly.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.GraphMLIOHandler" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLWriter.HandleSerialization">
      <summary>
        <para>Occurs when XML content is about to be serialized.</para>
      </summary>
      <remarks>
        <para>Subscribe to this event to provide custom serialization handling for XML content.</para>
        <para>The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called earlier.</para>
        <para>The current item is provided by <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" />.</para>
      </remarks>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.HandleSerialization" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers">
      <summary>
        <para>Occurs when <see cref="T:yWorks.GraphML.IOutputHandler" />s are queried.</para>
      </summary>
      <remarks>
        <para>Subscribe to this event to dynamically register one or more <see cref="T:yWorks.GraphML.IOutputHandler" /> instance(s) for a given GraphML attribute key definition.</para>
        <para>The event handlers added to this event are called in inverse order, i.e. handlers that have been added later are called earlier.</para>
        <para>If you want to register an <see cref="T:yWorks.GraphML.IOutputHandler" /> for this GraphML attribute, you can add the handler with <see cref="M:yWorks.GraphML.QueryOutputHandlersEventArgs.AddOutputHandler(yWorks.GraphML.IOutputHandler)" />.</para>
      </remarks>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.QueryOutputHandlers" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLWriter.QueryReferenceId">
      <summary>
        <para>Occurs when a reference is queried.</para>
      </summary>
      <remarks>
        <para>This event can be used to provide names of external references for objects.</para>
        <para>These reference targets are not serialized to the GraphML file.</para>
      </remarks>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.QueryReferenceId" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.OnHandleSerialization(yWorks.GraphML.HandleSerializationEventArgs)">
      <summary>
        <para>Fires the <see cref="E:yWorks.GraphML.GraphMLWriter.HandleSerialization" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments that get passed to the <see cref="E:yWorks.GraphML.GraphMLWriter.HandleSerialization" /> event.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.OnHandleSerialization(yWorks.GraphML.HandleSerializationEventArgs)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.OnQueryOutputHandlers(yWorks.GraphML.QueryOutputHandlersEventArgs)">
      <summary>
        <para>Fires the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments that get passed to the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.OnQueryOutputHandlers(yWorks.GraphML.QueryOutputHandlersEventArgs)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.OnQueryReferenceId(yWorks.GraphML.QueryReferenceIdEventArgs)">
      <summary>
        <para>Fires the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryReferenceId" /> event.</para>
      </summary>
      <param name="args">
        <para>The arguments that get passed to the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryReferenceId" /> event.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.OnQueryReferenceId(yWorks.GraphML.QueryReferenceIdEventArgs)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.GetOutputHandlers(yWorks.GraphML.IWriteContext,yWorks.GraphML.KeyScope)">
      <summary>
        <para>Dynamically retrieve all <see cref="T:yWorks.GraphML.IOutputHandler" /> that should be used for the current write process.</para>
      </summary>
      <remarks>
        <para>Typically, this method is called only indirectly by the write process. This implementation calls <see cref="M:yWorks.GraphML.GraphMLWriter.OnQueryOutputHandlers(yWorks.GraphML.QueryOutputHandlersEventArgs)" />, which in turn raises the <see cref="E:yWorks.GraphML.GraphMLWriter.QueryOutputHandlers" /> event.</para>
      </remarks>
      <param name="context">
        <para>The current write context.</para>
      </param>
      <param name="scope">
        <para>The scope to get output handlers for.</para>
      </param>
      <returns>
        <para>A dictionary from handler definition ids to <see cref="T:yWorks.GraphML.IOutputHandler">IOutputHandlers</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.Serialize``1(yWorks.GraphML.IWriteContext,``0)">
      <summary>
        <para>Serialize <paramref name="item" />.</para>
      </summary>
      <remarks>
        <para>Typically, this method is called only indirectly by calls to <see cref="M:yWorks.GraphML.IWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)" /> or <see cref="M:yWorks.GraphML.WriteContextExtensions.Serialize``1(yWorks.GraphML.IWriteContext,``0)" />. This implementation calls <see cref="M:yWorks.GraphML.GraphMLWriter.OnHandleSerialization(yWorks.GraphML.HandleSerializationEventArgs)" />, which in turn raises the <see cref="E:yWorks.GraphML.GraphMLWriter.HandleSerialization" /> event.</para>
      </remarks>
      <typeparam name="T">
        <para>The desired type of the result.</para>
      </typeparam>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="item">
        <para>The object that should be serialized.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.IWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)" />
      <seealso cref="M:yWorks.GraphML.WriteContextExtensions.Serialize``1(yWorks.GraphML.IWriteContext,``0)" />
      <seealso cref="E:yWorks.GraphML.GraphMLWriter.HandleSerialization" />
      <exception cref="T:yWorks.GraphML.SerializationNotSupportedException">
        <para>
          <c>SerializationNotSupportedException</c> if <paramref name="item" /> cannot be serialized.</para>
      </exception>
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.SetSerializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)">
      <summary>
        <para>Set a serialization property that allows to fine tune the write process.</para>
      </summary>
      <param name="key">
        <para>The key for the property.</para>
      </param>
      <param name="value">
        <para>The property value.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.IWriteContext.GetSerializationProperty``1(yWorks.GraphML.TypedKey{``0})" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.RemoveSerializationProperty``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Remove a serialization property that has been set by <see cref="M:yWorks.GraphML.GraphMLWriter.SetSerializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)" />.</para>
      </summary>
      <param name="key">
        <para>The key for the property.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.IWriteContext.GetSerializationProperty``1(yWorks.GraphML.TypedKey{``0})" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.GetSerializationProperty``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Retrieve a serialization property that has been set by <see cref="M:yWorks.GraphML.GraphMLWriter.SetSerializationProperty``1(yWorks.GraphML.TypedKey{``0},``0)" />.</para>
      </summary>
      <remarks>
        <para>The return value is automatically converted to type <typeparamref name="T" />.</para>
      </remarks>
      <param name="key">
        <para>The key for the property.</para>
      </param>
      <typeparam name="T">
        <para>The target type of the property.</para>
      </typeparam>
      <seealso cref="M:yWorks.GraphML.IWriteContext.GetSerializationProperty``1(yWorks.GraphML.TypedKey{``0})" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.SetLookup``1(``0)">
      <summary>
        <para>Register an implementation of <typeparamref name="T" /> for use with <see cref="M:yWorks.GraphML.GraphMLWriter.Lookup(System.Type)" />.</para>
      </summary>
      <typeparam name="T">
        <para>The type of <paramref name="instance" />.</para>
      </typeparam>
      <param name="instance">
        <para>The implementation of <typeparamref name="T" /> for lookup retrieval.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.RemoveLookup``1">
      <summary>
        <para>Remove an implementation of <typeparamref name="T" /> that has been set with <see cref="M:yWorks.GraphML.GraphMLWriter.SetLookup``1(``0)" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.Lookup(System.Type)">
      <summary>
        <para>Dynamically retrieve an instance of <paramref name="type" />.</para>
      </summary>
      <param name="type">
        <para>The type for which an implementation is needed.</para>
      </param>
      <returns>
        <para>An implementation of <paramref name="type" />, or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.CreateWriteContext(yWorks.Graph.IGraph,yWorks.GraphML.IXmlWriter)">
      <summary>
        <para>Create the initial <see cref="T:yWorks.GraphML.IWriteContext" /> instance.</para>
      </summary>
      <param name="graph">
        <para>The graph that is written.</para>
      </param>
      <param name="writer">
        <para>The core <see cref="T:yWorks.GraphML.IXmlWriter" /> instance that does the actual writing of XML content.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.GraphML.IWriteContext" /> instance that is suitable for <paramref name="graph" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.GraphML.GraphMLWriter.WriteEvents">
      <summary>
        <para>Gets the events in the internal <see cref="T:yWorks.GraphML.IWriteEvents" /> implementation.</para>
      </summary>
      <remarks>
        <para>You can subscribe to any of the events in the returned <see cref="T:yWorks.GraphML.IWriteEvents" /> instance to react to various steps in the writing process</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.Write(yWorks.Graph.IGraph,yWorks.GraphML.IXmlWriter)">
      <summary>
        <para>Write the GraphML representation of <paramref name="graph" />, using <paramref name="writer" /> for the actual XML generation.</para>
      </summary>
      <remarks>
        <para>Typically, this method is called indirectly from <see cref="M:yWorks.GraphML.GraphMLIOHandler.Write(yWorks.Graph.IGraph,System.IO.Stream,System.Text.Encoding)" /> and its overloads.</para>
      </remarks>
      <param name="graph">
        <para>The graph instance that is populated.</para>
      </param>
      <param name="writer">
        <para>The writer that actually writes the XML content.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.Write(yWorks.Graph.IGraph,System.IO.Stream,System.Text.Encoding)" />
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.Write(yWorks.Graph.IGraph,System.String)" />
      <seealso cref="M:yWorks.GraphML.GraphMLIOHandler.Write(yWorks.Graph.IGraph,System.IO.TextWriter)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.OnWritten(yWorks.GraphML.WriteEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLWriter.Written" /> event.</para>
      </summary>
      <remarks>
        <para>This method is called just before the writing has been finished and after <see cref="E:yWorks.GraphML.IWriteEvents.DocumentWritten" /> is called for the last time.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.GraphML.WriteEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="E:yWorks.GraphML.GraphMLWriter.Written" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLWriter.Written">
      <summary>
        <para>Occurs when the writing of a document has just been finished.</para>
      </summary>
      <seealso cref="M:yWorks.GraphML.GraphMLWriter.OnWritten(yWorks.GraphML.WriteEventArgs)" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriter.OnWriting(yWorks.GraphML.WriteEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.GraphML.GraphMLWriter.Writing" /> event.</para>
      </summary>
      <remarks>
        <para>This method is called just before the writing starts and before <see cref="E:yWorks.GraphML.IWriteEvents.DocumentWriting" /> is called for the first time.</para>
      </remarks>
      <param name="args">
        <para>The <see cref="T:yWorks.GraphML.WriteEventArgs" /> instance containing the event data.</para>
      </param>
      <seealso cref="E:yWorks.GraphML.GraphMLWriter.Writing" />
    </member>
    <member name="E:yWorks.GraphML.GraphMLWriter.Writing">
      <summary>
        <para>Occurs when the writing of a document is just about to begin.</para>
      </summary>
      <remarks>
        <para>This event can be used to register to the fine-grained events available in the <see cref="P:yWorks.GraphML.WriteEventArgs.Context" />'s <see cref="P:yWorks.GraphML.IWriteContext.WriteEvents" /> and to configure the writing process on a per write case.</para>
      </remarks>
      <seealso cref="M:yWorks.GraphML.GraphMLWriter.OnWriting(yWorks.GraphML.WriteEventArgs)" />
    </member>
    <member name="T:yWorks.GraphML.HandleSerializationEventArgs">
      <summary>
        <para>The event arguments used by <see cref="E:yWorks.GraphML.GraphMLIOHandler.HandleSerialization" /> and <see cref="E:yWorks.GraphML.GraphMLWriter.HandleSerialization" /> to let registered serialization code perform the serialization of items.</para>
      </summary>
      <remarks>
        <para>If the event handler determines that it can serialize the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" />, it should use the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Writer" /> for output and mark the event as <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> so that other code will not perform serialization, too.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.HandleSerializationEventArgs.#ctor(yWorks.GraphML.IWriteContext,System.Object,System.Type)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.HandleSerializationEventArgs" /> class using the provided context to write the <paramref name="item" /> using the given type for serialization.</para>
      </summary>
      <param name="context">
        <para>The context to use for writing.</para>
      </param>
      <param name="item">
        <para>The item to to serialize.</para>
      </param>
      <param name="serializationType">
        <para>The type that should be used for serialization, which needs to be a super type or interface of the <paramref name="item" /> or <c>null</c>.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.HandleSerializationEventArgs.Item">
      <summary>
        <para>Gets the item that should be serialized.</para>
      </summary>
      <value>
        <para>The item.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.HandleSerializationEventArgs.SourceType">
      <summary>
        <para>Gets the type in the inheritance of the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> that should be used for serialization.</para>
      </summary>
      <value>
        <para>The type of the serialization or <c>null</c> if the type should be inferred from the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" />.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.HandleSerializationEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.GraphML.HandleSerializationEventArgs" /> is handled.</para>
      </summary>
      <remarks>
        <para>Setting this property to <c>true</c> indicates to the event source that the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> has been successfully serialized using the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Writer" /> and no other code needs to handle the serialization request, anymore.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this event has been handled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.HandleSerializationEventArgs.Context">
      <summary>
        <para>Gets the context to be used for writing.</para>
      </summary>
      <value>
        <para>The context.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.HandleSerializationEventArgs.ReplaceItem(System.Object,System.Type)">
      <summary>
        <para>Replaces the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> using a substitute for serialization.</para>
      </summary>
      <remarks>
        <para>This method can be used to replace the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> and <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.SourceType" /> property so that the serialization chain can be traversed with a substituted item. If this method has been called the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Handled" /> property should not be set to <c>true</c>.</para>
      </remarks>
      <param name="item">
        <para>The substitute to assign to the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.Item" /> property.</para>
      </param>
      <param name="serializationType">
        <para>The serialization type to assign to the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.SourceType" /> property.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.HandleSerializationEventArgs.Writer">
      <summary>
        <para>Gets the writer for writing the xml output.</para>
      </summary>
      <value>
        <para>The writer that writes the GraphML xml.</para>
      </value>
    </member>
    <member name="T:yWorks.GraphML.IGraphElementIdProvider">
      <summary>
        <para>Interface for classes that provide custom id's for core GraphML elements</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementIdProvider.GetGraphId(yWorks.GraphML.IWriteContext,yWorks.Graph.IGraph)">
      <summary>
        <para>Get an ID for the specified <paramref name="graph" /> object</para>
      </summary>
      <param name="context">
        <para>The current write context, for further information to the provider</para>
      </param>
      <param name="graph">
        <para>The current graph object</para>
      </param>
      <returns>
        <para>an ID for the specified graph object</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementIdProvider.GetNodeId(yWorks.GraphML.IWriteContext,yWorks.Graph.INode)">
      <summary>
        <para>Get an ID for the specified <paramref name="node" /> object</para>
      </summary>
      <param name="context">
        <para>The current write context, for further information to the provider</para>
      </param>
      <param name="node">
        <para>The current graph object</para>
      </param>
      <returns>
        <para>an ID for the specified graph object</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementIdProvider.GetEdgeId(yWorks.GraphML.IWriteContext,yWorks.Graph.IEdge)">
      <summary>
        <para>Get an ID for the specified <paramref name="edge" /> object</para>
      </summary>
      <param name="context">
        <para>The current write context, for further information to the provider</para>
      </param>
      <param name="edge">
        <para>The current graph object</para>
      </param>
      <returns>
        <para>an ID for the specified edge object</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IGraphElementIdProvider.GetPortId(yWorks.GraphML.IWriteContext,yWorks.Graph.IPort)">
      <summary>
        <para>Get an ID for the specified <paramref name="port" /> object</para>
      </summary>
      <param name="context">
        <para>The current write context, for further information to the provider</para>
      </param>
      <param name="port">
        <para>The current port object</para>
      </param>
      <returns>
        <para>an ID for the specified port object</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.GraphMLXmlAttribute">
      <summary>
        <para>A data holder for use in the <see cref="T:yWorks.GraphML.IOutputHandler" /> interface that encapsulates an XML attribute.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.GraphMLXmlAttribute.#ctor(System.Xml.Linq.XName,System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.GraphMLXmlAttribute" /> struct.</para>
      </summary>
      <param name="name">
        <para>The attribute name.</para>
      </param>
      <param name="value">
        <para>The value.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.GraphMLXmlAttribute.Name">
      <summary>
        <para>Gets the fully qualified name of the attribute.</para>
      </summary>
      <value>
        <para>The fully qualified name.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.GraphMLXmlAttribute.Value">
      <summary>
        <para>Gets the value of the attribute.</para>
      </summary>
      <value>
        <para>The value.</para>
      </value>
    </member>
    <member name="T:yWorks.GraphML.IOutputHandler">
      <summary>
        <para>The interface used by the <see cref="T:yWorks.GraphML.GraphMLIOHandler" /> for writing data to the GraphML.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.IOutputHandler.Precedence">
      <summary>
        <para>Gets the write precedence that is associated with this instance.</para>
      </summary>
      <remarks>
        <para>Registered output handlers are written either before or after the (optional) child content of the governing GraphML element.</para>
      </remarks>
      <value>
        <para>The write precedence for this instance.</para>
      </value>
      <seealso cref="T:yWorks.GraphML.WritePrecedence" />
    </member>
    <member name="P:yWorks.GraphML.IOutputHandler.KeyDefinitionAttributes">
      <summary>
        <para>Gets the XML attributes that should be added to the key definition in the GraphML key element.</para>
      </summary>
      <value>
        <para>The key definition attributes.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.IOutputHandler.DataTagAttributes">
      <summary>
        <para>Gets the XML attributes that should be added to the data element.</para>
      </summary>
      <value>
        <para>The attributes for the data element.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.IOutputHandler.IsDefaultValue(yWorks.GraphML.IWriteContext)">
      <summary>
        <para>Determines whether in the current context, the value is the default value and therefore no data element needs to be written.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if for the current context the default value applies and therefore no data element needs to be written.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IOutputHandler.WriteValue(yWorks.GraphML.IWriteContext)">
      <summary>
        <para>Actually writes the value for the current context.</para>
      </summary>
      <remarks>
        <para>At the time this method is called, the surrounding 'data' element has already been written.</para>
      </remarks>
      <param name="context">
        <para>The context.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.IOutputHandler.WriteKeyDefinitionContent(yWorks.GraphML.IWriteContext)">
      <summary>
        <para>Writes the contents of the key definition.</para>
      </summary>
      <remarks>
        <para>At the time this method is called, the surrounding 'key' element has already been written. However no 'default' element is written by the framework.</para>
      </remarks>
      <param name="context">
        <para>The context.</para>
      </param>
    </member>
    <member name="T:yWorks.GraphML.WritePrecedence">
      <summary>
        <para>Enumeration values to control the order in which <see cref="T:yWorks.GraphML.IOutputHandler" /> instances are used.</para>
      </summary>
      <remarks>
        <para>These enumeration values control whether the output handler is evaluated before or after any (optional) structural child content of the owner element.</para>
      </remarks>
      <seealso cref="P:yWorks.GraphML.IOutputHandler.Precedence" />
    </member>
    <member name="F:yWorks.GraphML.WritePrecedence.BeforeChildren">
      <summary>
        <para>The handler writes its content before the child nodes of the governing GraphML element.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.WritePrecedence.Default">
      <summary>
        <para>Default precedence, the order in relation to child content is unspecified.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.WritePrecedence.AfterChildren">
      <summary>
        <para>The handler writes its content after the child nodes of the governing GraphML element.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.IWriteContext">
      <summary>
        <para>Interface that provides the context of a GraphML write process.</para>
      </summary>
      <remarks>
        <para>All state data that is needed for the writing of a concrete graph instance should go here, allowing all handlers and deserializers to be implemented stateless.</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.IWriteContext.ObjectStack">
      <summary>
        <para>Gets the current nesting of graphs and graph elements.</para>
      </summary>
      <remarks>
        <para>The list contains the user objects which correspond to the GraphML elements.</para>
      </remarks>
      <value>
        <para>A read-only view on the current nesting</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.IWriteContext.GetCurrent``1">
      <summary>
        <para>Returns the most current (the last element) within the container hierarchy as it is returned by <see cref="P:yWorks.GraphML.IWriteContext.ObjectStack" /> or <c>default(T)</c> if the most current element is not of the desired target type.</para>
      </summary>
      <typeparam name="T">
        <para>The desired target type.</para>
      </typeparam>
      <returns>
        <para>the most current element within the container hierarchy or <c>default(T)</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.GraphML.IWriteContext.WriteEvents">
      <summary>
        <para>Gets an implementation of <see cref="T:yWorks.GraphML.IWriteEvents" /> that allows to subscribe to various events in the write process.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.IWriteContext.Writer">
      <summary>
        <para>Gets the current <see cref="T:yWorks.GraphML.IXmlWriter" /> implementation.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.IWriteContext.Graph">
      <summary>
        <para>Gets the currently active graph object</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IWriteContext.GetSerializationProperty``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Get a property value that specifies information about how to handle specific cases</para>
      </summary>
      <param name="key">
        <para>The identifier for the property</para>
      </param>
      <returns>
        <para>The property value, or <c>null</c> if no such property exists</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)">
      <summary>
        <para>Serialize <paramref name="item" /> to an XML representation.</para>
      </summary>
      <remarks>
        <para>Client code should usually use the extension method <see cref="M:yWorks.GraphML.WriteContextExtensions.Serialize``1(yWorks.GraphML.IWriteContext,``0)" /> instead to ensure the the correct <paramref name="context" /> instance is used.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the object that is serialized.</para>
      </typeparam>
      <param name="context">
        <para>The current write context.</para>
      </param>
      <param name="item">
        <para>The object that should be serialized.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.WriteContextExtensions.Serialize``1(yWorks.GraphML.IWriteContext,``0)" />
      <exception cref="T:yWorks.GraphML.SerializationNotSupportedException" />
    </member>
    <member name="T:yWorks.GraphML.IWriteEvents">
      <summary>
        <para>The interface of the event trigger class that is used by the <see cref="P:yWorks.GraphML.IWriteContext.WriteEvents" /> property.</para>
      </summary>
      <remarks>
        <para>This interface defines the available events that client code can register to during the writing of <see cref="T:yWorks.GraphML.GraphMLWriter">GraphML</see>.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.WriteEventArgs" />
      <seealso cref="T:yWorks.GraphML.GraphMLWriter" />
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.DocumentWriting">
      <summary>
        <para>Occurs just after the <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartDocument" /> has been called.</para>
      </summary>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.DocumentWritten">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.GraphML.IXmlWriter.WriteEndDocument" /> will be called.</para>
      </summary>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.NodeWriting">
      <summary>
        <para>Occurs right after the <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /> method for writing a GraphMl 'node' element has been called.</para>
      </summary>
      <remarks>
        <para>At that state, callees can use the <see cref="M:yWorks.GraphML.IXmlWriter.WriteAttribute(System.String,System.String,System.String,System.String)" /> methods to add custom attributes to the XML element or write a first custom inner element using <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /></para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.NodeWritten">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.GraphML.IXmlWriter.WriteEndElement" /> for the GraphML 'node' element will be called.</para>
      </summary>
      <remarks>
        <para>This can be used to append more custom elements to the node element.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.EdgeWriting">
      <summary>
        <para>Occurs right after the <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /> method for writing a GraphMl 'edge' element has been called.</para>
      </summary>
      <remarks>
        <para>At that state, callees can use the <see cref="M:yWorks.GraphML.IXmlWriter.WriteAttribute(System.String,System.String,System.String,System.String)" /> methods to add custom attributes to the XML element or write a first custom inner element using <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /></para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.EdgeWritten">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.GraphML.IXmlWriter.WriteEndElement" /> for the GraphML 'edge' element will be called.</para>
      </summary>
      <remarks>
        <para>This can be used to append more custom elements to the edge element.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.PortWriting">
      <summary>
        <para>Occurs right after the <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /> method for writing a GraphMl 'port' element has been called.</para>
      </summary>
      <remarks>
        <para>At that state, callees can use the <see cref="M:yWorks.GraphML.IXmlWriter.WriteAttribute(System.String,System.String,System.String,System.String)" /> methods to add custom attributes to the XML element or write a first custom inner element using <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /></para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.PortWritten">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.GraphML.IXmlWriter.WriteEndElement" /> for the GraphML 'port' element will be called.</para>
      </summary>
      <remarks>
        <para>This can be used to append more custom elements to the port element.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.GraphWriting">
      <summary>
        <para>Occurs right after the <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /> method for writing a GraphMl 'graph' element has been called.</para>
      </summary>
      <remarks>
        <para>At that state, callees can use the <see cref="M:yWorks.GraphML.IXmlWriter.WriteAttribute(System.String,System.String,System.String,System.String)" /> methods to add custom attributes to the XML element or write a first custom inner element using <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /></para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.GraphWritten">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.GraphML.IXmlWriter.WriteEndElement" /> for the GraphML 'graph' element will be called.</para>
      </summary>
      <remarks>
        <para>This can be used to append more custom elements to the graph element.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.GraphMLWriting">
      <summary>
        <para>Occurs right after the <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /> method for writing a GraphMl 'graphml' element has been called.</para>
      </summary>
      <remarks>
        <para>At that state, callees can use the <see cref="M:yWorks.GraphML.IXmlWriter.WriteAttribute(System.String,System.String,System.String,System.String)" /> methods to add custom attributes to the XML element or write a first custom inner element using <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /></para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.GraphMLWritten">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.GraphML.IXmlWriter.WriteEndElement" /> for the GraphML 'graphml' element will be called.</para>
      </summary>
      <remarks>
        <para>This can be used to append more custom elements to the graphml element.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.DataWriting">
      <summary>
        <para>Occurs right after the <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /> method for writing a GraphMl 'data' element has been called.</para>
      </summary>
      <remarks>
        <para>At that state, callees can use the <see cref="M:yWorks.GraphML.IXmlWriter.WriteAttribute(System.String,System.String,System.String,System.String)" /> methods to add custom attributes to the XML element or write a first custom inner element using <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /></para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.DataWritten">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.GraphML.IXmlWriter.WriteEndElement" /> for the GraphML 'data' element will be called.</para>
      </summary>
      <remarks>
        <para>This can be used to append more custom elements to the data element.</para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.KeyWriting">
      <summary>
        <para>Occurs right after the <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /> method for writing a GraphMl 'key' element has been called.</para>
      </summary>
      <remarks>
        <para>At that state, callees can use the <see cref="M:yWorks.GraphML.IXmlWriter.WriteAttribute(System.String,System.String,System.String,System.String)" /> methods to add custom attributes to the XML element or write a first custom inner element using <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /></para>
      </remarks>
    </member>
    <member name="E:yWorks.GraphML.IWriteEvents.KeyWritten">
      <summary>
        <para>Occurs just before the <see cref="M:yWorks.GraphML.IXmlWriter.WriteEndElement" /> for the GraphML 'key' element will be called.</para>
      </summary>
      <remarks>
        <para>This can be used to append more custom elements to the key element.</para>
      </remarks>
    </member>
    <member name="T:yWorks.GraphML.IXmlWriter">
      <summary>
        <para>Abstraction of XML output classes that provide a consistent way to write XML elements to some output</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteComment(System.String)">
      <summary>
        <para>Write a XML comment node</para>
      </summary>
      <param name="comment">
        <para>The content of the comment</para>
      </param>
      <returns>
        <para>The writer instance for further chaining</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteEndDocument">
      <summary>
        <para>Close the output.</para>
      </summary>
      <remarks>
        <para>Attempts to write after this method has been called will have undefined results.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)">
      <summary>
        <para>Begin a new XML element with given parameters</para>
      </summary>
      <remarks>
        <para>All subsequent output is attached to this element until <see cref="M:yWorks.GraphML.IXmlWriter.WriteEndElement" /> has been called or a new element has been started.</para>
      </remarks>
      <param name="prefix">
        <para>The namespace prefix to use for this element</para>
      </param>
      <param name="localName">
        <para>The local name of this element</para>
      </param>
      <param name="ns">
        <para>The namespace of this element</para>
      </param>
      <returns>
        <para>The writer instance for further chaining</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String)">
      <summary>
        <para>Begin a new XML element with given parameters</para>
      </summary>
      <remarks>
        <para>All subsequent output is attached to this element until <see cref="M:yWorks.GraphML.IXmlWriter.WriteEndElement" /> has been called or a new element has been started.</para>
        <para>This acts like <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" />, but uses the default prefix for the namespace</para>
      </remarks>
      <param name="localName">
        <para>The local name of this element</para>
      </param>
      <param name="ns">
        <para>The namespace of this element</para>
      </param>
      <returns>
        <para>The writer instance for further chaining</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteAttribute(System.String,System.String,System.String,System.String)">
      <summary>
        <para>Write a XML attribute node.</para>
      </summary>
      <remarks>
        <para>The attribute is attached to the closest open XML element that has been started with <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String)" /> or <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" /></para>
      </remarks>
      <param name="prefix">
        <para>The namespace prefix of the attribute</para>
      </param>
      <param name="localName">
        <para>The local name of the attribute</para>
      </param>
      <param name="ns">
        <para>The namespace URI of this attribute</para>
      </param>
      <param name="value">
        <para>The value of this attribute</para>
      </param>
      <returns>
        <para>The writer instance for further chaining</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteDocumentFragment(System.Xml.Linq.XDocument)">
      <summary>
        <para>Write a document fragment</para>
      </summary>
      <param name="fragment" />
      <returns>
        <para>The writer instance for further chaining</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteProcessingInstruction(System.String,System.String)">
      <summary>
        <para>Write a xml processing instruction.</para>
      </summary>
      <param name="target">
        <para>The target of the PI</para>
      </param>
      <param name="data">
        <para>The data of the PI</para>
      </param>
      <returns>
        <para>The writer instance for further chaining</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteCData(System.String)">
      <summary>
        <para>Write a CDATA section.</para>
      </summary>
      <param name="content">
        <para>The content of the CDATA section</para>
      </param>
      <returns>
        <para>The writer instance for further chaining</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteEndElement">
      <summary>
        <para>Close a XML element previously opened with <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String)" /> or <see cref="M:yWorks.GraphML.IXmlWriter.WriteStartElement(System.String,System.String,System.String)" />.</para>
      </summary>
      <returns>
        <para>The writer instance for further chaining</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteStartDocument">
      <summary>
        <para>Begin the output process</para>
      </summary>
      <returns>
        <para>The writer instance for further chaining</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.FlushDocument">
      <summary>
        <para>Close the document.</para>
      </summary>
      <remarks>
        <para>This is typically used to actually flush the document to an output stream</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.IXmlWriter.NamespaceManager">
      <summary>
        <para>Gets the namespace manager associated with this writer.</para>
      </summary>
      <value>
        <para>The namespace manager.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.IXmlWriter.WriteString(System.String)">
      <summary>
        <para>Write a text node.</para>
      </summary>
      <remarks>
        <para>The string value of <paramref name="s" /> will be correctly escaped</para>
      </remarks>
      <param name="s">
        <para>The string that gets written as XML text</para>
      </param>
      <returns>
        <para>The writer instance for further chaining</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.IXmlNamespaceManager">
      <summary>
        <para>Helper class to facilitate namespace handling together with <see cref="T:yWorks.GraphML.IXmlWriter" /> instances.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IXmlNamespaceManager.GetPrefixOfNamespace(System.String)">
      <summary>
        <para>Gets the registered XML prefix of <paramref name="ns" />.</para>
      </summary>
      <param name="ns">
        <para>The namespace URI for which a prefix is searched.</para>
      </param>
      <returns>
        <para>The registered XML prefix of <paramref name="ns" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlNamespaceManager.GetNamespaceOfPrefix(System.String)">
      <summary>
        <para>Gets the registered XML namespace URI of <paramref name="prefix" />.</para>
      </summary>
      <remarks>
        <para>If the prefix is redeclared, the nearest enclosing declaration (at the time of this method call) is used.</para>
      </remarks>
      <param name="prefix">
        <para>The prefix for which a namespace URI is searched.</para>
      </param>
      <returns>
        <para>The namespace URI of <paramref name="prefix" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlNamespaceManager.GetOrCreateUniqueMapping(System.String)">
      <summary>
        <para>Returns a unique namespace prefix, or creates and registeres one.</para>
      </summary>
      <param name="ns">
        <para>The namespace URI for which a prefix is searched.</para>
      </param>
      <returns>
        <para>a unique namespace prefix for <paramref name="ns" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXmlNamespaceManager.RegisterLocalMapping(System.String,System.String)">
      <summary>
        <para>Register a local namespace/prefix mapping</para>
      </summary>
      <param name="nsUri">
        <para>The namespace URI</para>
      </param>
      <param name="prefix">
        <para>The namespace prefix.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.IXmlNamespaceManager.PushScope">
      <summary>
        <para>Pushes a current declaration scope.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IXmlNamespaceManager.PopScope">
      <summary>
        <para>Pops a current declaration scope.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IXmlNamespaceManager.AddTemporaryMapping(System.String,System.String)">
      <summary>
        <para>Register a temporary mapping without writing an explicit XMLNS declaration.</para>
      </summary>
      <param name="nsUri">
        <para>The XML namespace URI</para>
      </param>
      <param name="prefix">
        <para>The prefix for the URI</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.IXmlNamespaceManager.GlobalNamespaces">
      <summary>
        <para>Gets a list of all namespace declarations that should be declared at the document's root element.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.XmlWriterExtensions">
      <summary>
        <para>Defines extension methods for interface <see cref="T:yWorks.GraphML.IXmlWriter" /></para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.XmlWriterExtensions.WriteAttribute(yWorks.GraphML.IXmlWriter,System.String,System.String)">
      <summary>
        <para>Write an XML attribute with the given parameters.</para>
      </summary>
      <remarks>
        <para>The attribute is not bound to a XML namespace.</para>
      </remarks>
      <param name="writer">
        <para>The XML writer to use.</para>
      </param>
      <param name="localName">
        <para>The name of the attribute.</para>
      </param>
      <param name="value">
        <para>The value of the attribute.</para>
      </param>
      <returns>
        <para>The writer instance <paramref name="writer" /> for writer chaining.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.XmlWriterExtensions.WriteAttribute(yWorks.GraphML.IXmlWriter,yWorks.GraphML.GraphMLXmlAttribute)">
      <summary>
        <para>Write an XML attribute from the given <paramref name="attribute" /> struct.</para>
      </summary>
      <param name="writer">
        <para>The XML writer to use.</para>
      </param>
      <param name="attribute">
        <para>Encapsulates the current attribute values.</para>
      </param>
      <returns>
        <para>The writer instance <paramref name="writer" /> for writer chaining.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.MapperOutputHandler`2">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.GraphML.OutputHandlerBase`2" /> class, that uses an <see cref="T:yWorks.Graph.IMapper`2" /> to retrieve the values to output for each item and a <see cref="P:yWorks.GraphML.MapperOutputHandler`2.Serializer" /> callback for the serialization or delegates to the <see cref="M:yWorks.GraphML.IWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)" /> callback.</para>
      </summary>
      <typeparam name="TKey">
        <para>The type of the keys.</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the data.</para>
      </typeparam>
    </member>
    <member name="P:yWorks.GraphML.MapperOutputHandler`2.MapperMetadata">
      <summary>
        <para>Gets or sets the mapper metadata to serialize to the key definition.</para>
      </summary>
      <value>
        <para>The mapper metadata.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.MapperOutputHandler`2.WriteKeyDefinitionContent(yWorks.GraphML.IWriteContext)">
      <summary>
        <para>Writes the contents of the key definition.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <remarks>
        <para>This method will additionally write the <see cref="P:yWorks.GraphML.MapperOutputHandler`2.MapperMetadata" /> to the key definition content, if any has been set.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.MapperOutputHandler`2.#ctor(System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.MapperOutputHandler`2" /> class using the given name and inferring the scope and the type from the class parameters.</para>
      </summary>
      <remarks>
        <para>The GraphML key scope and type are determined automatically.</para>
      </remarks>
      <param name="name">
        <para>The name to use for the key attributes.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.MapperOutputHandler`2.#ctor(yWorks.GraphML.KeyScope,System.String,yWorks.GraphML.KeyType)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.MapperOutputHandler`2" /> class using the provided key scope, the name, and the key type.</para>
      </summary>
      <param name="scope">
        <para>The scope for the key definition attributes.</para>
      </param>
      <param name="name">
        <para>The name for the key definition attributes.</para>
      </param>
      <param name="type">
        <para>The type for the key definition attributes.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.MapperOutputHandler`2.Mapper">
      <summary>
        <para>Gets or sets the mapper to use for querying the data for each item.</para>
      </summary>
      <value>
        <para>The mapper.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.MapperOutputHandler`2.Serializer">
      <summary>
        <para>Gets or sets the serialization callback to use for serializing the value in <see cref="M:yWorks.GraphML.MapperOutputHandler`2.WriteValueCore(yWorks.GraphML.IWriteContext,`1)" />.</para>
      </summary>
      <value>
        <para>The serialization callback or <c>null</c> to indicate that the context should be used instead.</para>
      </value>
      <seealso cref="P:yWorks.GraphML.MapperOutputHandler`2.SourceType" />
    </member>
    <member name="P:yWorks.GraphML.MapperOutputHandler`2.SourceType">
      <summary>
        <para>Gets or sets the source type of the serialization.</para>
      </summary>
      <value>
        <para>The desired type of the object that is serialized.</para>
      </value>
      <remarks>
        <para>This type will be used as the <see cref="P:yWorks.GraphML.HandleSerializationEventArgs.SourceType" />.</para>
      </remarks>
      <seealso cref="P:yWorks.GraphML.MapperOutputHandler`2.Serializer" />
      <seealso cref="T:yWorks.GraphML.HandleSerializationEventArgs" />
    </member>
    <member name="M:yWorks.GraphML.MapperOutputHandler`2.GetValue(yWorks.GraphML.IWriteContext,`0)">
      <summary>
        <para>Callback method that obtains the data for the given key.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="key">
        <para>The key.</para>
      </param>
      <returns>
        <para>The data that is associated with the key using the <see cref="P:yWorks.GraphML.MapperOutputHandler`2.Mapper" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.MapperOutputHandler`2.WriteValueCore(yWorks.GraphML.IWriteContext,`1)">
      <summary>
        <para>Callback method that performs the actual writing of the data using either the <see cref="P:yWorks.GraphML.MapperOutputHandler`2.Serializer" /> or the <see cref="M:yWorks.GraphML.IWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)" /> method.</para>
      </summary>
      <param name="context">
        <para>The context to use for writing.</para>
      </param>
      <param name="data">
        <para>The data to write.</para>
      </param>
    </member>
    <member name="T:yWorks.GraphML.OutputHandlerBase`2">
      <summary>
        <para>Convenience abstract base implementation of the <see cref="T:yWorks.GraphML.IOutputHandler" /> interface.</para>
      </summary>
      <typeparam name="TKey">
        <para>The type of the keys.</para>
      </typeparam>
      <typeparam name="TData">
        <para>The type of the data.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.#ctor(System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.OutputHandlerBase`2" /> class.</para>
      </summary>
      <remarks>
        <para>The GraphML key scope and type are determined automatically.</para>
      </remarks>
      <param name="name" />
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.#ctor(yWorks.GraphML.KeyScope,System.String,yWorks.GraphML.KeyType)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.OutputHandlerBase`2" /> class using the provided scope, name, and type for the key definition.</para>
      </summary>
      <param name="scope">
        <para>The scope.</para>
      </param>
      <param name="name">
        <para>The name to use for the key definition.</para>
      </param>
      <param name="type">
        <para>The type to use for the key definition.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.OutputHandlerBase`2.SetKeyDefinitionUri(System.String)" />
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.SetKeyDefinitionName(System.String)">
      <summary>
        <para>Sets the name for the key definition.</para>
      </summary>
      <param name="name">
        <para>The name of the key element.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.SetKeyDefinitionUri(System.String)">
      <summary>
        <para>Sets an optional URI for the key definition.</para>
      </summary>
      <remarks>
        <para>By default, no URI is set.</para>
      </remarks>
      <param name="uri">
        <para>The URI of the key element.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.SetKeyDefinitionType(yWorks.GraphML.KeyType)">
      <summary>
        <para>Sets the key type for the key definition.</para>
      </summary>
      <param name="type">
        <para>The type of the key element.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.SetKeyDefinitionScope(yWorks.GraphML.KeyScope)">
      <summary>
        <para>Sets the scope for the key definition.</para>
      </summary>
      <remarks>
        <para>Note that the official GraphML schema does not support the <see cref="F:yWorks.GraphML.KeyScope.Graphml" /> so this implementation will silently ignore this which will result in <see cref="F:yWorks.GraphML.KeyScope.All" /> implicitly being defined.</para>
      </remarks>
      <param name="scope">
        <para>The scope of the key element.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.OutputHandlerBase`2.DefaultValue">
      <summary>
        <para>Gets or sets the default value.</para>
      </summary>
      <remarks>
        <para>Setting this value also sets the <see cref="P:yWorks.GraphML.OutputHandlerBase`2.DefaultExists" /> property.</para>
      </remarks>
      <value>
        <para>The default value.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.OutputHandlerBase`2.DefaultExists">
      <summary>
        <para>Gets or sets a value indicating whether a default value has been assigned.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if a default value has been assigned, <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.OutputHandlerBase`2.Precedence">
      <summary>
        <para>Gets or sets the write precedence for the handler.</para>
      </summary>
      <value>
        <para>The write precedence.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.IsDefaultValue(yWorks.GraphML.IWriteContext)">
      <summary>
        <para>Determines whether in the current context, the value is the default value and therefore no data element needs to be written.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <remarks>
        <para>This implementation will return <c>false</c> if no <see cref="P:yWorks.GraphML.OutputHandlerBase`2.DefaultExists">default has been set</see>. Otherwise it will use <see cref="M:yWorks.GraphML.OutputHandlerBase`2.GetValue(yWorks.GraphML.IWriteContext,`0)" /> and compare the result with the <see cref="P:yWorks.GraphML.OutputHandlerBase`2.DefaultValue" /> to determine whether they are equal and therefore no data needs to be written.</para>
      </remarks>
      <returns>
        <para>
          <c>true</c> if for the current context the default value applies and therefore no data element needs to be written.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.WriteValue(yWorks.GraphML.IWriteContext)">
      <summary>
        <para>Actually writes the value for the current context.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <remarks>
        <para>This method will use <see cref="M:yWorks.GraphML.OutputHandlerBase`2.GetValue(yWorks.GraphML.IWriteContext,`0)" /> to obtain the data and delegate to <see cref="M:yWorks.GraphML.OutputHandlerBase`2.WriteValueCore(yWorks.GraphML.IWriteContext,`1)" /> to perform the actual serialization.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.WriteKeyDefinitionContent(yWorks.GraphML.IWriteContext)">
      <summary>
        <para>Writes the contents of the key definition.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <remarks>
        <para>Depending on whether <see cref="P:yWorks.GraphML.OutputHandlerBase`2.WriteKeyDefault" /> is enabled and <see cref="P:yWorks.GraphML.OutputHandlerBase`2.DefaultExists" /> is <c>true</c>, this method will write the GraphML 'default' element and use <see cref="M:yWorks.GraphML.OutputHandlerBase`2.WriteValueCore(yWorks.GraphML.IWriteContext,`1)" /> to serialize the <see cref="P:yWorks.GraphML.OutputHandlerBase`2.DefaultValue" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.OutputHandlerBase`2.WriteKeyDefault">
      <summary>
        <para>Gets or sets a value indicating whether to write the key default.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the key default should be written; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.WriteValueCore(yWorks.GraphML.IWriteContext,`1)">
      <summary>
        <para>Callback method that performs the actual writing of the data.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="data">
        <para>The data.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.OutputHandlerBase`2.GetValue(yWorks.GraphML.IWriteContext,`0)">
      <summary>
        <para>Callback method that obtains the data for the given key.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="key">
        <para>The key.</para>
      </param>
      <returns>
        <para>The data that is associated with the key.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.QueryOutputHandlersEventArgs">
      <summary>
        <para>Event argument implementation that is used by the <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryOutputHandlers" /> event.</para>
      </summary>
      <remarks>
        <para>These event arguments can be used to add more <see cref="T:yWorks.GraphML.IOutputHandler" /> implementations to the <see cref="T:yWorks.GraphML.GraphMLWriter" /> dynamically at the time of writing, by adding them to the <see cref="P:yWorks.GraphML.QueryOutputHandlersEventArgs.Handlers" /> collection.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.GraphMLIOHandler" />
    </member>
    <member name="M:yWorks.GraphML.QueryOutputHandlersEventArgs.#ctor(yWorks.GraphML.IWriteContext,yWorks.GraphML.KeyScope)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.QueryOutputHandlersEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context to assign to the <see cref="P:yWorks.GraphML.QueryOutputHandlersEventArgs.Context" /> property.</para>
      </param>
      <param name="scope">
        <para>The scope where the handlers should be added.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.QueryOutputHandlersEventArgs.Scope">
      <summary>
        <para>Gets the scope where the handlers should be added.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.QueryOutputHandlersEventArgs.AddOutputHandler(yWorks.GraphML.IOutputHandler)">
      <summary>
        <para>Adds the given output handler to the set of registered output handlers for the given scope.</para>
      </summary>
      <param name="handler">
        <para>The handler to add.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.QueryOutputHandlersEventArgs.Handlers">
      <summary>
        <para>Gets the <see cref="T:yWorks.GraphML.IOutputHandler" />s that have been registered on this event argument instance so far.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.QueryOutputHandlersEventArgs.Context">
      <summary>
        <para>Gets the context for which the handlers are queried.</para>
      </summary>
      <value>
        <para>The context of the query.</para>
      </value>
    </member>
    <member name="T:yWorks.GraphML.SerializationNotSupportedException">
      <summary>
        <para>Exception that will be thrown by the <see cref="M:yWorks.GraphML.IWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)" /> method and the like to indicate that the deserialization failed.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.SerializationNotSupportedException.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.SerializationNotSupportedException" /> class.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.SerializationNotSupportedException.#ctor(System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.SerializationNotSupportedException" /> class with the given message.</para>
      </summary>
      <param name="message">
        <para>The message.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.SerializationNotSupportedException.#ctor(System.String,System.Exception)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.SerializationNotSupportedException" /> class using the given message and inner exception.</para>
      </summary>
      <param name="message">
        <para>The message.</para>
      </param>
      <param name="inner">
        <para>The inner exception.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.SerializationNotSupportedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.SerializationNotSupportedException" /> class.</para>
      </summary>
      <param name="info">
        <para>The data for serializing or deserializing the object.</para>
      </param>
      <param name="context">
        <para>The source and destination for the object.</para>
      </param>
    </member>
    <member name="T:yWorks.GraphML.SerializationProperties">
      <summary>
        <para>Constant class for common serialization properties.</para>
      </summary>
      <seealso cref="M:yWorks.GraphML.IWriteContext.GetSerializationProperty``1(yWorks.GraphML.TypedKey{``0})" />
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.DisableUserTags">
      <summary>
        <para>Property key to control user tag serialization and deserialization</para>
      </summary>
      <remarks>
        <para>Setting this property as a <see cref="P:yWorks.GraphML.GraphMLIOHandler.SerializationPropertyOverrides">serialization property</see> disables tag serialization for all of the provided <see cref="T:yWorks.Graph.GraphItemTypes" />. Setting this property as a <see cref="P:yWorks.GraphML.GraphMLIOHandler.DeserializationPropertyOverrides">deserialization property</see> disables tag deserialization only for nodes, edges and/or ports. By default, this property is set to <see cref="F:yWorks.Graph.GraphItemTypes.None" /></para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.DisableStyles">
      <summary>
        <para>Property key to control graph element style serialization and deserialization</para>
      </summary>
      <remarks>
        <para>Setting this property as a <see cref="P:yWorks.GraphML.GraphMLIOHandler.SerializationPropertyOverrides">serialization property</see> disables style serialization for all of the provided <see cref="T:yWorks.Graph.GraphItemTypes" />. Setting this property as a <see cref="P:yWorks.GraphML.GraphMLIOHandler.DeserializationPropertyOverrides">deserialization property</see> disables style deserialization only for nodes, edges and/or ports. By default, this property is set to <see cref="F:yWorks.Graph.GraphItemTypes.None" /></para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.DisableItems">
      <summary>
        <para>Property key to control graph elements serialization and deserialization</para>
      </summary>
      <remarks>
        <para>Setting this property disables serialization and deserialization for the provided <see cref="T:yWorks.Graph.GraphItemTypes" />. By default, this property is set to <see cref="F:yWorks.Graph.GraphItemTypes.None" /></para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.DisableGeometry">
      <summary>
        <para>Property key to control graph element geometry serialization and deserialization</para>
      </summary>
      <remarks>
        <para>Setting this property as a <see cref="P:yWorks.GraphML.GraphMLIOHandler.SerializationPropertyOverrides">serialization property</see> disables style serialization for all of the provided <see cref="T:yWorks.Graph.GraphItemTypes" />. Setting this property as a <see cref="P:yWorks.GraphML.GraphMLIOHandler.DeserializationPropertyOverrides">deserialization property</see> disables style deserialization only for nodes, edges and/or ports. By default, this property is set to <see cref="F:yWorks.Graph.GraphItemTypes.None" /></para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.DisableStripeUserTags">
      <summary>
        <para>Property key to control user tag serialization and deserialization of <see cref="T:yWorks.Graph.IStripe" />s.</para>
      </summary>
      <remarks>
        <para>Setting this property disables tag serialization for the provided <see cref="T:yWorks.Graph.StripeTypes" />. By default, this property is set to <see cref="F:yWorks.Graph.StripeTypes.None" /></para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.DisableStripeStyles">
      <summary>
        <para>Property key to control style serialization and deserialization of <see cref="T:yWorks.Graph.IStripe" />s.</para>
      </summary>
      <remarks>
        <para>Setting this property disables style serialization for the provided <see cref="T:yWorks.Graph.StripeTypes" />. By default, this property is set to <see cref="F:yWorks.Graph.StripeTypes.None" /></para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.DisableStripeLabels">
      <summary>
        <para>Property key to control label serialization of <see cref="T:yWorks.Graph.IStripe" />s.</para>
      </summary>
      <remarks>
        <para>Setting this property disables label serialization for the provided <see cref="T:yWorks.Graph.StripeTypes" />. By default, this property is set to <see cref="F:yWorks.Graph.StripeTypes.None" /></para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.DisableGraphSettings">
      <summary>
        <para>Property key to omit serialization and deserialization of the <see cref="T:yWorks.Graph.IGraph" />'s default settings.</para>
      </summary>
      <remarks>
        <para>If this property is set to <c>true</c> in <see cref="P:yWorks.GraphML.GraphMLIOHandler.SerializationPropertyOverrides" /> or the write context, the current graph defaults are not written.</para>
        <para>If this property is set to <c>true</c> in <see cref="P:yWorks.GraphML.GraphMLIOHandler.DeserializationPropertyOverrides" /> or the parse context, any graph defaults present in the input are not parsed and applied to the current graph.</para>
        <para>Default for this property is <c>true</c> for writing and <c>false</c> for parsing.</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.IgnorePropertyCase">
      <summary>
        <para>Property key for alllowing to parse member names (properties and enum values) case-insensitively during XAML deserialization.</para>
      </summary>
      <remarks>
        <para>This will convert property and member names to lower-case and remove underscores to be able to compare things like <c>SOME_CONSTANT_NAME</c> and <c>SomeConstantName</c> as well as <c>somePropertyName</c> and <c>SomePropertyName</c>, respectively.</para>
        <para>Default for this property is <c>false</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.IndentOutput">
      <summary>
        <para>Property key whether the XML output should be properly indented.</para>
      </summary>
      <remarks>
        <para>Default for this property is <c>true</c></para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.CurrentKeyScope">
      <summary>
        <para>The current <see cref="T:yWorks.GraphML.KeyScope" /> in which an <see cref="T:yWorks.GraphML.IOutputHandler" />, <see cref="T:yWorks.GraphML.IInputHandler" />, or custom serialization code is called.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.RepresentedEdge">
      <summary>
        <para>The edge that is currently being represented by the dummy edge that is written instead.</para>
      </summary>
      <remarks>
        <para>If this value is set, then the edge currently being serialized represents the given edge in reality.</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.WriteNodeStyleDefault">
      <summary>
        <para>Write the default node style in the &lt;default&gt; element of the key definition.</para>
      </summary>
      <remarks>
        <para>A <see cref="T:System.Boolean" /> value indicates whether the default should be written.</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.WriteEdgeStyleDefault">
      <summary>
        <para>Write the default edge style in the &lt;default&gt; element of the key definition.</para>
      </summary>
      <remarks>
        <para>A <see cref="T:System.Boolean" /> value indicates whether the default should be written.</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.WritePortStyleDefault">
      <summary>
        <para>Write the default port style in the &lt;default&gt; element of the key definition.</para>
      </summary>
      <remarks>
        <para>A <see cref="T:System.Boolean" /> value indicates whether the default should be written.</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.WriteStripeDefaults">
      <summary>
        <para>Property key to specify whether the stripe defaults of a table should be written.</para>
      </summary>
      <remarks>
        <para>If set to <c>true</c> the <see cref="P:yWorks.Graph.ITable.ColumnDefaults" /> and <see cref="P:yWorks.Graph.ITable.RowDefaults" /> will be written. Default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.WriteLabelSizePredicate">
      <summary>
        <para>Provides a <see cref="T:System.Predicate`1" /> that determines if the preferred size of a label should be written.</para>
      </summary>
      <remarks>
        <para>If this property is not set, the label size is always written.</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.ParseLabelSize">
      <summary>
        <para>Property key to specify whether the preferred size of labels should be parsed.</para>
      </summary>
      <remarks>
        <para>If this property is set to <c>true</c>, the preferred size provided by GraphML is used, otherwise, the preferred size is determined automatically. This property is mainly meant for interoperability usecases where the text size calculations can be quite different for different platforms. Default value is <c>true</c></para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.BaseUri">
      <summary>
        <para>The current <see cref="T:System.String" /> base URI which is used for the GraphML file being parsed or written.</para>
      </summary>
      <remarks>
        <para>If set, this can be used to resolve or create relative paths.</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.RewriteRelativeResourceUris">
      <summary>
        <para>Whether to rewrite relative URIs relative to the current document location.</para>
      </summary>
      <remarks>
        <para>If set, relative URIs for images and other resources are rewritten relative to <see cref="F:yWorks.GraphML.SerializationProperties.BaseUri" />. If this property is <c>false</c>, or if <see cref="F:yWorks.GraphML.SerializationProperties.BaseUri" /> is not set (either explicitly or implicitly) or the resource URI is not relative, the resource URI will not be rewritten.</para>
        <para>Default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.IgnoreXamlDeserializationErrors">
      <summary>
        <para>If set to <c>true</c> errors during XAML deserialization will be ignored and instead <c>null</c> will be returned.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.SerializationProperties.CacheExternalReferences">
      <summary>
        <para>Property key to control caching for external references.</para>
      </summary>
      <remarks>
        <para>If this property is set to <c>false</c> in the write context, the writer will not cache remember <b>external</b> reference ids provided via <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryReferenceId" />, i.e. the event will be raised whenever an instance of the external object is encountered during the write process. This allows to provide different values for the same object, depending on the current context. Default for this property is <c>true</c></para>
      </remarks>
    </member>
    <member name="T:yWorks.GraphML.SingletonSerializationAttribute">
      <summary>
        <para>GraphML support attribute that can be used to make it possible to identify instances of the attributed types as static fields or properties.</para>
      </summary>
      <remarks>
        <para>When a type is annotated with this attribute, all types in the <see cref="P:yWorks.GraphML.SingletonSerializationAttribute.ContainerTypes" /> array are searched for public static fields or properties that have the annotated type. The GraphML writer will write these members as static members instead of the usual serialization.</para>
      </remarks>
      <example>
        <para>Using the following annotation</para>
        <para>has the effect that all references to field <c>ContainedTypeSingleton</c> will be written as static extensions, e.g.</para>
        <code>{x:Static myNSDeclarationPrefix:ContainingType.ContainedTypeSingleton}</code>
      </example>
      <seealso cref="P:yWorks.GraphML.SingletonSerializationAttribute.ContainerTypes" />
      <seealso cref="T:yWorks.Markup.Primitives.StaticExtension" />
    </member>
    <member name="P:yWorks.GraphML.SingletonSerializationAttribute.ContainerTypes">
      <summary>
        <para>Types that should be searched for static field or property members of the annotated type.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.WriteContextExtensions">
      <summary>
        <para>Extension methods for <see cref="T:yWorks.GraphML.IWriteContext" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.WriteContextExtensions.Serialize``1(yWorks.GraphML.IWriteContext,``0)">
      <summary>
        <para>Serialize the <paramref name="item" />.</para>
      </summary>
      <remarks>
        <para>This method calls <see cref="M:yWorks.GraphML.IWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)" /> with <paramref name="context" /> as first argument and should be used in virtually all cases.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the object that is serialized.</para>
      </typeparam>
      <param name="context">
        <para>The current write context.</para>
      </param>
      <param name="item">
        <para>The object that should be serialized.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.IWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)" />
      <exception cref="T:yWorks.GraphML.SerializationNotSupportedException" />
    </member>
    <member name="M:yWorks.GraphML.WriteContextExtensions.Serialize(yWorks.GraphML.IWriteContext,System.Object,System.Type)">
      <summary>
        <para>Serializes the specified item using the provided type information.</para>
      </summary>
      <remarks>
        <para>
          <paramref name="item" /> should be assignable to type <paramref name="t" />. This method simply delegates to <see cref="M:yWorks.GraphML.IWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)" />, using the correct type parameter.</para>
      </remarks>
      <param name="context">
        <para>The context to write the item in.</para>
      </param>
      <param name="item">
        <para>The item to serialize.</para>
      </param>
      <param name="t">
        <para>The type the item is known to be of at deserialization time.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.WriteContextExtensions.SerializeReplacement``1(yWorks.GraphML.IWriteContext,System.Object,``0)">
      <summary>
        <para>Serialize an replacement object <paramref name="replacement" /> instead of the original <paramref name="originalItem" />.</para>
      </summary>
      <remarks>
        <para>Calling this method allows to remember the original object instance, even if the object is really written through a <see cref="T:System.Windows.Markup.MarkupExtension" /> or similar replacement mechanisms.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the object that is serialized.</para>
      </typeparam>
      <param name="context">
        <para>The current write context.</para>
      </param>
      <param name="originalItem">
        <para>The original object that should be serialized.</para>
      </param>
      <param name="replacement">
        <para>The replacement object that will actually be serialized instead.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.IWriteContext.Serialize``1(yWorks.GraphML.IWriteContext,``0)" />
      <exception cref="T:yWorks.GraphML.SerializationNotSupportedException" />
    </member>
    <member name="T:yWorks.GraphML.WriteEventArgs">
      <summary>
        <para>This is the event argument that is used by the <see cref="T:yWorks.GraphML.IWriteEvents" /> interface that can be queried from the <see cref="P:yWorks.GraphML.IWriteContext.WriteEvents" /> property.</para>
      </summary>
      <remarks>
        <para>This class holds a reference to the <see cref="P:yWorks.GraphML.WriteEventArgs.Context">write context</see> and the <see cref="P:yWorks.GraphML.WriteEventArgs.Item" /> that is currently being written.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.WriteEventArgs.#ctor(yWorks.GraphML.IWriteContext,System.Object)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.WriteEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context to assign to <see cref="P:yWorks.GraphML.WriteEventArgs.Context" />.</para>
      </param>
      <param name="item">
        <para>The item to assign to <see cref="P:yWorks.GraphML.WriteEventArgs.Item" />.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.WriteEventArgs.Context">
      <summary>
        <para>Gets the context that is being used for writing.</para>
      </summary>
      <value>
        <para>The context.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.WriteEventArgs.Item">
      <summary>
        <para>Gets the item that is currently being written or <c>null</c> if nothing is applicable.</para>
      </summary>
      <value>
        <para>The item being written.</para>
      </value>
    </member>
    <member name="T:yWorks.GraphML.XmlWriter">
      <summary>
        <para>Implementation of <see cref="T:yWorks.GraphML.IXmlWriter" /> that writes directly to an output stream.</para>
      </summary>
      <remarks>
        <para>This writer does not support random access on the output document.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)">
      <summary>
        <para>Create a new instance that writes on the given stream with a specified encoding</para>
      </summary>
      <param name="os">
        <para>The output stream</para>
      </param>
      <param name="enc">
        <para>The document encoding</para>
      </param>
      <param name="indent">
        <para>Whether the output should be indented or not. Default is <c>true</c></para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.#ctor(System.IO.TextWriter,System.Boolean)">
      <summary>
        <para>Create a new instance that writes on a <see cref="T:System.IO.TextWriter" /></para>
      </summary>
      <remarks>
        <para>The document encoding is fixed by the <paramref name="os" /> encoding</para>
      </remarks>
      <param name="os">
        <para>The output stream</para>
      </param>
      <param name="indent">
        <para>Whether the output should be indented or not. Default is <c>true</c></para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.#ctor(System.Xml.XmlWriter)">
      <summary>
        <para>Create a new instance using the passed <paramref name="delegateWriter" />.</para>
      </summary>
      <param name="delegateWriter">
        <para>The writer to use.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.XmlWriter.DelegateWriter">
      <summary>
        <para>The writer the actuel XML creation is delegated to.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.CreateNamespaceManager">
      <summary>
        <para>Factory method that creates the namespace manager for this instance.</para>
      </summary>
      <returns>
        <para>A new manager instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.WriteStartDocument" />
    <member name="M:yWorks.GraphML.XmlWriter.FlushDocument" />
    <member name="P:yWorks.GraphML.XmlWriter.NamespaceManager">
      <summary>
        <para>Gets the namespace manager associated with this writer.</para>
      </summary>
      <value>
        <para>The namespace manager.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.WriteString(System.String)">
      <param name="s" />
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.WriteComment(System.String)">
      <param name="comment" />
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.WriteEndDocument" />
    <member name="M:yWorks.GraphML.XmlWriter.WriteStartElement(System.String,System.String,System.String)">
      <param name="prefix" />
      <param name="s" />
      <param name="ns" />
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.WriteStartElement(System.String,System.String)">
      <param name="localName" />
      <param name="ns" />
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.WriteAttribute(System.String,System.String,System.String,System.String)">
      <param name="prefix" />
      <param name="localName" />
      <param name="ns" />
      <param name="value" />
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.WriteDocumentFragment(System.Xml.Linq.XDocument)">
      <param name="fragment" />
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.WriteProcessingInstruction(System.String,System.String)">
      <param name="target" />
      <param name="data" />
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.WriteCData(System.String)">
      <param name="content" />
    </member>
    <member name="M:yWorks.GraphML.XmlWriter.WriteEndElement" />
    <member name="T:yWorks.GraphML.GraphMLReferenceExtension" />
    <member name="M:yWorks.GraphML.GraphMLReferenceExtension.#ctor" />
    <member name="M:yWorks.GraphML.GraphMLReferenceExtension.#ctor(System.String)">
      <param name="resourceKey" />
    </member>
    <member name="P:yWorks.GraphML.GraphMLReferenceExtension.ResourceKey">
      <summary>
        <para>Gets or sets the key to the resource that will be used to lookup the value.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.GraphMLReferenceExtension.ProvideValue(System.IServiceProvider)">
      <summary>
        <para>Note that this method will only work as expected if used within the GraphML parser.</para>
      </summary>
      <param name="serviceProvider">
        <para>The service provider instance.</para>
      </param>
      <returns>
        <para>The instance or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.IReferenceHandle">
      <summary>
        <para>Interface that allows a mark and identify shared resources.</para>
      </summary>
      <seealso cref="T:yWorks.GraphML.IReferenceHandler" />
    </member>
    <member name="P:yWorks.GraphML.IReferenceHandle.ReferenceType">
      <summary>
        <para>Gets the type of a resource (external or internal)</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.IReferenceHandle.Subject">
      <summary>
        <para>Gets the resource that is encapsulated by the handle.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.IReferenceHandle.Id">
      <summary>
        <para>Gets the id that identifies the resource in the GraphML document.</para>
      </summary>
      <remarks>
        <para>Note that this value is ignored for internal references.</para>
      </remarks>
    </member>
    <member name="T:yWorks.GraphML.SharingState">
      <summary>
        <para>The sharing states of objects registered at an <see cref="T:yWorks.GraphML.IReferenceHandler" /> via <see cref="M:yWorks.GraphML.IReferenceHandler.RegisterResource(yWorks.GraphML.IWriteContext,System.Object)" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.SharingState.Unshared">
      <summary>
        <para>The registered object shall not be shared.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.SharingState.FirstSeen">
      <summary>
        <para>The object has been registered the first time.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.SharingState.Duplicate">
      <summary>
        <para>The object has been registered multiple times and will be shared.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.IReferenceHandler">
      <summary>
        <para>This interface defines methods to write and configure shared sections in the resulting GraphML output</para>
      </summary>
      <remarks>
        <para>This interface provides infrastructure for both external and internal (i.e. stored in the GraphML document) references.</para>
        <para>Usually, it is not necessary to use this interface directly from client code.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.IReferenceHandler.RegisterResource(yWorks.GraphML.IWriteContext,System.Object)">
      <summary>
        <para>Register a shared resource.</para>
      </summary>
      <param name="context">
        <para>The current write context.</para>
      </param>
      <param name="subject">
        <para>The resource to register.</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff the resource needs to be serialized; otherwise the resource is either a duplicate resource or is declared externally and does not need any additional handling.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IReferenceHandler.MarkAsUnshared(yWorks.GraphML.IWriteContext,System.Object)">
      <summary>
        <para>Unregister a shared resource.</para>
      </summary>
      <remarks>
        <para>This allows to explicitly mark a resource as unshared even if it is referenced multiple times in the object graph. If a resource has already been registered with <see cref="M:yWorks.GraphML.IReferenceHandler.RegisterResource(yWorks.GraphML.IWriteContext,System.Object)" />, it will be unmarked. In addition, subsequent calls to <see cref="M:yWorks.GraphML.IReferenceHandler.RegisterResource(yWorks.GraphML.IWriteContext,System.Object)" /> for the same reference won't mark the resource as shared again.</para>
      </remarks>
      <param name="context">
        <para>The current write context.</para>
      </param>
      <param name="subject">
        <para>The resource to register.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.IReferenceHandler.RegisterResource(yWorks.GraphML.IWriteContext,System.Object)" />
      <seealso cref="P:yWorks.GraphML.GraphMLAttribute.Shareable" />
    </member>
    <member name="P:yWorks.GraphML.IReferenceHandler.InternalHandles">
      <summary>
        <para>Gets a collection of all registered reference handles that should be written to the GraphML shared data section.</para>
      </summary>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.QueryReferenceId" />
      <seealso cref="E:yWorks.GraphML.GraphMLWriter.QueryReferenceId" />
    </member>
    <member name="M:yWorks.GraphML.IReferenceHandler.GetHandle(yWorks.GraphML.IWriteContext,System.Object)">
      <summary>
        <para>Gets the reference handle for a given subject.</para>
      </summary>
      <param name="subject">
        <para>The subject.</para>
      </param>
      <param name="context">
        <para>The current write context.</para>
      </param>
      <returns>
        <para>A handle for the resource <paramref name="subject" />, or <c>null</c> if the resource is not registered.</para>
      </returns>
      <seealso cref="T:yWorks.GraphML.IReferenceHandle" />
      <seealso cref="P:yWorks.GraphML.IReferenceHandle.Subject" />
    </member>
    <member name="T:yWorks.GraphML.GraphMLReferenceType">
      <summary>
        <para>Specifies the type of the shared resource.</para>
      </summary>
      <seealso cref="P:yWorks.GraphML.IReferenceHandle.ReferenceType" />
    </member>
    <member name="F:yWorks.GraphML.GraphMLReferenceType.Internal">
      <summary>
        <para>Specifies an internal resource, that is the serialized form of the resource is stored in the GraphML document itself.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.GraphMLReferenceType.External">
      <summary>
        <para>Specifies an external resource, that is the resource description is not stored in the GraphML document itself.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.ResolveReferenceEventArgs">
      <summary>
        <para>Event arguments for calls to the <see cref="E:yWorks.GraphML.GraphMLIOHandler.ResolveReference" /> and <see cref="E:yWorks.GraphML.GraphMLIOHandler.OverrideResolveReference" /> events.</para>
      </summary>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.ResolveReference" />
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.OverrideResolveReference" />
    </member>
    <member name="M:yWorks.GraphML.ResolveReferenceEventArgs.#ctor(yWorks.GraphML.IParseContext,System.String)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.GraphML.ResolveReferenceEventArgs" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.GraphML.ResolveReferenceEventArgs.Handled" /> property is set to <c>false</c>, the <see cref="P:yWorks.GraphML.ResolveReferenceEventArgs.Value" /> property is set to <c>null</c></para>
      </remarks>
      <param name="context">
        <para>The current parse context that can be used by the event handler for additional information.</para>
      </param>
      <param name="referenceId">
        <para>The reference id that should evaluated by the event handler.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.ResolveReferenceEventArgs.ReferenceId">
      <summary>
        <para>Gets the reference id that should evaluated by the event handler.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.ResolveReferenceEventArgs.Value">
      <summary>
        <para>Gets or sets the reference value that is encapsulated by this instance.</para>
      </summary>
      <remarks>
        <para>Setting this property automatically sets <see cref="P:yWorks.GraphML.ResolveReferenceEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.GraphML.ResolveReferenceEventArgs.Handled" />
    </member>
    <member name="P:yWorks.GraphML.ResolveReferenceEventArgs.Handled">
      <summary>
        <para>Gets whether the last event handler invocation has actually handled the event.</para>
      </summary>
      <remarks>
        <para>This property is set implicitly by <see cref="P:yWorks.GraphML.ResolveReferenceEventArgs.Value" />.</para>
      </remarks>
      <seealso cref="P:yWorks.GraphML.ResolveReferenceEventArgs.Value" />
    </member>
    <member name="P:yWorks.GraphML.ResolveReferenceEventArgs.Context">
      <summary>
        <para>Gets the current parse context that can be used by the event handler for additional information.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.QueryReferenceIdEventArgs">
      <summary>
        <para>Event arguments for calls to the <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryReferenceId" /> or <see cref="E:yWorks.GraphML.GraphMLWriter.QueryReferenceId" /> events.</para>
      </summary>
      <remarks>
        <para>Event handling code should inspect the <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.Value" /> property and decide whether to set the <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceId" /> and/or <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceType" /> property in order to <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.Handled">handle</see> the event.</para>
      </remarks>
      <seealso cref="E:yWorks.GraphML.GraphMLIOHandler.QueryReferenceId" />
      <seealso cref="E:yWorks.GraphML.GraphMLWriter.QueryReferenceId" />
    </member>
    <member name="M:yWorks.GraphML.QueryReferenceIdEventArgs.#ctor(yWorks.GraphML.IWriteContext,System.Object)">
      <summary>
        <para>Creates a new instance.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.Handled" /> property is set to <c>false</c>, the <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceId" /> is set to <c>null</c>.</para>
      </remarks>
      <param name="context">
        <para>The current write context that can be used by the event handler for additional information.</para>
      </param>
      <param name="value">
        <para>The referenced object instance.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceId">
      <summary>
        <para>Gets or sets the reference id that should be evaluated by the event handler.</para>
      </summary>
      <remarks>
        <para>Setting this property to a non-<see cref="M:System.String.IsNullOrEmpty(System.String)">null string</see> automatically sets <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.Handled" /> to <c>true</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.Handled" />
    </member>
    <member name="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceType">
      <summary>
        <para>Gets or sets the type of the reference being queried.</para>
      </summary>
      <remarks>
        <para>Setting this property automatically sets <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.Handled" /> to <c>true</c>. By default this property is <see cref="F:yWorks.GraphML.GraphMLReferenceType.External" /> so <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.Value" />s that are given a <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceId" /> are treated as external references that are not serialized to the GraphML. Setting this property to <see cref="F:yWorks.GraphML.GraphMLReferenceType.Internal" /> and specifying a <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceId" /> will make the reference mechanism use the provided reference but will cause it to serialize the value to the GraphML, nevertheless.</para>
      </remarks>
      <seealso cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceId" />
      <seealso cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.Handled" />
    </member>
    <member name="P:yWorks.GraphML.QueryReferenceIdEventArgs.Value">
      <summary>
        <para>Gets the reference value that is encapsulated by this instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.QueryReferenceIdEventArgs.Handled">
      <summary>
        <para>Gets whether the last event handler invocation has actually handled the event.</para>
      </summary>
      <remarks>
        <para>This property is set implicitly by <see cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceId" />.</para>
      </remarks>
      <seealso cref="P:yWorks.GraphML.QueryReferenceIdEventArgs.ReferenceId" />
    </member>
    <member name="P:yWorks.GraphML.QueryReferenceIdEventArgs.Context">
      <summary>
        <para>Gets the current write context that can be used by the event handler for additional information.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.FoldingEdgeStateExtension" />
    <member name="P:yWorks.GraphML.FoldingEdgeStateExtension.Labels" />
    <member name="P:yWorks.GraphML.FoldingEdgeStateExtension.Style" />
    <member name="P:yWorks.GraphML.FoldingEdgeStateExtension.Bends" />
    <member name="P:yWorks.GraphML.FoldingEdgeStateExtension.SourcePort" />
    <member name="P:yWorks.GraphML.FoldingEdgeStateExtension.TargetPort" />
    <member name="P:yWorks.GraphML.FoldingEdgeStateExtension.Tag" />
    <member name="M:yWorks.GraphML.FoldingEdgeStateExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.GraphML.FolderNodeStateExtension" />
    <member name="P:yWorks.GraphML.FolderNodeStateExtension.Layout" />
    <member name="P:yWorks.GraphML.FolderNodeStateExtension.Labels" />
    <member name="P:yWorks.GraphML.FolderNodeStateExtension.Style" />
    <member name="M:yWorks.GraphML.FolderNodeStateExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Primitives.ArrayExtension" />
    <member name="P:yWorks.Markup.Primitives.ArrayExtension.Type" />
    <member name="P:yWorks.Markup.Primitives.ArrayExtension.Items" />
    <member name="M:yWorks.Markup.Primitives.ArrayExtension.#ctor" />
    <member name="M:yWorks.Markup.Primitives.ArrayExtension.#ctor(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Markup.Primitives.ArrayExtension.#ctor(System.Array)">
      <param name="array" />
    </member>
    <member name="M:yWorks.Markup.Primitives.ArrayExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Platform.HatchBrushExtension" />
    <member name="P:yWorks.Markup.Platform.HatchBrushExtension.BackgroundColor" />
    <member name="P:yWorks.Markup.Platform.HatchBrushExtension.ForegroundColor" />
    <member name="P:yWorks.Markup.Platform.HatchBrushExtension.HatchStyle" />
    <member name="M:yWorks.Markup.Platform.HatchBrushExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Platform.LinearGradientBrushExtension" />
    <member name="P:yWorks.Markup.Platform.LinearGradientBrushExtension.Blend" />
    <member name="P:yWorks.Markup.Platform.LinearGradientBrushExtension.GammaCorrection" />
    <member name="P:yWorks.Markup.Platform.LinearGradientBrushExtension.InterpolationColors" />
    <member name="P:yWorks.Markup.Platform.LinearGradientBrushExtension.LinearColors" />
    <member name="P:yWorks.Markup.Platform.LinearGradientBrushExtension.Rectangle" />
    <member name="P:yWorks.Markup.Platform.LinearGradientBrushExtension.Transform" />
    <member name="P:yWorks.Markup.Platform.LinearGradientBrushExtension.WrapMode" />
    <member name="M:yWorks.Markup.Platform.LinearGradientBrushExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Platform.SolidBrushExtension" />
    <member name="P:yWorks.Markup.Platform.SolidBrushExtension.Color" />
    <member name="M:yWorks.Markup.Platform.SolidBrushExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Platform.TextureBrushExtension" />
    <member name="P:yWorks.Markup.Platform.TextureBrushExtension.Image" />
    <member name="P:yWorks.Markup.Platform.TextureBrushExtension.Transform" />
    <member name="P:yWorks.Markup.Platform.TextureBrushExtension.WrapMode" />
    <member name="M:yWorks.Markup.Platform.TextureBrushExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Platform.ColorExtension" />
    <member name="M:yWorks.Markup.Platform.ColorExtension.#ctor" />
    <member name="M:yWorks.Markup.Platform.ColorExtension.#ctor(System.Drawing.Color)">
      <param name="value" />
    </member>
    <member name="P:yWorks.Markup.Platform.ColorExtension.Value" />
    <member name="M:yWorks.Markup.Platform.ColorExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Primitives.NullExtension" />
    <member name="M:yWorks.Markup.Primitives.NullExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Platform.PenExtension" />
    <member name="M:yWorks.Markup.Platform.PenExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="P:yWorks.Markup.Platform.PenExtension.Alignment" />
    <member name="P:yWorks.Markup.Platform.PenExtension.Brush" />
    <member name="P:yWorks.Markup.Platform.PenExtension.Color" />
    <member name="P:yWorks.Markup.Platform.PenExtension.CompoundArray" />
    <member name="P:yWorks.Markup.Platform.PenExtension.CustomEndCap" />
    <member name="P:yWorks.Markup.Platform.PenExtension.CustomStartCap" />
    <member name="P:yWorks.Markup.Platform.PenExtension.DashCap" />
    <member name="P:yWorks.Markup.Platform.PenExtension.DashOffset" />
    <member name="P:yWorks.Markup.Platform.PenExtension.DashPattern" />
    <member name="P:yWorks.Markup.Platform.PenExtension.DashStyle" />
    <member name="P:yWorks.Markup.Platform.PenExtension.EndCap" />
    <member name="P:yWorks.Markup.Platform.PenExtension.LineJoin" />
    <member name="P:yWorks.Markup.Platform.PenExtension.MiterLimit" />
    <member name="P:yWorks.Markup.Platform.PenExtension.StartCap" />
    <member name="P:yWorks.Markup.Platform.PenExtension.Transform" />
    <member name="P:yWorks.Markup.Platform.PenExtension.Width" />
    <member name="T:yWorks.Markup.Primitives.StaticExtension" />
    <member name="P:yWorks.Markup.Primitives.StaticExtension.Member" />
    <member name="P:yWorks.Markup.Primitives.StaticExtension.Type" />
    <member name="M:yWorks.Markup.Primitives.StaticExtension.#ctor" />
    <member name="M:yWorks.Markup.Primitives.StaticExtension.#ctor(System.String)">
      <param name="member" />
    </member>
    <member name="M:yWorks.Markup.Primitives.StaticExtension.#ctor(System.Type,System.String)">
      <param name="type" />
      <param name="member" />
    </member>
    <member name="M:yWorks.Markup.Primitives.StaticExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Primitives.TypeExtension" />
    <member name="P:yWorks.Markup.Primitives.TypeExtension.TypeName" />
    <member name="P:yWorks.Markup.Primitives.TypeExtension.Type" />
    <member name="M:yWorks.Markup.Primitives.TypeExtension.#ctor" />
    <member name="M:yWorks.Markup.Primitives.TypeExtension.#ctor(System.String)">
      <param name="typeName" />
    </member>
    <member name="M:yWorks.Markup.Primitives.TypeExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.GraphML.GraphMLParseValueSerializerContext">
      <summary>
        <para>Special implementation of <see cref="T:System.Windows.Markup.IValueSerializerContext" /> that should be used in a GraphML parse context.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.GraphMLParseValueSerializerContext.#ctor(yWorks.GraphML.IParseContext)">
      <summary>
        <para>Creates a new instance that wraps <paramref name="context" /></para>
      </summary>
      <param name="context">
        <para>The current write context</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLParseValueSerializerContext.GetService(System.Type)">
      <summary>
        <para>Returns the wrapped <see cref="T:yWorks.GraphML.IParseContext" /> for this serviceType, otherwise <c>null</c></para>
      </summary>
      <param name="serviceType">
        <para>The serviceType</para>
      </param>
      <returns>
        <para>the wrapped <see cref="T:yWorks.GraphML.IParseContext" /> for this serviceType, otherwise <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLParseValueSerializerContext.GetValueSerializerFor(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLParseValueSerializerContext.OnComponentChanging" />
    <member name="M:yWorks.GraphML.GraphMLParseValueSerializerContext.OnComponentChanged" />
    <member name="M:yWorks.GraphML.GraphMLParseValueSerializerContext.GetValueSerializerFor(System.ComponentModel.PropertyDescriptor)">
      <param name="descriptor" />
    </member>
    <member name="P:yWorks.GraphML.GraphMLParseValueSerializerContext.Owner">
      <summary>
        <para>Gets or sets the parent object of <see cref="P:yWorks.GraphML.GraphMLParseValueSerializerContext.Instance" />, if such an object exists currently.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.GraphMLWriteValueSerializerContext">
      <summary>
        <para>Special implementation of <see cref="T:System.Windows.Markup.IValueSerializerContext" /> that should be used in a GraphML write context.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriteValueSerializerContext.#ctor(yWorks.GraphML.IWriteContext)">
      <summary>
        <para>Creates a new instance that wraps <paramref name="context" /></para>
      </summary>
      <param name="context">
        <para>The current write context</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriteValueSerializerContext.GetService(System.Type)">
      <summary>
        <para>Returns the wrapped <see cref="T:yWorks.GraphML.IWriteContext" /> for this serviceType, otherwise <c>null</c></para>
      </summary>
      <param name="serviceType">
        <para>The serviceType</para>
      </param>
      <returns>
        <para>the wrapped <see cref="T:yWorks.GraphML.IWriteContext" /> for this serviceType, otherwise <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriteValueSerializerContext.GetValueSerializerFor(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.GraphML.GraphMLWriteValueSerializerContext.OnComponentChanging" />
    <member name="M:yWorks.GraphML.GraphMLWriteValueSerializerContext.OnComponentChanged" />
    <member name="M:yWorks.GraphML.GraphMLWriteValueSerializerContext.GetValueSerializerFor(System.ComponentModel.PropertyDescriptor)">
      <param name="descriptor" />
    </member>
    <member name="P:yWorks.GraphML.GraphMLWriteValueSerializerContext.Owner">
      <summary>
        <para>Gets or sets the parent object of <see cref="P:yWorks.GraphML.GraphMLWriteValueSerializerContext.Instance" />, if such an object exists currently.</para>
      </summary>
    </member>
    <member name="T:yWorks.GraphML.TypeConverterValueSerializer" />
    <member name="M:yWorks.GraphML.TypeConverterValueSerializer.#ctor(System.ComponentModel.TypeConverter)">
      <param name="coreConverter" />
    </member>
    <member name="M:yWorks.GraphML.TypeConverterValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)">
      <param name="value" />
      <param name="context" />
    </member>
    <member name="M:yWorks.GraphML.TypeConverterValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)">
      <param name="value" />
      <param name="context" />
    </member>
    <member name="M:yWorks.GraphML.TypeConverterValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)">
      <param name="value" />
      <param name="context" />
    </member>
    <member name="M:yWorks.GraphML.TypeConverterValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)">
      <param name="value" />
      <param name="context" />
    </member>
    <member name="T:yWorks.GraphML.IMarkupExtensionConverter">
      <summary>
        <para>An interface for converters that can convert an object to a corresponding <see cref="T:System.Windows.Markup.MarkupExtension" />.</para>
      </summary>
      <remarks>
        <para>This interface is only used for GraphML serialiaztion.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.IMarkupExtensionConverter.CanConvert(yWorks.GraphML.IWriteContext,System.Object)">
      <summary>
        <para>Returns if the converter can convert the <paramref name="value" /> to a <see cref="T:System.Windows.Markup.MarkupExtension" /> in the current write context.</para>
      </summary>
      <param name="context">
        <para>The current write context.</para>
      </param>
      <param name="value">
        <para>The object to convert.</para>
      </param>
      <returns>
        <para>Whether the converter can convert the passed value.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IMarkupExtensionConverter.Convert(yWorks.GraphML.IWriteContext,System.Object)">
      <summary>
        <para>Converts the <paramref name="value" /> to a <see cref="T:System.Windows.Markup.MarkupExtension" /> using the current write context.</para>
      </summary>
      <param name="context">
        <para>The current write context.</para>
      </param>
      <param name="value">
        <para>The object to convert.</para>
      </param>
      <returns>
        <para>The <see cref="T:System.Windows.Markup.MarkupExtension" /> the value was converted to.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.MarkupExtensionConverterAttribute">
      <summary>
        <para>Custom attribute to control specific aspects of GraphML serialization.</para>
      </summary>
      <remarks>
        <para>The specialized <see cref="T:yWorks.GraphML.XamlSerializer" /> will evaluate this attribute to override its built in mechanism to lookup an <see cref="T:yWorks.GraphML.IMarkupExtensionConverter" /> for an object.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.XamlSerializer" />
    </member>
    <member name="P:yWorks.GraphML.MarkupExtensionConverterAttribute.Type">
      <summary>
        <para>Gets a custom <see cref="T:yWorks.GraphML.IMarkupExtensionConverter" /> for attribute serialization.</para>
      </summary>
      <remarks>
        <para>The specified type must implement <see cref="T:yWorks.GraphML.IMarkupExtensionConverter" />.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.XamlSerializer" />
      <seealso cref="T:yWorks.GraphML.IMarkupExtensionConverter" />
    </member>
    <member name="M:yWorks.GraphML.MarkupExtensionConverterAttribute.#ctor(System.Type)">
      <summary>
        <para>Creates a new instance and initializes the property <see cref="P:yWorks.GraphML.MarkupExtensionConverterAttribute.Type" />.</para>
      </summary>
      <remarks>
        <para>The specified type must implement <see cref="T:yWorks.GraphML.IMarkupExtensionConverter" />.</para>
      </remarks>
      <param name="type">
        <para>The type of the <see cref="T:yWorks.GraphML.IMarkupExtensionConverter" /> implementation.</para>
      </param>
    </member>
    <member name="T:yWorks.GraphML.IXamlNameMapper">
      <summary>
        <para>Utility class that facilitates determining type information from XML elements and writing of markup extensions as attributes.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.IXamlNameMapper.GetType(yWorks.GraphML.IParseContext,System.Xml.Linq.XName)">
      <summary>
        <para>Returns a <see cref="T:System.Type" /> that matches the given <paramref name="fqTagName" /> of an XML element.</para>
      </summary>
      <remarks>
        <para>
          <paramref name="fqTagName" /> must follow the usual XAML naming rules.</para>
      </remarks>
      <param name="context">
        <para>The current parse context.</para>
      </param>
      <param name="fqTagName">
        <para>The fully qualified XML element name that must describe a valid type in this CLR namespace.</para>
      </param>
      <returns>
        <para>The first matching type, if any.</para>
      </returns>
      <seealso cref="T:System.Windows.Markup.XmlnsDefinitionAttribute" />
    </member>
    <member name="M:yWorks.GraphML.IXamlNameMapper.GetName(yWorks.GraphML.IWriteContext,System.Type)">
      <summary>
        <para>Returns the XML tag name that belongs to type <paramref name="type" /></para>
      </summary>
      <param name="context">
        <para>The current write context.</para>
      </param>
      <param name="type">
        <para>The type for which an XML namespace mapping is searched.</para>
      </param>
      <returns>
        <para>the XML tag name that belongs to type <paramref name="type" /></para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.InvalidXamlNamespaceDeclarationException">
      <summary>
        <para>Exception that gets thrown if an XML namespace declaration does violate the XAML naming conventions.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.InvalidXamlNamespaceDeclarationException.#ctor">
      <summary>
        <para>Create a new instance of <see cref="T:yWorks.GraphML.InvalidXamlNamespaceDeclarationException" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.InvalidXamlNamespaceDeclarationException.#ctor(System.String)">
      <summary>
        <para>Create a new instance of <see cref="T:yWorks.GraphML.InvalidXamlNamespaceDeclarationException" /> with a specific error message.</para>
      </summary>
      <param name="message" />
    </member>
    <member name="T:yWorks.Markup.Primitives.ListExtension" />
    <member name="M:yWorks.Markup.Primitives.ListExtension.#ctor" />
    <member name="M:yWorks.Markup.Primitives.ListExtension.#ctor(System.Collections.ICollection)">
      <param name="enumerable" />
    </member>
    <member name="M:yWorks.Markup.Primitives.ListExtension.#ctor(System.Collections.IEnumerable)">
      <param name="enumerable" />
    </member>
    <member name="P:yWorks.Markup.Primitives.ListExtension.Items" />
    <member name="M:yWorks.Markup.Primitives.ListExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Primitives.GenericListExtension" />
    <member name="M:yWorks.Markup.Primitives.GenericListExtension.#ctor(System.Type)">
      <param name="typeArgument" />
    </member>
    <member name="M:yWorks.Markup.Primitives.GenericListExtension.#ctor(System.Collections.IEnumerable,System.Type)">
      <param name="enumerable" />
      <param name="typeArgument" />
    </member>
    <member name="M:yWorks.Markup.Primitives.GenericListExtension.#ctor" />
    <member name="P:yWorks.Markup.Primitives.GenericListExtension.Items" />
    <member name="P:yWorks.Markup.Primitives.GenericListExtension.Type" />
    <member name="M:yWorks.Markup.Primitives.GenericListExtension.CopyItems(System.Collections.IList)">
      <param name="oldItems" />
    </member>
    <member name="M:yWorks.Markup.Primitives.GenericListExtension.GetCollectionType(System.Type)">
      <param name="typeArgument" />
    </member>
    <member name="M:yWorks.Markup.Primitives.GenericListExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Common.BendExtension" />
    <member name="M:yWorks.Markup.Common.BendExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.BendExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="P:yWorks.Markup.Common.BendExtension.Location" />
    <member name="P:yWorks.Markup.Common.BendExtension.Tag" />
    <member name="T:yWorks.Markup.Common.GraphSettings" />
    <member name="P:yWorks.Markup.Common.GraphSettings.NodeDefaults" />
    <member name="P:yWorks.Markup.Common.GraphSettings.GroupNodeDefaults" />
    <member name="P:yWorks.Markup.Common.GraphSettings.EdgeDefaults" />
    <member name="P:yWorks.Markup.Common.GraphSettings.UsePortCandidateProviders" />
    <member name="M:yWorks.Markup.Common.GraphSettings.ApplyTo(yWorks.Graph.IGraph)">
      <param name="graph" />
    </member>
    <member name="M:yWorks.Markup.Common.GraphSettings.ReadFrom(yWorks.Graph.IGraph)">
      <param name="graph" />
    </member>
    <member name="T:yWorks.Markup.Common.LabelExtension" />
    <member name="M:yWorks.Markup.Common.LabelExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.LabelExtension.#ctor(System.String)">
      <param name="text" />
    </member>
    <member name="P:yWorks.Markup.Common.LabelExtension.Text" />
    <member name="P:yWorks.Markup.Common.LabelExtension.LayoutParameter" />
    <member name="P:yWorks.Markup.Common.LabelExtension.Style" />
    <member name="P:yWorks.Markup.Common.LabelExtension.PreferredSize" />
    <member name="P:yWorks.Markup.Common.LabelExtension.Tag" />
    <member name="M:yWorks.Markup.Common.LabelExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Common.PortExtension" />
    <member name="M:yWorks.Markup.Common.PortExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.PortExtension.#ctor(yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="parameter" />
    </member>
    <member name="P:yWorks.Markup.Common.PortExtension.Tag" />
    <member name="P:yWorks.Markup.Common.PortExtension.Style" />
    <member name="P:yWorks.Markup.Common.PortExtension.LocationParameter" />
    <member name="M:yWorks.Markup.Common.PortExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Common.StripeDefaultsExtension" />
    <member name="M:yWorks.Markup.Common.StripeDefaultsExtension.#ctor" />
    <member name="P:yWorks.Markup.Common.StripeDefaultsExtension.Insets" />
    <member name="P:yWorks.Markup.Common.StripeDefaultsExtension.Size" />
    <member name="P:yWorks.Markup.Common.StripeDefaultsExtension.MinimumSize" />
    <member name="P:yWorks.Markup.Common.StripeDefaultsExtension.Labels" />
    <member name="P:yWorks.Markup.Common.StripeDefaultsExtension.Style" />
    <member name="P:yWorks.Markup.Common.StripeDefaultsExtension.ShareStyleInstance" />
    <member name="M:yWorks.Markup.Common.StripeDefaultsExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.GraphML.Property">
      <summary>
        <para>Wraps a property or field together with default values and meta data.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.Property.CanRead">
      <summary>
        <para>Gets whether or not the property has a <b>public</b> getter.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.Property.CanWrite">
      <summary>
        <para>Gets whether or not the property has a <b>public</b> setter.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.Property.IsStatic">
      <summary>
        <para>Gets whether or not this is a static property.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.Property.SerializationVisibility">
      <summary>
        <para>Gets the serialization visibility.</para>
      </summary>
      <value>
        <para>The serialization visibility.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.Property.ValueSerializer">
      <summary>
        <para>Gets the <see cref="P:yWorks.GraphML.Property.ValueSerializer" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.Property.MarkupExtensionConverter">
      <summary>
        <para>Gets the MarkupExtensionConverter.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.Property.TypeConverter">
      <summary>
        <para>Gets the TypeConverter.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.Property.GraphMLAttribute">
      <summary>
        <para>Gets the <see cref="P:yWorks.GraphML.Property.GraphMLAttribute" />.</para>
      </summary>
      <value>
        <para>The graph ML attribute.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.Property.IsContentProperty">
      <summary>
        <para>Gets a value indicating whether this instance is the one defined in the <see cref="T:System.Windows.Markup.ContentPropertyAttribute" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance is the one defined in the <see cref="T:System.Windows.Markup.ContentPropertyAttribute" />; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.Property.IsProperty">
      <summary>
        <para>Gets a value indicating whether this instance wraps a property.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.Property.Type">
      <summary>
        <para>Gets the type of the property.</para>
      </summary>
      <value>
        <para>The type of the property.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.Property.OwnerType">
      <summary>
        <para>Gets the type of the owner.</para>
      </summary>
      <value>
        <para>The type of the owner.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.Property.DefaultValue">
      <summary>
        <para>Gets the default value.</para>
      </summary>
      <value>
        <para>The default value.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.Property.HasDefaultValue">
      <summary>
        <para>Gets a value indicating whether this instance has a default value.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance has a default value; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.Property.GetValue(System.Object)">
      <summary>
        <para>Gets the value the wrapped property has on the given instance.</para>
      </summary>
      <param name="ownerInstance">
        <para>The instance to get the property value from.</para>
      </param>
      <returns>
        <para>The value the wrapped property has on the given instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.Property.SetValue(System.Object,System.Object)">
      <summary>
        <para>Sets the value to the wrapped property on the given instance.</para>
      </summary>
      <param name="ownerInstance">
        <para>The instance to set the property value on.</para>
      </param>
      <param name="value">
        <para>The value to set.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.Property.Name">
      <summary>
        <para>Gets the name of the property, as it will appear in GraphML.</para>
      </summary>
      <value>
        <para>The name.</para>
      </value>
    </member>
    <member name="T:yWorks.GraphML.QueryNameEventArgs">
      <summary>
        <para>The event arguments used by <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryName" /> to override automatic name determination in GraphML.</para>
      </summary>
      <remarks>
        <para>If the event handler determines that it map resolve <see cref="P:yWorks.GraphML.QueryNameEventArgs.Type" /> to a xml name, it should place the result into the <see cref="P:yWorks.GraphML.QueryNameEventArgs.Result" /> property and thus mark the event as <see cref="P:yWorks.GraphML.QueryNameEventArgs.Handled" />.</para>
        <para>It is valid to provide only part of the XML name by setting the other part to null. In that case, the default name determination rules are used for that part.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.QueryNameEventArgs.#ctor(yWorks.GraphML.IWriteContext,System.Type)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.QueryNameEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context in which the lookup shall take place.</para>
      </param>
      <param name="type">
        <para>The type that should be mapped.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.QueryNameEventArgs.Result">
      <summary>
        <para>Gets or sets the result of the name query, which is <c>null</c> initially.</para>
      </summary>
      <remarks>
        <para>Setting this property will automatically set the <see cref="P:yWorks.GraphML.QueryNameEventArgs.Handled" /> property to <c>true</c>.</para>
        <para>It is valid to provide only part of the XML name by setting the other part to null. In that case, the default name determination rules are used for that part.</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.QueryNameEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.GraphML.QueryNameEventArgs" /> is handled.</para>
      </summary>
      <remarks>
        <para>Setting this property to <c>true</c> indicates to the event source that the <see cref="P:yWorks.GraphML.QueryNameEventArgs.Result" /> has been assigned and that the event should not be propagated to further listeners.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this event has been handled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.QueryNameEventArgs.Type">
      <summary>
        <para>Gets the type for which the <see cref="P:yWorks.GraphML.QueryNameEventArgs.Result">XML name</see> is queried.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.QueryNameEventArgs.Context">
      <summary>
        <para>Gets the context in which the <see cref="P:yWorks.GraphML.QueryNameEventArgs.Type" /> shall mapped.</para>
      </summary>
      <value>
        <para>The context.</para>
      </value>
    </member>
    <member name="T:yWorks.GraphML.QueryTypeEventArgs">
      <summary>
        <para>The event arguments used by <see cref="E:yWorks.GraphML.GraphMLIOHandler.QueryType" /> to override automatic type resolution in GraphML.</para>
      </summary>
      <remarks>
        <para>If the event handler determines that it can resolve <see cref="P:yWorks.GraphML.QueryTypeEventArgs.XmlName" /> to a type, it should place the result into the <see cref="P:yWorks.GraphML.QueryTypeEventArgs.Result" /> property and thus mark the event as <see cref="P:yWorks.GraphML.QueryTypeEventArgs.Handled" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.QueryTypeEventArgs.#ctor(yWorks.GraphML.IParseContext,System.Xml.Linq.XName)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.QueryTypeEventArgs" /> class.</para>
      </summary>
      <param name="context">
        <para>The context in the lookup should take place.</para>
      </param>
      <param name="xName">
        <para>The type that should be mapped.</para>
      </param>
    </member>
    <member name="P:yWorks.GraphML.QueryTypeEventArgs.Result">
      <summary>
        <para>Gets or sets the result of the type query, which is <c>null</c> initially.</para>
      </summary>
      <remarks>
        <para>Setting this property will automatically set the <see cref="P:yWorks.GraphML.QueryTypeEventArgs.Handled" /> property to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.GraphML.QueryTypeEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.GraphML.QueryTypeEventArgs" /> is handled.</para>
      </summary>
      <remarks>
        <para>Setting this property to <c>true</c> indicates to the event source that the <see cref="P:yWorks.GraphML.QueryTypeEventArgs.Result" /> has been assigned and that the event should not be propagated to further listeners.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this event has been handled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.QueryTypeEventArgs.XmlName">
      <summary>
        <para>Gets the fully qualified xml name that should be resolved to a type.</para>
      </summary>
    </member>
    <member name="P:yWorks.GraphML.QueryTypeEventArgs.Context">
      <summary>
        <para>Gets the context in which the <see cref="T:System.Type" /> shall mapped.</para>
      </summary>
      <value>
        <para>The context.</para>
      </value>
    </member>
    <member name="T:yWorks.GraphML.XamlReader">
      <summary>
        <para>An implementation that can read (a subset of) XAML formatted XML content.</para>
      </summary>
    </member>
    <member name="F:yWorks.GraphML.XamlReader.Instance">
      <summary>
        <para>A singleton instance of this class.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.XamlReader.Deserialize(yWorks.GraphML.IParseContext,System.Xml.Linq.XElement)">
      <summary>
        <para>Deserializes the specified element node in the context to an instance.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="element">
        <para>The XML element node.</para>
      </param>
      <returns>
        <para>The instance that is described in the XML.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.IXamlPrefixMapper">
      <summary>
        <para>Interface for mapping XAML namespaces to XML namespace prefixes and vice versa.</para>
      </summary>
      <remarks>
        <para>This interface is only used to specify mappings between namespaces that are used for serialization or deserialization with classes <see cref="T:yWorks.GraphML.XamlSerializer" /> and <see cref="T:yWorks.GraphML.XamlReader" />. If no prefix mapping is specified for a namespace, a default XML namespace/prefix mapping is used.</para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.IXamlPrefixMapper.GetPrefixOfNamespace(System.String)">
      <summary>
        <para>Gets the prefix of namespace.</para>
      </summary>
      <param name="ns">
        <para>The namespace.</para>
      </param>
      <returns>
        <para>The prefix to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.IXamlPrefixMapper.GetNamespaceOfPrefix(System.String)">
      <summary>
        <para>Gets the namespace for the given prefix.</para>
      </summary>
      <param name="prefix">
        <para>The prefix.</para>
      </param>
      <returns>
        <para>The namespace.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.XamlSerializer">
      <summary>
        <para>Serializer that produces XAML conforming output from the target object's reflection data.</para>
      </summary>
      <remarks>
        <para>By default, the resulting XAML output follows the rules for normal XAML output. In addition, serialization can be fine tuned by applying <see cref="T:yWorks.GraphML.GraphMLAttribute" /> to the target object's class or some of its members.</para>
        <para>Note that usually the type should be excluded from obfuscation, or its name should be declared with <see cref="P:yWorks.GraphML.GraphMLAttribute.Name" />. The same holds for specific members.</para>
      </remarks>
      <seealso cref="T:yWorks.GraphML.GraphMLAttribute" />
    </member>
    <member name="F:yWorks.GraphML.XamlSerializer.Instance">
      <summary>
        <para>A singleton instance of this class.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.XamlSerializer.Serialize(yWorks.GraphML.IWriteContext,System.Object)">
      <summary>
        <para>Serialize the given object to a <see cref="T:yWorks.GraphML.IXmlWriter" /></para>
      </summary>
      <remarks>
        <para>This implementation already provides the toplevel XML element with an appropriate tag name.</para>
      </remarks>
      <param name="context">
        <para>The current write context</para>
      </param>
      <param name="subject">
        <para>The actual object</para>
      </param>
    </member>
    <member name="T:yWorks.Markup.Common.AnchoredParameterExtension" />
    <member name="M:yWorks.Markup.Common.AnchoredParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.AnchoredParameterExtension.#ctor(yWorks.Geometry.PointD)">
      <param name="anchor" />
    </member>
    <member name="P:yWorks.Markup.Common.AnchoredParameterExtension.Anchor" />
    <member name="M:yWorks.Markup.Common.AnchoredParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Common.DynamicAnchoredParameterExtension" />
    <member name="M:yWorks.Markup.Common.DynamicAnchoredParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.DynamicAnchoredParameterExtension.#ctor(yWorks.Geometry.IPoint)">
      <param name="anchor" />
    </member>
    <member name="P:yWorks.Markup.Common.DynamicAnchoredParameterExtension.Anchor" />
    <member name="M:yWorks.Markup.Common.DynamicAnchoredParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModel" /> that can create <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" />s that describe the location of ports that are attached to the bends of <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.Instance">
      <summary>
        <para>A static immutable global instance of this class.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.FirstBend">
      <summary>
        <para>A convenience instance of a parameter that is bound to the first <see cref="T:yWorks.Graph.IBend" /> of the edge.</para>
      </summary>
      <seealso cref="M:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.CreateFromSource(System.Int32)" />
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.LastBend">
      <summary>
        <para>A convenience instance of a parameter that is bound to the last <see cref="T:yWorks.Graph.IBend" /> of the edge.</para>
      </summary>
      <seealso cref="M:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.CreateFromTarget(System.Int32)" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.Lookup(System.Type)">
      <summary>
        <para>This implementation has nothing in its lookup and will always yield <c>null</c></para>
      </summary>
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.GetLocation(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="port" />
      <param name="locationParameter" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.CreateFromSource(System.Int32)">
      <summary>
        <para>Creates a parameter that indicates the location of the bend with index <paramref name="bendIndex" /> starting from the source side.</para>
      </summary>
      <param name="bendIndex">
        <para>The index of the bend counting from the source side.</para>
      </param>
      <returns>
        <para>A parameter that anchors the port at a bend.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.CreateFromTarget(System.Int32)">
      <summary>
        <para>Creates a parameter that indicates the location of the bend with index <paramref name="bendIndex" /> starting from the target side.</para>
      </summary>
      <param name="bendIndex">
        <para>The index of the bend counting from the target side.</para>
      </param>
      <returns>
        <para>A parameter that anchors the port at a bend.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.CreateParameter(yWorks.Graph.IPortOwner,yWorks.Geometry.PointD)">
      <param name="owner" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.BendAnchoredPortLocationModel.GetContext(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="port" />
      <param name="locationParameter" />
    </member>
    <member name="T:yWorks.Markup.Common.BendAnchoredParameterExtension" />
    <member name="M:yWorks.Markup.Common.BendAnchoredParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.BendAnchoredParameterExtension.#ctor(System.Int32,System.Boolean)">
      <param name="index" />
      <param name="fromSource" />
    </member>
    <member name="P:yWorks.Markup.Common.BendAnchoredParameterExtension.Index" />
    <member name="P:yWorks.Markup.Common.BendAnchoredParameterExtension.FromSource" />
    <member name="M:yWorks.Markup.Common.BendAnchoredParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Common.ColumnExtension" />
    <member name="M:yWorks.Markup.Common.ColumnExtension.#ctor" />
    <member name="P:yWorks.Markup.Common.ColumnExtension.Columns" />
    <member name="P:yWorks.Markup.Common.ColumnExtension.Style" />
    <member name="P:yWorks.Markup.Common.ColumnExtension.MinimumSize" />
    <member name="P:yWorks.Markup.Common.ColumnExtension.Size" />
    <member name="P:yWorks.Markup.Common.ColumnExtension.Insets" />
    <member name="P:yWorks.Markup.Common.ColumnExtension.Labels" />
    <member name="P:yWorks.Markup.Common.ColumnExtension.Tag" />
    <member name="M:yWorks.Markup.Common.ColumnExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Common.CompositeLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.CompositeLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.CompositeLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="parameter" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.CompositeLabelModelParameterExtension.Parameter" />
    <member name="P:yWorks.Markup.Common.CompositeLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.CompositeLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.CompositeLabelModel">
      <summary>
        <para>An implementation of <see cref="T:yWorks.Graph.LabelModels.ILabelModel" /> that can be used to create custom label models out of existing <see cref="T:yWorks.Graph.LabelModels.ILabelModel" /> instances.</para>
      </summary>
      <remarks>
        <para>This class holds a number of models and can provide all of their parameters in <see cref="M:yWorks.Graph.LabelModels.CompositeLabelModel.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)" />. A custom model can easily be created that way:</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.CompositeLabelModel.#ctor">
      <summary>
        <para>Creates a new instance of this label model with an empty <see cref="P:yWorks.Graph.LabelModels.CompositeLabelModel.LabelModels" /> collection.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.LabelModels.CompositeLabelModel.LabelModels">
      <summary>
        <para>Gets a list of <see cref="T:yWorks.Graph.LabelModels.ILabelModel" /> implementations that are wrapped by this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.CompositeLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.CompositeLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.CompositeLabelModel.CreateDefaultParameter">
      <summary>
        <para>Creates a default parameter that can be used for this model.</para>
      </summary>
      <remarks>
        <para>If <see cref="P:yWorks.Graph.LabelModels.CompositeLabelModel.LabelModels" /> is not empty, the default parameter for the first model in that list is returned. Otherwise, the default parameter for <see cref="M:yWorks.Graph.LabelModels.FreeLabelModel.CreateDefaultParameter" /> is returned.</para>
      </remarks>
      <returns>
        <para>a parameter for this model instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.CompositeLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.CompositeLabelModel.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <summary>
        <para>Returns an enumerator over a set of possible <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> instances that can be used for the given label and model.</para>
      </summary>
      <remarks>
        <para>This implementation returns all parameters from all models in <see cref="P:yWorks.Graph.LabelModels.CompositeLabelModel.LabelModels" /></para>
      </remarks>
      <param name="label">
        <para>The label instance to use.</para>
      </param>
      <param name="model">
        <para>The model to provide parameters for.</para>
      </param>
      <returns>
        <para>A possibly empty enumerator over a set of label model parameters.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.CompositeLabelModel.FindBestParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel,yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Tries to find a parameter that best matches the given layout for the provided label instance.</para>
      </summary>
      <remarks>
        <para>This implementation tests all parameters from all models in <see cref="P:yWorks.Graph.LabelModels.CompositeLabelModel.LabelModels" />.</para>
      </remarks>
      <param name="label">
        <para>The label to find a parameter for.</para>
      </param>
      <param name="model">
        <para>The model instance to use. This should be the instance this instance has been obtained from.</para>
      </param>
      <param name="layout">
        <para>The anticipated layout for the label.</para>
      </param>
      <returns>
        <para>A non-<c>null</c> parameter that can be used for the label to approximate the provided layout.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.Arrow">
      <summary>
        <para>A default implementation of the <see cref="T:yWorks.Graph.Styles.IArrow" /> interface that can render <see cref="T:yWorks.Graph.Styles.ArrowType" />s.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.Arrow.#ctor">
      <summary>
        <para>Creates a new arrow with default values for <see cref="P:yWorks.Graph.Styles.Arrow.Pen" /> and brush.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.Arrow.#ctor(System.Drawing.Color)">
      <summary>
        <para>Creates a new arrow with the given color to use for <see cref="P:yWorks.Graph.Styles.Arrow.Pen" /> and brush.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Graph.Styles.Arrow.Pen" /> is created with thickness 1.</para>
      </remarks>
      <param name="color">
        <para>The color to use for <see cref="P:yWorks.Graph.Styles.Arrow.Pen" /> and brush.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.Arrow.Type">
      <summary>
        <para>Gets or sets the type of this arrow.</para>
      </summary>
      <value>
        <para>The type of this arrow.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.Arrow.Scale">
      <summary>
        <para>Gets or sets the scale factor of this arrow.</para>
      </summary>
      <remarks>
        <para>The arrow bounds are scaled with this factor.</para>
      </remarks>
      <value>
        <para>The scale factor of this arrow.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.Arrow.Pen">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Graph.Styles.Arrow.Pen" /> of the outline of this arrow.</para>
      </summary>
      <value>
        <para>The <see cref="P:yWorks.Graph.Styles.Arrow.Pen" /> of this arrow.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.Arrow.Brush">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Graph.Styles.Arrow.Brush" /> of the fill of this arrow.</para>
      </summary>
      <value>
        <para>The brush.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.Arrow.CropLength">
      <summary>
        <para>Gets the cropping length associated with this instance.</para>
      </summary>
      <value />
      <remarks>
        <para>This value is used by <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> implementations to let the edge appear to end shortly before its actual target.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.Arrow.Equals(yWorks.Graph.Styles.Arrow)">
      <summary>
        <para>Determines whether this arrow is equal to the other arrow.</para>
      </summary>
      <param name="other">
        <para>The other.</para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.Graph.Styles.Arrow.Equals(System.Object)">
      <param name="other" />
    </member>
    <member name="M:yWorks.Graph.Styles.Arrow.GetHashCode" />
    <member name="M:yWorks.Graph.Styles.Arrow.ToString" />
    <member name="T:yWorks.Graph.Styles.Arrows">
      <summary>
        <para>Static helper class that provides convenience access to some frequently used predefined <see cref="T:yWorks.Graph.Styles.Arrow" /> instances.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.Arrows.None">
      <summary>
        <para>A singleton <see cref="T:yWorks.Graph.Styles.IArrow" /> instance that paints no arrow at all.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.Arrows.Simple">
      <summary>
        <para>A singleton <see cref="T:yWorks.Graph.Styles.IArrow" /> instance that paints a simple black arrow.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.Arrows.Default">
      <summary>
        <para>A singleton <see cref="T:yWorks.Graph.Styles.IArrow" /> instance that paints a default shaped black arrow.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.Arrows.Short">
      <summary>
        <para>A singleton <see cref="T:yWorks.Graph.Styles.IArrow" /> instance that paints a short black arrow.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.Arrows.Diamond">
      <summary>
        <para>A singleton <see cref="T:yWorks.Graph.Styles.IArrow" /> instance that paints a simple diamond-shaped black arrow.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.Arrows.Cross">
      <summary>
        <para>A singleton <see cref="T:yWorks.Graph.Styles.IArrow" /> instance that paints a simple cross-shaped black arrow.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.Arrows.Circle">
      <summary>
        <para>A singleton <see cref="T:yWorks.Graph.Styles.IArrow" /> instance that paints a simple circle-shaped black arrow.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.Arrows.Triangle">
      <summary>
        <para>A singleton <see cref="T:yWorks.Graph.Styles.IArrow" /> instance that paints a simple triangle-shaped black arrow.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.SimpleBend">
      <summary>
        <para>A simple mutable implementation of the <see cref="T:yWorks.Graph.IBend" /> interface that can be used stand-alone.</para>
      </summary>
      <remarks>
        <para>Note that this class is not the one used as the default implementation of a <see cref="T:yWorks.Graph.DefaultGraph" />'s <see cref="T:yWorks.Graph.IBend" />s and casting them to <see cref="T:yWorks.Graph.SimpleBend" /> will fail. Instances of this class can be used without an accompanying graph instance. All of the properties are mutable. An example of a possible use case would be the rendering of a <see cref="T:yWorks.Graph.SimpleEdge" /> with bends into a graphics context: Simply create two <see cref="T:yWorks.Graph.SimpleNode" />s, a <see cref="T:yWorks.Graph.SimpleEdge" /> to connect the two nodes and add instances of this class to the edge's <see cref="P:yWorks.Graph.SimpleEdge.Bends" /> model. Then render the edge.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.SimpleBend.#ctor(yWorks.Graph.IEdge,yWorks.Geometry.IPoint)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.SimpleBend" /> class using the given owner and location.</para>
      </summary>
      <param name="owner">
        <para>The owner of the bend.</para>
      </param>
      <param name="location">
        <para>The bend's location.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.SimpleBend.Owner">
      <summary>
        <para>Gets or sets the edge this bend instance belongs to.</para>
      </summary>
      <remarks>
        <para>This implies that <c>Owner.Bends</c> contains this instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleBend.Location">
      <summary>
        <para>Gets or sets the location of this bend.</para>
      </summary>
      <seealso cref="P:yWorks.Graph.SimpleBend.X" />
      <seealso cref="P:yWorks.Graph.SimpleBend.Y" />
    </member>
    <member name="P:yWorks.Graph.SimpleBend.X">
      <summary>
        <para>Gets the current x coordinate of this bend.</para>
      </summary>
      <value>
        <para>The value of <see cref="P:yWorks.Graph.SimpleBend.Location" />.X</para>
      </value>
      <remarks>
        <para>This delegates to the <see cref="P:yWorks.Graph.SimpleBend.Location" /> instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleBend.Y">
      <summary>
        <para>Gets the current y coordinate of this bend.</para>
      </summary>
      <value>
        <para>The value of <see cref="P:yWorks.Graph.SimpleBend.Location" />.Y</para>
      </value>
      <remarks>
        <para>This delegates to the <see cref="P:yWorks.Graph.SimpleBend.Location" /> instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.SimpleBend.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="P:yWorks.Graph.SimpleBend.LookupImplementation">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.ILookup" /> implementation used for calls to <see cref="M:yWorks.Graph.SimpleBend.Lookup(System.Type)" /> on this instance.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.DefaultBendCreator">
      <summary>
        <para>Simple default implementations of the <see cref="T:yWorks.Controls.Input.IBendCreator" /> interface used during the creation of bends in the UI.</para>
      </summary>
      <remarks>
        <para>An instance of this class can be found in the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of an edge, e.g.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.DefaultBendCreator.NoBends">
      <summary>
        <para>A static instance that does not create any bends.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.DefaultBendCreator.CreateBend(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.IEdge,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="graph" />
      <param name="edge" />
      <param name="location" />
    </member>
    <member name="T:yWorks.Graph.SimpleEdge">
      <summary>
        <para>A simple mutable implementation of the <see cref="T:yWorks.Graph.IEdge" /> interface that can be used stand-alone.</para>
      </summary>
      <remarks>
        <para>Note that this class is not the one used as the default implementation of a <see cref="T:yWorks.Graph.DefaultGraph" />'s <see cref="T:yWorks.Graph.IEdge" />s and casting them to <see cref="T:yWorks.Graph.SimpleEdge" /> will fail. Instances of this class can be used without an accompanying graph instance. All of the properties are mutable. An example of a possible use case would be the rendering of an edge into a graphics context: Simply create a <see cref="T:yWorks.Graph.SimpleEdge" />, associate a style with it and use the style's renderer instance to obtain a rendering for the edge.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.SimpleEdge.#ctor(yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Creates an edge with a <see cref="P:yWorks.Graph.DefaultGraph.DefaultEdgeLookup">default lookup</see>, and the given source and target ports.</para>
      </summary>
      <param name="sourcePort">
        <para>The source port for the edge.</para>
      </param>
      <param name="targetPort">
        <para>The target port for the edge.</para>
      </param>
      <remarks>
        <para>While technically the source and target port can be <c>null</c> here, this will cause all kinds of issues, e.g. with <see cref="T:yWorks.Graph.Styles.IEdgeStyle">styles</see> or <see cref="T:yWorks.Graph.LabelModels.ILabelModel">label models</see> that require the ports to be non-<c>null</c> to work properly.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleEdge.Style">
      <summary>
        <para>Gets or sets the style that is responsible for the visual representation of this edge in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>Note that the style instance associated with an edge instance may be shared between multiple edge instances and that the modification of this style will result in a change of the appearance of all edges that are associated with the same style instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleEdge.Bends">
      <summary>
        <para>Gets or sets the collection of <see cref="T:yWorks.Graph.IBend">bends</see> that describe the geometry of this edge.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.SimpleEdge.SourcePort">
      <summary>
        <para>Gets or sets the source port instance this edge is connected to.</para>
      </summary>
      <remarks>
        <para>Although the notion of source and target port is used for directed edges, it is still up to the client to decide whether the edge should be treated as such.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleEdge.TargetPort">
      <summary>
        <para>Gets or sets the target port instance this edge is connected to.</para>
      </summary>
      <remarks>
        <para>Although the notion of source and target port is used for directed edges, it is still up to the client to decide whether the edge should be treated as such.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleEdge.Ports">
      <summary>
        <para>Gets or sets the collection of <see cref="T:yWorks.Graph.IPort">ports</see> that are owned by this instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.SimpleEdge.Labels">
      <summary>
        <para>Gets or sets the collection of <see cref="T:yWorks.Graph.ILabel">labels</see> that are owned by this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.SimpleEdge.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="P:yWorks.Graph.SimpleEdge.LookupImplementation">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.ILookup" /> implementation used for calls to <see cref="M:yWorks.Graph.SimpleEdge.Lookup(System.Type)" /> on this instance.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.DefaultEdgePathCropper">
      <summary>
        <para>The default implementation of the <see cref="T:yWorks.Graph.Styles.IEdgePathCropper" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.DefaultEdgePathCropper.Instance">
      <summary>
        <para>A singleton instance.</para>
      </summary>
      <remarks>
        <para>Note that this is an immutable instance that cannot be cast to the <see cref="T:yWorks.Graph.Styles.DefaultEdgePathCropper" /> type.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultEdgePathCropper.CropEdgePathAtArrow(System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)">
      <summary>
        <para>Crops an edge's path at the source or target side with respect to the given arrow.</para>
      </summary>
      <remarks>
        <para>The <paramref name="path" /> is cropped by the length <see cref="M:yWorks.Graph.Styles.DefaultEdgePathCropper.CalculateTotalCropLength(yWorks.Graph.Styles.IArrow,System.Boolean)" /> returns for <paramref name="arrow" /> and <paramref name="atSource" />.</para>
      </remarks>
      <param name="atSource">
        <para>if set to <c>true</c> the source side is cropped.</para>
      </param>
      <param name="arrow">
        <para>The arrow to consider for the cropping.</para>
      </param>
      <param name="path">
        <para>The edge's path to crop.</para>
      </param>
      <returns>
        <para>The cropped path. This is can be either the same instance of the given path or a newly created instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultEdgePathCropper.CropEdgePath(yWorks.Graph.IEdge,System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)">
      <summary>
        <para>Crops the provided <paramref name="path" /> at one end of an edge.</para>
      </summary>
      <remarks>
        <para>If <see cref="P:yWorks.Graph.Styles.DefaultEdgePathCropper.CropAtPort" /> is <c>true</c> this implementation delegates to <see cref="M:yWorks.Graph.Styles.DefaultEdgePathCropper.CropEdgePathAtPortGeometry(yWorks.Graph.IEdge,System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)" />. Otherwise the edge path is cropped at the <see cref="M:yWorks.Graph.Styles.DefaultEdgePathCropper.GetNodeGeometry(yWorks.Graph.INode)">node geometry</see>. If this would result in an empty path, the cropping is delegated to <see cref="M:yWorks.Graph.Styles.DefaultEdgePathCropper.HandleEmptyPath(yWorks.Graph.IEdge,System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)" /> instead.</para>
      </remarks>
      <param name="edge">
        <para>The edge whose path is to be cropped.</para>
      </param>
      <param name="atSource">
        <para>Whether to crop the source or target side of the path.</para>
      </param>
      <param name="arrow">
        <para>The arrow that is used at the end of the edge.</para>
      </param>
      <param name="path">
        <para>The path to crop.</para>
      </param>
      <returns>
        <para>The cropped path. This is can be either the same instance of the given path or a newly created instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultEdgePathCropper.HandleEmptyPath(yWorks.Graph.IEdge,System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)">
      <summary>
        <para>Handles the edge path cropping if <see cref="M:yWorks.Graph.Styles.DefaultEdgePathCropper.CropEdgePath(yWorks.Graph.IEdge,System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)" /> would result in a <see cref="M:yWorks.Geometry.GeneralPath.Clear">cleared</see> path.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Graph.Styles.DefaultEdgePathCropper.CropEdgePath(yWorks.Graph.IEdge,System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)" /> if <see cref="P:yWorks.Graph.Styles.DefaultEdgePathCropper.CropAtPort" /> is <c>false</c> and cropping the edge path at the <see cref="M:yWorks.Graph.Styles.DefaultEdgePathCropper.GetNodeGeometry(yWorks.Graph.INode)">node geometry</see> would result in an empty path.</para>
        <para>The default implementation is to <see cref="M:yWorks.Geometry.GeneralPath.Clear" /> the edge path.</para>
      </remarks>
      <param name="edge">
        <para>The edge whose path is to be cropped.</para>
      </param>
      <param name="atSource">
        <para>Whether to crop the source or target side of the path.</para>
      </param>
      <param name="arrow">
        <para>The arrow that is used at the end of the edge.</para>
      </param>
      <param name="path">
        <para>The path to crop.</para>
      </param>
      <returns>
        <para>The cropped path. This is can be either the same instance of the given path or a newly created instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultEdgePathCropper.CalculateTotalCropLength(yWorks.Graph.Styles.IArrow,System.Boolean)">
      <summary>
        <para>Calculates the total length the edge path is cropped.</para>
      </summary>
      <param name="arrow">
        <para>The arrow at this edge end.</para>
      </param>
      <param name="atSource">
        <para>
          <c>true</c> if the crop length should be calculated at the edge source. <c>false</c> otherwise.</para>
      </param>
      <returns>
        <para>The total length the edge path is cropped.</para>
      </returns>
      <remarks>
        <para>This method can be overridden to change the length that is cropped from an edge. The default implementation returns the sum of <see cref="P:yWorks.Graph.Styles.DefaultEdgePathCropper.ExtraCropLength" />, <see cref="P:yWorks.Graph.Styles.IArrow.Length">arrow length</see> and <see cref="P:yWorks.Graph.Styles.IArrow.CropLength">arrow crop length</see></para>
      </remarks>
      <seealso cref="M:yWorks.Graph.Styles.DefaultEdgePathCropper.CropEdgePath(yWorks.Graph.IEdge,System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)" />
      <seealso cref="M:yWorks.Graph.Styles.DefaultEdgePathCropper.CropEdgePathAtArrow(System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultEdgePathCropper.GetIntersection(yWorks.Graph.INode,yWorks.Graph.Styles.IShapeGeometry,yWorks.Graph.IEdge,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Finds the intersection between a node and the edge.</para>
      </summary>
      <param name="node" />
      <param name="nodeShapeGeometry" />
      <param name="edge" />
      <param name="inner" />
      <param name="outer" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultEdgePathCropper.IsInside(yWorks.Geometry.PointD,yWorks.Graph.INode,yWorks.Graph.Styles.IShapeGeometry,yWorks.Graph.IEdge)">
      <summary>
        <para>Checks whether a given point is inside a node's shape geometry with respect to the edge that is being calculated.</para>
      </summary>
      <param name="location" />
      <param name="node" />
      <param name="nodeShapeGeometry" />
      <param name="edge" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultEdgePathCropper.GetNodeGeometry(yWorks.Graph.INode)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Graph.Styles.IShapeGeometry">geometry</see> that is used to crop the edge at the node outline.</para>
      </summary>
      <param name="node">
        <para>The node the edge should be cropped at.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.Styles.IShapeGeometry">geometry</see> of the node.</para>
      </returns>
      <remarks>
        <para>The default implementation queries the <see cref="M:yWorks.Graph.Styles.INodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">node style renderer</see> for an implementation of <see cref="T:yWorks.Graph.Styles.IShapeGeometry" />. This method can be overridden to return an arbitrary <see cref="T:yWorks.Graph.Styles.IShapeGeometry">geometry</see> for a node.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultEdgePathCropper.CropEdgePathAtPortGeometry(yWorks.Graph.IEdge,System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)">
      <summary>
        <para>Crops an edge's path at the source or target side at the <see cref="M:yWorks.Graph.Styles.DefaultEdgePathCropper.GetPortGeometry(yWorks.Graph.IPort)">port geometry</see> with respect to the given arrow.</para>
      </summary>
      <param name="edge">
        <para>The edge whose path is to be cropped.</para>
      </param>
      <param name="atSource">
        <para>Whether to crop the source or target side of the path.</para>
      </param>
      <param name="arrow">
        <para>The arrow that is used at the end of the edge.</para>
      </param>
      <param name="path">
        <para>The path to crop.</para>
      </param>
      <returns>
        <para>The cropped path. This is can be either the same instance of the given path or a newly created instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultEdgePathCropper.GetPortGeometry(yWorks.Graph.IPort)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Graph.Styles.IShapeGeometry">geometry</see> that is used to crop the edge at the port outline if <see cref="P:yWorks.Graph.Styles.DefaultEdgePathCropper.CropAtPort" /> is set to <c>true</c>.</para>
      </summary>
      <param name="port">
        <para>The port the edge should be cropped at.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.Styles.IShapeGeometry">geometry</see> of the port.</para>
      </returns>
      <remarks>
        <para>The default implementation returns <c>null</c>. This method can be overridden to return an arbitrary <see cref="T:yWorks.Graph.Styles.IShapeGeometry">geometry</see> for a port.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.Styles.DefaultEdgePathCropper.CropAtPort" />
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultEdgePathCropper.ExtraCropLength">
      <summary>
        <para>Gets or sets an extra length the edge is cropped.</para>
      </summary>
      <remarks>
        <para>The default value is 0.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultEdgePathCropper.CropAtPort">
      <summary>
        <para>Gets the value that determines if the edge path is cropped at the port or at the node bounds.</para>
      </summary>
      <remarks>
        <para>The default is <c>false</c>.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.DefaultGraph">
      <summary>
        <para>Central implementation of the <see cref="T:yWorks.Graph.IGraph" /> interface.</para>
      </summary>
      <remarks>
        <para>This implementation deals with the proper firing of events and handling of default values.<br /> This implementation has inherent support for undoability. If the <see cref="P:yWorks.Graph.DefaultGraph.UndoEngineEnabled" /> property is set to <c>true</c>, changes to the structure of the graph will automatically be recorded using the <see cref="T:yWorks.Graph.UndoEngine" /> instance that can be queried from this instance's <see cref="M:yWorks.Graph.DefaultGraph.Lookup(System.Type)" /> method. Clients that wish to enqueue custom undo events or that need to make non-structural changes to the graph can use the <see cref="T:yWorks.Graph.UndoEngine" /> to do so. The current instance of <see cref="T:yWorks.Graph.UndoEngine" /> can be queried using the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method of this instance. Also there are several protected methods <c>Create...UndoUnit</c> that will be used by this instance to create the actual undo units for structural changes in the graph's structure. If clients need to customize these units they can create a subclass of <see cref="T:yWorks.Graph.DefaultGraph" /> and override these methods. <br /> Finally this implementation supports grouped graphs.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.DefaultGraph.CreateUndoEngine" />
      <seealso cref="M:yWorks.Graph.DefaultGraph.Lookup(System.Type)" />
      <seealso cref="T:yWorks.Graph.DefaultGraph" />
      <seealso cref="T:yWorks.Graph.FoldingManager" />
    </member>
    <member name="P:yWorks.Graph.DefaultGraph.DefaultNodeLookup">
      <summary>
        <para>Gets an <see cref="T:yWorks.Graph.IContextLookup" /> that provides the default implementations returned by an <see cref="T:yWorks.Graph.INode" />'s lookup.</para>
      </summary>
      <remarks>
        <para>The provided default implementations can for example be used as fallback when the node lookup is wrapped.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.DefaultGraph.DefaultEdgeLookup">
      <summary>
        <para>Gets an <see cref="T:yWorks.Graph.IContextLookup" /> that provides the default implementations returned by an <see cref="T:yWorks.Graph.IEdge" />'s lookup.</para>
      </summary>
      <remarks>
        <para>The provided default implementations can for example be used as fallback when the edge lookup is wrapped.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.DefaultGraph.DefaultLabelLookup">
      <summary>
        <para>Gets an <see cref="T:yWorks.Graph.IContextLookup" /> that provides the default implementations returned by an <see cref="T:yWorks.Graph.ILabel" />'s lookup.</para>
      </summary>
      <remarks>
        <para>The provided default implementations can for example be used as fallback when the label lookup is wrapped.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.DefaultGraph.DefaultPortLookup">
      <summary>
        <para>Gets an <see cref="T:yWorks.Graph.IContextLookup" /> that provides the default implementations returned by an <see cref="T:yWorks.Graph.IPort" />'s lookup.</para>
      </summary>
      <remarks>
        <para>The provided default implementations can for example be used as fallback when the port lookup is wrapped.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.DefaultGraph.DefaultBendLookup">
      <summary>
        <para>Gets an <see cref="T:yWorks.Graph.IContextLookup" /> that provides the default implementations returned by an <see cref="T:yWorks.Graph.IBend" />'s lookup.</para>
      </summary>
      <remarks>
        <para>The provided default implementations can for example be used as fallback when the bend lookup is wrapped.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.#ctor">
      <summary>
        <para>Creates a new instance of a graph that provides an <see cref="T:yWorks.Graph.ILookupDecorator" /> for all of its entities.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.DefaultGraph.MapperRegistry">
      <summary>
        <para>Gets the mapper registry that is associated with this graph instance.</para>
      </summary>
      <value />
      <remarks>
        <para>The registry can be used to store data mappings for the items in this instance. This field is populated upon first access. Also this property provides write access.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IMapperRegistry" />
      <seealso cref="T:yWorks.Graph.IModelItem" />
      <seealso cref="P:yWorks.Graph.ITagOwner.Tag" />
    </member>
    <member name="P:yWorks.Graph.DefaultGraph.UndoEngineEnabled">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Graph.UndoEngine" /> used for this instance should be enabled.</para>
      </summary>
      <remarks>
        <para>The default is <c>false</c>. In order to enable undoability for this instance, set this property to <c>true</c> and <see cref="M:yWorks.Graph.DefaultGraph.Lookup(System.Type)" /> the <see cref="T:yWorks.Graph.UndoEngine" /> type. Disabling this property clears and removes the current <see cref="T:yWorks.Graph.UndoEngine" /> (and all enqueued IUndoUnits).</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoEngine">
      <summary>
        <para>Creates an <see cref="T:yWorks.Graph.UndoEngine" /> instance that automatically triggers <see cref="M:yWorks.Graph.DefaultGraph.InvalidateDisplays" /> upon each invocation of <see cref="M:yWorks.Graph.UndoEngine.Undo" /> and <see cref="M:yWorks.Graph.UndoEngine.Redo" /></para>
      </summary>
      <returns>
        <para>An <see cref="T:yWorks.Graph.UndoEngine" /> instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.AddLookup(yWorks.Graph.IContextLookupChainLink)">
      <summary>
        <para>Adds the chain element to the lookup for this instance.</para>
      </summary>
      <param name="lookup">
        <para>The lookup to decorate the current instance with.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.RemoveLookup(yWorks.Graph.IContextLookupChainLink)">
      <summary>
        <para>Removes a previously added lookup chain element from the lookup of <c>this</c>.</para>
      </summary>
      <param name="lookup">
        <para>The element to remove.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetLookupImplementation(yWorks.Graph.ILookup)">
      <summary>
        <para>Sets the lookup implementation that will be used for <see cref="M:yWorks.Graph.DefaultGraph.Lookup(System.Type)" /> calls.</para>
      </summary>
      <remarks>
        <para>A value of <c>null</c> will revert to the default behavior.</para>
      </remarks>
      <param name="lookup">
        <para>The lookup instance to delegate lookup calls to.</para>
      </param>
      <seealso cref="M:yWorks.Graph.DefaultGraph.AddLookup(yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="M:yWorks.Graph.DefaultGraph.GetLookup" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.GetLookup">
      <summary>
        <para>Returns the lookup implementation that is used for <see cref="M:yWorks.Graph.DefaultGraph.Lookup(System.Type)" /> calls.</para>
      </summary>
      <returns>
        <para>The replacing lookup instance or <c>null</c> if the internal lookup mechanism is used.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.DefaultGraph.SetLookupImplementation(yWorks.Graph.ILookup)" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateNode(yWorks.Geometry.RectD,yWorks.Graph.Styles.INodeStyle,System.Object)">
      <param name="layout" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnCreatingNode(yWorks.Graph.INode)">
      <summary>
        <para>Callback that is invoked before the node is added to this graph's structure.</para>
      </summary>
      <param name="node">
        <para>A node that is not yet contained in this graph.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateEdge(yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Graph.Styles.IEdgeStyle,System.Object)">
      <summary>
        <para>Convenience method that creates and returns an edge that connects to the given node instances using the given style instance.</para>
      </summary>
      <param name="source">
        <para>The source node the created edge will connect to. This implementation queries the <see cref="M:yWorks.Graph.DefaultGraph.GetNewSourcePort(yWorks.Graph.IPortOwner)" /> method to determine which port to use.</para>
      </param>
      <param name="target">
        <para>The target node the created edge will connect to. This implementation queries the <see cref="M:yWorks.Graph.DefaultGraph.GetNewSourcePort(yWorks.Graph.IPortOwner)" /> method to determine which port to use.</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the newly created instance. This is done by reference.</para>
      </param>
      <param name="tag">
        <para>the initial <see cref="P:yWorks.Graph.ITagOwner.Tag" /> to assign.</para>
      </param>
      <returns>
        <para>the newly created edge instance</para>
      </returns>
      <remarks>
        <para>The nodes must be part of this graph at the time of the invocation, and the implementation will choose the <see cref="T:yWorks.Graph.IPort" /> instances to which the edge will be connected. The edge will be a part of this graph after the method returns. This will trigger the corresponding events.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.DefaultGraph.EdgeCreated" />
      <seealso cref="M:yWorks.Graph.DefaultGraph.GetNewSourcePort(yWorks.Graph.IPortOwner)" />
      <seealso cref="M:yWorks.Graph.DefaultGraph.GetNewTargetPort(yWorks.Graph.IPortOwner)" />
      <seealso cref="M:yWorks.Graph.DefaultGraph.CreateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort,yWorks.Graph.Styles.IEdgeStyle,System.Object)" />
      <exception cref="T:System.ArgumentException">
        <para>If <paramref name="source" /> or <paramref name="target" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.Remove(yWorks.Graph.IModelItem)">
      <param name="item" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.GetNewTargetPort(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Determines a <see cref="T:yWorks.Graph.IPort" /> instance to use for the creation of a new edge that ends at the given <see cref="T:yWorks.Graph.IPortOwner" />.</para>
      </summary>
      <remarks>
        <para>This implementation will <see cref="M:yWorks.Graph.DefaultGraph.AddPort(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)">add a new center anchored port</see> to the node.</para>
      </remarks>
      <param name="targetOwner">
        <para>The target node to find a port for.</para>
      </param>
      <returns>
        <para>The port to use for a newly created edge.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.DefaultGraph.CreateEdge(yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Graph.Styles.IEdgeStyle,System.Object)" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.GetNewSourcePort(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Determines a <see cref="T:yWorks.Graph.IPort" /> instance to use for the creation of a new edge that starts at the given <see cref="T:yWorks.Graph.IPortOwner" />.</para>
      </summary>
      <remarks>
        <para>This implementation will <see cref="M:yWorks.Graph.DefaultGraph.AddPort(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)">add a new center anchored port</see> to the node.</para>
      </remarks>
      <param name="source">
        <para>The source node to find a port for.</para>
      </param>
      <returns>
        <para>The port to use for a newly created edge.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.DefaultGraph.CreateEdge(yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Graph.Styles.IEdgeStyle,System.Object)" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetEdgePorts(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Sets the ports of the given edge to the new values.</para>
      </summary>
      <param name="edge">
        <para>The edge to change the ports.</para>
      </param>
      <param name="sourcePort">
        <para>The new source port instance.</para>
      </param>
      <param name="targetPort">
        <para>The new target port instance.</para>
      </param>
      <remarks>
        <para>This will trigger an <see cref="E:yWorks.Graph.DefaultGraph.EdgePortsChanged" /> event if source or target ports differ from the current ones. Both ports and the edge must belong to the current graph instance. If <see cref="P:yWorks.Graph.IPortDefaults.AutoCleanup" /> is enabled, this method will remove unoccupied ports after they have been changed.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)">
      <param name="port" />
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.EdgesAt(yWorks.Graph.IPortOwner,yWorks.Graph.AdjacencyTypes)">
      <param name="owner" />
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort,yWorks.Graph.Styles.IEdgeStyle,System.Object)">
      <param name="sourcePort" />
      <param name="targetPort" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnCreatingEdge(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Callback that is invoked before the edge is added to this graph's structure.</para>
      </summary>
      <param name="edge">
        <para>An edge that is not yet contained in this graph.</para>
      </param>
      <param name="sourcePort">
        <para>The source port this edge will connect to.</para>
      </param>
      <param name="targetPort">
        <para>The target port this edge will connect to.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.Contains(yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether this graph contains the specified item.</para>
      </summary>
      <param name="item">
        <para>The item.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this graph contains the specified item; otherwise, <c>false</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetStyle(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Assigns the given style instance by reference to the node.</para>
      </summary>
      <remarks>
        <para>Style instances can be shared.</para>
      </remarks>
      <param name="node">
        <para>The node that will be assigned the new style</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the node.</para>
      </param>
      <seealso cref="P:yWorks.Graph.INode.Style" />
      <seealso cref="M:yWorks.Graph.DefaultGraph.OnChangingNodeStyle(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />
      <seealso cref="E:yWorks.Graph.DefaultGraph.NodeStyleChanged" />
      <exception cref="T:System.ArgumentException">
        <para>If <paramref name="node" /> is not in this graph.</para>
      </exception>
      <exception cref="T:System.ArgumentNullException">
        <para>If <paramref name="style" /> is <c>null</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Assigns the given style instance by reference to the label.</para>
      </summary>
      <remarks>
        <para>Style instances can be shared. This implementation will <see cref="M:yWorks.Graph.GraphExtensions.AdjustLabelPreferredSize(yWorks.Graph.IGraph,yWorks.Graph.ILabel)">adjust the preferred size</see> for the label if <see cref="P:yWorks.Graph.ILabelDefaults.AutoAdjustPreferredSize" /> is enabled.</para>
      </remarks>
      <param name="label">
        <para>The label that will be assigned the new style</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the label.</para>
      </param>
      <seealso cref="P:yWorks.Graph.ILabel.Style" />
      <seealso cref="M:yWorks.Graph.DefaultGraph.OnChangingLabelStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />
      <seealso cref="E:yWorks.Graph.DefaultGraph.LabelStyleChanged" />
      <exception cref="T:System.ArgumentException">
        <para>If <paramref name="label" /> is not in this graph.</para>
      </exception>
      <exception cref="T:System.ArgumentNullException">
        <para>If <paramref name="style" /> is <c>null</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnChangingLabelLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Callback that is invoked before the <see cref="P:yWorks.Graph.ILabel.LayoutParameter" /> of a label is being changed.</para>
      </summary>
      <param name="label">
        <para>A label whose <see cref="P:yWorks.Graph.ILabel.LayoutParameter" /> is to be changed.</para>
      </param>
      <param name="newLayoutParameter">
        <para>The new label model parameter</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnChangingLabelStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Callback that is invoked before a label style is being changed.</para>
      </summary>
      <param name="label">
        <para>A label whose the style is going to be changed.</para>
      </param>
      <param name="newStyle">
        <para>The new label style.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnChangingLabelPreferredSize(yWorks.Graph.ILabel,yWorks.Geometry.SizeD)">
      <summary>
        <para>Callback that is invoked before the preferred size of a label is being changed.</para>
      </summary>
      <param name="label">
        <para>A label whose preferred size is going to be changed.</para>
      </param>
      <param name="newSize">
        <para>The new preferred size</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnChangingLabelText(yWorks.Graph.ILabel,System.String)">
      <summary>
        <para>Callback that is invoked before the text of a label is being changed.</para>
      </summary>
      <param name="label">
        <para>A label whose text is going to be changed.</para>
      </param>
      <param name="newText">
        <para>The new label text</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnChangingNodeStyle(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Callback that is invoked before a node style is being changed.</para>
      </summary>
      <param name="node">
        <para>A node whose the style is going to be changed.</para>
      </param>
      <param name="newStyle">
        <para>The new node style.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnNodeStyleChanged(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Callback that is invoked after a node style has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.NodeStyleChanged" /> event.</para>
      </remarks>
      <param name="node">
        <para>The node whose style has changed.</para>
      </param>
      <param name="oldStyle">
        <para>The node style before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnNodeLayoutChanged(yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <summary>
        <para>Callback that is invoked after a node layout has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.NodeLayoutChanged" /> event.</para>
      </remarks>
      <param name="node">
        <para>The node whose layout has changed.</para>
      </param>
      <param name="oldLayout">
        <para>The node layout before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnNodeTagChanged(yWorks.Graph.INode,System.Object)">
      <summary>
        <para>Callback that is invoked after a node tag has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.NodeTagChanged" /> event.</para>
      </remarks>
      <param name="node">
        <para>The node whose tag has changed.</para>
      </param>
      <param name="oldTag">
        <para>The node tag before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnBendLocationChanged(yWorks.Graph.IBend,yWorks.Geometry.PointD)">
      <summary>
        <para>Callback that is invoked after a bend location has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.BendLocationChanged" /> event.</para>
      </remarks>
      <param name="bend">
        <para>The bend whose location has changed.</para>
      </param>
      <param name="oldLocation">
        <para>The bend location before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnBendTagChanged(yWorks.Graph.IBend,System.Object)">
      <summary>
        <para>Callback that is invoked after a bend tag has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.BendTagChanged" /> event.</para>
      </remarks>
      <param name="bend">
        <para>The bend whose tag has changed.</para>
      </param>
      <param name="oldTag">
        <para>The bend tag before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnLabelStyleChanged(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Callback that is invoked after a label style has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.LabelStyleChanged" /> event.</para>
      </remarks>
      <param name="label">
        <para>The label whose style has changed.</para>
      </param>
      <param name="oldStyle">
        <para>The label style before the change.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnLabelPreferredSizeChanged(yWorks.Graph.ILabel,yWorks.Geometry.SizeD)">
      <summary>
        <para>Callback that is invoked after the preferred size of a label has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.LabelPreferredSizeChanged" /> event.</para>
      </remarks>
      <param name="label">
        <para>The label whose preferred size has changed.</para>
      </param>
      <param name="oldSize">
        <para>The preferred size of the label before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnLabelTextChanged(yWorks.Graph.ILabel,System.String)">
      <summary>
        <para>Callback that is invoked after a label text has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.LabelTextChanged" /> event.</para>
      </remarks>
      <param name="label">
        <para>The label whose text has changed.</para>
      </param>
      <param name="oldText">
        <para>The label text before the change.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnLabelLayoutParameterChanged(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Callback that is invoked after a label model parameter has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.LabelLayoutParameterChanged" /> event.</para>
      </remarks>
      <param name="label">
        <para>The label whose model parameter has changed.</para>
      </param>
      <param name="oldLayoutParamater">
        <para>The label model parameter before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnLabelTagChanged(yWorks.Graph.ILabel,System.Object)">
      <summary>
        <para>Callback that is invoked after a label tag has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.LabelTagChanged" /> event.</para>
      </remarks>
      <param name="label">
        <para>The label whose tag has changed.</para>
      </param>
      <param name="oldTag">
        <para>The label tag before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetStyle(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <param name="edge" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetStyle(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <param name="port" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnChangingEdgePorts(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Callback that is invoked before the ports of an edge are being changed.</para>
      </summary>
      <param name="edge">
        <para>An edge whose the ports are to be changed.</para>
      </param>
      <param name="newSource">
        <para>The new source port</para>
      </param>
      <param name="newTarget">
        <para>The new target port</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnChangingEdgeStyle(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Callback that is invoked before an edge style is being changed.</para>
      </summary>
      <param name="edge">
        <para>An edge whose the style is going to be changed.</para>
      </param>
      <param name="newStyle">
        <para>The new edge style.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnEdgeStyleChanged(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Callback that is invoked after the style of an edge has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.EdgeStyleChanged" /> event.</para>
      </remarks>
      <param name="edge">
        <para>The edge whose style that has changed.</para>
      </param>
      <param name="oldStyle">
        <para>The edge style before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnEdgePortsChanged(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Callback that is invoked after the ports of an edge has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.EdgePortsChanged" /> event.</para>
      </remarks>
      <param name="edge">
        <para>The edge whose ports have changed.</para>
      </param>
      <param name="oldSource">
        <para>The source port that the edge had been connected to before the change.</para>
      </param>
      <param name="oldTarget">
        <para>The target port that the edge had been connected to before the change.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnEdgeTagChanged(yWorks.Graph.IEdge,System.Object)">
      <summary>
        <para>Callback that is invoked after the tag of an edge has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.EdgeTagChanged" /> event.</para>
      </remarks>
      <param name="edge">
        <para>The edge whose tag has changed.</para>
      </param>
      <param name="oldTag">
        <para>The edge tag before the change.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnChangingPortLocationModelParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <summary>
        <para>Callback that is invoked before the <see cref="P:yWorks.Graph.IPort.LocationParameter" /> of a port is being changed.</para>
      </summary>
      <param name="port">
        <para>A port whose <see cref="P:yWorks.Graph.IPort.LocationParameter" /> is to be changed.</para>
      </param>
      <param name="newLocationParameter">
        <para>The new location model parameter</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnChangingPortStyle(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Callback that is invoked before a port style is being changed.</para>
      </summary>
      <param name="port">
        <para>A port whose the style is going to be changed.</para>
      </param>
      <param name="newStyle">
        <para>The new port style.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnPortLocationParameterChanged(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <summary>
        <para>Callback that is invoked after a port location model parameter has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.PortLocationParameterChanged" /> event.</para>
      </remarks>
      <param name="port">
        <para>The port whose location model parameter has changed.</para>
      </param>
      <param name="oldLocationParameter">
        <para>The port location model parameter before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnPortStyleChanged(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Callback that is invoked after a port style has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.PortStyleChanged" /> event.</para>
      </remarks>
      <param name="port">
        <para>The port whose style has changed.</para>
      </param>
      <param name="oldStyle">
        <para>The port style before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnPortTagChanged(yWorks.Graph.IPort,System.Object)">
      <summary>
        <para>Callback that is invoked after a port tag has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.DefaultGraph.PortTagChanged" /> event.</para>
      </remarks>
      <param name="port">
        <para>The port whose tag has changed.</para>
      </param>
      <param name="oldTag">
        <para>The port tag before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.AddBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD,System.Int32)">
      <param name="edge" />
      <param name="location" />
      <param name="index" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnAddingBend(yWorks.Graph.IEdge,yWorks.Graph.IBend,System.Int32)">
      <summary>
        <para>Callback that is invoked before a bend is added to this graph's structure.</para>
      </summary>
      <param name="edge">
        <para>The edge the bend will be added to.</para>
      </param>
      <param name="bend">
        <para>The bend that will be added to the edge.</para>
      </param>
      <param name="index">
        <para>The index where the bend will be added to the edge.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnBendAdded(yWorks.Graph.IBend)">
      <summary>
        <para>Callback that after a bend has been added to this graph's structure.</para>
      </summary>
      <remarks>
        <para>When overriding this method it is mandatory to call the base implementation.</para>
      </remarks>
      <param name="bend">
        <para>The bend that has been added to the edge.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetBendLocation(yWorks.Graph.IBend,yWorks.Geometry.PointD)">
      <summary>
        <para>Modifies the location of the given bend.</para>
      </summary>
      <remarks>
        <para>This implementation will also trigger an <see cref="M:yWorks.Graph.DefaultGraph.InvalidateDisplays" /> call.</para>
      </remarks>
      <param name="bend">
        <para>the bend whose location is to be modified</para>
      </param>
      <param name="location">
        <para>the new coordinates of the bend</para>
      </param>
      <seealso cref="M:yWorks.Graph.DefaultGraph.AddBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD,System.Int32)" />
      <exception cref="T:System.ArgumentException">
        <para>If <paramref name="bend" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnRemovingBend(yWorks.Graph.IBend)">
      <summary>
        <para>Callback method that is invoked just before a bend is removed.</para>
      </summary>
      <param name="bend">
        <para>The bend that will be removed.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnBendRemoved(yWorks.Graph.IEdge,yWorks.Graph.IBend,System.Int32)">
      <summary>
        <para>Callback method that is invoked just after a bend has been removed from its edge.</para>
      </summary>
      <remarks>
        <para>When overriding this method it is mandatory to call the base implementation.</para>
      </remarks>
      <param name="owner">
        <para>The old edge.</para>
      </param>
      <param name="bend">
        <para>The bend.</para>
      </param>
      <param name="index">
        <para>The former index of the bend in the <see cref="P:yWorks.Graph.IEdge.Bends" /> list.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.AddPort(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)">
      <summary>
        <para>Add a port to the given port owner using the coordinates as the new initial position of the port anchor.</para>
      </summary>
      <param name="owner">
        <para>the owner to add the port instance to.</para>
      </param>
      <param name="locationParameter">
        <para>the parameter to use for the port to determine its location.</para>
      </param>
      <param name="style">
        <para>the style to assign initially to the port, e.g. <see cref="F:yWorks.Graph.Styles.VoidPortStyle.Instance" />.</para>
      </param>
      <param name="tag">
        <para>The tag to associate with the port, may be <c>null</c>.</para>
      </param>
      <returns>
        <para>the newly created port</para>
      </returns>
      <seealso cref="E:yWorks.Graph.DefaultGraph.PortAdded" />
      <exception cref="T:System.NotSupportedException">
        <para>If this instance cannot add a port to <paramref name="owner" />.</para>
      </exception>
      <exception cref="T:System.ArgumentException">
        <para>If <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetPortLocationParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="port" />
      <param name="locationParameter" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnAddingPort(yWorks.Graph.IPortOwner,yWorks.Graph.IPort)">
      <summary>
        <para>Called when a port is going to be added to a node.</para>
      </summary>
      <param name="owner">
        <para>The node.</para>
      </param>
      <param name="port">
        <para>The port to be added.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnPortAdded(yWorks.Graph.IPort)">
      <summary>
        <para>Called when a port has been added to a node.</para>
      </summary>
      <remarks>
        <para>When overriding this method it is mandatory to call the base implementation.</para>
      </remarks>
      <param name="port">
        <para>The port that has just been added to its owner.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnPortRemoved(yWorks.Graph.IPortOwner,yWorks.Graph.IPort)">
      <summary>
        <para>Callback method that is called just after a port has been removed from its owner.</para>
      </summary>
      <remarks>
        <para>When overriding this method it is mandatory to call the base implementation.</para>
      </remarks>
      <param name="port">
        <para>The port that has been removed.</para>
      </param>
      <param name="oldOwner">
        <para>The previous owner of the port.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnRemovingPort(yWorks.Graph.IPort)">
      <summary>
        <para>Callback method that is called just before a port will be removed.</para>
      </summary>
      <param name="port">
        <para>The port that is about to be removed.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.AddLabel(yWorks.Graph.ILabelOwner,System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,System.Nullable{yWorks.Geometry.SizeD},System.Object)">
      <param name="owner" />
      <param name="text" />
      <param name="layoutParameter" />
      <param name="style" />
      <param name="preferredSize" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetLabelText(yWorks.Graph.ILabel,System.String)">
      <summary>
        <para>Sets the label text of the given label.</para>
      </summary>
      <remarks>
        <para>This implementation will <see cref="M:yWorks.Graph.GraphExtensions.AdjustLabelPreferredSize(yWorks.Graph.IGraph,yWorks.Graph.ILabel)">adjust the preferred size</see> for the label if <see cref="P:yWorks.Graph.ILabelDefaults.AutoAdjustPreferredSize" /> is enabled.</para>
      </remarks>
      <param name="label">
        <para>the label to modify</para>
      </param>
      <param name="text">
        <para>the new text of the label</para>
      </param>
      <seealso cref="P:yWorks.Graph.ILabel.Text" />
      <exception cref="T:System.ArgumentException">
        <para>If <paramref name="label" /> is not in this graph.</para>
      </exception>
      <exception cref="T:System.ArgumentNullException">
        <para>If <paramref name="text" /> is <c>null</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnAddingNodeLabel(yWorks.Graph.INode,yWorks.Graph.ILabel)">
      <summary>
        <para>Callback method that will be called just before a node label is added to a node.</para>
      </summary>
      <param name="node" />
      <param name="label" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnAddingEdgeLabel(yWorks.Graph.IEdge,yWorks.Graph.ILabel)">
      <summary>
        <para>Callback method that will be called just before an edge label is added to an edge.</para>
      </summary>
      <param name="edge" />
      <param name="label" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetLabelPreferredSize(yWorks.Graph.ILabel,yWorks.Geometry.SizeD)">
      <param name="label" />
      <param name="size" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetLabelLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnNodeLabelAdded(yWorks.Graph.ILabel)">
      <summary>
        <para>Called after a label has been added to a node.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Graph.DefaultGraph.LabelAdded" /> event.</para>
        <para>When overriding this method it is mandatory to call the base implementation.</para>
      </remarks>
      <param name="label">
        <para>The label that has just been added.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnEdgeLabelAdded(yWorks.Graph.ILabel)">
      <summary>
        <para>Called after a label has been added to an edge.</para>
      </summary>
      <remarks>
        <para>This method triggers the <see cref="E:yWorks.Graph.DefaultGraph.LabelAdded" /> event.</para>
        <para>When overriding this method it is mandatory to call the base implementation.</para>
      </remarks>
      <param name="label">
        <para>The label that has just been added.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnRemovingNodeLabel(yWorks.Graph.ILabel)">
      <summary>
        <para>Callback method that will be called just before a node label is removed from its node.</para>
      </summary>
      <param name="label" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnNodeLabelRemoved(yWorks.Graph.ILabelOwner,yWorks.Graph.ILabel)">
      <summary>
        <para>Called after a label has been removed from its node.</para>
      </summary>
      <remarks>
        <para>When overriding this method it is mandatory to call the base implementation.</para>
      </remarks>
      <param name="label">
        <para>The label that has just been removed.</para>
      </param>
      <param name="owner">
        <para>The old owner of the label.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnRemovingEdgeLabel(yWorks.Graph.ILabel)">
      <summary>
        <para>Callback method that will be called just before an edge label is removed from its edge.</para>
      </summary>
      <param name="label" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnEdgeLabelRemoved(yWorks.Graph.ILabelOwner,yWorks.Graph.ILabel)">
      <summary>
        <para>Called after a label has been removed from its edge.</para>
      </summary>
      <remarks>
        <para>When overriding this method it is mandatory to call the base implementation.</para>
      </remarks>
      <param name="label">
        <para>The label that has just been removed.</para>
      </param>
      <param name="owner">
        <para>The previous owner of the label.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetNodeLayout(yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <summary>
        <para>Sets the layout of the given node to the new values.</para>
      </summary>
      <remarks>
        <para>This will trigger a call to <see cref="M:yWorks.Graph.DefaultGraph.InvalidateDisplays" />.</para>
      </remarks>
      <param name="node">
        <para>a live node that belongs to this graph</para>
      </param>
      <param name="layout">
        <para>the new absolute layout in world coordinates of the node</para>
      </param>
      <seealso cref="P:yWorks.Graph.INode.Layout" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.InvalidateDisplays">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Graph.DefaultGraph.DisplaysInvalidated" /> event.</para>
      </summary>
      <remarks>
        <para>Clients can call this method to force an invalidation of the displays that show this graph instance. This implementation delegates to <see cref="M:yWorks.Graph.DefaultGraph.OnInvalidateDisplays(System.EventArgs)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnInvalidateDisplays(System.EventArgs)">
      <summary>
        <para>Triggers the <see cref="E:yWorks.Graph.DefaultGraph.DisplaysInvalidated" /> event.</para>
      </summary>
      <param name="args">
        <para>The event arguments.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForNodeCreation(yWorks.Graph.INode,yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Creates the node creation <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given node.</para>
      </summary>
      <param name="node">
        <para>The node that has been created.</para>
      </param>
      <param name="parent" />
      <param name="isGroupNode" />
      <returns>
        <para>The unit that can be used to undo and redo the creation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForEdgeCreation(yWorks.Graph.IEdge)">
      <summary>
        <para>Creates the edge creation <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given edge.</para>
      </summary>
      <param name="edge">
        <para>The edge that has been created.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the creation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForPortAddition(yWorks.Graph.IPort)">
      <summary>
        <para>Creates the port addition <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given port.</para>
      </summary>
      <param name="port">
        <para>The port that has been added.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the creation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForLabelAddition(yWorks.Graph.ILabel)">
      <summary>
        <para>Creates the label addition <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given label.</para>
      </summary>
      <param name="label">
        <para>The label that has been added.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the creation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForBendAddition(yWorks.Graph.IBend,System.Int32)">
      <summary>
        <para>Creates the bend addition <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given bend.</para>
      </summary>
      <param name="bend">
        <para>The bend that has been added.</para>
      </param>
      <param name="index">
        <para>The index at which the bend has been added.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the creation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForNodeRemoval(yWorks.Graph.INode)">
      <summary>
        <para>Creates the node removal <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given node.</para>
      </summary>
      <param name="node">
        <para>The node that will be removed.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the removal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForEdgeRemoval(yWorks.Graph.IEdge)">
      <summary>
        <para>Creates the edge removal <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given edge.</para>
      </summary>
      <param name="edge">
        <para>The edge that will be removed.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the removal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForBendRemoval(yWorks.Graph.IBend)">
      <summary>
        <para>Creates the bend removal <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given bend.</para>
      </summary>
      <param name="bend">
        <para>The bend that will be removed.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the removal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForPortRemoval(yWorks.Graph.IPort)">
      <summary>
        <para>Creates the port removal <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given port.</para>
      </summary>
      <param name="port">
        <para>The port that will be removed.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the removal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForLabelRemoval(yWorks.Graph.ILabel)">
      <summary>
        <para>Creates the label removal <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given label.</para>
      </summary>
      <param name="label">
        <para>The label that will be removed.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the removal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForEdgeReconnection(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Creates the edge reconnection <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given edge.</para>
      </summary>
      <param name="edge">
        <para>The edge that has been reconnected to other ports.</para>
      </param>
      <param name="oldSource">
        <para>The old source port the edge connected to before the change.</para>
      </param>
      <param name="oldTarget">
        <para>The old target port the edge connected to before the change.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the port change operation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForIsGroupNodeChange(yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Creates the <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for changing whether the given node is a group node.</para>
      </summary>
      <param name="node">
        <para>The node whose group node status has been changed.</para>
      </param>
      <param name="isGroupNode">
        <para>The new group node status.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the group node status change.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateUndoUnitForParentChange(yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Creates the parent change <see cref="T:yWorks.Graph.IUndoUnit">undo unit</see> for the given node.</para>
      </summary>
      <param name="node">
        <para>The node whose parent has been changed.</para>
      </param>
      <param name="oldParent" />
      <param name="newParent">
        <para>The node which is the new parent.</para>
      </param>
      <returns>
        <para>The unit that can be used to undo and redo the parent change.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnRemovingNode(yWorks.Graph.INode)">
      <summary>
        <para>Callback that will be invoked before the node will be removed.</para>
      </summary>
      <param name="node">
        <para>That node that is going to be removed.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnRemovingEdge(yWorks.Graph.IEdge)">
      <summary>
        <para>Callback that will be invoked before the node will be removed.</para>
      </summary>
      <param name="edge">
        <para>That edge that is going to be removed.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnNodeRemoved(yWorks.Graph.INode,yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Callback that triggers the <see cref="E:yWorks.Graph.DefaultGraph.NodeRemoved" /> event.</para>
      </summary>
      <param name="node">
        <para>The node that got removed</para>
      </param>
      <param name="oldParent" />
      <param name="oldIsGroupNode" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnEdgeRemoved(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Callback that triggers the <see cref="E:yWorks.Graph.DefaultGraph.EdgeRemoved" /> event.</para>
      </summary>
      <param name="edge">
        <para>The edge that got removed</para>
      </param>
      <param name="oldSource">
        <para>The source port that the edge had been connected to.</para>
      </param>
      <param name="oldTarget">
        <para>The target port that the edge had been connected to.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnNodeCreated(yWorks.Graph.INode)">
      <summary>
        <para>Callback that triggers the <see cref="E:yWorks.Graph.DefaultGraph.NodeCreated" /> event.</para>
      </summary>
      <param name="node">
        <para>The node that has been created.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnEdgeCreated(yWorks.Graph.IEdge)">
      <summary>
        <para>Callback that triggers the <see cref="E:yWorks.Graph.DefaultGraph.EdgeCreated" /> event.</para>
      </summary>
      <param name="edge">
        <para>The edge that has been created.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.Lookup(System.Type)">
      <summary>
        <para>Returns an instance that provides another aspect of this instance of the given type or <c>null</c>.</para>
      </summary>
      <param name="type">
        <para>the type for which an instance shall be returned</para>
      </param>
      <returns>
        <para>An instance that is assignable to type or <c>null</c></para>
      </returns>
      <remarks>
        <para>Typically, this method will be called in order to obtain a different view or aspect of the current instance. This is quite similar to casting or using a super type or interface of this instance, but is not limited to inheritance or compile time constraints. This method is not required to return non-<c>null</c> implementations for the types, nor does it have to return the same instance any time. Also it depends on the type and context whether the instance returned stays up to date or needs to be re-obtained for subsequent use. This implementation uses the <see cref="M:yWorks.Graph.DefaultGraph.SetLookupImplementation(yWorks.Graph.ILookup)">set lookup implementation</see> if it has been set or an internal <see cref="T:yWorks.Graph.LookupChain">lookup chain</see>, that can be customized using the <see cref="M:yWorks.Graph.DefaultGraph.AddLookup(yWorks.Graph.IContextLookupChainLink)" /> and <see cref="M:yWorks.Graph.DefaultGraph.RemoveLookup(yWorks.Graph.IContextLookupChainLink)" /> methods.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.InnerLookup(System.Type)">
      <summary>
        <para>The last element in the lookup chain is implemented by this method.</para>
      </summary>
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateGroupNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">
      <param name="parent" />
      <param name="layout" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetParent(yWorks.Graph.INode,yWorks.Graph.INode)">
      <param name="node" />
      <param name="parent" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.CreateNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">
      <param name="parent" />
      <param name="layout" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.GetChildren(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.GetParent(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.IsGroupNode(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.SetIsGroupNode(yWorks.Graph.INode,System.Boolean)">
      <param name="node" />
      <param name="isGroupNode" />
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.ToString" />
    <member name="M:yWorks.Graph.DefaultGraph.OnChangingGraphTag(System.Object)">
      <summary>
        <para>Callback that is invoked before the graph's tag is being changed.</para>
      </summary>
      <param name="newTag">
        <para>The new port tag</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultGraph.OnGraphTagChanged(System.Object)">
      <summary>
        <para>Callback that triggers the <see cref="E:yWorks.Graph.DefaultGraph.GraphTagChanged" /> event.</para>
      </summary>
      <param name="oldTag">
        <para>The graph tag before the change.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.SimpleLabel">
      <summary>
        <para>A simple mutable implementation of the <see cref="T:yWorks.Graph.ILabel" /> interface that can be used stand-alone.</para>
      </summary>
      <remarks>
        <para>Note that this class is not the one used as the default implementation of a <see cref="T:yWorks.Graph.DefaultGraph" />'s <see cref="T:yWorks.Graph.ILabel" />s and casting them to <see cref="T:yWorks.Graph.SimpleLabel" /> will fail. Instances of this class can be used without an accompanying graph instance. All of the properties are mutable. An example of a possible use case would be the rendering of a label into a graphics context: Simply create a <see cref="T:yWorks.Graph.SimpleLabel" />, associate a style with it and use the style's renderer instance to obtain a rendering for the label.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.SimpleLabel.#ctor(yWorks.Graph.ILabelOwner,System.String,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Creates an instance of the <see cref="T:yWorks.Graph.SimpleLabel" /> class with default <see cref="P:yWorks.Graph.DefaultGraph.DefaultLabelLookup">lookup</see>, an instance of <see cref="T:yWorks.Graph.Styles.VoidLabelStyle" /> and the given <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter">parameter</see>, text, and owner.</para>
      </summary>
      <param name="layoutParameter">
        <para>The parameter that describes the label's layout.</para>
      </param>
      <param name="text">
        <para>The label's text.</para>
      </param>
      <param name="owner">
        <para>The label's owner.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.SimpleLabel.LayoutParameter">
      <summary>
        <para>Gets or sets the label model's parameter that determines the positioning of this label.</para>
      </summary>
      <remarks>
        <para>Note that the label model parameter instance associated with a label instance may be shared between multiple label instances and that the modification of this instance or its <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> will result in a change of the positioning of all labels that are associated with the same parameter or model instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleLabel.Text">
      <summary>
        <para>Gets or sets the text string associated with this label.</para>
      </summary>
      <remarks>
        <para>It is up to the visualization engine to interpret this property for the visualization of the label. Normally, it will render the text into the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see> of this instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleLabel.Style">
      <summary>
        <para>Gets or sets the style that is responsible for the visual representation of this node in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>Note that the style instance associated with a label instance may be shared between multiple label instances and that the modification of this style will result in a change of the appearance of all labels that are associated with the same style instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleLabel.Owner">
      <summary>
        <para>Gets or sets the owner of this label.</para>
      </summary>
      <remarks>
        <para>Typically this will yield an instance of <see cref="T:yWorks.Graph.INode" /> or <see cref="T:yWorks.Graph.IEdge" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleLabel.PreferredSize">
      <summary>
        <para>Gets or sets the preferred size of the label with respect to its current contents and the implementation of the visualization.</para>
      </summary>
      <remarks>
        <para>Often times the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout's</see> size will be the same as the preferred size, but it's up to the implementation of the <see cref="T:yWorks.Graph.LabelModels.ILabelModel" /> to interpret it differently.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.SimpleLabel.AdoptPreferredSizeFromStyle">
      <summary>
        <para>Gets the <see cref="M:yWorks.Graph.Styles.ILabelStyleRenderer.GetPreferredSize(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" /> from the labels style and sets the <see cref="P:yWorks.Graph.SimpleLabel.PreferredSize" /> to that value.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.SimpleLabel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="P:yWorks.Graph.SimpleLabel.LookupImplementation">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.ILookup" /> implementation used for calls to <see cref="M:yWorks.Graph.SimpleLabel.Lookup(System.Type)" /> on this instance.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.SimpleNode">
      <summary>
        <para>A simple mutable implementation of the <see cref="T:yWorks.Graph.INode" /> interface that can be used stand-alone.</para>
      </summary>
      <remarks>
        <para>Note that this class is not the one used as the default implementation of a <see cref="T:yWorks.Graph.DefaultGraph" />'s <see cref="T:yWorks.Graph.INode" />s and casting them to <see cref="T:yWorks.Graph.SimpleNode" /> will fail.</para>
        <para>Instances of this class can be used without an accompanying graph instance. All of the properties are mutable. An example of a possible use case would be the rendering of a node into a graphics context: Simply create a <see cref="T:yWorks.Graph.SimpleNode" />, associate a style with it and use the style's renderer instance to obtain a rendering for the node.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.SimpleNode.#ctor">
      <summary>
        <para>Creates a default node with default <see cref="P:yWorks.Graph.DefaultGraph.DefaultNodeLookup">lookup</see>, an instance of <see cref="T:yWorks.Graph.Styles.VoidNodeStyle" />, empty <see cref="P:yWorks.Graph.SimpleNode.Layout" /> and no labels or ports.</para>
      </summary>
      <remarks>
        <para>The instances assigned to <see cref="P:yWorks.Graph.SimpleNode.Layout" />, <see cref="P:yWorks.Graph.SimpleNode.Ports" /> and <see cref="P:yWorks.Graph.SimpleNode.Labels" /> are immutable by default. To modify the values of those properties, first assign an instance of a mutable class.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleNode.Layout">
      <summary>
        <para>Gets or sets the layout of the node.</para>
      </summary>
      <remarks>
        <para>The layout of a node is a rectangle in the world coordinate system that describes the bounding box of the representation of a node.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleNode.Style">
      <summary>
        <para>Gets or sets the style that is responsible for the visual representation of this node in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>Note that the style instance associated with a node instance may be shared between multiple node instances and that the modification of this style will result in a change of the appearance of all nodes that are associated with the same style instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimpleNode.Ports">
      <summary>
        <para>Gets or sets the collection of <see cref="T:yWorks.Graph.IPort">ports</see> that are owned by this instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.SimpleNode.Labels">
      <summary>
        <para>Gets or sets the collection of <see cref="T:yWorks.Graph.ILabel">labels</see> that are owned by this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.SimpleNode.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="P:yWorks.Graph.SimpleNode.LookupImplementation">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.ILookup" /> implementation used for calls to <see cref="M:yWorks.Graph.SimpleNode.Lookup(System.Type)" /> on this instance.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.SimplePort">
      <summary>
        <para>A simple mutable implementation of the <see cref="T:yWorks.Graph.IPort" /> interface that can be used stand-alone.</para>
      </summary>
      <remarks>
        <para>Note that this class is not the one used as the default implementation of a <see cref="T:yWorks.Graph.DefaultGraph" />'s <see cref="T:yWorks.Graph.IPort" />s and casting them to <see cref="T:yWorks.Graph.SimplePort" /> will fail. Instances of this class can be used without an accompanying graph instance. All of the properties are mutable. An example of a possible use case would be the rendering of a port into a graphics context: Simply create a <see cref="T:yWorks.Graph.SimplePort" />, associate a style with it and use the style's renderer instance to obtain a rendering for the port.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.SimplePort.#ctor(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <summary>
        <para>Creates a port with a <see cref="P:yWorks.Graph.DefaultGraph.DefaultPortLookup">default lookup</see> using the given location and owner.</para>
      </summary>
      <param name="owner">
        <para>The port's owner.</para>
      </param>
      <param name="locationParameter">
        <para>The port's location model parameter.</para>
      </param>
      <remarks>
        <para>While technically the owner can be <c>null</c> here, this can cause issues, e.g. with <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModel">port location models</see> that position the port relative to its owner.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimplePort.Style">
      <summary>
        <para>Gets or sets the style that is responsible for the visual representation of this port in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>Note that the style instance associated with a port instance may be shared between multiple port instances and that the modification of this style will result in a change of the appearance of all ports that are associated with the same style instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.SimplePort.LocationParameter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> that is used to determine the location of this port.</para>
      </summary>
      <remarks>
        <para>The port location can be calculated using the <see cref="P:yWorks.Graph.PortLocationModels.IPortLocationModelParameter.Model" />'s <see cref="M:yWorks.Graph.PortLocationModels.IPortLocationModel.GetLocation(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" /> method or the convenience methods <see cref="M:yWorks.Graph.GraphExtensions.GetLocation(yWorks.Graph.IPort)" /> and <see cref="M:yWorks.Graph.GraphExtensions.GetDynamicLocation(yWorks.Graph.IPort)" />.</para>
        <para>Note that parameters may be shared across port instances.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetPortLocationParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" />
      <seealso cref="M:yWorks.Graph.GraphExtensions.GetLocation(yWorks.Graph.IPort)" />
      <seealso cref="M:yWorks.Graph.GraphExtensions.GetDynamicLocation(yWorks.Graph.IPort)" />
    </member>
    <member name="P:yWorks.Graph.SimplePort.Owner">
      <summary>
        <para>Gets or sets the owner of this port.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.SimplePort.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.SimplePort.SetLocation(yWorks.Geometry.PointD)">
      <summary>
        <para>Sets the location of this port.</para>
      </summary>
      <param name="location" />
    </member>
    <member name="P:yWorks.Graph.SimplePort.LookupImplementation">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.ILookup" /> implementation used for calls to <see cref="M:yWorks.Graph.SimplePort.Lookup(System.Type)" /> on this instance.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.DefaultPortCandidate">
      <summary>
        <para>A simple default implementation of an <see cref="T:yWorks.Controls.Input.IPortCandidate" />.</para>
      </summary>
      <remarks>
        <para>Subclasses need to override <see cref="M:yWorks.Controls.Input.DefaultPortCandidate.CreateInstance(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)" /> if they don't <see cref="M:yWorks.Controls.Input.DefaultPortCandidate.SetInstance(yWorks.Graph.IPort)">set</see> a port instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.DefaultPortCandidate.#ctor(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModel)">
      <summary>
        <para>Creates a candidate for the given <paramref name="owner" /> that uses the graph's defaults for the port's style and a default parameter for the given <paramref name="model" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Controls.Input.DefaultPortCandidate.LocationParameter" /> is set to the parameter that best matches the <see cref="F:yWorks.Geometry.PointD.Origin">origin</see> for the given <paramref name="model" />.</para>
      </remarks>
      <param name="owner">
        <para>The owner.</para>
      </param>
      <param name="model">
        <para>The model.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.DefaultPortCandidate.#ctor(yWorks.Graph.IPort)">
      <summary>
        <para>Creates a candidate using the given port as the template.</para>
      </summary>
      <param name="port">
        <para>The port to use.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.DefaultPortCandidate.#ctor(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Controls.Input.PortCandidateValidity)">
      <summary>
        <para>Creates a candidate for the given <paramref name="owner" /> that uses the graph's defaults for the port's style and the given <paramref name="locationParameter" />.</para>
      </summary>
      <remarks>
        <para>If no <paramref name="locationParameter" /> is given, the used candidate has a fixed location at <see cref="F:yWorks.Geometry.PointD.Origin" /> that does not depend on the <paramref name="owner" />.</para>
      </remarks>
      <param name="owner">
        <para>The owner.</para>
      </param>
      <param name="locationParameter">
        <para>The location.</para>
      </param>
      <param name="validity">
        <para>The validity of the port candidate.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.DefaultPortCandidate.Validity">
      <summary>
        <para>Gets or sets whether this candidate is a valid one depending on the context it has been obtained from.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.DefaultPortCandidate.CandidateTag">
      <summary>
        <para>Gets or set the tag for this candidate.</para>
      </summary>
      <remarks>
        <para>The interpretation of this value is implementation dependent and may be used for visual feedback or interactive behavior.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.DefaultPortCandidate.PortTag">
      <summary>
        <para>Gets or sets the port tag to create the port with.</para>
      </summary>
      <value>
        <para>The port tag to use when the port is created.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.DefaultPortCandidate.LocationParameter">
      <summary>
        <para>Gets or sets the model parameter that will be used for the <see cref="P:yWorks.Graph.IPort.LocationParameter" /> if this candidate is chosen.</para>
      </summary>
      <remarks>
        <para>The parameter which may not be <c>null</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.DefaultPortCandidate.Model">
      <summary>
        <para>Gets or sets the model that will be used by this instance to determine the new <see cref="P:yWorks.Controls.Input.DefaultPortCandidate.LocationParameter" /> if the <see cref="M:yWorks.Controls.Input.DefaultPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> is called and the <see cref="P:yWorks.Controls.Input.DefaultPortCandidate.Validity" /> is set to <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.DefaultPortCandidate.Style">
      <summary>
        <para>Gets or sets the style to use for the newly created port.</para>
      </summary>
      <value>
        <para>The style. If this property is <c>null</c>, the current default in the graph will be used.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.DefaultPortCandidate.Owner">
      <summary>
        <para>Gets or sets the owner of the port to be created.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.DefaultPortCandidate.Port">
      <summary>
        <para>Gets the instance provided to the constructor or to the <see cref="M:yWorks.Controls.Input.DefaultPortCandidate.SetInstance(yWorks.Graph.IPort)">setter</see>.</para>
      </summary>
      <value>
        <para>The instance to use or <c>null</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.DefaultPortCandidate.CreatePort(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.DefaultPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Returns a candidate that is derived from this instance that best fits the provided <paramref name="location" />.</para>
      </summary>
      <param name="context">
        <para>The input mode context for which a concrete candidate is queried.</para>
      </param>
      <param name="location">
        <para>The location for which a candidate should be returned.</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Controls.Input.IPortCandidate" /> implementation whose <see cref="P:yWorks.Controls.Input.DefaultPortCandidate.Validity" /> is guaranteed to be non-<see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" />.</para>
      </returns>
      <remarks>
        <para>The returned implementation will finally call <see cref="M:yWorks.Controls.Input.DefaultPortCandidate.CreateInstance(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)" /> using the newly calculated <see cref="P:yWorks.Controls.Input.DefaultPortCandidate.LocationParameter" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.DefaultPortCandidate.Validity" />
    </member>
    <member name="M:yWorks.Controls.Input.DefaultPortCandidate.SetInstance(yWorks.Graph.IPort)">
      <summary>
        <para>Sets the instance that will be returned by <see cref="P:yWorks.Controls.Input.DefaultPortCandidate.Port" /> and <see cref="M:yWorks.Controls.Input.DefaultPortCandidate.CreatePort(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </summary>
      <param name="port">
        <para>A port that already exists in the graph or <c>null</c>.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.DefaultPortCandidate.CreatePort(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>This implementation will throw a <see cref="T:System.NotSupportedException" /> if the validity is <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" />.</para>
      </summary>
      <remarks>
        <para>This implementation will delegate to the <see cref="M:yWorks.Controls.Input.DefaultPortCandidate.CreateInstance(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)" /> method.</para>
      </remarks>
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.DefaultPortCandidate.CreateInstance(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)">
      <summary>
        <para>Actually creates the <see cref="T:yWorks.Graph.IPort" /> instance.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a call to <see cref="M:yWorks.Controls.Input.DefaultPortCandidate.CreatePort(yWorks.Controls.Input.IInputModeContext)" /> on this instance and the instances created by <see cref="M:yWorks.Controls.Input.DefaultPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="graph">
        <para>The graph to add the port to.</para>
      </param>
      <param name="locationParameter">
        <para>The parameter to use.</para>
      </param>
      <param name="style">
        <para>The style to use.</para>
      </param>
      <param name="tag">
        <para>The tag to use.</para>
      </param>
      <returns>
        <para>The newly created port.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.DefaultPortCandidateDescriptor">
      <summary>
        <para>A simple <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> that can be used to draw <see cref="T:yWorks.Controls.Input.IPortCandidate" /> instances in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.DefaultPortCandidateDescriptor.CandidateDrawingValidNonFocusedKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.DefaultPortCandidateDescriptor" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for rendering a valid, non-focused <see cref="T:yWorks.Controls.Input.IPortCandidate" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.DefaultPortCandidateDescriptor.CandidateDrawingValidFocusedKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.DefaultPortCandidateDescriptor" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for rendering a valid, focused <see cref="T:yWorks.Controls.Input.IPortCandidate" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.DefaultPortCandidateDescriptor.CandidateDrawingInvalidNonFocusedKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.DefaultPortCandidateDescriptor" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for rendering an invalid, non-focused <see cref="T:yWorks.Controls.Input.IPortCandidate" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.DefaultPortCandidateDescriptor.CandidateDrawingInvalidFocusedKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used by instances of the <see cref="T:yWorks.Controls.DefaultPortCandidateDescriptor" /> to look up a <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used for rendering a invalid, focused <see cref="T:yWorks.Controls.Input.IPortCandidate" />.</para>
      </summary>
      <remarks>
        <para>The drawing returned should be centered around <c>(0,0)</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.DefaultPortCandidateDescriptor.#ctor">
      <summary>
        <para>Instantiates a new descriptor.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.DefaultPortCandidateDescriptor.CurrentCandidate">
      <summary>
        <para>Gets or sets a property that determines whether this descriptor uses the "current" candidates.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.DefaultPortCandidateDescriptor.Size">
      <summary>
        <para>Gets or sets the logical size of the candidate.</para>
      </summary>
      <remarks>
        <para>This size is used for hit testing, visibility tests, etc. The default is <c>3</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.DefaultPortCandidateDescriptor.SetTemplate(yWorks.Controls.ResourceKey,yWorks.Controls.TemplateVisual)">
      <summary>
        <para>Sets the <see cref="T:yWorks.Controls.TemplateVisual" /> to use for the given <see cref="T:yWorks.Controls.ResourceKey" /> by this instance.</para>
      </summary>
      <remarks>
        <para>This method can be used to reconfigure the visualization for the various keys that are declared by this class.</para>
      </remarks>
      <param name="resourceKey">
        <para>The key to reconfigure. This is one of <see cref="F:yWorks.Controls.DefaultPortCandidateDescriptor.CandidateDrawingValidNonFocusedKey" />, <see cref="F:yWorks.Controls.DefaultPortCandidateDescriptor.CandidateDrawingInvalidNonFocusedKey" />, <see cref="F:yWorks.Controls.DefaultPortCandidateDescriptor.CandidateDrawingInvalidFocusedKey" />, <see cref="F:yWorks.Controls.DefaultPortCandidateDescriptor.CandidateDrawingValidFocusedKey" />.</para>
      </param>
      <param name="template">
        <para>The template to use instead of the default.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.DefaultPortCandidateDescriptor.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Controls.DefaultPortCandidateDescriptor.GetVisualCreator(System.Object)">
      <param name="forUserObject" />
    </member>
    <member name="M:yWorks.Controls.DefaultPortCandidateDescriptor.IsDirty(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObject)">
      <param name="context" />
      <param name="canvasObject" />
    </member>
    <member name="M:yWorks.Controls.DefaultPortCandidateDescriptor.GetBoundsProvider(System.Object)">
      <param name="forUserObject" />
    </member>
    <member name="M:yWorks.Controls.DefaultPortCandidateDescriptor.GetVisibilityTestable(System.Object)">
      <param name="forUserObject" />
    </member>
    <member name="M:yWorks.Controls.DefaultPortCandidateDescriptor.GetHitTestable(System.Object)">
      <param name="forUserObject" />
    </member>
    <member name="T:yWorks.Markup.Common.DescriptorWrapperLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.DescriptorWrapperLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.DescriptorWrapperLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.LabelModels.DescriptorWrapperLabelModel)">
      <param name="parameter" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.DescriptorWrapperLabelModelParameterExtension.Parameter" />
    <member name="P:yWorks.Markup.Common.DescriptorWrapperLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.DescriptorWrapperLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel">
      <summary>
        <para>A label model that wraps an existing label model and decorates it with a <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptor">descriptor</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.#ctor">
      <summary>
        <para>Creates a new instance that uses <see cref="F:yWorks.Graph.LabelModels.FreeLabelModel.Instance" /> as inner model.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.#ctor(yWorks.Graph.LabelModels.ILabelModel)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel" /> class.</para>
      </summary>
      <param name="innerModel">
        <para>The wrapped label model.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.Descriptor">
      <summary>
        <para>Gets or sets the descriptor.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.InnerModel">
      <summary>
        <para>Gets or sets the inner label model</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.CreateDefaultParameter">
      <summary>
        <para>Creates a default parameter that can be used for this model.</para>
      </summary>
      <returns>
        <para>The default parameter from <see cref="P:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.InnerModel" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.GetDescriptor(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.DescriptorWrapperLabelModel.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="label" />
      <param name="model" />
    </member>
    <member name="T:yWorks.Graph.FoldingEdgeStateId">
      <summary>
        <para>A data holder that can be used to describe a <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">folding</see> edge that connects to nodes inside a collapsed group or to other folder nodes in a <see cref="T:yWorks.Graph.IFoldingView" />.</para>
      </summary>
      <remarks>
        <para>Instances of this type are passed to the various methods in <see cref="T:yWorks.Graph.FoldingManager" /> to identify different possible states of an edge inside <see cref="T:yWorks.Graph.IFoldingView" />s. A folding edge is identified through the master edge, which is an edge in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> and a source and target node. Also whether those source and target nodes are currently <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">folder</see> nodes needs to be taken into account. The source and target nodes need to be either the true <see cref="P:yWorks.Graph.IPort.Owner">owners</see> of the adjacent edge's <see cref="P:yWorks.Graph.IEdge.SourcePort" /> and <see cref="P:yWorks.Graph.IEdge.TargetPort" /> respectively, or <see cref="M:yWorks.Graph.IGraph.GetParent(yWorks.Graph.INode)">ancestor</see> group nodes in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />. In the latter case these folding edges are used to describe the state of the folding edges that are present in the views of the corresponding group nodes are in <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> state, so that the true source and target nodes are not currently visible in the view. As such the <see cref="P:yWorks.Graph.FoldingEdgeStateId.CurrentMasterSource" /> and <see cref="P:yWorks.Graph.FoldingEdgeStateId.CurrentMasterTarget" /> nodes represent the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">masters</see> of the nearest ancestors in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> that are visible in the <see cref="T:yWorks.Graph.IFoldingView">folding view</see> graph.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.FoldingManager.HasFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)" />
      <seealso cref="M:yWorks.Graph.FoldingManager.GetFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)" />
      <seealso cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeStateId.#ctor(yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Initializes an id for a folding edge in a <see cref="T:yWorks.Graph.IFoldingView">view</see> that represent a master edge and connects a specific pair of nodes.</para>
      </summary>
      <remarks>
        <para>All of the arguments need to be entities of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master graph</see>.</para>
      </remarks>
      <param name="masterEdge">
        <para>An edge in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> that is represented by the folding edge.</para>
      </param>
      <param name="currentMasterSource">
        <para>The source node of the edge or one of its ancestors to which the folding edge connects in the view, if the actual parent is currently <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed in an ancestor node</see>.</para>
      </param>
      <param name="sourceCollapsed">
        <para>
          <c>true</c> if the <paramref name="currentMasterSource" /> is the true source of the <paramref name="masterEdge" />, but is in its <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed/dummy</see> state.</para>
      </param>
      <param name="targetCollapsed">
        <para>
          <c>true</c> if the <paramref name="currentMasterTarget" /> is the true target of the <paramref name="masterEdge" />, but is in its <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed/dummy</see> state.</para>
      </param>
      <param name="currentMasterTarget">
        <para>The target node of the edge or one of its ancestors to which the folding edge connects in the view, if the actual parent is currently <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed in an ancestor node</see>.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeStateId.#ctor(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge)">
      <summary>
        <para>Initializes an id for a folding edge that is currently part of the given view.</para>
      </summary>
      <param name="foldingView">
        <para>The view the folding edge is part of.</para>
      </param>
      <param name="foldingEdge">
        <para>The instance that is part of the <see cref="P:yWorks.Graph.IFoldingView.Graph">folding view graph</see>.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeStateId.MasterEdge">
      <summary>
        <para>Gets the edge instance in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> that is represented by the folding edge in a view.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeStateId.CurrentMasterSource">
      <summary>
        <para>Gets the source node of the edge or an ancestor (both in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />).</para>
      </summary>
      <remarks>
        <para>This may be an ancestor of the true source node if this ancestor is <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see>. More specific it is the source node of the <see cref="P:yWorks.Graph.FoldingEdgeStateId.MasterEdge" /> if the source node is represented in the view and otherwise the first ancestor of the source node which is represented in the view.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeStateId.CurrentMasterTarget">
      <summary>
        <para>Gets the target node of the edge or an ancestor (both in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />).</para>
      </summary>
      <remarks>
        <para>This may be an ancestor of the true target node if this ancestor is <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see>. More precisely it is the target node of the <see cref="P:yWorks.Graph.FoldingEdgeStateId.MasterEdge" /> if the target node is represented in the view and otherwise the first ancestor of the target node which is represented in the view.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeStateId.SourceIsCollapsed">
      <summary>
        <para>Gets whether the <see cref="P:yWorks.Graph.FoldingEdgeStateId.CurrentMasterSource" /> node <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">is in folder state</see>.</para>
      </summary>
      <remarks>
        <para>Since an edge will be converted to a folding edge if the adjacent node itself will be <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> to a folder node, this property determines which state the source node is in for this folding edge.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeStateId.TargetIsCollapsed">
      <summary>
        <para>Gets whether the <see cref="P:yWorks.Graph.FoldingEdgeStateId.CurrentMasterTarget" /> node <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">is in folder state</see>.</para>
      </summary>
      <remarks>
        <para>Since an edge will be converted to a folding edge if the adjacent node itself will be <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> to a folder node, this property determines which state the source node is in for this folding edge.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Markup.Common.EdgePathLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.EdgePathLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.EdgePathLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.EdgeSides,System.Double,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="sideOfEdge" />
      <param name="segmentRatio" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.EdgePathLabelModelParameterExtension.Model" />
    <member name="P:yWorks.Markup.Common.EdgePathLabelModelParameterExtension.SideOfEdge" />
    <member name="P:yWorks.Markup.Common.EdgePathLabelModelParameterExtension.SegmentRatio" />
    <member name="M:yWorks.Markup.Common.EdgePathLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.EdgePathLabelModel">
      <summary>
        <para>An edge label model that allows placement of labels along the edge path at a set of continuous positions at specified <see cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.SideOfEdge">sides of the edge path</see>.</para>
      </summary>
      <remarks>
        <para>The set of positions can be influenced by specifying the <see cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.SideOfEdge" /> value that controls on which side of the edge labels positions should be considered. Furthermore, it's possible to specify distance values that control the distance between label and edge and between label and nodes.</para>
        <para>If a label model parameter is created <see cref="F:yWorks.Graph.LabelModels.EdgeSides.OnEdge" />, the label's center is usually placed on the edge. It can be shifted by specifying a <see cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.Offset" /> value but the <see cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.Distance" /> value is ignored. For all other values of <see cref="T:yWorks.Graph.LabelModels.EdgeSides" /> the total distance between the label bounds and the edge path is the sum of <see cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.Offset" /> and <see cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.Distance" />.</para>
        <para>The label placements use a <see cref="M:yWorks.Graph.LabelModels.EdgePathLabelModel.CreateRatioParameter(System.Double,yWorks.Graph.LabelModels.EdgeSides)">ratio</see> value as fraction of the full edge path length. This is the main difference to the <see cref="T:yWorks.Graph.LabelModels.EdgePathLabelModel" /> which uses a specified segment index from the <see cref="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.CreateParameterFromSource(System.Int32,System.Double,yWorks.Graph.LabelModels.EdgeSides)">source</see> or <see cref="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.CreateParameterFromTarget(System.Int32,System.Double,yWorks.Graph.LabelModels.EdgeSides)">target</see> side and a ratio on this segment.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgePathLabelModel.#ctor">
      <summary>
        <para>Returns a new instance of <see cref="T:yWorks.Graph.LabelModels.EdgePathLabelModel" /> class.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgePathLabelModel.#ctor(System.Double,System.Double,System.Double,System.Boolean,yWorks.Graph.LabelModels.EdgeSides)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LabelModels.EdgePathLabelModel" /> class.</para>
      </summary>
      <param name="distance">
        <para>the distance to the edge.</para>
      </param>
      <param name="offset">
        <para>the offset to the default placement.</para>
      </param>
      <param name="angle">
        <para>the angle of the label's rotation in radians.</para>
      </param>
      <param name="autoRotationEnabled">
        <para>if set to <c>true</c> auto rotation is enabled.</para>
      </param>
      <param name="sideOfEdge">
        <para>the side of the edge labels.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.LabelModels.EdgePathLabelModel.SideOfEdge">
      <summary>
        <para>Gets or sets the side placement specifiers for edge labels.</para>
      </summary>
      <remarks>
        <para>The label model parameter <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder">finder</see> and <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterProvider">provider</see> returned by <see cref="M:yWorks.Graph.LabelModels.EdgePathLabelModel.Lookup(System.Type)" /> consider the specified sides.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.LabelModels.EdgeSides" />
    </member>
    <member name="P:yWorks.Graph.LabelModels.EdgePathLabelModel.Distance">
      <summary>
        <para>Gets or sets the distance between the label box and the edge path.</para>
      </summary>
      <value>
        <para>The distance between the label box and the edge path.</para>
      </value>
      <remarks>
        <para>The interpretation of the values depends on the <see cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.SideOfEdge" /> of the individual <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" />.</para>
        <para>Note that for <see cref="F:yWorks.Graph.LabelModels.EdgeSides.OnEdge" /> this property is ignored. For all other values of <see cref="T:yWorks.Graph.LabelModels.EdgeSides" /> the <see cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.Offset" /> property is added to this distance.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.SideOfEdge" />
      <seealso cref="T:yWorks.Graph.LabelModels.EdgeSides" />
      <seealso cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.Offset" />
    </member>
    <member name="P:yWorks.Graph.LabelModels.EdgePathLabelModel.Offset">
      <summary>
        <para>Gets or sets the offset of the label box and the edge path relative to the default placement.</para>
      </summary>
      <value>
        <para>The offset of the label box and the edge path relative to the default placement.</para>
      </value>
      <remarks>
        <para>For <see cref="F:yWorks.Graph.LabelModels.EdgeSides.OnEdge" /> this is the offset between the center of the label box and the edge path. For all other <see cref="T:yWorks.Graph.LabelModels.EdgeSides" /> values this offset is added to the <see cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.Distance" /> property which results in the total distance between the label box and the edge path.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.LabelModels.EdgePathLabelModel.SideOfEdge" />
      <seealso cref="T:yWorks.Graph.LabelModels.EdgeSides" />
    </member>
    <member name="P:yWorks.Graph.LabelModels.EdgePathLabelModel.AutoRotationEnabled">
      <summary>
        <para>Gets or sets whether edge labels are automatically rotated according to the angle of the corresponding reference edge segment.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels are automatically rotated; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>By default, this feature is enabled.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.LabelModels.EdgePathLabelModel.Angle">
      <summary>
        <para>Gets or sets the rotation angle of all labels with this model in radians.</para>
      </summary>
      <value>
        <para>The rotation angle of all labels with this model in radians.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgePathLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgePathLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Returns an empty context.</para>
      </summary>
      <param name="label">
        <para>The label to use in the context.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter to use for the label in the context.</para>
      </param>
      <returns>
        <para>An empty context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgePathLabelModel.CreateDefaultParameter">
      <summary>
        <para>A model parameter that encodes the default position of this model's allowed edge label positions.</para>
      </summary>
      <remarks>
        <para>Returns a model parameter that encodes the default position of this model's allowed edge label positions.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgePathLabelModel.CreateRatioParameter(System.Double,yWorks.Graph.LabelModels.EdgeSides)">
      <summary>
        <para>Creates a parameter at the provided edge path ratio.</para>
      </summary>
      <param name="edgePathRatio">
        <para>The ratio at which to place the label at the edge path. A ratio of 0.0 will place the label at the source side of the edge path, a ratio of 1.0 at the target side.</para>
      </param>
      <param name="sideOfEdge">
        <para>The side of the edge the label is placed on. Note that only single enum values but no combined ones are allowed.</para>
      </param>
      <returns>
        <para>A label parameter at the provided edge path ratio for this model instance.</para>
      </returns>
    </member>
    <member name="T:yWorks.Markup.Common.EdgeSegmentLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.EdgeSegmentLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.EdgeSegmentLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.EdgeSides,yWorks.Graph.LabelModels.PlaceAlongEdge,System.Int32,System.Double,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="sideOfEdge" />
      <param name="placeAlongEdge" />
      <param name="segmentIndex" />
      <param name="segmentRatio" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.EdgeSegmentLabelModelParameterExtension.Model" />
    <member name="P:yWorks.Markup.Common.EdgeSegmentLabelModelParameterExtension.SideOfEdge" />
    <member name="P:yWorks.Markup.Common.EdgeSegmentLabelModelParameterExtension.PlaceAlongEdge" />
    <member name="P:yWorks.Markup.Common.EdgeSegmentLabelModelParameterExtension.SegmentIndex" />
    <member name="P:yWorks.Markup.Common.EdgeSegmentLabelModelParameterExtension.SegmentRatio" />
    <member name="M:yWorks.Markup.Common.EdgeSegmentLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.EdgeSegmentLabelModel">
      <summary>
        <para>An edge label model that allows placement of labels relative to an edge segment at a set of continuous positions at specified <see cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.SideOfEdge">sides of the edge path</see>.</para>
      </summary>
      <remarks>
        <para>The set of positions can be influenced by specifying the <see cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.SideOfEdge" /> value that controls on which side of the edge labels positions should be considered. Furthermore, it's possible to specify distance values that control the distance between label and edge and between label and nodes.</para>
        <para>If a label model parameter is created <see cref="F:yWorks.Graph.LabelModels.EdgeSides.OnEdge" />, the label's center is usually placed on the edge. It can be shifted by specifying a <see cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Offset" /> value but the <see cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Distance" /> value is ignored. For all other values of <see cref="T:yWorks.Graph.LabelModels.EdgeSides" /> the total distance between the label bounds and the edge path is the sum of <see cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Offset" /> and <see cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Distance" />.</para>
        <para>The label placements use a specified segment index from the <see cref="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.CreateParameterFromSource(System.Int32,System.Double,yWorks.Graph.LabelModels.EdgeSides)">source</see> or <see cref="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.CreateParameterFromTarget(System.Int32,System.Double,yWorks.Graph.LabelModels.EdgeSides)">target</see> side and a ratio on this segment. This is the main difference to the <see cref="T:yWorks.Graph.LabelModels.EdgePathLabelModel" /> which only uses a ratio value of the full edge path.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.#ctor">
      <summary>
        <para>Returns a new instance of <see cref="T:yWorks.Graph.LabelModels.EdgeSegmentLabelModel" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.#ctor(System.Double,System.Double,System.Double,System.Boolean,yWorks.Graph.LabelModels.EdgeSides)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LabelModels.EdgeSegmentLabelModel" /> class.</para>
      </summary>
      <param name="distance">
        <para>the distance to the edge.</para>
      </param>
      <param name="offset">
        <para>the offset to the default placement.</para>
      </param>
      <param name="angle">
        <para>the angle of the label's rotation in radians.</para>
      </param>
      <param name="autoRotationEnabled">
        <para>if set to <c>true</c> auto rotation is enabled.</para>
      </param>
      <param name="sideOfEdge">
        <para>the side of the edge labels.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.SideOfEdge">
      <summary>
        <para>Gets or sets the side placement specifiers for edge labels.</para>
      </summary>
      <remarks>
        <para>The label model parameter <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder">finder</see> and <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterProvider">provider</see> returned by <see cref="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Lookup(System.Type)" /> consider the specified sides.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.LabelModels.EdgeSides" />
    </member>
    <member name="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Distance">
      <summary>
        <para>Gets or sets the distance between the label box and the edge path.</para>
      </summary>
      <value>
        <para>The distance between the label box and the edge path.</para>
      </value>
      <remarks>
        <para>The interpretation of the values depends on the <see cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.SideOfEdge" /> of the individual <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" />.</para>
        <para>Note that for <see cref="F:yWorks.Graph.LabelModels.EdgeSides.OnEdge" /> this property is ignored. For all other values of <see cref="T:yWorks.Graph.LabelModels.EdgeSides" /> the <see cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Offset" /> property is added to this distance.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.SideOfEdge" />
      <seealso cref="T:yWorks.Graph.LabelModels.EdgeSides" />
      <seealso cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Offset" />
    </member>
    <member name="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Offset">
      <summary>
        <para>Gets or sets the offset of the label box and the edge path relative to the default placement.</para>
      </summary>
      <value>
        <para>The offset of the label box and the edge path relative to the default placement.</para>
      </value>
      <remarks>
        <para>For <see cref="F:yWorks.Graph.LabelModels.EdgeSides.OnEdge" /> this is the offset between the center of the label box and the edge path. For all other <see cref="T:yWorks.Graph.LabelModels.EdgeSides" /> values this offset is added to the <see cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Distance" /> property which results in the total distance between the label box and the edge path.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.SideOfEdge" />
      <seealso cref="T:yWorks.Graph.LabelModels.EdgeSides" />
    </member>
    <member name="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.AutoRotationEnabled">
      <summary>
        <para>Gets or sets whether edge labels are automatically rotated according to the angle of the corresponding reference edge segment.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels are automatically rotated; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>By default, this feature is enabled.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Angle">
      <summary>
        <para>Gets or sets the rotation angle of all labels with this model in radians.</para>
      </summary>
      <value>
        <para>The rotation angle of all labels with this model in radians.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.CreateDefaultParameter">
      <summary>
        <para>A model parameter that encodes the default position of this model's allowed edge label positions.</para>
      </summary>
      <remarks>
        <para>Returns a model parameter that encodes the default position of this model's allowed edge label positions.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Returns an empty context.</para>
      </summary>
      <param name="label">
        <para>The label to use in the context.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter to use for the label in the context.</para>
      </param>
      <returns>
        <para>An empty context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.CreateParameterFromSource(System.Int32,System.Double,yWorks.Graph.LabelModels.EdgeSides)">
      <summary>
        <para>Creates a parameter that measures the provided segment index from the source side of the edge path.</para>
      </summary>
      <param name="segmentIndex">
        <para>The zero-based index of the segment beginning from the source side.</para>
      </param>
      <param name="segmentRatio">
        <para>The ratio at which to place the label at the segment. A ratio of 0.0 will place the label at the source side of the segment, a ratio of 1.0 at the target side. Ratios &lt; 0.0 or &gt; 1.0 will be interpreted as absolute values in world coordinates.</para>
      </param>
      <param name="sideOfEdge">
        <para>The side of the edge the label is placed on. Note that only single enum values but no combined ones are allowed.</para>
      </param>
      <returns>
        <para>A label parameter that describes the provided parameters for this model instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.CreateParameterFromTarget(System.Int32,System.Double,yWorks.Graph.LabelModels.EdgeSides)">
      <summary>
        <para>Creates a parameter that measures the provided segment index from the target side of the edge path.</para>
      </summary>
      <param name="segmentIndex">
        <para>The zero-based index of the segment beginning from the target side.</para>
      </param>
      <param name="segmentRatio">
        <para>The ratio at which to place the label at the segment. A ratio of 0.0 will place the label at the target side of the segment, a ratio of 1.0 at the source side. Ratios &lt; 0.0 or &gt; 1.0 will be interpreted as absolute values in world coordinates.</para>
      </param>
      <param name="sideOfEdge">
        <para>The side of the edge the label is placed on. Note that only single enum values but no combined ones are allowed.</para>
      </param>
      <returns>
        <para>A label parameter that describes the provided parameters for this model instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.EdgeSegmentLabelModel.CreateParameterFromCenter(System.Double,yWorks.Graph.LabelModels.EdgeSides)">
      <summary>
        <para>Creates a parameter where the label is attached to the edge segment that contains the edge's midpoint.</para>
      </summary>
      <param name="segmentRatio">
        <para>The ratio at which to place the label at the segment. A ratio of 0.0 will place the label at the source side of the segment, a ratio of 1.0 at the target side. Ratios &lt; 0.0 or &gt; 1.0 will be interpreted as absolute values in world coordinates.</para>
      </param>
      <param name="sideOfEdge">
        <para>The side of the edge the label is placed on. Note that only single enum values but no combined ones are allowed.</para>
      </param>
      <returns>
        <para>A label parameter that describes the provided parameters for this model instance.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.LabelModels.EdgeSides">
      <summary>
        <para>The side placement specifier for edge labels used by <see cref="T:yWorks.Graph.LabelModels.EdgeSegmentLabelModel" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.EdgeSides.OnEdge">
      <summary>
        <para>The label should be placed on the path of the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.EdgeSides.LeftOfEdge">
      <summary>
        <para>The label should be placed on the left hand side of the edge path if looking from the source node into the direction of the target node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.EdgeSides.RightOfEdge">
      <summary>
        <para>The label should be placed on the right hand side of the edge path if looking from the source node into the direction of the target node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.EdgeSides.AboveEdge">
      <summary>
        <para>The label should be placed above the edge (in geometric sense).</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.EdgeSides.BelowEdge">
      <summary>
        <para>The label should be placed below the edge (in geometric sense).</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.LabelModels.PlaceAlongEdge">
      <summary>
        <para>Enumeration that is used by <see cref="T:yWorks.Graph.LabelModels.EdgeSegmentLabelModel" /> to indicate the position of the label along the edge.</para>
      </summary>
      <remarks>
        <para>This enumeration is mainly used by the XAML serialization mechanisms.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.PlaceAlongEdge.AtSource">
      <summary>
        <para>The segment index is counted from the edge source.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.PlaceAlongEdge.AtTarget">
      <summary>
        <para>The segment index is counted from the edge target.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.PlaceAlongEdge.AtCenter">
      <summary>
        <para>The label is at the center of the edge and the segment index is ignored.</para>
      </summary>
    </member>
    <member name="T:yWorks.Markup.Common.ExteriorLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.ExteriorLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.ExteriorLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.ExteriorLabelModel.Position)">
      <param name="position" />
    </member>
    <member name="M:yWorks.Markup.Common.ExteriorLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.ExteriorLabelModel.Position,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="position" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.ExteriorLabelModelParameterExtension.Position" />
    <member name="P:yWorks.Markup.Common.ExteriorLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.ExteriorLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.ExteriorLabelModel">
      <summary>
        <para>A label model for node labels that lie outside of the node's <see cref="P:yWorks.Graph.INode.Layout" /> bounds.</para>
      </summary>
      <remarks>
        <para>This label model supports eight positions outside of the layout's bounds.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.North">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.ExteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.ExteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.East">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.ExteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.ExteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.South">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.ExteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.ExteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.SouthEast">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.ExteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.ExteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.SouthWest">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.ExteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.ExteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.West">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.ExteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.ExteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.NorthEast">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.ExteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.ExteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.NorthWest">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.ExteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.ExteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.LabelModels.ExteriorLabelModel.Position">
      <summary>
        <para>Enumeration of the possible positions of the <see cref="T:yWorks.Graph.LabelModels.ExteriorLabelModel" />.</para>
      </summary>
      <remarks>
        <para>This field can be used as an argument for the <see cref="M:yWorks.Graph.LabelModels.ExteriorLabelModel.CreateParameter(yWorks.Graph.LabelModels.ExteriorLabelModel.Position)" /> factory method.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.Position.North">
      <summary>
        <para>Encodes a position outside the node at the top</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.Position.East">
      <summary>
        <para>Encodes a position outside the node at the right side</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.Position.South">
      <summary>
        <para>Encodes a position outside the node at the bottom</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.Position.West">
      <summary>
        <para>Encodes a position outside the node at the left side</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.Position.NorthEast">
      <summary>
        <para>Encodes a position outside the node at the upper right corner</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.Position.SouthEast">
      <summary>
        <para>Encodes a position outside the node at the lower right corner</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.Position.NorthWest">
      <summary>
        <para>Encodes a position outside the node at the upper left corner</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ExteriorLabelModel.Position.SouthWest">
      <summary>
        <para>Encodes a position outside the node at the lower left corner</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.ExteriorLabelModel.#ctor">
      <summary>
        <para>Creates a new instance of this model</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.LabelModels.ExteriorLabelModel.Insets">
      <summary>
        <para>Gets or sets the insets to use by this model.</para>
      </summary>
      <remarks>
        <para>The insets are in fact "outsets", i.e. they are treated as margins. Positive values will increase the distance of the labels to the node.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.ExteriorLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.ExteriorLabelModel.CreateDefaultParameter" />
    <member name="M:yWorks.Graph.LabelModels.ExteriorLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.ExteriorLabelModel.CreateParameter(yWorks.Graph.LabelModels.ExteriorLabelModel.Position)">
      <summary>
        <para>Creates a new parameter that is associated with this instance for the provided position.</para>
      </summary>
      <param name="position">
        <para>The position constant that describes the position of the label.</para>
      </param>
      <returns>
        <para>A new parameter instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.ExteriorLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.ExteriorLabelModel.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="label" />
      <param name="model" />
    </member>
    <member name="T:yWorks.Graph.FilteredGraphWrapper">
      <summary>
        <para>An <see cref="T:yWorks.Graph.IGraph" /> that contains a live subgraph of another <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Graph.FilteredGraphWrapper" /> is a decorator for another <see cref="T:yWorks.Graph.IGraph" /> instance and can be used to retain only a subset of nodes and edges of the original graph. The properties <see cref="P:yWorks.Graph.FilteredGraphWrapper.NodePredicate" /> and <see cref="P:yWorks.Graph.FilteredGraphWrapper.EdgePredicate" /> control which nodes and edges are retained in the filtered graph. Edges adjacent to filtered nodes are also filtered automatically (as their source or target would not be in the graph anyway).</para>
        <para>Note that <see cref="T:yWorks.Graph.FilteredGraphWrapper" /> has to listen to events raised by the wrapped graph to keep itself updated, so <see cref="M:yWorks.Graph.FilteredGraphWrapper.Dispose" /> should be called if this instance is not used any more. Otherwise the wrapped graph may be kept alive for longer than necessary.</para>
        <para>
          <see cref="P:yWorks.Graph.IPortOwner.Ports" /> at <see cref="T:yWorks.Graph.IEdge" />s (i.e. edge-to-edge connections) are not fully supported.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FilteredGraphWrapper.NodePredicate">
      <summary>
        <para>Gets the predicate function for the nodes.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FilteredGraphWrapper.EdgePredicate">
      <summary>
        <para>Gets the predicate function for the edges.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.#ctor(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.INode},System.Predicate{yWorks.Graph.IEdge})">
      <summary>
        <para>Creates a new graph instance that wraps the original graph and uses the <see cref="T:System.Predicate`1" />s to determine which nodes and edges should be contained in the graph.</para>
      </summary>
      <remarks>
        <para>Note that this instance will register listeners with the <paramref name="graph" />, so <see cref="M:yWorks.Graph.FilteredGraphWrapper.Dispose" /> should be called if this instance is not used any more.</para>
      </remarks>
      <param name="graph">
        <para>The graph to wrap</para>
      </param>
      <param name="nodePredicate">
        <para>The predicate that determines which nodes to keep.</para>
      </param>
      <param name="edgePredicate">
        <para>The predicate that determines which edges to keep.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.AddEventHandlers(yWorks.Graph.IGraph)">
      <param name="graph" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.RemoveEventHandlers(yWorks.Graph.IGraph)">
      <param name="graph" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)">
      <param name="port" />
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.EdgesAt(yWorks.Graph.IPortOwner,yWorks.Graph.AdjacencyTypes)">
      <param name="owner" />
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.OnGraphChanged(yWorks.Graph.IGraph,yWorks.Graph.IGraph)">
      <param name="oldGraph" />
      <param name="newGraph" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.Dispose" />
    <member name="M:yWorks.Graph.FilteredGraphWrapper.NodePredicateChanged(yWorks.Graph.INode)">
      <summary>
        <para>Should be called by clients if the <see cref="P:yWorks.Graph.FilteredGraphWrapper.NodePredicate" /> changed for the given node.</para>
      </summary>
      <param name="node">
        <para>The node.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.NodePredicateChanged">
      <summary>
        <para>Should be called by the client if the <see cref="P:yWorks.Graph.FilteredGraphWrapper.NodePredicate" /> changed for the nodes in the graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.EdgePredicateChanged(yWorks.Graph.IEdge)">
      <summary>
        <para>Should be called by the client if the <see cref="P:yWorks.Graph.FilteredGraphWrapper.EdgePredicate" /> changed for the given edge in the graph.</para>
      </summary>
      <param name="edge" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.EdgePredicateChanged">
      <summary>
        <para>Should be called by the client if the <see cref="P:yWorks.Graph.FilteredGraphWrapper.EdgePredicate" /> changed for the edge in the graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.Contains(yWorks.Graph.IModelItem)">
      <param name="item" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.CreateGroupNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">
      <param name="parent" />
      <param name="layout" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.SetParent(yWorks.Graph.INode,yWorks.Graph.INode)">
      <param name="node" />
      <param name="parent" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.CreateNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">
      <param name="parent" />
      <param name="layout" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.GetChildren(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.GetParent(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.IsGroupNode(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Graph.FilteredGraphWrapper.SetIsGroupNode(yWorks.Graph.INode,System.Boolean)">
      <param name="node" />
      <param name="isGroupNode" />
    </member>
    <member name="T:yWorks.Graph.FoldingEdgeConverterBase">
      <summary>
        <para>An abstract basic implementation of the <see cref="T:yWorks.Graph.IFoldingEdgeConverter" /> interface that may be derived from to create a customized <see cref="P:yWorks.Graph.FoldingManager.FoldingEdgeConverter" />.</para>
      </summary>
      <remarks>
        <para>This class provides default mechanisms and callbacks that can be used to set another style for folding edges, for the ports of folding edges, synchronizing the first label of a folding edge with the master edge, etc. Subclasses need to implement the <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)" /> method, only.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.DefaultFoldingEdgeConverter" />
      <seealso cref="T:yWorks.Graph.FoldingManager" />
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.CloneEdgeStyle">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.FoldingEdgeStyle" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone" />clone or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the folding edge style should be cloned; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.SourcePortStyle">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.Styles.IPortStyle" /> to use for the folding source port.</para>
      </summary>
      <remarks>
        <para>A value of <c>null</c> will leave the style property unmodified.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.CloneSourcePortStyle">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.SourcePortStyle" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone">clone</see> or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the port style should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.TargetPortStyle">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.Styles.IPortStyle" /> to use for the folding target port.</para>
      </summary>
      <remarks>
        <para>A value of <c>null</c> will leave the style property unmodified.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.CloneTargetPortStyle">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.TargetPortStyle" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone" />clone or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the port style should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.SourcePortLocationParameter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> to use for the source port of the folding edge.</para>
      </summary>
      <remarks>
        <para>Since the appearance of the folding edge may totally differ from the appearance of the master edge, the location of the source port may also be different. This property can be used to assign a different specific location parameter to the source port if the edge <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">is in folding state</see>. A value of <c>null</c> will leave the location parameter property unmodified. The default is <c>null</c></para>
      </remarks>
      <seealso cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateSourcePortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.CloneSourcePortLocationParameter">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.SourcePortLocationParameter" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone" />clone or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the port location parameter should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.TargetPortLocationParameter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> to use for the target port of the folding edge.</para>
      </summary>
      <remarks>
        <para>Since the appearance of the folding edge may totally differ from the appearance of the master edge, the location of the target port may also be different. This property can be used to assign a different specific location parameter to the target port if the edge <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">is in folding state</see>. A value of <c>null</c> will leave the location parameter property unmodified. The default is <c>null</c></para>
      </remarks>
      <seealso cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateTargetPortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.CloneTargetPortLocationParameter">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.TargetPortLocationParameter" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone" />clone or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the port location parameter should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.LabelStyle">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.Styles.ILabelStyle" /> to use for the first label of the folding edge.</para>
      </summary>
      <remarks>
        <para>This will only affect the folding edge if the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CopyFirstLabel" /> property is set to <c>true</c>.</para>
        <para>A value of <c>null</c> will leave the style property unmodified.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.CloneLabelStyle">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.LabelStyle" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone" />clone or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the label style should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.LabelLayoutParameter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> to use for the first label of the folding edge.</para>
      </summary>
      <remarks>
        <para>This will only affect the folding edge if the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CopyFirstLabel" /> property is set to <c>true</c>.</para>
        <para>A value of <c>null</c> will leave the label model parameter property unmodified.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.CloneLabelLayoutParameter">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.LabelLayoutParameter" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone" />clone or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the label layout parameter should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.FoldingEdgeStyle">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> to use for the folding edge.</para>
      </summary>
      <remarks>
        <para>Depending on the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CloneEdgeStyle" /> property this implementation will assign a <see cref="M:System.ICloneable.Clone" /> to the property or this instance.</para>
        <para>A value of <c>null</c> (the default) will leave the style property unmodified.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.ResetBends">
      <summary>
        <para>Gets or sets a value indicating whether to reset and clear the bends of a folding edge initially.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the folding edge should initially not contain any bends; <c>false</c> otherwise, which is the default.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeConverterBase.CopyFirstLabel">
      <summary>
        <para>Gets or sets a value indicating whether the first label of the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">master edge</see> should be recreated for the folding edge.</para>
      </summary>
      <remarks>
        <para>This setting can be used to initially create a copy of the first label of the master edge (if any) and subsequently synchronize the <see cref="P:yWorks.Graph.ILabel.Text" /> property with the master's edge label text.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the first label should be copied; <c>false</c> otherwise.</para>
      </value>
      <seealso cref="P:yWorks.Graph.FoldingEdgeConverterBase.LabelStyle" />
      <seealso cref="P:yWorks.Graph.FoldingEdgeConverterBase.LabelLayoutParameter" />
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)">
      <param name="factory" />
      <param name="foldingView" />
      <param name="masterEdge" />
      <param name="source" />
      <param name="sourceIsCollapsed" />
      <param name="target" />
      <param name="targetIsCollapsed" />
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Implements the <see cref="M:yWorks.Graph.IFoldingEdgeConverter.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> method and changes the folding edge appearance.</para>
      </summary>
      <remarks>
        <para>This method calls <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.SynchronizeLabels(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />, only.</para>
      </remarks>
      <param name="state" />
      <param name="foldingView" />
      <param name="foldingEdge" />
      <param name="masterEdges" />
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.SynchronizeLabels(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Called by <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> to synchronize the first label if <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CopyFirstLabel" /> is enabled.</para>
      </summary>
      <remarks>
        <para>This will adjust the label's text, preferred size and tag properties or remove the label if there is no master label or there is more than one master edge.</para>
      </remarks>
      <param name="state">
        <para>The viewstate of the edge to change.</para>
      </param>
      <param name="foldingView">
        <para>The folding view.</para>
      </param>
      <param name="foldingEdge">
        <para>The folding edge.</para>
      </param>
      <param name="masterEdges">
        <para>The master edges.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Implements the <see cref="M:yWorks.Graph.IFoldingEdgeConverter.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> method and initializes the folding edge appearance.</para>
      </summary>
      <remarks>
        <para>This method calls <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeStyle(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />, <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgePorts(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />, <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeBends(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />, <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeLabels(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />.</para>
      </remarks>
      <param name="state" />
      <param name="foldingView" />
      <param name="foldingEdge" />
      <param name="masterEdges" />
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeStyle(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback method that initializes the <see cref="P:yWorks.Graph.FoldingEdgeState.Style">style property</see> of the folding edge.</para>
      </summary>
      <remarks>
        <para>This implementation calls <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateEdgeStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> and <see cref="P:yWorks.Graph.FoldingEdgeState.Style">assigns</see> the style to the folding edge if a non-<c>null</c> value has been returned.</para>
      </remarks>
      <param name="state">
        <para>The viewstate to change.</para>
      </param>
      <param name="foldingView">
        <para>The folding view instance that has triggered the <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> call.</para>
      </param>
      <param name="foldingEdge">
        <para>The folding edge in the view that may be changed using the <paramref name="state" />.</para>
      </param>
      <param name="masterEdges">
        <para>The master edges that the folding edge represents.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.CreateEdgeStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> for use in <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeStyle(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="foldingEdge">
        <para>The folding edge in the view whose <see cref="P:yWorks.Graph.IEdge.Style" /> should be initialized.</para>
      </param>
      <param name="masterEdges">
        <para>The edges that are being represented by the folding edge.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.FoldingEdgeStyle" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CloneEdgeStyle" /> property. This method may return <c>null</c> to indicate that the default style should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgePorts(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback method that initializes the ports of the folding edge.</para>
      </summary>
      <remarks>
        <para>If the source port of the <paramref name="foldingEdge" /> <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">is in folding state</see>, this implementation calls <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateSourcePortStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> and <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateSourcePortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> and <see cref="P:yWorks.Graph.FoldingPortState.Style">assigns the style</see> and <see cref="P:yWorks.Graph.FoldingPortState.LocationParameter">location parameter</see> to the folding source port if non-<c>null</c> values have been returned. The same holds true for the target port where the <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateTargetPortStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> and <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateTargetPortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> callbacks are used.</para>
      </remarks>
      <param name="state">
        <para>The viewState to change.</para>
      </param>
      <param name="foldingView">
        <para>The folding view instance that has triggered the <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> call.</para>
      </param>
      <param name="foldingEdge">
        <para>The folding edge in the view that may be changed using the <paramref name="state" />.</para>
      </param>
      <param name="masterEdges">
        <para>The master edges that the folding edge represents.</para>
      </param>
      <seealso cref="P:yWorks.Graph.FoldingEdgeConverterBase.SourcePortStyle" />
      <seealso cref="P:yWorks.Graph.FoldingEdgeConverterBase.TargetPortStyle" />
      <seealso cref="P:yWorks.Graph.FoldingEdgeConverterBase.SourcePortLocationParameter" />
      <seealso cref="P:yWorks.Graph.FoldingEdgeConverterBase.TargetPortLocationParameter" />
      <seealso cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateSourcePortStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />
      <seealso cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateTargetPortStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />
      <seealso cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateSourcePortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />
      <seealso cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateTargetPortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.CreateSourcePortStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.Styles.IPortStyle" /> of the source port for use in <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgePorts(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="localEdge">
        <para>The local edge in the view whose source port's <see cref="P:yWorks.Graph.IPort.Style" /> should be initialized.</para>
      </param>
      <param name="masterEdges">
        <para>The master edges that the folding edge represents.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.SourcePortStyle" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CloneSourcePortStyle" /> property. This method may return <c>null</c> to indicate that the default style should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.CreateTargetPortStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.Styles.IPortStyle" /> of the target port for use in <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgePorts(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="localEdge">
        <para>The local edge in the view whose target port's <see cref="P:yWorks.Graph.IPort.Style" /> should be initialized.</para>
      </param>
      <param name="masterEdges">
        <para>The master edges that the folding edge represents.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.TargetPortStyle" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CloneTargetPortStyle" /> property. This method may return <c>null</c> to indicate that the default style should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.CreateSourcePortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> of the source port for use in <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgePorts(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="localEdge">
        <para>The local edge in the view whose source port's <see cref="P:yWorks.Graph.IPort.LocationParameter" /> should be initialized.</para>
      </param>
      <param name="masterEdges">
        <para>The master edges that the folding edge represents.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.SourcePortLocationParameter" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CloneSourcePortLocationParameter" /> property. This method may return <c>null</c> to indicate that the default port location parameter should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.CreateTargetPortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> of the target port for use in <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgePorts(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="localEdge">
        <para>The local edge in the view whose target port's <see cref="P:yWorks.Graph.IPort.LocationParameter" /> should be initialized.</para>
      </param>
      <param name="masterEdges">
        <para>The master edges that the folding edge represents.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.TargetPortLocationParameter" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CloneTargetPortLocationParameter" /> property. This method may return <c>null</c> to indicate that the default port location parameter should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeBends(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback method that initializes the bends of the folding edge.</para>
      </summary>
      <remarks>
        <para>This will call the <see cref="M:yWorks.Graph.FoldingEdgeState.ClearBends" /> callback if <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.ResetBends" /> is enabled.</para>
      </remarks>
      <param name="state">
        <para>The viewstate to change.</para>
      </param>
      <param name="foldingView">
        <para>The folding view instance that has triggered the <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> call.</para>
      </param>
      <param name="foldingEdge">
        <para>The folding edge in the view that may be changed using the <paramref name="state" />.</para>
      </param>
      <param name="masterEdges">
        <para>The master edges that the folding edge represents.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeLabels(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback method that initializes the initial labels of the folding edge.</para>
      </summary>
      <remarks>
        <para>This will first <see cref="M:yWorks.Graph.FoldingLabelOwnerState.ClearLabels">clear all the labels</see> and then try to copy the first label of the single master edge if <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CopyFirstLabel" /> is enabled. It will call <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateLabelStyle(yWorks.Graph.IFoldingView,yWorks.Graph.ILabel,yWorks.Graph.ILabel)" /> and <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.CreateLabelLayoutParameter(yWorks.Graph.IFoldingView,yWorks.Graph.ILabel,yWorks.Graph.ILabel)" /> and use the returned style and layout parameter if they are non-<c>null</c> when <see cref="M:yWorks.Graph.FoldingEdgeState.AddLabel(System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,yWorks.Geometry.SizeD,System.Object)">adding the label</see> on the folding edge.</para>
      </remarks>
      <param name="state">
        <para>The viewstate to change.</para>
      </param>
      <param name="foldingView">
        <para>The folding view instance that has triggered the <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> call.</para>
      </param>
      <param name="foldingEdge">
        <para>The folding edge in the view that may be changed using the <paramref name="state" />.</para>
      </param>
      <param name="masterEdges">
        <para>The master edges that the folding edge represents.</para>
      </param>
      <seealso cref="P:yWorks.Graph.FoldingEdgeConverterBase.LabelStyle" />
      <seealso cref="P:yWorks.Graph.FoldingEdgeConverterBase.LabelLayoutParameter" />
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.CreateLabelStyle(yWorks.Graph.IFoldingView,yWorks.Graph.ILabel,yWorks.Graph.ILabel)">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.Styles.ILabelStyle" /> for use in <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeLabels(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="localLabel">
        <para>The local label in the view whose <see cref="P:yWorks.Graph.ILabel.Style" /> should be initialized. May be <c>null</c> if the label style is requested for the label creation.</para>
      </param>
      <param name="masterLabel">
        <para>The label that is being represented by the folding label.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.LabelStyle" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CloneLabelStyle" /> property. This method may return <c>null</c> to indicate that the default style should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeConverterBase.CreateLabelLayoutParameter(yWorks.Graph.IFoldingView,yWorks.Graph.ILabel,yWorks.Graph.ILabel)">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> for use in <see cref="M:yWorks.Graph.FoldingEdgeConverterBase.InitializeFoldingEdgeLabels(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="localLabel">
        <para>The local label in the view whose <see cref="P:yWorks.Graph.ILabel.LayoutParameter" /> should be initialized. May be <c>null</c> if the label layout parameter is requested for the label creation.</para>
      </param>
      <param name="masterLabel">
        <para>The label that is being represented by the folding label.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.LabelLayoutParameter" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.CloneLabelLayoutParameter" /> property. This method may return <c>null</c> to indicate that the default label layout parameter should not be changed.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.DefaultFoldingEdgeConverter">
      <summary>
        <para>The default implementation of the <see cref="T:yWorks.Graph.IFoldingEdgeConverter" /> that is used by the <see cref="T:yWorks.Graph.FoldingManager" /> initially and can be customized to suit the application's needs.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.FoldingEdgeConverterBase" />
      <seealso cref="P:yWorks.Graph.DefaultFoldingEdgeConverter.ReuseMasterPorts" />
    </member>
    <member name="P:yWorks.Graph.DefaultFoldingEdgeConverter.ReuseMasterPorts">
      <summary>
        <para>Gets or sets a property that determines whether this implementation should reuse the ports of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> at non-<see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">folder</see> nodes for the folding edges.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Graph.IFoldingView">view</see> can be configured to use separate port instances for folding edges. This makes it possible to assign different styles and locations to source and target ports of folding edges, which may be desirable if the style and geometry of folding edges differs a lot from the style of the master edges. Folding edges may of course still connect to non-folder nodes at one of their ports. Setting this property to <c>true</c> will make the folding edge connect to the <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)">view</see> port instance. This property can be set to <c>true</c>, iff the graph model used is port-centric, i.e. each edge connects to specific ports and even folding edges should still connect to those specific view ports. The default value is <c>false</c></para>
      </remarks>
      <seealso cref="P:yWorks.Graph.DefaultFoldingEdgeConverter.ReuseFolderNodePorts" />
    </member>
    <member name="P:yWorks.Graph.DefaultFoldingEdgeConverter.ReuseFolderNodePorts">
      <summary>
        <para>Gets or sets a property that determines whether this implementation should reuse the ports of <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">folder</see> nodes for the folding edges.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Graph.IFoldingView">view</see> can be configured to use separate port instances for folding edges. This makes it possible to assign different styles and locations to source and target ports of folding edges, which may be desirable if the style and geometry of folding edges differs a lot from the style of the master edges. Folder nodes (<see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> group nodes), will have all of their master's ports <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)">represented</see> in the view. This property can be used to make folding edges that connect to the master ports connect to these folding port instances instead of creating extra folding ports for the edges. Note that ports can only be automatically reused by folding edges if they still connect to the same nodes. Otherwise the view will have to create new folding ports to let the edges connect to the representing adjacent nodes. This property can be set to <c>true</c>, iff the graph model used is port-centric, i.e. each edge connects to specific ports and even folding edges should still connect to those specific port instances, if possible. The default value is <c>false</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.DefaultFoldingEdgeConverter.ReuseMasterPorts" />
    </member>
    <member name="M:yWorks.Graph.DefaultFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Actually adds the folding edge as a <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddAsSeparateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort)">separate edge</see> to the view, reusing existing <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)">view</see> ports of the original source and target port, if <see cref="P:yWorks.Graph.DefaultFoldingEdgeConverter.ReuseMasterPorts" /> is enabled and that is possible for the given edge.</para>
      </summary>
      <param name="factory">
        <para>The <see cref="T:yWorks.Graph.IFoldingEdgeFactory" /> implementation.</para>
      </param>
      <param name="foldingView">
        <para>The instance into which the folding edge is going to be inserted.</para>
      </param>
      <param name="masterEdge">
        <para>The edge from the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> that needs to be represented by a folding edge.</para>
      </param>
      <param name="source">
        <para>The source node that belongs to the <see cref="T:yWorks.Graph.IFoldingView" /> graph that will act as the local view node of the actual source node.</para>
      </param>
      <param name="sourceIsCollapsed">
        <para>Determines whether the <paramref name="source" /> is currently a folder node.</para>
      </param>
      <param name="target">
        <para>The target node that belongs to the <see cref="T:yWorks.Graph.IFoldingView" /> graph that will act as the local view node of the actual target node.</para>
      </param>
      <param name="targetIsCollapsed">
        <para>Determines whether the <paramref name="target" /> is currently a folder node.</para>
      </param>
      <returns>
        <para>The edge as returned by the call to <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddAsSeparateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort)" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.DefaultFolderNodeConverter">
      <summary>
        <para>Simple default implementation of the <see cref="T:yWorks.Graph.IFolderNodeConverter" /> interface that is used by the <see cref="T:yWorks.Graph.FoldingManager" />'s <see cref="P:yWorks.Graph.FoldingManager.FolderNodeConverter" /> property.</para>
      </summary>
      <remarks>
        <para>This class has a couple of properties that can be adjusted to customize the behavior. Also, it contains a number of callback methods for conveniently overriding the implementation in custom sub classes.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.FoldingManager" />
      <seealso cref="T:yWorks.Graph.IFolderNodeConverter" />
      <seealso cref="T:yWorks.Graph.DefaultFoldingEdgeConverter" />
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.#ctor">
      <summary>
        <para>Initializes a new instance of this class with default values.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.#ctor(yWorks.Graph.INodeDefaults)">
      <summary>
        <para>Initializes a new instance of this class using the values provided by the <paramref name="collapsedDefaults" /> parameter.</para>
      </summary>
      <param name="collapsedDefaults" />
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.FolderNodeStyle">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.Styles.INodeStyle" /> to use for the <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> group nodes.</para>
      </summary>
      <remarks>
        <para>Depending on the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.CloneNodeStyle" /> property this implementation will assign a <see cref="M:System.ICloneable.Clone" /> to the property or this instance. The default is <c>null</c></para>
        <para>A value of <c>null</c> will leave the style property unmodified.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.CopyFirstLabel">
      <summary>
        <para>Gets or sets a value indicating whether the first label of the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">master group node</see> should be recreated for the collapsed group node instance.</para>
      </summary>
      <remarks>
        <para>This setting can be used to initially create a copy of the first label of the master group node (if any) and subsequently synchronize the <see cref="P:yWorks.Graph.ILabel.Text" /> property with the master's node label text. Set it to <c>true</c> if the first label should be copied; <c>false</c> otherwise. The default is <c>false</c>.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.DefaultFolderNodeConverter.LabelStyle" />
      <seealso cref="P:yWorks.Graph.DefaultFolderNodeConverter.LabelLayoutParameter" />
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.LabelStyle">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.Styles.ILabelStyle" /> to use for the first label of the collapsed group nodes.</para>
      </summary>
      <remarks>
        <para>This will only affect the collapsed group node if the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.CopyFirstLabel" /> property is set to <c>true</c>. The default is <c>null</c></para>
        <para>A value of <c>null</c> will leave the style property unmodified.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.DefaultFolderNodeConverter.CopyFirstLabel" />
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.LabelLayoutParameter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> to use for the first label of the collapsed group node.</para>
      </summary>
      <remarks>
        <para>This will only affect the folder node if the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.CopyFirstLabel" /> property is set to <c>true</c>. The default is <c>null</c></para>
        <para>A value of <c>null</c> will leave the label model parameter property unmodified.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.DefaultFolderNodeConverter.CopyFirstLabel" />
      <seealso cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeLabels(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.PortStyle">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.Styles.IPortStyle" /> to use for the ports at the collapsed group node that <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)">represent</see> the ports of the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">master group node</see> in the collapsed state.</para>
      </summary>
      <remarks>
        <para>Since the appearance of the collapsed group node may totally differ from the appearance of the expanded group node, the appearance of the ports may also be different. This property can be used to assign a different specific style to the ports if the node is in collapsed state. A value of <c>null</c> will leave the style property unmodified. The default is <c>null</c></para>
      </remarks>
      <seealso cref="M:yWorks.Graph.DefaultFolderNodeConverter.CreatePortStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IPort,yWorks.Graph.IPort)" />
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.FolderNodeSize">
      <summary>
        <para>Sets the initial size of the <see cref="P:yWorks.Graph.INode.Layout" /> of the collapsed group node that will be assigned during the <see cref="M:yWorks.Graph.IFolderNodeConverter.InitializeFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">creation</see> of the appearance of the collapsed group node.</para>
      </summary>
      <remarks>
        <para>Since the <see cref="P:yWorks.Graph.INode.Layout" /> of an <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)">expanded</see> group node normally encompasses the child nodes, it will have quite a large size. Since the contents of a collapsed group node are not visible, there is no need for the collapsed group node to encompass the area of its children. Thus the size can be different and most of the time should be smaller. Setting this property to non-<c>null</c> values will make the initial layout of the collapsed node become the given size assigned. The default is <c>null</c></para>
      </remarks>
      <seealso cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeLayout(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.PortLocationParameter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> to use for the ports at the collapsed group node that <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)">represent</see> the ports of the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">master group node</see> in the collapsed state.</para>
      </summary>
      <remarks>
        <para>Since the appearance of the collapsed group node may totally differ from the appearance of the expanded group node, the appearance of the ports may also be different. This property can be used to assign a different specific location parameter to the ports if the node is in collapsed state. A value of <c>null</c> will leave the location parameter property unmodified. The default is <c>null</c></para>
      </remarks>
      <seealso cref="M:yWorks.Graph.DefaultFolderNodeConverter.CreatePortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IPort,yWorks.Graph.IPort)" />
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.CloneNodeStyle">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.FolderNodeStyle" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone" />clone or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the folder node style should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.ClonePortStyle">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.PortStyle" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone" />clone or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the port style should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.ClonePortLocationParameter">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.PortLocationParameter" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone">clone</see> or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the port location parameter should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.CloneLabelStyle">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.LabelStyle" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone" />clone or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the label style should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="P:yWorks.Graph.DefaultFolderNodeConverter.CloneLabelLayoutParameter">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.LabelLayoutParameter" /> instance should be assigned as a <see cref="M:System.ICloneable.Clone" />clone or not.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the label layout parameter should be cloned; <c>false</c> otherwise. The default is <c>false</c></para>
      </value>
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.UpdateFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Implements the <see cref="M:yWorks.Graph.IFolderNodeConverter.UpdateFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" /> method and changes the folder node appearance.</para>
      </summary>
      <remarks>
        <para>This method calls <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.SynchronizeLabels(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />, only.</para>
      </remarks>
      <param name="state" />
      <param name="foldingView" />
      <param name="viewNode" />
      <param name="masterNode" />
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.SynchronizeLabels(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Called by <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.UpdateFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" /> to synchronize the first label if <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.CopyFirstLabel" /> is enabled.</para>
      </summary>
      <remarks>
        <para>This will adjust the label text property or remove the label if there is no master label.</para>
      </remarks>
      <param name="state">
        <para>The node view state whose labels should be synchronized.</para>
      </param>
      <param name="foldingView">
        <para>The folding view.</para>
      </param>
      <param name="viewNode">
        <para>The local node instance.</para>
      </param>
      <param name="masterNode">
        <para>The master node.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Implements the <see cref="M:yWorks.Graph.IFolderNodeConverter.InitializeFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" /> method and initializes the appearance of the collapsed group node.</para>
      </summary>
      <remarks>
        <para>This method calls <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeStyle(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />, <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeLabels(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />, <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeLayout(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />, and <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodePorts(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />.</para>
      </remarks>
      <param name="state" />
      <param name="foldingView" />
      <param name="viewNode" />
      <param name="masterNode" />
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodePorts(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Called by <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" /> to initialize the appearance of the <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)">representatives</see> of the master ports at the collapsed group node.</para>
      </summary>
      <remarks>
        <para>This method will call <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.CreatePortStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IPort,yWorks.Graph.IPort)" /> and <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.CreatePortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IPort,yWorks.Graph.IPort)" /> for each port at the group node and assign the returned style and location parameter if they are non-<c>null</c>.</para>
      </remarks>
      <param name="state">
        <para>The node view state whose ports should be synchronized.</para>
      </param>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="viewNode">
        <para>The local group node.</para>
      </param>
      <param name="masterNode">
        <para>The master group node.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeStyle(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Callback method that initializes the <see cref="P:yWorks.Graph.FolderNodeState.Style">style property</see> of the collapsed group node.</para>
      </summary>
      <remarks>
        <para>This implementation calls <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.CreateNodeStyle(yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" /> and <see cref="P:yWorks.Graph.FolderNodeState.Style">assigns</see> the style to the group node if a non-<c>null</c> value has been returned.</para>
      </remarks>
      <param name="state">
        <para>The node view state whose style should be synchronized.</para>
      </param>
      <param name="foldingView">
        <para>The folding view instance that has triggered the <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" /> call.</para>
      </param>
      <param name="viewNode">
        <para>The local node in the view that may be changed using the <see cref="T:yWorks.Graph.FolderNodeState" />.</para>
      </param>
      <param name="masterNode">
        <para>The master node that the local folder node represents.</para>
      </param>
      <seealso cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.CreateNodeStyle(yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.Styles.INodeStyle" /> for use in <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeStyle(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="viewNode">
        <para>The local folder node in the view whose <see cref="P:yWorks.Graph.INode.Style" /> should be initialized.</para>
      </param>
      <param name="masterNode">
        <para>The node that is being represented by the folder node.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.FolderNodeStyle" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.CloneNodeStyle" /> property. This method may return <c>null</c> to indicate that the default style should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.CreatePortStyle(yWorks.Graph.IFoldingView,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.Styles.IPortStyle" /> for use in <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodePorts(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="localPort">
        <para>The local port in the view whose <see cref="P:yWorks.Graph.IPort.Style" /> should be initialized.</para>
      </param>
      <param name="masterPort">
        <para>The port that is being represented by the folding port.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.PortStyle" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.ClonePortStyle" /> property. This method may return <c>null</c> to indicate that the default style should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.CreatePortLocationParameter(yWorks.Graph.IFoldingView,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> for use in <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodePorts(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="localPort">
        <para>The local port in the view whose <see cref="P:yWorks.Graph.IPort.LocationParameter" /> should be initialized.</para>
      </param>
      <param name="masterPort">
        <para>The port that is being represented by the folding port.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.PortLocationParameter" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.ClonePortLocationParameter" /> property. This method may return <c>null</c> to indicate that the default port location parameter should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeLabels(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Callback method that initializes the initial labels of the collapsed group node.</para>
      </summary>
      <remarks>
        <para>This will try to copy the first label of the master node if <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.CopyFirstLabel" /> is enabled. It will call <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.CreateLabelStyle(yWorks.Graph.IFoldingView,yWorks.Graph.ILabel,yWorks.Graph.ILabel)" /> and <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.CreateLabelLayoutParameter(yWorks.Graph.IFoldingView,yWorks.Graph.ILabel,yWorks.Graph.ILabel)" /> and use the returned style and layout parameter if they are non-<c>null</c> when <see cref="M:yWorks.Graph.FolderNodeState.AddLabel(System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,yWorks.Geometry.SizeD,System.Object)">adding the label</see> on the folder node.</para>
      </remarks>
      <param name="state">
        <para>The node view state whose labels should be synchronized.</para>
      </param>
      <param name="foldingView">
        <para>The folding view instance that has triggered the <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" /> call.</para>
      </param>
      <param name="viewNode">
        <para>The collapsed group node in the view that may be changed using the <see cref="T:yWorks.Graph.FolderNodeState" />.</para>
      </param>
      <param name="masterNode">
        <para>The master node that the folder node represents.</para>
      </param>
      <seealso cref="P:yWorks.Graph.DefaultFolderNodeConverter.LabelStyle" />
      <seealso cref="P:yWorks.Graph.DefaultFolderNodeConverter.LabelLayoutParameter" />
      <seealso cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.CreateLabelStyle(yWorks.Graph.IFoldingView,yWorks.Graph.ILabel,yWorks.Graph.ILabel)">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.Styles.ILabelStyle" /> for use in <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeLabels(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="localLabel">
        <para>The local label in the view whose <see cref="P:yWorks.Graph.ILabel.Style" /> should be initialized. May be <c>null</c> if the label style is requested for the label creation.</para>
      </param>
      <param name="masterLabel">
        <para>The label that is being represented by the folding label.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.LabelStyle" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.CloneLabelStyle" /> property. This method may return <c>null</c> to indicate that the default style should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.CreateLabelLayoutParameter(yWorks.Graph.IFoldingView,yWorks.Graph.ILabel,yWorks.Graph.ILabel)">
      <summary>
        <para>Callback factory method that creates the <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> for use in <see cref="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeLabels(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />.</para>
      </summary>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="localLabel">
        <para>The local label in the view whose <see cref="P:yWorks.Graph.ILabel.LayoutParameter" /> should be initialized. May be <c>null</c> if the label layout parameter is requested for the label creation.</para>
      </param>
      <param name="masterLabel">
        <para>The label that is being represented by the folding label.</para>
      </param>
      <returns>
        <para>The <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.LabelLayoutParameter" /> or a <see cref="M:System.ICloneable.Clone" /> of it depending on the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.CloneLabelLayoutParameter" /> property. This method may return <c>null</c> to indicate that the default label layout parameter should not be changed.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DefaultFolderNodeConverter.InitializeFolderNodeLayout(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Callback method that initializes the <see cref="P:yWorks.Graph.INode.Layout" /> of the collapsed group node.</para>
      </summary>
      <remarks>
        <para>This implementation will <see cref="P:yWorks.Graph.FolderNodeState.Layout">set the bounds</see> of the nodes in such a way that the size will be that of the <see cref="P:yWorks.Graph.DefaultFolderNodeConverter.FolderNodeSize" /> property (if non-<c>null</c>) but not smaller than the <see cref="M:yWorks.Controls.Input.INodeSizeConstraintProvider.GetMinimumSize(yWorks.Graph.INode)">minimum</see> size that is reported by a potential <see cref="T:yWorks.Controls.Input.INodeSizeConstraintProvider" /> for <see cref="T:yWorks.Graph.INode" />s that has been found in the <see cref="T:yWorks.Graph.ILookup" /> of the <paramref name="viewNode" />.</para>
      </remarks>
      <param name="state">
        <para>The node view state whose layout should be synchronized.</para>
      </param>
      <param name="foldingView">
        <para>The folding view instance.</para>
      </param>
      <param name="viewNode">
        <para>The local collapsed group node to change.</para>
      </param>
      <param name="masterNode">
        <para>The master node that is represented by the local group node.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.ExcludingFoldingEdgeConverter">
      <summary>
        <para>A simple implementation of the <see cref="T:yWorks.Graph.IFoldingEdgeConverter" /> interface for use in the <see cref="P:yWorks.Graph.FoldingManager.FoldingEdgeConverter" /> property, that will prevent folding edges from appearing in the <see cref="T:yWorks.Graph.IFoldingView">view</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.ExcludingFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Always calls <see cref="M:yWorks.Graph.IFoldingEdgeFactory.ExcludeFoldingEdge" /></para>
      </summary>
      <param name="factory" />
      <param name="foldingView" />
      <param name="masterEdge" />
      <param name="source" />
      <param name="sourceIsCollapsed" />
      <param name="target" />
      <param name="targetIsCollapsed" />
    </member>
    <member name="M:yWorks.Graph.ExcludingFoldingEdgeConverter.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Does nothing and should not normally be called by the view since all folding edges are excluded from it.</para>
      </summary>
      <param name="state" />
      <param name="foldingView" />
      <param name="foldingEdge" />
      <param name="masterEdges" />
    </member>
    <member name="M:yWorks.Graph.ExcludingFoldingEdgeConverter.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Does nothing and should not normally be called by the view since all folding edges are excluded from it.</para>
      </summary>
      <param name="state" />
      <param name="foldingView" />
      <param name="foldingEdge" />
      <param name="masterEdges" />
    </member>
    <member name="T:yWorks.Graph.MergingFoldingEdgeConverter">
      <summary>
        <para>A simple implementation of the <see cref="T:yWorks.Graph.IFoldingEdgeConverter" /> interface that will make the <see cref="T:yWorks.Graph.IFoldingView">view</see> contain at most one folding edge between each pair of nodes by letting a single folding edge represent all master edges.</para>
      </summary>
      <remarks>
        <para>This implementation by default, will have the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.SourcePortLocationParameter" /> and the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.TargetPortLocationParameter" /> properties set to <see cref="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.NodeCenterAnchored" /> and the <see cref="P:yWorks.Graph.FoldingEdgeConverterBase.ResetBends" /> property set to <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.MergingFoldingEdgeConverter.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.MergingFoldingEdgeConverter" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.MergingFoldingEdgeConverter.IgnoreEdgeDirection">
      <summary>
        <para>Gets or sets a value indicating whether edge direction should be ignored for the determination of the <see cref="M:yWorks.Graph.IFoldingEdgeFactory.GetExistingFoldingEdges(System.Boolean)">existing folding edges</see>.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge direction should be ignored; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.MergingFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Tries to add the folding edge to an <see cref="M:yWorks.Graph.IFoldingEdgeFactory.GetExistingFoldingEdges(System.Boolean)">existing</see> folding edge, considering the <see cref="P:yWorks.Graph.MergingFoldingEdgeConverter.IgnoreEdgeDirection" /> property.</para>
      </summary>
      <remarks>
        <para>If this is the first folding edge that connects the source and target node, this method will use the <see cref="M:yWorks.Graph.MergingFoldingEdgeConverter.AddFirstSeparateEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)" /> factory to create the initial representative.</para>
      </remarks>
      <param name="factory" />
      <param name="foldingView" />
      <param name="masterEdge" />
      <param name="source" />
      <param name="sourceIsCollapsed" />
      <param name="target" />
      <param name="targetIsCollapsed" />
    </member>
    <member name="M:yWorks.Graph.MergingFoldingEdgeConverter.AddFirstSeparateEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Adds the first separate edge to the source and target node pair using the <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddAsSeparateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort)" /> method.</para>
      </summary>
      <param name="factory" />
      <param name="foldingView" />
      <param name="masterEdge" />
      <param name="viewSourceNode" />
      <param name="sourceIsCollapsed" />
      <param name="targetSourceNode" />
      <param name="targetIsCollapsed" />
    </member>
    <member name="T:yWorks.Graph.FoldingManager">
      <summary>
        <para>This class adds folding support to <see cref="T:yWorks.Graph.IGraph" /> implementations.</para>
      </summary>
      <remarks>
        <para>This implementation manages the varying states nodes and edges can have in different views and during different <see cref="M:yWorks.Graph.IFoldingView.IsExpanded(yWorks.Graph.INode)">collapsed/expanded</see> states of the nodes. Create an instance of this class for a given <see cref="T:yWorks.Graph.IGraph" /> and use the <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})" /> methods to create an <see cref="T:yWorks.Graph.IGraph" /> implementation that provides a view of a subset of the graph, where <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">group nodes</see> can be <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> and <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)">expanded</see>.</para>
        <para>This class can be used to <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})">create folding views</see> of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />, where group nodes can appear as <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> group nodes with their contents hidden. Edges that connect to elements inside collapsed group nodes can be <see cref="P:yWorks.Graph.FoldingManager.FoldingEdgeConverter">configured</see> to be represented by <see cref="T:yWorks.Graph.FoldingEdgeStateId">folding edges</see> in the views. The process of converting one or more true edges from the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> to zero or more folding edges can be customized, as well as the process of <see cref="P:yWorks.Graph.FoldingManager.FolderNodeConverter">converting</see> an expanded group node to a collapsed group node.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IFoldingView" />
      <seealso cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})" />
    </member>
    <member name="M:yWorks.Graph.FoldingManager.#ctor">
      <summary>
        <para>Creates a new manager with a default backing graph implementation.</para>
      </summary>
      <remarks>
        <para>Use <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})" /> to create a view that supports the <see cref="T:yWorks.Graph.IFoldingView" /> interface for displaying and working with a collapsible graph structure.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})" />
      <seealso cref="P:yWorks.Graph.FoldingManager.MasterGraph" />
    </member>
    <member name="M:yWorks.Graph.FoldingManager.#ctor(yWorks.Graph.IGraph)">
      <summary>
        <para>Creates a manager instance for the given <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> to create views on top of it that support folding operations.</para>
      </summary>
      <param name="masterGraph">
        <para>The graph to use as the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
      </param>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>masterGraph</c> is null.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.FoldingManager.Dispose">
      <summary>
        <para>Disposes of this instance.</para>
      </summary>
      <remarks>
        <para>This will disconnect the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> from the previously created <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})">managed views</see>. Also each view will be <see cref="M:yWorks.Graph.IFoldingView.Dispose">disposed</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FoldingManager.FoldingEdgeConverter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.IFoldingEdgeConverter" /> implementation that is used to create/convert and modify the <see cref="T:yWorks.Graph.FoldingEdgeStateId">folding edges</see> inside the view instances.</para>
      </summary>
      <remarks>
        <para>The converter instance will be used to <see cref="M:yWorks.Graph.IFoldingEdgeConverter.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">create the initial</see> and <see cref="M:yWorks.Graph.IFoldingEdgeConverter.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">change</see> the appearance of the folding edges as soon as they appear in a view.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.DefaultFoldingEdgeConverter" />
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>value</c> is null.</para>
      </exception>
    </member>
    <member name="P:yWorks.Graph.FoldingManager.FolderNodeConverter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.IFolderNodeConverter" /> implementation that is used to create/convert and modify the folder nodes inside the view instances.</para>
      </summary>
      <remarks>
        <para>The converter instance will be used to <see cref="M:yWorks.Graph.IFolderNodeConverter.InitializeFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">create the initial</see> and <see cref="M:yWorks.Graph.IFolderNodeConverter.UpdateFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">change</see> the appearance of the folder nodes as soon as they appear in a view.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.DefaultFolderNodeConverter" />
    </member>
    <member name="P:yWorks.Graph.FoldingManager.MasterGraph">
      <summary>
        <para>Gets the master <see cref="T:yWorks.Graph.IGraph" /> instance that holds the complete model in expanded group node state.</para>
      </summary>
      <remarks>
        <para>This graph contains all non-folding edges and expanded group nodes, no folding edges and no collapsed group nodes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.FoldingManager.PrepareFoldingView(yWorks.Graph.IFoldingView)">
      <summary>
        <para>Callback that can be overridden by subclasses to prepare the <see cref="T:yWorks.Graph.IFoldingView" /> instance right before it will be initialized with a copy of the elements in the initial graph.</para>
      </summary>
      <remarks>
        <para>Subclasses could override this method to register additional <see cref="T:yWorks.Graph.IMapper`2" /> instances with the graph instance or add <see cref="T:yWorks.Graph.IContextLookupChainLink" />s via the <see cref="T:yWorks.Graph.ILookupDecorator" /> of the <see cref="P:yWorks.Graph.IFoldingView.Graph" /> to the instance if they are essential for the initial creation of the elements in the view instance. Overriding methods should always consider to call the base class implementation, first.</para>
      </remarks>
      <param name="foldingView">
        <para>The graph view that has just been created but is still empty.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})">
      <summary>
        <para>Creates a separate view instance of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> which is a synchronized copy of a subset of the items from the master graph.</para>
      </summary>
      <remarks>
        <para>This method will create a new instance of an <see cref="T:yWorks.Graph.IGraph" /> that is constructed as a synchronized copy of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />. That instance can be obtained from the <see cref="P:yWorks.Graph.IFoldingView.Graph" /> property of the returned <see cref="T:yWorks.Graph.IFoldingView" /> implementation. The graph instance will provide an <see cref="T:yWorks.Graph.IFoldingView" /> instance in its <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> mechanism:</para>
        <para>This instance can be used to gain access to this <see cref="P:yWorks.Graph.IFoldingView.Manager">manager instance</see> and the folding operations.</para>
        <para>Note that the entities that are contained in the returned graph instance are not the same instances as the original "master" entities in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />. However they share the same properties (style, <see cref="P:yWorks.Graph.ITagOwner.Tag">tag</see>, <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter">parameters</see>, and <see cref="P:yWorks.Graph.INode.Layout">geometry</see>). For collapsed group nodes and view edges, there is a separate set of properties available for each possible state combination. The <see cref="M:yWorks.Graph.FoldingManager.GetFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)" /> method for edges and the <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)" /> method for nodes provide access to that state while it is not being displayed in a view.</para>
      </remarks>
      <param name="root">
        <para>A group node or the root of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> whose contents will be displayed in the view.</para>
      </param>
      <param name="isExpanded">
        <para>A predicate that can be provided to the view that will be used as a callback to determine the initial <see cref="M:yWorks.Graph.IFoldingView.IsExpanded(yWorks.Graph.INode)">expansion state</see> of group nodes in the view.</para>
      </param>
      <returns>
        <para>A new graph instance that represents a synchronized view on the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.FoldingManager.PrepareFoldingView(yWorks.Graph.IFoldingView)" />
    </member>
    <member name="P:yWorks.Graph.FoldingManager.Views">
      <summary>
        <para>Gets all currently known <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})">view instances</see> that are managed by this instance.</para>
      </summary>
      <seealso cref="P:yWorks.Graph.IFoldingView.Graph" />
    </member>
    <member name="M:yWorks.Graph.FoldingManager.HasFolderNodeState(yWorks.Graph.INode)">
      <summary>
        <para>Determines whether for the given <paramref name="masterNode" /> this manager has stored associated folder node state.</para>
      </summary>
      <remarks>
        <para>The manager does not necessarily have folder node state for folder nodes if that specific state has never been requested by a <see cref="T:yWorks.Graph.IFoldingView">view</see> because it has never been visualized. This method indicates whether there is state information available for the given master node.</para>
      </remarks>
      <param name="masterNode">
        <para>The master node for which the state is requested.</para>
      </param>
      <returns>
        <para>Whether <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)" /> would return existing state information.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Graph.FoldingManager.HasFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)">
      <summary>
        <para>Determines whether for the given <see cref="T:yWorks.Graph.FoldingEdgeStateId" /> this manager has stored associated view local state.</para>
      </summary>
      <remarks>
        <para>The manager does not necessarily have a <see cref="T:yWorks.Graph.FoldingEdgeState" /> for folding elements if that specific state has never been requested by a <see cref="T:yWorks.Graph.IFoldingView" /> because it has never been visualized. This method indicates whether there is state information available for the given id.</para>
      </remarks>
      <param name="id">
        <para>The id for which state is requested.</para>
      </param>
      <returns>
        <para>Whether <see cref="M:yWorks.Graph.FoldingManager.GetFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)" /> would return existing state information.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.FoldingManager.GetFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)" />
    </member>
    <member name="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)">
      <summary>
        <para>Provides access to the folder node state of a node.</para>
      </summary>
      <remarks>
        <para>This method can be used to query the collapsed state of a node, even if the node is currently not present in any managed view or the node is in fact expanded in all views.</para>
      </remarks>
      <param name="masterNode">
        <para>The node in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> for which the state should be returned.</para>
      </param>
      <returns>
        <para>A state holder implementation of a node, which is not part of any graph.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>The master node does not belong to the managed graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.FoldingManager.GetFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)">
      <summary>
        <para>Return a data container implementation that is not part of any actual <see cref="T:yWorks.Graph.IGraph" /> that describes the state of the edge for the given <see cref="T:yWorks.Graph.FoldingEdgeStateId" />.</para>
      </summary>
      <remarks>
        <para>This method can be used to query the state of an edge that is either not currently visible in any <see cref="P:yWorks.Graph.FoldingManager.Views">view</see> or connects to different source and target nodes because of the <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> states of the nodes and their parents in the view.</para>
      </remarks>
      <param name="id">
        <para>The ID of the folding edge for which the folding state should be returned.</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Graph.FoldingEdgeState" /> that can be used to query and change the properties of the edge.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)" />
      <seealso cref="T:yWorks.Graph.FoldingEdgeStateId" />
    </member>
    <member name="M:yWorks.Graph.FoldingManager.UpdateFoldingEdgeStates(yWorks.Graph.IEdge)">
      <summary>
        <para>Triggers a call to <see cref="M:yWorks.Graph.IFoldingEdgeConverter.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> for all folder edges that <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)">represent</see> the given <paramref name="masterEdge" />.</para>
      </summary>
      <remarks>
        <para>In all <see cref="P:yWorks.Graph.FoldingManager.Views" /> that are currrently showing the view edge for the provided master edge, the <see cref="M:yWorks.Graph.FoldingManager.GetFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)">view-local state</see> will be updated via a call to the <see cref="T:yWorks.Graph.IFoldingEdgeConverter" />'s <see cref="M:yWorks.Graph.IFoldingEdgeConverter.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> method.</para>
        <para>This method is useful in situations where a change in the data on the master graph did not automatically trigger a call to the converter. Using this method, the state of the representing edges in the views can be synchronized according to the logic in the <see cref="T:yWorks.Graph.IFoldingEdgeConverter" /> implementation.</para>
      </remarks>
      <param name="masterEdge">
        <para>The master edge that belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
      </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>If the provided master edge does not belong to the master graph.</para>
      </exception>
      <seealso cref="M:yWorks.Graph.FoldingManager.UpdateFolderNodeStates(yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Graph.FoldingManager.UpdateFolderNodeStates(yWorks.Graph.INode)">
      <summary>
        <para>Triggers a call to <see cref="M:yWorks.Graph.IFolderNodeConverter.UpdateFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" /> for all view nodes that <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)">represent</see> the given <paramref name="masterNode" /> in its collapsed state.</para>
      </summary>
      <remarks>
        <para>In all <see cref="P:yWorks.Graph.FoldingManager.Views" /> that are currrently showing the node in collapsed state, the <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)">view-local state</see> will be updated via a call to the <see cref="T:yWorks.Graph.IFolderNodeConverter" />'s <see cref="M:yWorks.Graph.IFolderNodeConverter.UpdateFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" /> method.</para>
        <para>Note that all <see cref="P:yWorks.Graph.FoldingManager.Views" /> share the same <see cref="T:yWorks.Graph.FolderNodeState" /> for the <paramref name="masterNode" />.</para>
        <para>This method is useful in situations where a change in the data on the master graph did not automatically trigger a call to the converter. Using this method, the state of the collapsed nodes in the views can be synchronized according to the logic in the <see cref="T:yWorks.Graph.IFolderNodeConverter" /> implementation.</para>
      </remarks>
      <param name="masterNode">
        <para>The master node that belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
      </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>If the provided master node does not belong to the master graph.</para>
      </exception>
      <seealso cref="M:yWorks.Graph.FoldingManager.UpdateFoldingEdgeStates(yWorks.Graph.IEdge)" />
    </member>
    <member name="T:yWorks.Graph.FoldingBendState">
      <summary>
        <para>A data container representing the state of a bend of a <see cref="T:yWorks.Graph.FoldingEdgeState" />.</para>
      </summary>
      <remarks>
        <para>When the properties of the state are changed, these changes are reflected immediately in the <see cref="P:yWorks.Graph.FoldingManager.Views" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.FoldingBendState.Location">
      <summary>
        <para>Gets or sets the location of the bend.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingBendState.Tag">
      <summary>
        <para>Gets or sets the tag of the bend.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingBendState.Index">
      <summary>
        <para>Gets the bend's index in the <see cref="P:yWorks.Graph.FoldingEdgeState.Bends" /> of its owner.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FoldingBendState.AsBend">
      <summary>
        <para>Returns an <see cref="T:yWorks.Graph.IBend" /> instance which represents this bend state.</para>
      </summary>
      <remarks>
        <para>The returned bend is not present in any graph but may be passed to <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)" /> to get the bend state's view bend in the <see cref="P:yWorks.Graph.IFoldingView.Graph">folding view graph</see>.</para>
      </remarks>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IBend" /> instance which represents this bend state.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.FoldingEdgeState">
      <summary>
        <para>A data container representing the state of an edge whose source and/or target node are collapsed.</para>
      </summary>
      <remarks>
        <para>When the properties of the state are changed, these changes are reflected immediately in the <see cref="P:yWorks.Graph.FoldingManager.Views" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.FoldingEdgeStateId" />
      <seealso cref="M:yWorks.Graph.FoldingManager.GetFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)" />
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeState.Tag">
      <summary>
        <para>Gets or sets the tag of the edge.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeState.Bends">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.FoldingBendState" />s of this state.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeState.SourcePort">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.FoldingPortState" /> which represents the source port of this edge state.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeState.TargetPort">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.FoldingPortState" /> which represents the target port of this edge state.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingEdgeState.Style">
      <summary>
        <para>Gets or sets the style of this edge.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeState.AddBend(yWorks.Geometry.PointD,System.Int32)">
      <summary>
        <para>Adds a new <see cref="T:yWorks.Graph.FoldingBendState" /> to this edge state at the given <paramref name="index" /> and <paramref name="location" />.</para>
      </summary>
      <param name="location">
        <para>The location of the new bend state.</para>
      </param>
      <param name="index">
        <para>The index the bend state shall be inserted in the <see cref="P:yWorks.Graph.FoldingEdgeState.Bends" />; a negative value (which is the default) indicates that the bend should be appended to the end of the list of bends.</para>
      </param>
      <returns>
        <para>The newly added bend state.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeState.Remove(yWorks.Graph.FoldingBendState)">
      <summary>
        <para>Removes the <paramref name="bend" /> from this edge state.</para>
      </summary>
      <param name="bend">
        <para>The bend to remove.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>Thrown if the <paramref name="bend" /> doesn't belong to this edge state.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeState.ClearBends">
      <summary>
        <para>Removes all <see cref="P:yWorks.Graph.FoldingEdgeState.Bends" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeState.AddLabel(System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,yWorks.Geometry.SizeD,System.Object)">
      <param name="text" />
      <param name="layoutParameter" />
      <param name="style" />
      <param name="preferredSize" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeState.Remove(yWorks.Graph.FoldingLabelState)">
      <param name="label" />
    </member>
    <member name="M:yWorks.Graph.FoldingEdgeState.AsEdge">
      <summary>
        <para>Returns an <see cref="T:yWorks.Graph.IEdge" /> instance which represents this edge state.</para>
      </summary>
      <remarks>
        <para>The returned edge is not present in any graph but may be passed to <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)" /> to get the edge state's view edge in the <see cref="P:yWorks.Graph.IFoldingView.Graph">folding view graph</see>.</para>
      </remarks>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IEdge" /> instance which represents this edge state.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.FoldingLabelState">
      <summary>
        <para>A data container representing the state of a label at a <see cref="T:yWorks.Graph.FolderNodeState" /> or <see cref="T:yWorks.Graph.FoldingEdgeState" />.</para>
      </summary>
      <remarks>
        <para>When the properties of the state are changed, these changes are reflected immediately in the <see cref="P:yWorks.Graph.FoldingManager.Views" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.FoldingLabelOwnerState.Labels" />
      <seealso cref="M:yWorks.Graph.FoldingLabelOwnerState.AddLabel(System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,yWorks.Geometry.SizeD,System.Object)" />
      <seealso cref="M:yWorks.Graph.FoldingLabelOwnerState.Remove(yWorks.Graph.FoldingLabelState)" />
    </member>
    <member name="P:yWorks.Graph.FoldingLabelState.Style">
      <summary>
        <para>Gets or sets the style of this label.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingLabelState.PreferredSize">
      <summary>
        <para>Gets or sets the preferred size of the label.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingLabelState.Text">
      <summary>
        <para>Gets or sets the label's text.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingLabelState.LayoutParameter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> used to describe the label's layout.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingLabelState.Tag">
      <summary>
        <para>Gets or sets the tag of the label.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FoldingLabelState.AsLabel">
      <summary>
        <para>Returns an <see cref="T:yWorks.Graph.ILabel" /> instance which represents this label state.</para>
      </summary>
      <remarks>
        <para>The returned label is not present in any graph but may be passed to <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)" /> to get the label state's view label in the <see cref="P:yWorks.Graph.IFoldingView.Graph">folding view graph</see>.</para>
      </remarks>
      <returns>
        <para>An <see cref="T:yWorks.Graph.ILabel" /> instance which represents this label state.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.FoldingLabelOwnerState">
      <summary>
        <para>An abstract base class for data containers representing the state of model items which can own labels.</para>
      </summary>
      <remarks>
        <para>Developers should not extend this class. Only instances of its subclasses <see cref="T:yWorks.Graph.FolderNodeState" /> and <see cref="T:yWorks.Graph.FoldingEdgeState" /> are supported.</para>
        <para>When the properties of the state are changed, these changes are reflected immediately in the <see cref="P:yWorks.Graph.FoldingManager.Views" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.FolderNodeState" />
      <seealso cref="T:yWorks.Graph.FoldingEdgeState" />
      <seealso cref="T:yWorks.Graph.FoldingLabelState" />
    </member>
    <member name="M:yWorks.Graph.FoldingLabelOwnerState.AddLabel(System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,yWorks.Geometry.SizeD,System.Object)">
      <summary>
        <para>Adds a <see cref="T:yWorks.Graph.FoldingLabelState" /> to this state.</para>
      </summary>
      <param name="text">
        <para>The text of the new label.</para>
      </param>
      <param name="layoutParameter">
        <para>The layout parameter of the new label.</para>
      </param>
      <param name="style">
        <para>The style of the new label.</para>
      </param>
      <param name="preferredSize">
        <para>The preferred size of the label.</para>
      </param>
      <param name="tag">
        <para>The tag of the label.</para>
      </param>
      <returns>
        <para>The newly added <see cref="T:yWorks.Graph.FoldingLabelState" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.FoldingLabelOwnerState.Remove(yWorks.Graph.FoldingLabelState)">
      <summary>
        <para>Removes the <paramref name="label" /> from its owning <see cref="T:yWorks.Graph.FoldingLabelOwnerState" />.</para>
      </summary>
      <param name="label">
        <para>The label to remove.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.FoldingLabelOwnerState.Labels">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.FoldingLabelState" />s owned by this state.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FoldingLabelOwnerState.ClearLabels">
      <summary>
        <para>Removes all <see cref="P:yWorks.Graph.FoldingLabelOwnerState.Labels" />.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.FoldingPortState">
      <summary>
        <para>A data container representing the state of a port at a <see cref="T:yWorks.Graph.FolderNodeState" /> or <see cref="T:yWorks.Graph.FoldingEdgeState" />.</para>
      </summary>
      <remarks>
        <para>When the properties of the state are changed, these changes are reflected immediately in the <see cref="P:yWorks.Graph.FoldingManager.Views" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.FoldingEdgeState.SourcePort" />
      <seealso cref="P:yWorks.Graph.FoldingEdgeState.TargetPort" />
      <seealso cref="P:yWorks.Graph.FolderNodeState.Ports" />
      <seealso cref="M:yWorks.Graph.FolderNodeState.GetFoldingPortState(yWorks.Graph.IPort)" />
    </member>
    <member name="P:yWorks.Graph.FoldingPortState.Style">
      <summary>
        <para>Gets or sets the style of this port.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingPortState.LocationParameter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> describing the position of this port.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FoldingPortState.Tag">
      <summary>
        <para>Gets or sets the tag of the port.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FoldingPortState.AsPort">
      <summary>
        <para>Returns an <see cref="T:yWorks.Graph.IPort" /> instance which represents this port state.</para>
      </summary>
      <remarks>
        <para>The returned port is not present in any graph but may be passed to <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)" /> to get the port state's view port in the <see cref="P:yWorks.Graph.IFoldingView.Graph">folding view graph</see>.</para>
      </remarks>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IPort" /> instance which represents this port state.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.FolderNodeState">
      <summary>
        <para>A data container representing the collapsed state of a node.</para>
      </summary>
      <remarks>
        <para>When the properties of the state are changed, these changes are reflected immediately in the <see cref="P:yWorks.Graph.FoldingManager.Views" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)" />
    </member>
    <member name="P:yWorks.Graph.FolderNodeState.Layout">
      <summary>
        <para>Gets or sets the layout of the node.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FolderNodeState.Style">
      <summary>
        <para>Gets or sets the style of this node.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.FolderNodeState.Tag">
      <summary>
        <para>Gets or sets the tag of the node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FolderNodeState.AddLabel(System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,yWorks.Geometry.SizeD,System.Object)">
      <param name="text" />
      <param name="layoutParameter" />
      <param name="style" />
      <param name="preferredSize" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.FolderNodeState.Remove(yWorks.Graph.FoldingLabelState)">
      <param name="label" />
    </member>
    <member name="P:yWorks.Graph.FolderNodeState.Ports">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.FoldingPortState" />s owned by this state.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.FolderNodeState.GetFoldingPortState(yWorks.Graph.IPort)">
      <summary>
        <para>Provides access to the folding state of a master port.</para>
      </summary>
      <remarks>
        <para>This method can be used to query the folding state of a port at the folder which is represented by this state.</para>
      </remarks>
      <param name="masterPort">
        <para>The master port for which the state should be returned.</para>
      </param>
      <returns>
        <para>A state holder implementation of the <paramref name="masterPort" />, which reflects the port in the node's collapsed state.</para>
      </returns>
      <seealso cref="P:yWorks.Graph.FoldingPortState.Style" />
      <seealso cref="P:yWorks.Graph.FoldingPortState.LocationParameter" />
    </member>
    <member name="M:yWorks.Graph.FolderNodeState.AsNode">
      <summary>
        <para>Returns an <see cref="T:yWorks.Graph.INode" /> instance which represents this folder node state.</para>
      </summary>
      <remarks>
        <para>The returned node is not present in any graph but may be passed to <see cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)" /> to get the node state's folder node in the <see cref="P:yWorks.Graph.IFoldingView.Graph">folding view graph</see>.</para>
      </remarks>
      <returns>
        <para>An <see cref="T:yWorks.Graph.INode" /> instance which represents this folder node state.</para>
      </returns>
    </member>
    <member name="T:yWorks.Markup.Common.FreeEdgeLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.FreeEdgeLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.FreeEdgeLabelModelParameterExtension.#ctor(System.Double,System.Double,System.Double)">
      <param name="ratio" />
      <param name="distance" />
      <param name="angle" />
    </member>
    <member name="M:yWorks.Markup.Common.FreeEdgeLabelModelParameterExtension.#ctor(System.Double,System.Double,System.Double,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="ratio" />
      <param name="distance" />
      <param name="angle" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.FreeEdgeLabelModelParameterExtension.Ratio" />
    <member name="P:yWorks.Markup.Common.FreeEdgeLabelModelParameterExtension.Distance" />
    <member name="P:yWorks.Markup.Common.FreeEdgeLabelModelParameterExtension.Angle" />
    <member name="P:yWorks.Markup.Common.FreeEdgeLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.FreeEdgeLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.FreeEdgeLabelModel">
      <summary>
        <para>An edge label model that can be used to describe any position and orientation of a label.</para>
      </summary>
      <remarks>
        <para>The position of the label is stored relative to the positions of the ports of the edge the label belongs to.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.LabelModels.FreeEdgeLabelModel.EdgeRelativeAngle">
      <summary>
        <para>Gets or sets a property that indicates whether the angle used by the <see cref="M:yWorks.Graph.LabelModels.FreeEdgeLabelModel.CreateEdgeAnchored(System.Double,System.Double,System.Double)">parameter</see> should be interpreted relative to the edge's orientation or as an absolute angle in the coordinate system.</para>
      </summary>
      <remarks>
        <para>By default the angle is interpreted to be relative to the world coordinates axes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeEdgeLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeEdgeLabelModel.CreateDefaultParameter" />
    <member name="F:yWorks.Graph.LabelModels.FreeEdgeLabelModel.Instance">
      <summary>
        <para>A shared unmodifiable public instance that can be used to obtain parameters.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeEdgeLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeEdgeLabelModel.CreateEdgeAnchored(System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a parameter for the given location.</para>
      </summary>
      <param name="ratio">
        <para>The ratio at which the label will be anchored between the location of the source port and the location of the target port.</para>
      </param>
      <param name="distance">
        <para>The distance orthogonally to the connection between the source and target point.</para>
      </param>
      <param name="angle">
        <para>The angle by which the label should be rotated.</para>
      </param>
      <returns>
        <para>A parameter that describes the position.</para>
      </returns>
      <seealso cref="P:yWorks.Graph.LabelModels.FreeEdgeLabelModel.EdgeRelativeAngle" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeEdgeLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeEdgeLabelModel.FindBestParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel,yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Tries to find a parameter that best matches the given layout for the provided label instance.</para>
      </summary>
      <param name="label">
        <para>The label to find a parameter for.</para>
      </param>
      <param name="model">
        <para>The model instance to use. This should be this instance.</para>
      </param>
      <param name="layout">
        <para>The anticipated layout for the label.</para>
      </param>
      <returns>
        <para>A non-<c>null</c> parameter that can be used for the label to approximate the provided layout.</para>
      </returns>
      <remarks>
        <para>This implementation will match the provided layout perfectly.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Markup.Common.AnchoredLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.AnchoredLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.AnchoredLabelModelParameterExtension.#ctor(yWorks.Geometry.IPoint,System.Double)">
      <param name="anchorLocation" />
      <param name="angle" />
    </member>
    <member name="M:yWorks.Markup.Common.AnchoredLabelModelParameterExtension.#ctor(yWorks.Geometry.IPoint,System.Double,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="anchorLocation" />
      <param name="angle" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.AnchoredLabelModelParameterExtension.AnchorLocation" />
    <member name="P:yWorks.Markup.Common.AnchoredLabelModelParameterExtension.Angle" />
    <member name="P:yWorks.Markup.Common.AnchoredLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.AnchoredLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Markup.Common.FixedLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.FixedLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.FixedLabelModelParameterExtension.#ctor(yWorks.Geometry.PointD,System.Double)">
      <param name="anchorLocation" />
      <param name="angle" />
    </member>
    <member name="M:yWorks.Markup.Common.FixedLabelModelParameterExtension.#ctor(yWorks.Geometry.PointD,System.Double,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="anchorLocation" />
      <param name="angle" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.FixedLabelModelParameterExtension.AnchorLocation" />
    <member name="P:yWorks.Markup.Common.FixedLabelModelParameterExtension.Angle" />
    <member name="P:yWorks.Markup.Common.FixedLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.FixedLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.FreeLabelModel">
      <summary>
        <para>A label model that can be used to describe any position and orientation of a label.</para>
      </summary>
      <remarks>
        <para>The position of the label is stored absolutely and is not influenced by the layout or position of the owner of the label. In fact the owner is not even queried during a call to <see cref="M:yWorks.Graph.LabelModels.FreeLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.FreeLabelModel.Instance">
      <summary>
        <para>A shared public instance that can be used to obtain parameters.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeLabelModel.CreateDefaultParameter" />
    <member name="M:yWorks.Graph.LabelModels.FreeLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeLabelModel.CreateAbsolute(yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Creates a new label model parameter that places the label at the given absolute position using the provided angle.</para>
      </summary>
      <param name="anchorLocation">
        <para>The location for the parameter.</para>
      </param>
      <param name="angle">
        <para>The angle of rotation.</para>
      </param>
      <returns>
        <para>A new parameter that is associated with this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeLabelModel.CreateDynamic(yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Creates a new label model parameter that dynamically reads the label layout from the provided instance.</para>
      </summary>
      <param name="layout">
        <para>The oriented rectangle to dynamically retrieve the values from.</para>
      </param>
      <returns>
        <para>A new parameter that is associated with this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeLabelModel.CreateAnchored(yWorks.Geometry.IPoint,System.Double)">
      <summary>
        <para>Creates a new label at the given dynamic location using the provided angle.</para>
      </summary>
      <param name="location">
        <para>The location to place the parameter at. That instance is stored by reference.</para>
      </param>
      <param name="angle">
        <para>The angle of rotation.</para>
      </param>
      <returns>
        <para>A new parameter that is associated with this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="T:yWorks.Markup.Common.RatioAnchoredLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.RatioAnchoredLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.RatioAnchoredLabelModelParameterExtension.#ctor(yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="layoutRatio" />
      <param name="layoutOffset" />
      <param name="labelRatio" />
      <param name="labelOffset" />
      <param name="angle" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.RatioAnchoredLabelModelParameterExtension.LayoutRatio" />
    <member name="P:yWorks.Markup.Common.RatioAnchoredLabelModelParameterExtension.LayoutOffset" />
    <member name="P:yWorks.Markup.Common.RatioAnchoredLabelModelParameterExtension.LabelRatio" />
    <member name="P:yWorks.Markup.Common.RatioAnchoredLabelModelParameterExtension.LabelOffset" />
    <member name="P:yWorks.Markup.Common.RatioAnchoredLabelModelParameterExtension.Angle" />
    <member name="P:yWorks.Markup.Common.RatioAnchoredLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.RatioAnchoredLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.FreeNodeLabelModel">
      <summary>
        <para>This node label model can be used to specify any position and orientation of a label.</para>
      </summary>
      <remarks>
        <para>The position of the label is stored relative to the layout of the node the label belongs to.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.FreeNodeLabelModel.Instance">
      <summary>
        <para>A shared public instance that can be used to obtain parameters.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeNodeLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeNodeLabelModel.CreateDefaultParameter">
      <summary>
        <para>Creates a parameter that is anchored at the node center and has no rotation.</para>
      </summary>
      <returns>
        <para>A parameter that is anchored at the node center and has no rotation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeNodeLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Returns an empty context.</para>
      </summary>
      <param name="label">
        <para>The label to use in the context.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter to use for the label in the context.</para>
      </param>
      <returns>
        <para>An empty context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeNodeLabelModel.CreateParameter(yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Creates a parameter instance that anchors the label to the node at a given position.</para>
      </summary>
      <remarks>
        <para>The parameter will use the ratio and offset values to determine a point on both the label and the node. It will place the label in such a way that both points coincide.</para>
      </remarks>
      <param name="layoutRatio">
        <para>The ratio that describes the point on the node's layout relative to its upper-left corner. A value of (0,0) describes the upper-left corner, while (1,1) is the lower-right corner.</para>
      </param>
      <param name="layoutOffset">
        <para>The absolute offset to apply to the point on the node after the ratio has been determined.</para>
      </param>
      <param name="labelRatio">
        <para>The ratio that describes the point on the label's layout relative to its upper-left corner. A value of (0,0) describes the upper-left corner, while (1,1) is the lower-right corner.</para>
      </param>
      <param name="labelOffset">
        <para>The absolute offset to apply to the point on the label after the ratio has been determined.</para>
      </param>
      <param name="angle">
        <para>The angle by which the label should be rotated around the point described using the ratio and offset, measured in radians.</para>
      </param>
      <returns>
        <para>A parameter that exactly fits the described location.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeNodeLabelModel.CreateCanonicalParameter(yWorks.Geometry.RectD,yWorks.Geometry.IOrientedRectangle,System.Nullable{yWorks.Geometry.PointD})">
      <summary>
        <para>Creates a parameter instance that anchors the label to the node at the canonical position with respect to the given reference point.</para>
      </summary>
      <remarks>
        <para>This method <see cref="M:yWorks.Graph.LabelModels.FreeNodeLabelModel.CreateParameter(yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.PointD,System.Double)">creates a parameter</see> with the canonical settings for the ratios and offsets in the following way. Each coordinate axis is considered independently. If the reference point coordinate is within the node layout interval, its relative location specifies the layout ratio for this coordinate. Otherwise, the absolute distance of the reference point and the interval specifies the layout offset and the layout ratio is either either <c>0.0</c> or <c>1.0</c>. The parameters for the label ratio and label offset are calculated analogously. If no reference point is provided, the reference point is determined automatically in the following way: For each coordinate, if the node layout and label layout do not overlap, the reference is the label corner that is closest to the node. If they overlap and if in addition the start or end coordinate of the label matches the start, center or end coordinate of the node, that coordinate is the reference. Otherwise, the center of the label specifies the reference.</para>
      </remarks>
      <param name="nodeLayout">
        <para>The node layout.</para>
      </param>
      <param name="labelLayout">
        <para>The label layout.</para>
      </param>
      <param name="referenceLocation">
        <para>The reference location.</para>
      </param>
      <returns>
        <para>The canonical parameter for the specified node and label layout.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeNodeLabelModel.FindBestParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel,yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Tries to find a parameter that best matches the given layout for the provided label instance.</para>
      </summary>
      <param name="label">
        <para>The label to find a parameter for.</para>
      </param>
      <param name="model">
        <para>The model instance to use. This should be this instance.</para>
      </param>
      <param name="layout">
        <para>The anticipated layout for the label.</para>
      </param>
      <returns>
        <para>A non-<c>null</c> parameter that can be used for the label to approximate the provided layout.</para>
      </returns>
      <remarks>
        <para>This implementation will match the provided layout perfectly.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.FreeNodeLabelModel.Lookup(System.Type)">
      <summary>
        <para>Returns this instance if an instance of <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder" /> is requested and <c>null</c> otherwise.</para>
      </summary>
      <param name="type">
        <para>The type for which an instance is requested.</para>
      </param>
      <returns>
        <para>An instance that is assignable to the given type or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel">
      <summary>
        <para>A straightforward implementation of an <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModel" /> for <see cref="T:yWorks.Graph.IPort" />s at <see cref="T:yWorks.Graph.INode" />s that determine the location dynamically using the <see cref="P:yWorks.Graph.INode.Layout" />.</para>
      </summary>
      <remarks>
        <para>Internally the location is stored as the ratios by which the <see cref="P:yWorks.Geometry.ISize.Width" /> and <see cref="P:yWorks.Geometry.ISize.Height" /> of the <see cref="P:yWorks.Graph.INode.Layout" /> need to be scaled and additional offsets to obtain the offset to the top-left corner of the node layout.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.Instance">
      <summary>
        <para>A read only immutable instance of the <see cref="T:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.NodeCenterAnchored">
      <summary>
        <para>A read only immutable singleton instance of a parameter that locates the port at the center of the node layout.</para>
      </summary>
      <remarks>
        <para>This is the same as <see cref="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Geometry.PointD,System.Nullable{yWorks.Geometry.PointD})">creating a parameter</see> using <c>(0.5,0.5)</c> as ratios and <c>(0,0)</c> as offsets.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.NodeLeftAnchored">
      <summary>
        <para>A read only immutable singleton instance of a parameter that locates the port at the center of the left border of the node layout.</para>
      </summary>
      <remarks>
        <para>This is the same as <see cref="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Geometry.PointD,System.Nullable{yWorks.Geometry.PointD})">creating a parameter</see> using <c>(0,0.5)</c> as ratios and <c>(0,0)</c> as offsets.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.NodeRightAnchored">
      <summary>
        <para>A read only immutable singleton instance of a parameter that locates the port at the center of the right border of the node layout.</para>
      </summary>
      <remarks>
        <para>This is the same as <see cref="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Geometry.PointD,System.Nullable{yWorks.Geometry.PointD})">creating a parameter</see> using <c>(1,0.5)</c> as ratios and <c>(0,0)</c> as offsets.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.NodeTopAnchored">
      <summary>
        <para>A read only immutable singleton instance of a parameter that locates the port at the center of the top border of the node layout.</para>
      </summary>
      <remarks>
        <para>This is the same as <see cref="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Geometry.PointD,System.Nullable{yWorks.Geometry.PointD})">creating a parameter</see> using <c>(0.5,0)</c> as ratios and <c>(0,0)</c> as offsets.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.NodeBottomAnchored">
      <summary>
        <para>A read only immutable singleton instance of a parameter that locates the port at the center of the bottom border of the node layout.</para>
      </summary>
      <remarks>
        <para>This is the same as <see cref="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Geometry.PointD,System.Nullable{yWorks.Geometry.PointD})">creating a parameter</see> using <c>(0.5,1)</c> as ratios and <c>(0,0)</c> as offsets.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.NodeTopLeftAnchored">
      <summary>
        <para>A read only immutable singleton instance of a parameter that locates the port at the top left corner of the node layout.</para>
      </summary>
      <remarks>
        <para>This is the same as <see cref="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Geometry.PointD,System.Nullable{yWorks.Geometry.PointD})">creating a parameter</see> using <c>(0,0)</c> as ratios and <c>(0,0)</c> as offsets.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.NodeTopRightAnchored">
      <summary>
        <para>A read only immutable singleton instance of a parameter that locates the port at the top right corner of the node layout.</para>
      </summary>
      <remarks>
        <para>This is the same as <see cref="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Geometry.PointD,System.Nullable{yWorks.Geometry.PointD})">creating a parameter</see> using <c>(1,0)</c> as ratios and <c>(0,0)</c> as offsets.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.NodeBottomRightAnchored">
      <summary>
        <para>A read only immutable singleton instance of a parameter that locates the port at the bottom right corner of the node layout.</para>
      </summary>
      <remarks>
        <para>This is the same as <see cref="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Geometry.PointD,System.Nullable{yWorks.Geometry.PointD})">creating a parameter</see> using <c>(1,1)</c> as ratios and <c>(0,0)</c> as offsets.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.NodeBottomLeftAnchored">
      <summary>
        <para>A read only immutable singleton instance of a parameter that locates the port at the bottom left corner of the node layout.</para>
      </summary>
      <remarks>
        <para>This is the same as <see cref="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Geometry.PointD,System.Nullable{yWorks.Geometry.PointD})">creating a parameter</see> using <c>(0,1)</c> as ratios and <c>(0,0)</c> as offsets.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.GetLocation(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="port" />
      <param name="locationParameter" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Geometry.PointD,System.Nullable{yWorks.Geometry.PointD})">
      <summary>
        <para>Creates a parameter that uses the given ratios and offsets.</para>
      </summary>
      <remarks>
        <para>The <paramref name="ratios" /> will be scaled by the node layout's size and added to the node's top left corner and the <paramref name="offset" /> to determine the port location.</para>
      </remarks>
      <param name="ratios">
        <para>The ratios of the node layout's size.</para>
      </param>
      <param name="offset">
        <para>The offset that is added after the <paramref name="ratios" /> are applied.</para>
      </param>
      <returns>
        <para>A new parameter that matches the specification.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.CreateParameter(yWorks.Graph.IPortOwner,yWorks.Geometry.PointD)">
      <param name="owner" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.FreeNodePortLocationModel.GetContext(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="port" />
      <param name="locationParameter" />
    </member>
    <member name="T:yWorks.Markup.Common.FreeNodePortLocationModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.FreeNodePortLocationModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.FreeNodePortLocationModelParameterExtension.#ctor(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="ratio" />
      <param name="offset" />
    </member>
    <member name="P:yWorks.Markup.Common.FreeNodePortLocationModelParameterExtension.Ratio" />
    <member name="P:yWorks.Markup.Common.FreeNodePortLocationModelParameterExtension.Offset" />
    <member name="M:yWorks.Markup.Common.FreeNodePortLocationModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Common.GenericLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.GenericLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.GenericLabelModelParameterExtension.#ctor(System.Int32,yWorks.Graph.LabelModels.GenericLabelModel)">
      <param name="index" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.GenericLabelModelParameterExtension.Index" />
    <member name="P:yWorks.Markup.Common.GenericLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.GenericLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Markup.Common.GenericLabelModelExtension" />
    <member name="M:yWorks.Markup.Common.GenericLabelModelExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.GenericLabelModelExtension.#ctor(yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="defaultParameter" />
    </member>
    <member name="M:yWorks.Markup.Common.GenericLabelModelExtension.#ctor(yWorks.Graph.LabelModels.ILabelModelParameter,System.Collections.Generic.List{yWorks.Graph.LabelModels.ILabelModelParameter})">
      <param name="defaultParameter" />
      <param name="parameters" />
    </member>
    <member name="P:yWorks.Markup.Common.GenericLabelModelExtension.Parameters" />
    <member name="P:yWorks.Markup.Common.GenericLabelModelExtension.Default" />
    <member name="M:yWorks.Markup.Common.GenericLabelModelExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Markup.Common.GenericLabelModelParameterPair" />
    <member name="P:yWorks.Markup.Common.GenericLabelModelParameterPair.Parameter" />
    <member name="P:yWorks.Markup.Common.GenericLabelModelParameterPair.Descriptor" />
    <member name="T:yWorks.Graph.LabelModels.GenericLabelModel">
      <summary>
        <para>An implementation of <see cref="T:yWorks.Graph.LabelModels.ILabelModel" /> that can be used to create custom label models out of existing <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> instances.</para>
      </summary>
      <remarks>
        <para>This class holds a number of parameters and serves as a container for these parameters. Custom models can easily be created that way:</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.GenericLabelModel.#ctor(yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.LabelModels.ILabelCandidateDescriptor)">
      <summary>
        <para>Create a new generic label model using the provided parameter as the <see cref="M:yWorks.Graph.LabelModels.GenericLabelModel.CreateDefaultParameter">default parameter.</see></para>
      </summary>
      <remarks>
        <para>The parameter is stored by reference.</para>
      </remarks>
      <param name="defaultLayoutParameter">
        <para>The parameter to use as the default.</para>
      </param>
      <param name="descriptor">
        <para>The descriptor to associate with the parameter.</para>
      </param>
      <seealso cref="M:yWorks.Graph.LabelModels.GenericLabelModel.GetDescriptor(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)" />
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>defaultParameter</c> is null.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.LabelModels.GenericLabelModel.AddParameter(yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.LabelModels.ILabelCandidateDescriptor)">
      <summary>
        <para>Adds another parameter to this models collection of parameters.</para>
      </summary>
      <remarks>
        <para>Note that the parameter will be wrapped by this class and the resulting parameter which will use this model instance as its <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> will be returned. The parameter is stored by reference and subsequent modification of the parameter or its associated model will be reflected by this instance. Also the methods allows for associating a <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptor" /> with each parameter that can later be retrieved via the <see cref="M:yWorks.Graph.LabelModels.GenericLabelModel.GetDescriptor(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)" /> method.</para>
      </remarks>
      <param name="layoutParameter">
        <para>The parameter to add to this instance.</para>
      </param>
      <param name="descriptor">
        <para>The descriptor to associate with the parameter.</para>
      </param>
      <returns>
        <para>A new parameter that wraps the provided parameter and uses this instance as its model.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.GenericLabelModel.CreateDefaultParameter" />
    <member name="M:yWorks.Graph.LabelModels.GenericLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.GenericLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.GenericLabelModel.GetDescriptor(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Yields the <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptor" /> that has been associated with the instance during <see cref="M:yWorks.Graph.LabelModels.GenericLabelModel.AddParameter(yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.LabelModels.ILabelCandidateDescriptor)" />.</para>
      </summary>
      <param name="label">
        <para>The label instance to use.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter to get the descriptor for.</para>
      </param>
      <returns>
        <para>The descriptor instance that had been added to this instance during <see cref="M:yWorks.Graph.LabelModels.GenericLabelModel.AddParameter(yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.LabelModels.ILabelCandidateDescriptor)" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.Markup.Common.GenericPortLocationParameterExtension" />
    <member name="M:yWorks.Markup.Common.GenericPortLocationParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.GenericPortLocationParameterExtension.#ctor(System.Int32,yWorks.Graph.PortLocationModels.GenericPortLocationModel)">
      <param name="index" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.GenericPortLocationParameterExtension.Index" />
    <member name="P:yWorks.Markup.Common.GenericPortLocationParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.GenericPortLocationParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Common.GenericPortLocationModelExtension" />
    <member name="M:yWorks.Markup.Common.GenericPortLocationModelExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.GenericPortLocationModelExtension.#ctor(System.Collections.Generic.IEnumerable{yWorks.Graph.PortLocationModels.IPortLocationModelParameter})">
      <param name="locationParameters" />
    </member>
    <member name="P:yWorks.Markup.Common.GenericPortLocationModelExtension.LocationParameters" />
    <member name="M:yWorks.Markup.Common.GenericPortLocationModelExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.PortLocationModels.GenericPortLocationModel">
      <summary>
        <para>An implementation of <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModel" /> that can be used to create custom port location models out of existing <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> instances.</para>
      </summary>
      <remarks>
        <para>This class holds a number of parameters and serves as a container for these parameters.</para>
      </remarks>
      <example>
        <para>Custom models can easily be created in the following way:</para>
        <para>Note that in order to work, this model needs to have at least one <see cref="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.AddParameter(yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">parameter added</see>.</para>
      </example>
      <seealso cref="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.AddParameter(yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.PortLocationModels.GenericPortLocationModel" /> class.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.GetLocation(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="port" />
      <param name="locationParameter" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.AddParameter(yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <summary>
        <para>Adds the given parameter to the <see cref="P:yWorks.Graph.PortLocationModels.GenericPortLocationModel.LocationParameters" /> of this instance.</para>
      </summary>
      <remarks>
        <para>Note that this will create a new parameter instance that is then actually bound to this instance and returned. The instance is stored by reference so if this is a mutable instance this instance will be modified, implicitly, too.</para>
      </remarks>
      <param name="locationParameter">
        <para>The parameter to add to this instance.</para>
      </param>
      <returns>
        <para>The parameter to use with this model that wraps the given parameter.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.Add(yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" />
    </member>
    <member name="P:yWorks.Graph.PortLocationModels.GenericPortLocationModel.LocationParameters">
      <summary>
        <para>Gets all parameters that are associated with this instance.</para>
      </summary>
      <remarks>
        <para>This enumerates the instances that wraps the parameters that have been added to this instance via <see cref="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.AddParameter(yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" /></para>
      </remarks>
      <value>
        <para>The parameters that are managed by this instance.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.CreateParameter(yWorks.Graph.IPortOwner,yWorks.Geometry.PointD)">
      <summary>
        <para>Factory method that creates a parameter for the given port that tries to match the provided location in absolute world coordinates.</para>
      </summary>
      <param name="owner">
        <para>The port owner that will own the port for which the parameter shall be created.</para>
      </param>
      <param name="location">
        <para>The location in the world coordinate system that should be matched as best as possible.</para>
      </param>
      <remarks>
        <para>This implementation iterates over all <see cref="P:yWorks.Graph.PortLocationModels.GenericPortLocationModel.LocationParameters" /> to return the one that matches the given location the best.</para>
      </remarks>
      <returns>
        <para>A new instance that can be used to describe the location of an <see cref="T:yWorks.Graph.IPort" /> at the given <paramref name="owner" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.GetContext(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="port" />
      <param name="locationParameter" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.Add(yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <summary>
        <para>This method simply delegates to <see cref="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.AddParameter(yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" />.</para>
      </summary>
      <remarks>
        <para>It is there to allow for convenient initialization in code.</para>
        <para>This method is used by the compiler if the collection initializer syntax is used.</para>
      </remarks>
      <param name="locationParameter">
        <para>The parameter to add to this instance.</para>
      </param>
      <seealso cref="M:yWorks.Graph.PortLocationModels.GenericPortLocationModel.AddParameter(yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" />
    </member>
    <member name="T:yWorks.Graph.IClipboardHelper">
      <summary>
        <para>This interface can be used to customize the clipboard behavior for individual <see cref="T:yWorks.Graph.IModelItem" />s.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface can <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">decorate</see> the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method of <see cref="T:yWorks.Graph.IModelItem" />s to change their behavior during <see cref="T:yWorks.Graph.GraphClipboard">clipboard</see> actions.</para>
      </remarks>
      <example>
        <para>The easiest way to decorate certain model items with a custom <see cref="T:yWorks.Graph.IClipboardHelper" /> implementation is via the various decorators available on <see cref="T:yWorks.Graph.GraphDecorator" />:</para>
      </example>
    </member>
    <member name="M:yWorks.Graph.IClipboardHelper.ShouldCopy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether the given item can or should be copied to the clipboard.</para>
      </summary>
      <remarks>
        <para>If the source graph is a managed folding view, the <paramref name="item" /> is always a view item. Furthermore, if collapsed nodes are to be copied, this method will be queried with the collapsed group node as <paramref name="item" /> for each "hidden" node that is currently not visible.</para>
      </remarks>
      <param name="context">
        <para>The context in which this interface is used, can be <c>null</c></para>
      </param>
      <param name="item">
        <para>The item in question.</para>
      </param>
      <returns>
        <para>Whether this item should be copied.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IClipboardHelper.ShouldCut(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether the given item can or should be cut to the clipboard.</para>
      </summary>
      <remarks>
        <para>If the source graph is a managed folding view, the <paramref name="item" /> is always a view item. Furthermore, if collapsed nodes are to be cut, this method will be queried with the collapsed group node as <paramref name="item" /> for each "hidden" node that is currently not visible.</para>
      </remarks>
      <param name="context">
        <para>The context in which this interface is used, can be <c>null</c></para>
      </param>
      <param name="item">
        <para>The item in question.</para>
      </param>
      <returns>
        <para>Whether this item should be cut.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IClipboardHelper.ShouldPaste(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem,System.Object)">
      <summary>
        <para>Determines whether the given item can or should be pasted from the clipboard to the target graph.</para>
      </summary>
      <remarks>
        <para>The <paramref name="item" /> is always a master item since the clipboard graph is not a managed folding view.</para>
      </remarks>
      <param name="context">
        <para>The context in which this interface is used, can be <c>null</c></para>
      </param>
      <param name="item">
        <para>The item in the clipboard graph.</para>
      </param>
      <param name="userData">
        <para>The state memento that had been created during <see cref="M:yWorks.Graph.IClipboardHelper.Cut(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> or <see cref="M:yWorks.Graph.IClipboardHelper.Copy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" />.</para>
      </param>
      <returns>
        <para>Whether this item should be pasted.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IClipboardHelper.Copy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)">
      <summary>
        <para>This method is called during the copy operation of the given item to retrieve additional state that can be later used during a <see cref="M:yWorks.Graph.IClipboardHelper.Paste(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem,System.Object)" /> operation.</para>
      </summary>
      <remarks>
        <para>If the source graph is a managed folding view, the <paramref name="item" /> is always a master item.</para>
      </remarks>
      <param name="context">
        <para>The context in which this interface is used, can be <c>null</c></para>
      </param>
      <param name="item">
        <para>The item to copy to the clipboard.</para>
      </param>
      <returns>
        <para>A custom user object that will later be provided to <see cref="M:yWorks.Graph.IClipboardHelper.Paste(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem,System.Object)" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IClipboardHelper.Cut(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)">
      <summary>
        <para>This method is called during the cut operation of the given item to retrieve additional state that can be later used during a <see cref="M:yWorks.Graph.IClipboardHelper.Paste(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem,System.Object)" /> operation.</para>
      </summary>
      <remarks>
        <para>If the source graph is a managed folding view, the <paramref name="item" /> is always a master item.</para>
      </remarks>
      <param name="context">
        <para>The context in which this interface is used, can be <c>null</c></para>
      </param>
      <param name="item">
        <para>The item to cut to the clipboard.</para>
      </param>
      <returns>
        <para>A custom user object that will later be provided to <see cref="M:yWorks.Graph.IClipboardHelper.Paste(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem,System.Object)" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IClipboardHelper.Paste(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem,System.Object)">
      <summary>
        <para>This method is called after the item has been pasted from the clipboard.</para>
      </summary>
      <remarks>
        <para>The <paramref name="item" /> is always a master item since the clipboard graph is not a managed folding view.</para>
      </remarks>
      <param name="context">
        <para>The context in which this interface is used, can be <c>null</c></para>
      </param>
      <param name="item">
        <para>The item that has been created during the paste operation.</para>
      </param>
      <param name="userData">
        <para>The data that had been queried during <see cref="M:yWorks.Graph.IClipboardHelper.Cut(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> or <see cref="M:yWorks.Graph.IClipboardHelper.Copy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> respectively.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.IGraphClipboardContext">
      <summary>
        <para>The interface for the context that is passed by the <see cref="T:yWorks.Graph.GraphClipboard" /> implementation to the <see cref="T:yWorks.Graph.IClipboardHelper" /> methods and <see cref="T:yWorks.Graph.IClipboardIdProvider" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.IGraphClipboardContext.Clipboard">
      <summary>
        <para>Gets the clipboard that created this context and is used during the current operation.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.IGraphClipboardContext.SourceGraph">
      <summary>
        <para>Gets the source graph for the current operation.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.IGraphClipboardContext.TargetGraph">
      <summary>
        <para>Gets the target graph for the current operation.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.IClipboardIdProvider">
      <summary>
        <para>Used by the <see cref="T:yWorks.Graph.GraphClipboard" /> to assign IDs for elements in the clipboard.</para>
      </summary>
      <remarks>
        <para>IDs are created when items are copied (or cut) into the clipboard and queried when the items are pasted from the clipboard.<br /> Providing a custom ID provider allows for identifying conceptually identical items across different graph instances.<br /> The default implementation uses the <see cref="T:yWorks.Graph.IModelItem" /> object reference as the ID.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.IClipboardIdProvider.GetId(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)">
      <summary>
        <para>Gets the ID for the given <paramref name="originalItem" />.</para>
      </summary>
      <param name="context">
        <para>The clipboard context</para>
      </param>
      <param name="originalItem">
        <para>The original item which is copied. The item is part of the original graph from which the item is copied.</para>
      </param>
      <returns>
        <para>An ID for the given item. The object should be suitable for use in a <see cref="T:System.Collections.Generic.Dictionary`2" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IClipboardIdProvider.GetItem(yWorks.Graph.IGraphClipboardContext,System.Object)">
      <summary>
        <para>Gets the item which is represented by the given <paramref name="id" />.</para>
      </summary>
      <param name="context">
        <para>The clipboard context.</para>
      </param>
      <param name="id">
        <para>The ID to get the item for.</para>
      </param>
      <returns>
        <para>The item which is represented by the given ID or <c>null</c> if the item cannot be located or is invalid. The item needs to be part of the target graph for paste operations.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.GraphClipboard">
      <summary>
        <para>Clipboard implementation for <see cref="T:yWorks.Graph.IGraph" /> instances.</para>
      </summary>
      <remarks>
        <para>This implementation copies a given graph to an internally held <see cref="P:yWorks.Graph.GraphClipboard.ClipboardGraph">clipboard graph</see>. The clipboard graph can then be pasted to a target graph instance.</para>
        <para>The clipboard can be configured to copy and paste <see cref="P:yWorks.Graph.GraphClipboard.IndependentCopyItems">items that depend on other items</see> without copying the items it depends on, e.g. labels, ports, edges, and bends.</para>
        <para>Also depending on the selection in the target graph, items can be pasted at multiple locations at once, e.g. a single label can be copied to the clipboard independently and pasted onto several selected target items.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IClipboardHelper" />
      <seealso cref="M:yWorks.Graph.GraphClipboard.Cut(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})" />
      <seealso cref="M:yWorks.Graph.GraphClipboard.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.ElementCopiedCallback)" />
      <seealso cref="M:yWorks.Graph.GraphClipboard.Paste(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.ElementCopiedCallback)" />
      <seealso cref="P:yWorks.Graph.GraphClipboard.ClipboardGraph" />
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.#ctor">
      <summary>
        <para>Creates a new initially empty clipboard.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.PasteDelta">
      <summary>
        <para>Gets or sets a vector that will be used to move nodes and bends by after they have been pasted to the target graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateClipBoardHelperCutFilter">
      <summary>
        <para>Convenience method that creates a <see cref="T:System.Predicate`1" /> that is based upon the outcome of the <see cref="M:yWorks.Graph.IClipboardHelper.ShouldCut(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> method that can be found in the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the provided <see cref="T:yWorks.Graph.IModelItem" />.</para>
      </summary>
      <returns>
        <para>A predicate that uses <see cref="M:yWorks.Graph.IClipboardHelper.ShouldCut(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphClipboard.Cut(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})" />
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateClipBoardHelperPasteFilter">
      <summary>
        <para>Convenience method that creates a <see cref="T:System.Predicate`1" /> that is based upon the outcome of the <see cref="M:yWorks.Graph.IClipboardHelper.ShouldPaste(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem,System.Object)" /> method that can be found in the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the provided <see cref="T:yWorks.Graph.IModelItem" />.</para>
      </summary>
      <returns>
        <para>A predicate that uses <see cref="M:yWorks.Graph.IClipboardHelper.ShouldPaste(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem,System.Object)" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphClipboard.Cut(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})" />
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateDefaultCutFilter(yWorks.Controls.IGraphSelection,yWorks.Graph.IGraph)">
      <summary>
        <para>Creates a <see cref="T:System.Predicate`1" /> for use in the <see cref="M:yWorks.Graph.GraphClipboard.Cut(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})" /> method.</para>
      </summary>
      <remarks>
        <para>This filter uses two predicates to decide whether a graph item can be cut. The base set of items specified by this filter is induced by the <see cref="M:yWorks.Graph.GraphClipboard.CreateSelectionFilter(yWorks.Controls.IGraphSelection,yWorks.Graph.IGraph)" />. Optionally, this set can be restricted further by an <see cref="M:yWorks.Graph.IClipboardHelper.ShouldCut(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> predicate. If such a predicate returns <c>false</c> for the item itself or any item this item depends on, then the item will not be cut. Items without such a predicate are handled solely according to their selection state.</para>
      </remarks>
      <param name="selection">
        <para>The selection model to base the filter on.</para>
      </param>
      <param name="graph">
        <para>The graph to use for determining adjacency.</para>
      </param>
      <returns>
        <para>A predicate that filters subgraph induced by the selection of nodes and restricted by an optional <see cref="M:yWorks.Graph.IClipboardHelper.ShouldCut(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> predicate.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateDefaultCopyFilter(yWorks.Controls.IGraphSelection,yWorks.Graph.IGraph)">
      <summary>
        <para>Creates a <see cref="T:System.Predicate`1" /> for use in the <see cref="M:yWorks.Graph.GraphClipboard.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.ElementCopiedCallback)" /> method.</para>
      </summary>
      <remarks>
        <para>This filter uses two predicates to decide whether a graph item can be copied. The base set of items specified by this filter is induced by the <see cref="M:yWorks.Graph.GraphClipboard.CreateSelectionFilter(yWorks.Controls.IGraphSelection,yWorks.Graph.IGraph)" />. Optionally, this set can be restricted further by an <see cref="M:yWorks.Graph.IClipboardHelper.ShouldCopy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> predicate. If such a predicate returns <c>false</c> for the item itself or any item this item depends on, then the item will not be copied. Items without such a predicate are handled solely according to their selection state.</para>
      </remarks>
      <param name="selection">
        <para>The selection model to base the filter on.</para>
      </param>
      <param name="graph">
        <para>The graph to use for determining adjacency.</para>
      </param>
      <returns>
        <para>A predicate that filters subgraph induced by the selection of nodes and restricted by an optional <see cref="M:yWorks.Graph.IClipboardHelper.ShouldCopy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> predicate.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateDefaultDuplicateFilter(yWorks.Controls.IGraphSelection,yWorks.Graph.IGraph)">
      <summary>
        <para>Creates a <see cref="T:System.Predicate`1" /> for use in the <see cref="M:yWorks.Graph.GraphClipboard.Duplicate(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.ElementCopiedCallback)" /> method.</para>
      </summary>
      <remarks>
        <para>By default this method uses the same filter implementation as <see cref="M:yWorks.Graph.GraphClipboard.CreateDefaultCopyFilter(yWorks.Controls.IGraphSelection,yWorks.Graph.IGraph)" />: This filter uses two predicates to decide whether a graph item will be duplicated. The base set of items specified by this filter is induced by the <see cref="M:yWorks.Graph.GraphClipboard.CreateSelectionFilter(yWorks.Controls.IGraphSelection,yWorks.Graph.IGraph)" />. Optionally, this set can be restricted further by an <see cref="M:yWorks.Graph.IClipboardHelper.ShouldCopy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> predicate. If such a predicate returns <c>false</c> for the item itself or any item this item depends on, then the item will not be copied. Items without such a predicate are handled solely according to their selection state.</para>
      </remarks>
      <param name="selection">
        <para>The selection model to base the filter on.</para>
      </param>
      <param name="graph">
        <para>The graph to use for determining adjacency.</para>
      </param>
      <returns>
        <para>A predicate that filters subgraph induced by the selection of nodes and restricted by an optional <see cref="M:yWorks.Graph.IClipboardHelper.ShouldCopy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> predicate.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateWrappedFilter(System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,System.Boolean)">
      <summary>
        <para>Creates an induced <see cref="T:System.Predicate`1" /> from <paramref name="coreFilter" /> for use in the <see cref="M:yWorks.Graph.GraphClipboard.Cut(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})" /> and <see cref="M:yWorks.Graph.GraphClipboard.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.ElementCopiedCallback)" /> methods that takes dependent items into account.</para>
      </summary>
      <remarks>
        <para>This method can create a predicate for only a core set of items which is then extended or restricted depending on the predicate values of graph item dependencies.</para>
        <para>The <paramref name="restrictive" /> parameter determines whether the result restricts or extends the set of elements handled by <paramref name="coreFilter" />:</para>
        <list type="bullet">
          <item>If <paramref name="restrictive" /> is <c>false</c>, an item is allowed if either <paramref name="coreFilter" /> returns <c>true</c> for itself or if all items it depends on (e.g. label/port owner, source/target port etc.) are allowed by <paramref name="coreFilter" />.</item>
          <item>If <paramref name="restrictive" /> is <c>true</c>, an item is forbidden if either <paramref name="coreFilter" /> returns <c>false</c> for itself or if any item it depends on (e.g. label/port owner, source/target port etc.) is forbidden by <paramref name="coreFilter" />.</item>
        </list>
      </remarks>
      <param name="coreFilter">
        <para>The core predicate for the base set of elements.</para>
      </param>
      <param name="graph">
        <para>The graph to use for determining adjacency.</para>
      </param>
      <param name="restrictive">
        <para>Whether to create a restriction or extension for the <paramref name="coreFilter" /> predicate</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateContext(yWorks.Graph.IGraph,yWorks.Graph.IGraph)">
      <summary>
        <para>Factory method that creates the context for the upcoming calls to the <see cref="T:yWorks.Graph.IClipboardHelper" /> methods.</para>
      </summary>
      <param name="sourceGraph">
        <para>The source graph of the operation.</para>
      </param>
      <param name="targetGraph">
        <para>The target graph of the operation.</para>
      </param>
      <returns>
        <para>A context that has the properties configured according to the parameters.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateClipBoardHelperCopyFilter">
      <summary>
        <para>Convenience method that creates a <see cref="T:System.Predicate`1" /> that is based upon the outcome of the <see cref="M:yWorks.Graph.IClipboardHelper.ShouldCopy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> method that can be found in the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the provided <see cref="T:yWorks.Graph.IModelItem" />.</para>
      </summary>
      <returns>
        <para>A predicate that uses <see cref="M:yWorks.Graph.IClipboardHelper.ShouldCopy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphClipboard.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.ElementCopiedCallback)" />
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateSelectionFilter(yWorks.Controls.IGraphSelection,yWorks.Graph.IGraph)">
      <summary>
        <para>Creates a <see cref="T:System.Predicate`1" /> for use in the <see cref="M:yWorks.Graph.GraphClipboard.Cut(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})" /> and <see cref="M:yWorks.Graph.GraphClipboard.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.ElementCopiedCallback)" /> methods.</para>
      </summary>
      <remarks>
        <para>This predicate is based on the element induced by the set of selected nodes, e.g. each edge that has both of its adjacent port owners selected will be included as well as each label and port whose owner is included. Also ports where no adjacent edge is included (but edges exist), will not be included, unless the <see cref="P:yWorks.Graph.IPortDefaults.AutoCleanup" /> is set to <c>false</c>.</para>
      </remarks>
      <param name="selection">
        <para>The selection model to base the filter on.</para>
      </param>
      <param name="graph">
        <para>The graph to use for determining adjacency.</para>
      </param>
      <returns>
        <para>A predicate that filters subgraph induced by the selection of nodes.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateClipboardGraph">
      <summary>
        <para>Creates the graph used for the clipboard.</para>
      </summary>
      <returns>
        <para>A new readily configured <see cref="T:yWorks.Graph.DefaultGraph" /> instance.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.Empty">
      <summary>
        <para>Gets whether the clipboard graph is empty.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.Cut(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})">
      <summary>
        <para>Cuts the items indicated by <paramref name="filter" /> to the clipboard and removes them from the graph.</para>
      </summary>
      <remarks>
        <para>This method delegates the core work to <see cref="M:yWorks.Graph.GraphClipboard.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.ElementCopiedCallback)" /> which will use the <see cref="P:yWorks.Graph.GraphClipboard.ToClipboardCopier" /> to copy the cut elements to the clipboard.</para>
      </remarks>
      <param name="sourceGraph">
        <para>The graph to cut the items from.</para>
      </param>
      <param name="filter">
        <para>The filter to use.</para>
      </param>
      <seealso cref="M:yWorks.Graph.GraphClipboard.CreateSelectionFilter(yWorks.Controls.IGraphSelection,yWorks.Graph.IGraph)" />
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.ToClipboardCopier">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.GraphCopier" /> instance that will be used to copy the graph to the clipboard.</para>
      </summary>
      <remarks>
        <para>This instance is lazily created using <see cref="M:yWorks.Graph.GraphClipboard.CreateToClipboardCopier" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.FromClipboardCopier">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.GraphCopier" /> instance that will be used to copy the graph from the clipboard to the target graph.</para>
      </summary>
      <remarks>
        <para>This instance is lazily created using <see cref="M:yWorks.Graph.GraphClipboard.CreateFromClipboardCopier" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.DuplicateCopier">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.GraphCopier" /> instance that will be used to duplicate elements inside the graph.</para>
      </summary>
      <remarks>
        <para>This instance is lazily created using <see cref="M:yWorks.Graph.GraphClipboard.CreateDuplicateCopier" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateToClipboardCopier">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Graph.GraphClipboard.ToClipboardCopier" />.</para>
      </summary>
      <returns>
        <para>A new <see cref="T:yWorks.Graph.GraphCopier" /> instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateFromClipboardCopier">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" />.</para>
      </summary>
      <returns>
        <para>A new <see cref="T:yWorks.Graph.GraphCopier" /> instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateDuplicateCopier">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Graph.GraphClipboard.DuplicateCopier" />.</para>
      </summary>
      <returns>
        <para>A new <see cref="T:yWorks.Graph.GraphCopier" /> instance.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.IdProvider">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.IClipboardIdProvider" /> used by this instance to provide IDs for copied items.</para>
      </summary>
      <remarks>
        <para>The default implementation simply uses a reference to the original item as ID.<br /> Custom ID can be used to map between elements in different graphs.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.CreateDefaultClipboardIdProvider">
      <summary>
        <para>Creates the default <see cref="T:yWorks.Graph.IClipboardIdProvider" /> used by this instance to provide IDs for copied items.</para>
      </summary>
      <remarks>
        <para>The default implementation simply uses a reference to the original item as ID.</para>
        <para>Custom ID can be used to map between elements in different graphs.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.ElementCopiedCallback)">
      <summary>
        <para>Calls <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /> on the current <see cref="P:yWorks.Graph.GraphClipboard.ToClipboardCopier" /> instance or <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" /> instance, depending on whether the <paramref name="targetGraph" /> is the <see cref="P:yWorks.Graph.GraphClipboard.ClipboardGraph" /> instance.</para>
      </summary>
      <param name="sourceGraph">
        <para>The source graph to pass to <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /></para>
      </param>
      <param name="filter">
        <para>The predicate to pass on.</para>
      </param>
      <param name="targetGraph">
        <para>The target graph to pass on.</para>
      </param>
      <param name="targetRootNode">
        <para>The node to use as the root node in the grouped <paramref name="targetGraph" />.</para>
      </param>
      <param name="elementCopiedCallback">
        <para>The delegate to pass on. For each element that is copied during the operation to the clipboard, this callback will be passed the original and the copy of the item. In case the <paramref name="sourceGraph" /> is a <see cref="P:yWorks.Graph.FoldingManager.Views">folding view graph</see> both elements are passed as <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master</see> elements or <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)">folding state elements</see> if a master element does not exist.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.Paste(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.ElementCopiedCallback,System.Predicate{yWorks.Graph.IModelItem})">
      <summary>
        <para>Calls <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /> on the current <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" /> instance, depending on whether the <paramref name="targetGraph" /> is the <see cref="P:yWorks.Graph.GraphClipboard.ClipboardGraph" /> instance.</para>
      </summary>
      <param name="sourceGraph">
        <para>The source graph to pass to <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /></para>
      </param>
      <param name="filter">
        <para>The predicate to pass on.</para>
      </param>
      <param name="targetGraph">
        <para>The target graph to pass on.</para>
      </param>
      <param name="targetRootNode">
        <para>The node to use as the root node in the grouped <paramref name="targetGraph" />.</para>
      </param>
      <param name="elementCopiedCallback">
        <para>The delegate to pass on. For each element that is copied during the operation to the clipboard, this callback will be passed the original and the copy of the item. In case the <paramref name="targetGraph" /> is a <see cref="P:yWorks.Graph.FoldingManager.Views">folding view graph</see> the original element is passed as <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master</see> elements or <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)">folding state elements</see> if a master element does not exist. The copied element is always part of the <paramref name="targetGraph" />.</para>
      </param>
      <param name="targetFilter">
        <para>This predicate is used to determine which <see cref="T:yWorks.Graph.INode" />s and <see cref="T:yWorks.Graph.IEdge" />s can be used as targets for paste operations, e.g. if a labels or ports are copied without their owners. If <c>null</c> all model items can be used as targets.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.RemoveElements(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})">
      <summary>
        <para>Removes elements from the graph based on a <see cref="T:System.Predicate`1" />.</para>
      </summary>
      <param name="sourceGraph">
        <para>The graph to remove elements from.</para>
      </param>
      <param name="predicate">
        <para>The predicate that decides which elements to remove.</para>
      </param>
      <seealso cref="M:yWorks.Graph.GraphClipboard.Cut(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})" />
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})">
      <summary>
        <para>Copies the elements indicated by the filter to the clipboard graph.</para>
      </summary>
      <remarks>
        <para>For each element copied to the clipboard graph the <see cref="M:yWorks.Graph.GraphClipboard.OnElementCopied(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)" /> delegate will be called. The actual work of this method is delegated to the <see cref="P:yWorks.Graph.GraphClipboard.ToClipboardCopier" />'s <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /> method.</para>
      </remarks>
      <param name="sourceGraph">
        <para>The graph to copy the contents from.</para>
      </param>
      <param name="filter">
        <para>The filter to apply to the source graph's elements.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.Clear">
      <summary>
        <para>Clears the clipboard's contents.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.Paste(yWorks.Graph.IGraph,yWorks.Controls.IGraphSelection)">
      <summary>
        <para>Pastes the <see cref="P:yWorks.Graph.GraphClipboard.ClipboardGraph" />'s contents into the <paramref name="targetGraph" />, selecting all pasted elements.</para>
      </summary>
      <remarks>
        <para>The actual work of this method is delegated to the <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" />'s <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /> method.</para>
      </remarks>
      <param name="targetGraph">
        <para>The graph to paste into.</para>
      </param>
      <param name="selection">
        <para>The selection model to set the selection on.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.Paste(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.ElementCopiedCallback)">
      <summary>
        <para>Pastes the contents from the <see cref="P:yWorks.Graph.GraphClipboard.ClipboardGraph" /> to the <paramref name="targetGraph" /> after applying a <paramref name="filter" />.</para>
      </summary>
      <remarks>
        <para>For each element pasted into the graph the <paramref name="elementPasted" /> delegate will be invoked and the <see cref="M:yWorks.Graph.GraphClipboard.OnElementPasted(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)" /> method will be called. The actual work of this method is delegated to the <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" />'s <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /> method.</para>
      </remarks>
      <param name="targetGraph">
        <para>The graph to paste the contents in.</para>
      </param>
      <param name="filter">
        <para>The filter to apply to the clipboard graph.</para>
      </param>
      <param name="elementPasted">
        <para>The callback to use for each element that has been pasted. For each element that is copied during the operation to the clipboard, this callback will be passed the original and the copy of the item. In case the <paramref name="targetGraph" /> is a <see cref="P:yWorks.Graph.FoldingManager.Views">folding view graph</see> the original element is passed as <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master</see> elements or <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)">folding state elements</see> if a master element does not exist. The copied element is always part of the <paramref name="targetGraph" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.Paste(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.ElementCopiedCallback,System.Predicate{yWorks.Graph.IModelItem})">
      <summary>
        <para>Pastes the contents from the <see cref="P:yWorks.Graph.GraphClipboard.ClipboardGraph" /> to the <paramref name="targetGraph" /> after applying a <paramref name="filter" />.</para>
      </summary>
      <remarks>
        <para>For each element pasted into the graph the <paramref name="elementPasted" /> delegate will be invoked and the <see cref="M:yWorks.Graph.GraphClipboard.OnElementPasted(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)" /> method will be called. The actual work of this method is delegated to the <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" />'s <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /> method. <br /> Providing a valid <paramref name="targetFilter" /> allows for pasting <see cref="T:yWorks.Graph.ILabel" />s, <see cref="T:yWorks.Graph.IPort" />s, and <see cref="T:yWorks.Graph.IEdge" />s without valid owners.</para>
      </remarks>
      <param name="context">
        <para>A valid input mode context. Passing a valid input mode context is required for keeping orthogonal edges at group nodes whose size might be adjusted after the paste operation.</para>
      </param>
      <param name="targetGraph">
        <para>The graph to paste the contents in.</para>
      </param>
      <param name="filter">
        <para>The filter to apply to the clipboard graph.</para>
      </param>
      <param name="elementPasted">
        <para>The callback to use for each element that has been pasted. For each element that is copied during the operation to the clipboard, this callback will be passed the original and the copy of the item. In case the <paramref name="targetGraph" /> is a <see cref="P:yWorks.Graph.FoldingManager.Views">folding view graph</see> the original element is passed as <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master</see> elements or <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)">folding state elements</see> if a master element does not exist. The copied element is always part of the <paramref name="targetGraph" />.</para>
      </param>
      <param name="targetFilter">
        <para>A filter which returns <c>true</c> for model items which can be used as target for clipboard items which need an owner (e.g. <see cref="T:yWorks.Graph.ILabel" />s which were copied without their owner). If <c>null</c> all model items can be used as targets.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.OnElementCut(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)">
      <summary>
        <para>
          <see cref="T:yWorks.Graph.ElementCopiedCallback" /> that will be invoked for each item that has been copied into the clipboard graph in response to a <see cref="M:yWorks.Graph.GraphClipboard.Cut(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})" /> operation.</para>
      </summary>
      <remarks>
        <para>This implementation will <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> a <see cref="T:yWorks.Graph.IClipboardHelper" /> for each item in the original graph and remember the memento retrieved by the <see cref="M:yWorks.Graph.IClipboardHelper.Cut(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> method for later use during the <see cref="M:yWorks.Graph.GraphClipboard.OnElementPasted(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)" /> operation.</para>
      </remarks>
      <param name="original">
        <para>The original element from the source graph instance. If the source graph is a managed folding view, this is always a master item.</para>
      </param>
      <param name="copy">
        <para>The copy from the clipboard graph.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.GetClipboardHelper(yWorks.Graph.IModelItem)">
      <summary>
        <para>Retrieves the <see cref="T:yWorks.Graph.IClipboardHelper" /> instance associated with the given item.</para>
      </summary>
      <remarks>
        <para>This implementation uses the item's <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method to retrieve the helper instance.</para>
      </remarks>
      <param name="item">
        <para>The item to find the clipboard helper for.</para>
      </param>
      <returns>
        <para>An instance or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.OnElementCopied(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)">
      <summary>
        <para>
          <see cref="T:yWorks.Graph.ElementCopiedCallback" /> that will be invoked for each item that has been copied into the clipboard graph in response to a <see cref="M:yWorks.Graph.GraphClipboard.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.ElementCopiedCallback)" /> operation.</para>
      </summary>
      <remarks>
        <para>This implementation will <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> a <see cref="T:yWorks.Graph.IClipboardHelper" /> for each item in the original graph and remember the memento retrieved by the <see cref="M:yWorks.Graph.IClipboardHelper.Copy(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem)" /> method for later use during the <see cref="M:yWorks.Graph.GraphClipboard.OnElementPasted(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)" /> operation.</para>
      </remarks>
      <param name="original">
        <para>The original element from the source graph instance. If the source graph is a managed folding view, this is always a master item.</para>
      </param>
      <param name="copy">
        <para>The copy from the clipboard graph.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.GetMemento(yWorks.Graph.IModelItem)">
      <summary>
        <para>Retrieves the memento associated with an item in the clipboard graph that has been stored with the item during <see cref="M:yWorks.Graph.GraphClipboard.OnElementCopied(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)" /> and <see cref="M:yWorks.Graph.GraphClipboard.OnElementCut(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)" />.</para>
      </summary>
      <param name="clipboardItem">
        <para>The item in the clipboard graph.</para>
      </param>
      <returns>
        <para>The object returned by the <see cref="T:yWorks.Graph.IClipboardHelper" /> methods or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.OnElementPasted(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)">
      <summary>
        <para>
          <see cref="T:yWorks.Graph.ElementCopiedCallback" /> that will be invoked for each item that has been pasted into the target graph in response to a <see cref="M:yWorks.Graph.GraphClipboard.Paste(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.ElementCopiedCallback,System.Predicate{yWorks.Graph.IModelItem})" /> operation.</para>
      </summary>
      <remarks>
        <para>This method will use a previously stored <see cref="T:yWorks.Graph.IClipboardHelper" /> to let it <see cref="M:yWorks.Graph.IClipboardHelper.Paste(yWorks.Graph.IGraphClipboardContext,yWorks.Graph.IModelItem,System.Object)">finish</see> its work.</para>
      </remarks>
      <param name="original">
        <para>The original element from the clipboard graph instance. If the target graph is a managed folding view, this is always a master item.</para>
      </param>
      <param name="copy">
        <para>The copy from the target graph.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.ClipboardGraph">
      <summary>
        <para>Gets or sets the graph that contains the clipboard's contents.</para>
      </summary>
      <remarks />
      <exception cref="T:System.ArgumentNullException">
        <para>If <c>value</c> is <c>null</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.GetTarget(yWorks.Graph.ILabel)">
      <summary>
        <para>Provides an <see cref="T:yWorks.Graph.ILabelOwner" /> where the given <paramref name="originalLabel" /> can be added to.</para>
      </summary>
      <remarks>
        <para>Called for <see cref="T:yWorks.Graph.ILabel" />s whose owners are not copied to provide a new owner. Might return <c>null</c> if no target for the given <paramref name="originalLabel" /> is found. In this case the label will not be copied.</para>
      </remarks>
      <param name="originalLabel">
        <para>The label to be copied.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.ILabelOwner" /> for the label to be added to or <c>null</c> if the label should not be copied.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.IsFoldingStateElement(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)">
      <summary>
        <para>Whether the given <paramref name="item" /> exists in a folding state of its <paramref name="owner" />.</para>
      </summary>
      <param name="owner">
        <para>The owner of the given item.</para>
      </param>
      <param name="item">
        <para>An <see cref="T:yWorks.Graph.ILabel" />, <see cref="T:yWorks.Graph.IPort" />, or <see cref="T:yWorks.Graph.IBend" />.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given item exists in a folding state.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.GetTarget(yWorks.Graph.IPort)">
      <summary>
        <para>Provides an <see cref="T:yWorks.Graph.IPortOwner" /> where the given <paramref name="originalPort" /> can be added to.</para>
      </summary>
      <remarks>
        <para>Called for <see cref="T:yWorks.Graph.IPort" />s whose owners are not copied to provide a new owner. Might return <c>null</c> if no target for the given <paramref name="originalPort" /> is found. In this case the port will not be copied.</para>
      </remarks>
      <param name="originalPort">
        <para>The port to be copied.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IPortOwner" /> for the port to be added to or <c>null</c> if the port should not be copied.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.GetTarget(yWorks.Graph.IEdge,System.Boolean)">
      <summary>
        <para>Provides an <see cref="T:yWorks.Graph.IPort" /> where the given <paramref name="originalEdge" /> can be added to.</para>
      </summary>
      <remarks>
        <para>Called for <see cref="T:yWorks.Graph.IEdge" />s whose source or target ports are not copied to provide a new port. Might return <c>null</c> if no target for the given <paramref name="originalEdge" /> is found. In this case the edge will not be copied.</para>
      </remarks>
      <param name="originalEdge">
        <para>The edge to be copied.</para>
      </param>
      <param name="atSource">
        <para>Whether to look for a source port.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IPort" /> for the edge to be added to or <c>null</c> if the edge should not be copied.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.GetTarget(yWorks.Graph.IBend)">
      <summary>
        <para>Provides an <see cref="T:yWorks.Graph.IEdge" /> where the given <paramref name="originalBend" /> can be added to.</para>
      </summary>
      <remarks>
        <para>Called for <see cref="T:yWorks.Graph.IBend" />s whose edge is not copied to provide a new owner. Might return <c>null</c> if no target for the given <paramref name="originalBend" /> is found. In this case the bend will not be copied.</para>
      </remarks>
      <param name="originalBend">
        <para>The bend to be copied.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IEdge" /> for the bend to be added to or <c>null</c> if the bend should not be copied.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.GetTarget(yWorks.Graph.INode)">
      <summary>
        <para>Provides a parent group node for the given <paramref name="originalNode" />.</para>
      </summary>
      <remarks>
        <para>Called for <see cref="T:yWorks.Graph.INode" />s to place them inside a group node. Might return <c>null</c> if the given node should be placed at the root or if the graph is not grouped.</para>
      </remarks>
      <param name="originalNode">
        <para>The node to be copied.</para>
      </param>
      <returns>
        <para>The new parent group of the node or <c>null</c> if the node should be placed at the root of the hierarchy or if the graph is not grouped.</para>
      </returns>
      <seealso cref="P:yWorks.Graph.GraphClipboard.ParentNodeDetection" />
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.ParentNodeDetection">
      <summary>
        <para>Gets or sets whether or not nodes should be automatically put into a group node and if so how this group will be determined.</para>
      </summary>
      <remarks>
        <para>This property is used by <see cref="M:yWorks.Graph.GraphClipboard.GetTarget(yWorks.Graph.INode)" /> to decide what node to yield as the target group node for the newly pasted node.</para>
        <para>The default is <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Selection" />|<see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.PreviousParent" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes">
      <summary>
        <para>Defines the rules for pasting nodes into group nodes.</para>
      </summary>
      <remarks>
        <para>The enumeration can be used to create <see cref="T:System.FlagsAttribute">bitwise combination</see> of the types.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Root">
      <summary>
        <para>Nodes should always be pasted into the root group.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Selection">
      <summary>
        <para>If exactly one group node is selected the nodes should be pasted into that group.</para>
      </summary>
      <remarks>
        <para>As long as <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.AllowSelf" /> is not set, too, a node will not be pasted into its original node. Note that it can be pasted into a copy of its original, though.</para>
        <para>If this setting is combined with <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Root" /> or <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.PreviousParent" /> it will override that setting if a group node is selected.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.PreviousParent">
      <summary>
        <para>A node should be pasted into its original parent.</para>
      </summary>
      <remarks>
        <para>If the parent has been removed from the graph in between the copy and paste operation the node will be placed into the parent's parent.</para>
        <para>If the previous parent has been moved too far away the node will be placed into the root unless <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Force" /> is set, too.</para>
        <para>If this setting is combined with <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Selection" /> or <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.AtLocation" /> it will be overridden by the other setting.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.AtLocation">
      <summary>
        <para>A node should be pasted into the group node at the location where the node is pasted to or the root if there is no group node.</para>
      </summary>
      <remarks>
        <para>As long as <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.AllowSelf" /> is not set, too, the node will not be pasted into its original node. Note that it can be pasted into a copy of its original, though.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.AllowSelf">
      <summary>
        <para>When used in combination with <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Selection" /> or <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.AtLocation" /> this setting will allow pasting nodes into their original.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Force">
      <summary>
        <para>If combined with <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.PreviousParent" /> forces the node to be pasted into its original parent, even if the parent has moved far away and pasting the node would increase the parents size considerably.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.ModeMask">
      <summary>
        <para>A bitmask that can be used to query the actual mode (<see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Root" />, <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Selection" />, <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.AtLocation" />, or <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.PreviousParent" />).</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.ModifierMask">
      <summary>
        <para>A bitmask that can be used to query modifications of the actual mode such as <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.AllowSelf" /> or <see cref="F:yWorks.Graph.GraphClipboard.ParentNodeDetectionModes.Force" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.DependentCopyItems">
      <summary>
        <para>Gets or sets the type of items that depend on other elements but should automatically be copied implicitly to the clipboard if all elements that it depends on are explicitly selected for copying.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Graph.ILabel">Labels</see> depend on their <see cref="T:yWorks.Graph.ILabelOwner">owner</see>, like <see cref="T:yWorks.Graph.IPort">ports</see> depend on their <see cref="T:yWorks.Graph.IPortOwner">owner</see>. Also <see cref="T:yWorks.Graph.IBend">bends</see> of course depend on their <see cref="T:yWorks.Graph.IEdge">owning edge</see>.</para>
        <para>If the corresponding element type is set in this property, items that depend on other items are implicitly included in the copy operation, if all of the items that they depend on are included recursively, even if they are not included explicitly themselves.</para>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" /> minus <see cref="F:yWorks.Graph.GraphItemTypes.Node" />, which means that selecting a number of nodes will automatically select all elements that directly and indirectly depend on the existence of this set of nodes will be copied to the clipboard, too.</para>
        <para>Technically nodes do not depend on anything. Setting this property to a value that includes <see cref="F:yWorks.Graph.GraphItemTypes.Node" /> will include all child nodes for every selected group node.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.IndependentCopyItems">
      <summary>
        <para>Gets or sets the type of items that can be copied and pasted independently of their owning element.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Graph.ILabel">Labels</see> depend on their <see cref="T:yWorks.Graph.ILabelOwner">owner</see>, like <see cref="T:yWorks.Graph.IPort">ports</see> depend on their <see cref="T:yWorks.Graph.IPortOwner">owner</see>. Also <see cref="T:yWorks.Graph.IBend">bends</see> of course depend on their <see cref="T:yWorks.Graph.IEdge">owning edge</see>.</para>
        <para>If the corresponding element type is set in this property, items can be copied alone to the clipboard and be pasted onto different owning elements.</para>
        <para>This enables copying of a label to one or more owners, without having to copy the owner of the label. Also ports can be copied to other <see cref="T:yWorks.Graph.IPortOwner" />s and bends to other edges.</para>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" /> which means that all elements can be copied to the clipboard even if the items that they depend on are not copied to the clipboard.</para>
        <para>Technically owning elements are still part of the clipboard as <see cref="M:yWorks.Graph.GraphClipboard.IsDummy(yWorks.Graph.IModelItem)">dummy elements</see>, but these elements will not be pasted to the target during paste or duplicate operations.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.CopyItems">
      <summary>
        <para>Gets or sets the type of items that can be copied and pasted at all using the clipboard.</para>
      </summary>
      <remarks>
        <para>If the corresponding element type is set in this property, items can be effectively copied.</para>
        <para>If the corresponding element type is not set in this property, items will not be pasted, even if they have been explicitly selected. They may copied to the clipboard and become part of the <see cref="P:yWorks.Graph.GraphClipboard.ClipboardGraph" />, nevertheless though, if they are required as <see cref="M:yWorks.Graph.GraphClipboard.IsDummy(yWorks.Graph.IModelItem)">dummy elements</see>. But these elements will not be pasted to the target during paste or duplicate operations.</para>
        <para>The default is <see cref="F:yWorks.Graph.GraphItemTypes.All" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.GetLabelLayoutParameter(yWorks.Graph.GraphCopier,yWorks.Graph.IGraph,yWorks.Graph.ILabel,yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> for the given <paramref name="label" /> to be placed at the given <paramref name="newOwner" />.</para>
      </summary>
      <remarks>
        <para>Implementations might delegate to <see cref="M:yWorks.Graph.GraphCopier.CopyLabelLayoutParameter(yWorks.Graph.IGraph,yWorks.Graph.ILabel)" /> to copy the existing parameter or use the <see cref="P:yWorks.Graph.IGraph.NodeDefaults" /> or <see cref="P:yWorks.Graph.IGraph.EdgeDefaults" /> to create a new one. Note that the type of the owner might have changed during the copy operation.</para>
      </remarks>
      <param name="copier">
        <para>The <see cref="T:yWorks.Graph.GraphCopier" /> whose <see cref="M:yWorks.Graph.GraphCopier.CopyLabelLayoutParameter(yWorks.Graph.IGraph,yWorks.Graph.ILabel)" /> method can be used to copy the existing parameter.</para>
      </param>
      <param name="graph">
        <para>The <see cref="T:yWorks.Graph.IGraph" /> whose <see cref="P:yWorks.Graph.IGraph.NodeDefaults" /> or <see cref="P:yWorks.Graph.IGraph.EdgeDefaults" /> can be used to create a new parameter.</para>
      </param>
      <param name="label">
        <para>The label to be copied.</para>
      </param>
      <param name="newOwner">
        <para>The new owner for the label.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> for the copied label.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.GetPortLocationParameter(yWorks.Graph.GraphCopier,yWorks.Graph.IGraph,yWorks.Graph.IPort,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> for the given <paramref name="originalPort" /> to be placed at the given <paramref name="newOwner" />.</para>
      </summary>
      <remarks>
        <para>Implementations might delegate to <see cref="M:yWorks.Graph.GraphCopier.CopyPortLocationParameter(yWorks.Graph.IGraph,yWorks.Graph.IPort)" /> to copy the existing parameter or use the <see cref="P:yWorks.Graph.IGraph.NodeDefaults" /> or <see cref="P:yWorks.Graph.IGraph.EdgeDefaults" /> to create a new one. Note that the type of the owner might have changed during the copy operation.</para>
      </remarks>
      <param name="copier">
        <para>The <see cref="T:yWorks.Graph.GraphCopier" /> whose <see cref="M:yWorks.Graph.GraphCopier.CopyPortLocationParameter(yWorks.Graph.IGraph,yWorks.Graph.IPort)" /> method can be used to copy the existing parameter.</para>
      </param>
      <param name="graph">
        <para>The <see cref="T:yWorks.Graph.IGraph" /> whose <see cref="P:yWorks.Graph.IGraph.NodeDefaults" /> or <see cref="P:yWorks.Graph.IGraph.EdgeDefaults" /> can be used to create a new parameter.</para>
      </param>
      <param name="originalPort">
        <para>The port to be copied.</para>
      </param>
      <param name="newOwner">
        <para>The new owner for the port.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> for the copied port.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.GetFoldingEdgeState(yWorks.Graph.IEdge,yWorks.Graph.FoldingEdgeStateId)">
      <summary>
        <para>Gets a folding state of an edge for a given <see cref="T:yWorks.Graph.FoldingEdgeStateId" />.</para>
      </summary>
      <remarks>
        <para>This method might be overridden to map folding states for edges whose source or target node's hierarchy might have changed during a paste operation.</para>
      </remarks>
      <param name="edge">
        <para>The edge to get the folding state for.</para>
      </param>
      <param name="id">
        <para>The original <see cref="T:yWorks.Graph.FoldingEdgeStateId" /> to get the folding state for. Passing <c>null</c> will return the folding state which was visible when the edge was copied into the clipboard.</para>
      </param>
      <returns>
        <para>The folding state which is mapped to the given <paramref name="id" />. May be <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.IsDummy(yWorks.Graph.IModelItem)">
      <summary>
        <para>Whether the given <paramref name="item" /> is a "dummy" item which should not be pasted.</para>
      </summary>
      <remarks>
        <para>A dummy item is used to keep <see cref="T:yWorks.Graph.IModelItem" />s which cannot exist without an owner in the <see cref="P:yWorks.Graph.GraphClipboard.ClipboardGraph" /> (e.g. <see cref="T:yWorks.Graph.ILabel" />s).</para>
      </remarks>
      <param name="item">
        <para>The item to test.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the item is a "dummy" item.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.GraphClipboard.IgnoreEdgesWithOneNode">
      <summary>
        <para>Gets or sets whether to paste edges whose source or target node was selected when copying to the clipboard while the other node was not.</para>
      </summary>
      <remarks>
        <para>The default is <c>false</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphClipboard.Duplicate(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.ElementCopiedCallback)">
      <summary>
        <para>Duplicates the elements indicated by the filter.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Graph.GraphClipboard.ClipboardGraph" /> is not altered by this operation.</para>
      </remarks>
      <param name="context">
        <para>The current <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </param>
      <param name="sourceGraph">
        <para>The graph whose elements should be duplicated.</para>
      </param>
      <param name="filter">
        <para>A <see cref="T:System.Predicate`1" /> which returns <c>true</c> for elements which should be duplicated.</para>
      </param>
      <param name="elementDuplicated">
        <para>An <see cref="T:yWorks.Graph.ElementCopiedCallback" /> which gets invoked for each element which has been duplicated. The two parameters passed into the callback are guaranteed to be part of the <paramref name="sourceGraph" />.</para>
      </param>
    </member>
    <member name="E:yWorks.Graph.GraphClipboard.ElementsCut">
      <summary>
        <para>Occurs when the <see cref="M:yWorks.Graph.GraphClipboard.Cut(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})" /> operation finished successfully.</para>
      </summary>
    </member>
    <member name="E:yWorks.Graph.GraphClipboard.ElementsCopied">
      <summary>
        <para>Occurs when the <see cref="M:yWorks.Graph.GraphClipboard.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem})" /> operation finished successfully.</para>
      </summary>
    </member>
    <member name="E:yWorks.Graph.GraphClipboard.ElementsPasted">
      <summary>
        <para>Occurs when the <see cref="M:yWorks.Graph.GraphClipboard.Paste(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.ElementCopiedCallback,System.Predicate{yWorks.Graph.IModelItem})" /> operation finished successfully.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.ElementCopiedCallback">
      <summary>
        <para>Callback delegate used by <see cref="T:yWorks.Graph.GraphCopier" /> and the like.</para>
      </summary>
      <param name="original">
        <para>The element that has been copied.</para>
      </param>
      <param name="copy">
        <para>The copy of the original element.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.GraphCopier">
      <summary>
        <para>Utility class that copies parts of an <see cref="T:yWorks.Graph.IGraph" /> to another instance.</para>
      </summary>
      <remarks>
        <para>Instances of this class can be used in <see cref="T:yWorks.Graph.GraphClipboard" />, e.g.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.GraphCopier.CloneTypes">
      <summary>
        <para>Enumeration that can use <see cref="T:System.FlagsAttribute">flags</see> to indicate which items should be <see cref="M:System.ICloneable.Clone">cloned</see> during copy operations.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphCopier.CloneTypes.NodeStyle">
      <summary>
        <para>Indicates the <see cref="T:yWorks.Graph.Styles.INodeStyle" /> constant.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphCopier.CloneTypes.EdgeStyle">
      <summary>
        <para>Indicates the <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> constant.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphCopier.CloneTypes.PortStyle">
      <summary>
        <para>Indicates the <see cref="T:yWorks.Graph.Styles.IPortStyle" /> constant.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphCopier.CloneTypes.LabelStyle">
      <summary>
        <para>Indicates the <see cref="T:yWorks.Graph.Styles.ILabelStyle" /> constant.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphCopier.CloneTypes.LabelModelParameter">
      <summary>
        <para>Indicates the <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> constant.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphCopier.CloneTypes.PortLocationModelParameter">
      <summary>
        <para>Indicates the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> constant.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphCopier.CloneTypes.Tags">
      <summary>
        <para>Indicates the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> constant.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.GraphCopier.CloneTypes.All">
      <summary>
        <para>A combination of all flags in this enumeration.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.GraphCopier.Clone">
      <summary>
        <para>Gets or sets the types of items that should be <see cref="M:System.ICloneable.Clone">cloned</see> for the copy operation.</para>
      </summary>
      <value>
        <para>A bitwise combination of the types to clone.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.OnObjectCopied(yWorks.Graph.ItemCopiedEventArgs{System.Object})">
      <summary>
        <para>Emits the <see cref="E:yWorks.Graph.GraphCopier.ObjectCopied" /> event.</para>
      </summary>
      <param name="itemCopiedEventArgs">
        <para>The argument to use.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyEdgeStyle(yWorks.Graph.IGraph,yWorks.Graph.IEdge)">
      <summary>
        <para>Copies an <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> instance.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:System.ICloneable.Clone" /> method to create a copy.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains the edge.</para>
      </param>
      <param name="edge">
        <para>The edge to copy the style from.</para>
      </param>
      <returns>
        <para>The style to apply for the copy.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" />
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyPortStyle(yWorks.Graph.IGraph,yWorks.Graph.IPort)">
      <summary>
        <para>Copies an <see cref="T:yWorks.Graph.Styles.IPortStyle" /> instance.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:System.ICloneable.Clone" /> method to create a copy.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains the port.</para>
      </param>
      <param name="port">
        <para>The port to copy the style from.</para>
      </param>
      <returns>
        <para>The style to apply for the copy.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" />
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyNodeStyle(yWorks.Graph.IGraph,yWorks.Graph.INode)">
      <summary>
        <para>Copies an <see cref="T:yWorks.Graph.Styles.INodeStyle" /> instance.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:System.ICloneable.Clone" /> method to create a copy.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains the node.</para>
      </param>
      <param name="node">
        <para>The node to copy the style from.</para>
      </param>
      <returns>
        <para>The style to apply for the copy.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" />
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyLabelStyle(yWorks.Graph.IGraph,yWorks.Graph.ILabel)">
      <summary>
        <para>Copies an <see cref="T:yWorks.Graph.Styles.ILabelStyle" /> instance.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:System.ICloneable.Clone" /> method to create a copy.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains the label.</para>
      </param>
      <param name="label">
        <para>The label to copy the style from.</para>
      </param>
      <returns>
        <para>The style to apply for the copy.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" />
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyLabelLayoutParameter(yWorks.Graph.IGraph,yWorks.Graph.ILabel)">
      <summary>
        <para>Copies a <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> for a given label.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:System.ICloneable.Clone" /> method to create a copy.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains the label.</para>
      </param>
      <param name="label">
        <para>The label to copy the label model parameter from.</para>
      </param>
      <returns>
        <para>The copy of the parameter to apply for the copy.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" />
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyPortLocationParameter(yWorks.Graph.IGraph,yWorks.Graph.IPort)">
      <summary>
        <para>Copies a <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> for a given port.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:System.ICloneable.Clone" /> method to create a copy.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains the port.</para>
      </param>
      <param name="port">
        <para>The port to copy the model parameter from.</para>
      </param>
      <returns>
        <para>The copy of the parameter to apply for the copy.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" />
    </member>
    <member name="P:yWorks.Graph.GraphCopier.ReferentialIdentityTypes">
      <summary>
        <para>Gets or sets the types of objects where the referential identity should be kept across clipboard operations.</para>
      </summary>
      <remarks>
        <para>For each of the types that are set via this property, this implementation will use a caching copy mechanism as follows: If there has already been an instance copied via this clipboard (<see cref="M:yWorks.Graph.GraphCopier.GetCopy``1(``0,``0@)" />), that instance will instead be returned, otherwise, this implementation will clone the original instance (depending on the setting of <see cref="P:yWorks.Graph.GraphCopier.Clone" />) and <see cref="M:yWorks.Graph.GraphCopier.CacheCopy``1(``0,``0)">cache the copy</see> until after the operation the <see cref="M:yWorks.Graph.GraphCopier.ClearCopyCache">cache is cleared</see>. This feature is implemented directly by the various <see cref="M:yWorks.Graph.GraphCopier.CopyNodeStyle(yWorks.Graph.IGraph,yWorks.Graph.INode)">CopyXXX</see> methods.</para>
      </remarks>
      <value>
        <para>The referential identity types.</para>
      </value>
      <seealso cref="M:yWorks.Graph.GraphCopier.GetOrCreateCopy``1(``0,System.Func{``0,``0})" />
    </member>
    <member name="M:yWorks.Graph.GraphCopier.GetCopy``1(``0,``0@)">
      <summary>
        <para>Tries to obtain a previously <see cref="M:yWorks.Graph.GraphCopier.CacheCopy``1(``0,``0)">cached</see> copy for the given original.</para>
      </summary>
      <remarks>
        <para>Values will be stored in the cache until the next call to <see cref="M:yWorks.Graph.GraphCopier.ClearCopyCache" />.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the item to copy.</para>
      </typeparam>
      <param name="original">
        <para>The original item.</para>
      </param>
      <param name="copy">
        <para>The copy will be returned via this parameter if this method yields <c>true</c>.</para>
      </param>
      <returns>
        <para>Whether a valid copy has been found in the cache.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphCopier.CacheCopy``1(``0,``0)" />
      <seealso cref="M:yWorks.Graph.GraphCopier.GetOrCreateCopy``1(``0,System.Func{``0,``0})" />
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CacheCopy``1(``0,``0)">
      <summary>
        <para>This method places the given copy into an internal cache.</para>
      </summary>
      <remarks>
        <para>The cache can be queried using <see cref="M:yWorks.Graph.GraphCopier.GetCopy``1(``0,``0@)" />. The cache is held until <see cref="M:yWorks.Graph.GraphCopier.ClearCopyCache" /> is called.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the item to cache.</para>
      </typeparam>
      <param name="original">
        <para>The original item.</para>
      </param>
      <param name="copy">
        <para>The copy of the item.</para>
      </param>
      <seealso cref="M:yWorks.Graph.GraphCopier.GetOrCreateCopy``1(``0,System.Func{``0,``0})" />
    </member>
    <member name="P:yWorks.Graph.GraphCopier.CopyGrouping">
      <summary>
        <para>Gets or sets a property that determines whether grouping information should be copied to target graphs.</para>
      </summary>
      <remarks>
        <para>With this property set to <c>false</c> the <see cref="T:yWorks.Graph.GraphCopier" /> can be used to flatten a grouped graph, i.e. remove the grouping information.</para>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.GraphCopier.CopyFoldingStates">
      <summary>
        <para>Gets or sets a property that determines whether <see cref="T:yWorks.Graph.FoldingManager">additional folding states</see>.</para>
      </summary>
      <remarks>
        <para>Should be copied to target graphs.</para>
        <para>If the source and target graphs have an instance of <see cref="T:yWorks.Graph.FoldingManager" /> in their lookup, the additional <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)">folding state</see> of the nodes and edges will be copied. The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,yWorks.Graph.IGraph)">
      <summary>
        <para>Copies <paramref name="sourceGraph" /> to <paramref name="targetGraph" />.</para>
      </summary>
      <remarks>
        <para>This method actually delegates to <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /> and provides the root as the "targetGraph" parameter if there is a hierarchy associated with <paramref name="targetGraph" />.</para>
      </remarks>
      <param name="sourceGraph">
        <para>The graph to copy.</para>
      </param>
      <param name="targetGraph">
        <para>The graph to copy to.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)">
      <summary>
        <para>Copies a subgraph described by a <see cref="T:System.Predicate`1" /> from the <paramref name="sourceGraph" /> to the <paramref name="targetGraph" />.</para>
      </summary>
      <remarks>
        <para>For each element that has been copied, the <paramref name="elementCopiedCallback" /> will be invoked. This method actually delegates to <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /> and provides the root as the "targetGraph" parameter if there is a hierarchy associated with <paramref name="targetGraph" />.</para>
      </remarks>
      <param name="sourceGraph">
        <para>The graph to copy the elements from.</para>
      </param>
      <param name="filter">
        <para>The filter that decides which elements to copy.</para>
      </param>
      <param name="targetGraph">
        <para>The graph to copy the elements to.</para>
      </param>
      <param name="offset">
        <para>The offset to apply to the copied items. Only nodes and bends will be offset explicitly, while other items will move implicitly.</para>
      </param>
      <param name="elementCopiedCallback">
        <para>A delegate to invoke for each element being copied.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)">
      <summary>
        <para>Copies a subgraph induced by a <see cref="T:System.Predicate`1" /> from the <paramref name="sourceGraph" /> to the <paramref name="targetGraph" />.</para>
      </summary>
      <remarks>
        <para>For each element that has been copied, the <paramref name="elementCopiedCallback" /> will be invoked.</para>
      </remarks>
      <param name="sourceGraph">
        <para>The graph to copy the elements from.</para>
      </param>
      <param name="filter">
        <para>The filter that decides which elements to copy.</para>
      </param>
      <param name="targetGraph">
        <para>The graph to copy the elements to.</para>
      </param>
      <param name="targetRootNode">
        <para>The group node that should act as the root node for the pasted elements. May be <c>null</c> if there is no such node.</para>
      </param>
      <param name="offset">
        <para>The offset to apply to the copied items. Only nodes and bends will be offset explicitly, while other items will move implicitly.</para>
      </param>
      <param name="elementCopiedCallback">
        <para>A delegate to invoke for each element being copied.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if <paramref name="targetRootNode" /> is not in <paramref name="targetGraph" /></para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.GetTargetFoldingManager(yWorks.Graph.IGraph)">
      <summary>
        <para>Callback method that retrieves the <see cref="T:yWorks.Graph.FoldingManager" /> from the given target graph.</para>
      </summary>
      <param name="targetGraph">
        <para>The target graph.</para>
      </param>
      <returns>
        <para>The folding manager as obtained from the lookup of the graph.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.GetSourceFoldingManager(yWorks.Graph.IGraph)">
      <summary>
        <para>Callback method that retrieves the <see cref="T:yWorks.Graph.FoldingManager" /> from the given source graph.</para>
      </summary>
      <param name="sourceGraph">
        <para>The source graph.</para>
      </param>
      <returns>
        <para>The folding manager as obtained from the lookup of the graph.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.ClearCopyCache">
      <summary>
        <para>Clears the cache for the <see cref="M:yWorks.Graph.GraphCopier.CacheCopy``1(``0,``0)">cached copies</see> of the instance copied using this class.</para>
      </summary>
      <remarks>
        <para>This method is called before and after a copy operation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.AddBend(yWorks.Graph.IGraph,yWorks.Graph.IGraph,yWorks.Graph.IEdge,yWorks.Graph.IBend,yWorks.Geometry.PointD,System.Int32)">
      <summary>
        <para>Callback method that adds a bend to the targetEdge in the targetGraph as a copy of the source bend.</para>
      </summary>
      <param name="sourceGraph">
        <para>The source graph.</para>
      </param>
      <param name="targetGraph">
        <para>The target graph.</para>
      </param>
      <param name="targetEdge">
        <para>The target edge to add the bend to.</para>
      </param>
      <param name="sourceBend">
        <para>The source bend to copy the values from.</para>
      </param>
      <param name="offset">
        <para>The offset to apply to the copied bend.</para>
      </param>
      <param name="index">
        <para>The index to add the bend at.</para>
      </param>
      <returns>
        <para>The newly created bend.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyEdge(yWorks.Graph.IGraph,yWorks.Graph.IGraph,yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Callback method that adds an edge to the targetGraph as a copy of the source edge.</para>
      </summary>
      <remarks>
        <para>This implementation does not need to copy the <see cref="T:yWorks.Graph.IBend" />s of the <paramref name="sourceEdge" />, nor should it copy <see cref="T:yWorks.Graph.IPort" />s or <see cref="T:yWorks.Graph.ILabel" />s. This implementation uses <see cref="M:yWorks.Graph.GraphCopier.CopyEdgeStyle(yWorks.Graph.IGraph,yWorks.Graph.IEdge)" /> and <see cref="M:yWorks.Graph.GraphCopier.CopyEdgeTag(yWorks.Graph.IEdge,System.Object)" /> as callbacks.</para>
      </remarks>
      <param name="sourceGraph">
        <para>The source graph.</para>
      </param>
      <param name="targetGraph">
        <para>The target graph.</para>
      </param>
      <param name="sourceEdge">
        <para>The edge in the source graph.</para>
      </param>
      <param name="targetSourcePort">
        <para>The new source port in the target graph.</para>
      </param>
      <param name="targetTargetPort">
        <para>The new target port in the target graph.</para>
      </param>
      <returns>
        <para>The newly created edge.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.AddPort(yWorks.Graph.IGraph,yWorks.Graph.IGraph,yWorks.Graph.IPortOwner,yWorks.Graph.IPort)">
      <summary>
        <para>Callback method that adds a port to the targetPortOwner in the targetGraph as a copy of the source port.</para>
      </summary>
      <param name="sourceGraph">
        <para>The source graph.</para>
      </param>
      <param name="targetGraph">
        <para>The target graph.</para>
      </param>
      <param name="targetOwner">
        <para>The port owner in the target graph to add the port to.</para>
      </param>
      <param name="sourcePort">
        <para>The source port in the source graph.</para>
      </param>
      <returns>
        <para>The newly created port.</para>
      </returns>
      <remarks>
        <para>This implementation does not need to copy the adjacent <see cref="T:yWorks.Graph.IEdge" />s of the <paramref name="sourcePort" />. This implementation uses <see cref="M:yWorks.Graph.GraphCopier.CopyPortLocationParameter(yWorks.Graph.IGraph,yWorks.Graph.IPort)" />, <see cref="M:yWorks.Graph.GraphCopier.CopyPortStyle(yWorks.Graph.IGraph,yWorks.Graph.IPort)" />, and <see cref="M:yWorks.Graph.GraphCopier.CopyPortTag(yWorks.Graph.IPort,System.Object)" /> as callbacks.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.AddLabel(yWorks.Graph.IGraph,yWorks.Graph.IGraph,yWorks.Graph.ILabelOwner,yWorks.Graph.ILabel)">
      <summary>
        <para>Callback method that adds a label to the target item in the targetGraph as a copy of the source label.</para>
      </summary>
      <param name="sourceGraph">
        <para>The source graph.</para>
      </param>
      <param name="targetGraph">
        <para>The target graph.</para>
      </param>
      <param name="targetOwner">
        <para>The item owner in the target graph to add the label to.</para>
      </param>
      <param name="sourceLabel">
        <para>The source label in the source graph.</para>
      </param>
      <returns>
        <para>The newly created label.</para>
      </returns>
      <remarks>
        <para>This implementation uses <see cref="M:yWorks.Graph.GraphCopier.CopyLabelLayoutParameter(yWorks.Graph.IGraph,yWorks.Graph.ILabel)" />, <see cref="M:yWorks.Graph.GraphCopier.CopyLabelStyle(yWorks.Graph.IGraph,yWorks.Graph.ILabel)" />, and <see cref="M:yWorks.Graph.GraphCopier.CopyLabelTag(yWorks.Graph.ILabel,System.Object)" /> as callbacks.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyNode(yWorks.Graph.IGraph,yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD)">
      <summary>
        <para>Callback method that creates a copy of the <paramref name="node" /> in the <paramref name="targetGraph" />.</para>
      </summary>
      <remarks>
        <para>This implementation does not need to copy <see cref="T:yWorks.Graph.IPort" />s or <see cref="T:yWorks.Graph.ILabel" />s. This implementation uses <see cref="M:yWorks.Graph.GraphCopier.CopyNodeStyle(yWorks.Graph.IGraph,yWorks.Graph.INode)" /> and <see cref="M:yWorks.Graph.GraphCopier.CopyNodeTag(yWorks.Graph.INode,System.Object)" /> as callbacks.</para>
      </remarks>
      <param name="sourceGraph">
        <para>The source graph.</para>
      </param>
      <param name="targetGraph">
        <para>The target graph.</para>
      </param>
      <param name="node">
        <para>The source node to create a copy of in the <paramref name="targetGraph" />.</para>
      </param>
      <param name="offset">
        <para>The offset to apply to the copied node.</para>
      </param>
      <returns>
        <para>The newly created node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyGroupNode(yWorks.Graph.IGraph,yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Geometry.PointD)">
      <summary>
        <para>Callback method that creates a copy of the <paramref name="sourceGroupNode" /> in the <paramref name="targetGraph" />.</para>
      </summary>
      <remarks>
        <para>This implementation does not need to copy <see cref="T:yWorks.Graph.IPort" />s or <see cref="T:yWorks.Graph.ILabel" />s. This implementation uses <see cref="M:yWorks.Graph.GraphCopier.CopyNodeStyle(yWorks.Graph.IGraph,yWorks.Graph.INode)" /> and <see cref="M:yWorks.Graph.GraphCopier.CopyNodeTag(yWorks.Graph.INode,System.Object)" /> as callbacks.</para>
      </remarks>
      <param name="sourceGraph">
        <para>The source graph.</para>
      </param>
      <param name="targetGraph">
        <para>The target graph.</para>
      </param>
      <param name="sourceGroupNode">
        <para>The source node to create a copy of in the <paramref name="targetGraph" />.</para>
      </param>
      <param name="targetParent">
        <para>The parent of the group node in the target graph.</para>
      </param>
      <param name="offset">
        <para>The offset to apply to the copied node.</para>
      </param>
      <returns>
        <para>The newly created node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyNode(yWorks.Graph.IGraph,yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Geometry.PointD)">
      <summary>
        <para>Callback method that creates a copy of the <paramref name="node" /> in the <paramref name="targetGraph" />.</para>
      </summary>
      <remarks>
        <para>This implementation does not need to copy <see cref="T:yWorks.Graph.IPort" />s or <see cref="T:yWorks.Graph.ILabel" />s. This implementation uses <see cref="M:yWorks.Graph.GraphCopier.CopyNodeStyle(yWorks.Graph.IGraph,yWorks.Graph.INode)" /> and <see cref="M:yWorks.Graph.GraphCopier.CopyNodeTag(yWorks.Graph.INode,System.Object)" /> as callbacks.</para>
      </remarks>
      <param name="sourceGraph">
        <para>The source graph.</para>
      </param>
      <param name="targetGraph">
        <para>The target graph.</para>
      </param>
      <param name="targetParent">
        <para>The parent of the group node in the target graph.</para>
      </param>
      <param name="node">
        <para>The source node to create a copy of in the <paramref name="targetGraph" />.</para>
      </param>
      <param name="offset">
        <para>The offset to apply to the copied node.</para>
      </param>
      <returns>
        <para>The newly created node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyLabelTag(yWorks.Graph.ILabel,System.Object)">
      <summary>
        <para>Callback that copies the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> of a <see cref="T:yWorks.Graph.ILabel" />.</para>
      </summary>
      <remarks>
        <para>This implementation simply delegates to <see cref="M:yWorks.Graph.GraphCopier.CopyTag(yWorks.Graph.IModelItem,System.Object)" /></para>
      </remarks>
      <param name="label">
        <para>The old label.</para>
      </param>
      <param name="tag">
        <para>The tag to copy.</para>
      </param>
      <returns>
        <para>The copy of the tag.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyEdgeTag(yWorks.Graph.IEdge,System.Object)">
      <summary>
        <para>Callback that copies the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </summary>
      <remarks>
        <para>This implementation simply delegates to <see cref="M:yWorks.Graph.GraphCopier.CopyTag(yWorks.Graph.IModelItem,System.Object)" /></para>
      </remarks>
      <param name="edge">
        <para>The old edge.</para>
      </param>
      <param name="tag">
        <para>The tag to copy.</para>
      </param>
      <returns>
        <para>The copy of the tag.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyPortTag(yWorks.Graph.IPort,System.Object)">
      <summary>
        <para>Callback that copies the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> of a <see cref="T:yWorks.Graph.IPort" />.</para>
      </summary>
      <remarks>
        <para>This implementation simply delegates to <see cref="M:yWorks.Graph.GraphCopier.CopyTag(yWorks.Graph.IModelItem,System.Object)" /></para>
      </remarks>
      <param name="port">
        <para>The old port.</para>
      </param>
      <param name="tag">
        <para>The tag to copy.</para>
      </param>
      <returns>
        <para>The copy of the tag.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyNodeTag(yWorks.Graph.INode,System.Object)">
      <summary>
        <para>Callback that copies the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> of a <see cref="T:yWorks.Graph.INode" />.</para>
      </summary>
      <remarks>
        <para>This implementation simply delegates to <see cref="M:yWorks.Graph.GraphCopier.CopyTag(yWorks.Graph.IModelItem,System.Object)" /></para>
      </remarks>
      <param name="node">
        <para>The old node.</para>
      </param>
      <param name="tag">
        <para>The tag to copy.</para>
      </param>
      <returns>
        <para>The copy of the tag.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.CopyTag(yWorks.Graph.IModelItem,System.Object)">
      <summary>
        <para>Callback that will copy a <see cref="P:yWorks.Graph.ITagOwner.Tag" /> for the target graph.</para>
      </summary>
      <remarks>
        <para>This implementation will try to <see cref="M:System.ICloneable.Clone" /> the <paramref name="tag" /> if the <see cref="P:yWorks.Graph.GraphCopier.Clone" /> property has the <see cref="F:yWorks.Graph.GraphCopier.CloneTypes.Tags" /> flag set. If this is not the case or the tag is not <see cref="T:System.ICloneable" />, the instance will be returned.</para>
      </remarks>
      <param name="owner">
        <para>The old owner of the tag.</para>
      </param>
      <param name="tag">
        <para>The tag to copy.</para>
      </param>
      <returns>
        <para>A copy of the tag.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.GetOrCreateCopy``1(``0,System.Func{``0,``0})">
      <summary>
        <para>Convenience method that either yields a previously <see cref="M:yWorks.Graph.GraphCopier.CacheCopy``1(``0,``0)">cached</see> copy for the given original or uses the <paramref name="copyDelegate" /> to create the copy of the original.</para>
      </summary>
      <remarks>
        <para>If there is a cache miss, the delegate will be used to create the copy and the copy will be placed into the <see cref="M:yWorks.Graph.GraphCopier.CacheCopy``1(``0,``0)">cache</see>.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the item to copy.</para>
      </typeparam>
      <param name="original">
        <para>The original item.</para>
      </param>
      <param name="copyDelegate">
        <para>The copy delegate to create the copy.</para>
      </param>
      <returns>
        <para>A copy of the original, either cached, or newly created and then cached.</para>
      </returns>
    </member>
    <member name="E:yWorks.Graph.GraphCopier.NodeCopied">
      <summary>
        <para>Occurs after a node has been copied.</para>
      </summary>
      <remarks>
        <para>This event is dispatched after the <see cref="T:yWorks.Graph.ElementCopiedCallback" /> has been executed.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.ToClipboardCopier" /> (Cut/Copy) and the source graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Original">original</see> item is a master item, i.e. it belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" /> (Paste) and the target graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Copy">copied</see> item is a master item, i.e. it belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Graph.GraphCopier.BendCopied">
      <summary>
        <para>Occurs after a bend has been copied.</para>
      </summary>
      <remarks>
        <para>This event is dispatched after the <see cref="T:yWorks.Graph.ElementCopiedCallback" /> has been executed.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.ToClipboardCopier" /> (Cut/Copy) and the source graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Original">original</see> item is a master item, i.e. it belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" /> (Paste) and the target graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Copy">copied</see> item is a master item, i.e. it belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
        <para>For <see cref="M:yWorks.Graph.FoldingManager.GetFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)">folding edge</see> bends, their view state representation is passed. These elements are neither part of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> nor the <see cref="P:yWorks.Graph.FoldingManager.Views">view graph</see>.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Graph.GraphCopier.ObjectCopied">
      <summary>
        <para>Occurs after a style has been copied.</para>
      </summary>
      <remarks>
        <para>This event is triggered for all minor objects the graph items are made up of, e.g. the <see cref="M:yWorks.Graph.GraphCopier.CopyNodeStyle(yWorks.Graph.IGraph,yWorks.Graph.INode)">styles</see>, <see cref="M:yWorks.Graph.GraphCopier.CopyTag(yWorks.Graph.IModelItem,System.Object)">tags</see>, <see cref="M:yWorks.Graph.GraphCopier.CopyLabelLayoutParameter(yWorks.Graph.IGraph,yWorks.Graph.ILabel)">labels</see>, and <see cref="M:yWorks.Graph.GraphCopier.CopyPortLocationParameter(yWorks.Graph.IGraph,yWorks.Graph.IPort)">port</see> parameters.</para>
        <para>This event will <b>not</b> be triggered for the graph items themselves and will not be triggered if the object reference is reused, i.e. it will only be triggered if the old and new references actually differ.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Graph.GraphCopier.EdgeCopied">
      <summary>
        <para>Occurs after an edge has been copied.</para>
      </summary>
      <remarks>
        <para>This event is dispatched after the <see cref="T:yWorks.Graph.ElementCopiedCallback" /> has been executed.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.ToClipboardCopier" /> (Cut/Copy) and the source graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Original">original</see> item is a master item, i.e. it belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" /> (Paste) and the target graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Copy">copied</see> item is a master item, i.e. it belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Graph.GraphCopier.PortCopied">
      <summary>
        <para>Occurs after a port has been copied.</para>
      </summary>
      <remarks>
        <para>This event is dispatched after the <see cref="T:yWorks.Graph.ElementCopiedCallback" /> has been executed.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.ToClipboardCopier" /> (Cut/Copy) and the source graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Original">original</see> item is a master item, i.e. it belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" /> (Paste) and the target graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Copy">copied</see> item is a master item, i.e. it belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Graph.GraphCopier.LabelCopied">
      <summary>
        <para>Occurs after a label has been copied.</para>
      </summary>
      <remarks>
        <para>This event is dispatched after the <see cref="T:yWorks.Graph.ElementCopiedCallback" /> has been executed.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.ToClipboardCopier" /> (Cut/Copy) and the source graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Original">original</see> item is a master item, i.e. it belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" /> (Paste) and the target graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Copy">copied</see> item is a master item, i.e. it belongs to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
        <para>For <see cref="M:yWorks.Graph.FoldingManager.GetFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)">folding edge</see> or dummy node labels, their view state representation is passed. These elements are neither part of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> nor the <see cref="P:yWorks.Graph.FoldingManager.Views">view graph</see>.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Graph.GraphCopier.GraphCopied">
      <summary>
        <para>Occurs after the entire graph has been copied.</para>
      </summary>
      <remarks>
        <para>This event is dispatched at the end of the <see cref="M:yWorks.Graph.GraphCopier.Copy(yWorks.Graph.IGraph,System.Predicate{yWorks.Graph.IModelItem},yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.ElementCopiedCallback)" /> method.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.ToClipboardCopier" /> (Cut/Copy) and the source graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Original">source graph</see> item is the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master graph</see> of the folding view.</para>
        <para>If this GraphCopier instance is used as <see cref="T:yWorks.Graph.GraphClipboard" />'s <see cref="P:yWorks.Graph.GraphClipboard.FromClipboardCopier" /> (Paste) and the target graph is a folding view graph the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Copy">target graph</see> is the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master graph</see> of the folding view.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.OnNodeCopied(yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Called after a node has been copied.</para>
      </summary>
      <remarks>
        <para>Raises the <see cref="E:yWorks.Graph.GraphCopier.NodeCopied" /> event.</para>
      </remarks>
      <param name="original">
        <para>The original of the copied node.</para>
      </param>
      <param name="copy">
        <para>The copied node.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.OnBendCopied(yWorks.Graph.IBend,yWorks.Graph.IBend)">
      <summary>
        <para>Called after a bend has been copied.</para>
      </summary>
      <remarks>
        <para>Raises the <see cref="E:yWorks.Graph.GraphCopier.BendCopied" /> event.</para>
      </remarks>
      <param name="original">
        <para>The original of the copied bend.</para>
      </param>
      <param name="copy">
        <para>The copied bend.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.OnEdgeCopied(yWorks.Graph.IEdge,yWorks.Graph.IEdge)">
      <summary>
        <para>Called after an edge has been copied.</para>
      </summary>
      <remarks>
        <para>Raises the <see cref="E:yWorks.Graph.GraphCopier.EdgeCopied" /> event.</para>
      </remarks>
      <param name="original">
        <para>The original of the copied edge.</para>
      </param>
      <param name="copy">
        <para>The copied edge.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.OnLabelCopied(yWorks.Graph.ILabel,yWorks.Graph.ILabel)">
      <summary>
        <para>Called after a label has been copied.</para>
      </summary>
      <remarks>
        <para>Raises the <see cref="E:yWorks.Graph.GraphCopier.LabelCopied" /> event.</para>
      </remarks>
      <param name="original">
        <para>The original of the copied label.</para>
      </param>
      <param name="copy">
        <para>The copied label.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.OnPortCopied(yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Called after a port has been copied.</para>
      </summary>
      <remarks>
        <para>Raises the <see cref="E:yWorks.Graph.GraphCopier.PortCopied" /> event.</para>
      </remarks>
      <param name="original">
        <para>The original of the copied port.</para>
      </param>
      <param name="copy">
        <para>The copied port.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphCopier.OnGraphCopied(yWorks.Graph.IGraph,yWorks.Graph.IGraph)">
      <summary>
        <para>Called after the entire graph has been copied.</para>
      </summary>
      <remarks>
        <para>Raises the <see cref="E:yWorks.Graph.GraphCopier.GraphCopied" /> event.</para>
      </remarks>
      <param name="sourceGraph">
        <para>The source graph from which the elements have been copied.</para>
      </param>
      <param name="targetGraph">
        <para>The graph to which the elements have been copied.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.ItemCopiedEventArgs`1">
      <summary>
        <para>Event arguments for the events in <see cref="T:yWorks.Graph.GraphCopier" />.</para>
      </summary>
      <remarks>
        <para>This event is used for the <see cref="E:yWorks.Graph.GraphCopier.NodeCopied" />, <see cref="E:yWorks.Graph.GraphCopier.EdgeCopied" />, <see cref="E:yWorks.Graph.GraphCopier.PortCopied" />, <see cref="E:yWorks.Graph.GraphCopier.GraphCopied" />, <see cref="E:yWorks.Graph.GraphCopier.LabelCopied" />, and <see cref="E:yWorks.Graph.GraphCopier.ObjectCopied" /> events. This event holds references to the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Original">original</see> of the copied item and the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Copy">copied item</see> itself.</para>
      </remarks>
      <typeparam name="T">
        <para>The logical base type of the copied item.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Graph.ItemCopiedEventArgs`1.#ctor(`0,`0)">
      <summary>
        <para>Creates a new argument for the given item and its original.</para>
      </summary>
      <param name="original">
        <para>The <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Original">original</see> of the copied item.</para>
      </param>
      <param name="copy">
        <para>The <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Copy">copied item</see>.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.ItemCopiedEventArgs`1.Original">
      <summary>
        <para>Gets the original of the <see cref="P:yWorks.Graph.ItemCopiedEventArgs`1.Copy">copied item</see>.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.ItemCopiedEventArgs`1.Copy">
      <summary>
        <para>Gets the copied item.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.GraphDecoratorExtensions">
      <summary>
        <para>Static class that contains extension methods for <see cref="T:yWorks.Graph.IGraph" /> to aid in conveniently using <see cref="T:yWorks.Graph.ILookupDecorator" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.GraphDecoratorExtensions.GetDecorator(yWorks.Graph.IGraph)">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.GraphDecorator" /> instance for use with the given graph.</para>
      </summary>
      <param name="graph">
        <para>The graph to get a <see cref="T:yWorks.Graph.GraphDecorator" /> instance for.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Graph.GraphDecorator" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.GraphDecorator">
      <summary>
        <para>Helper class that can be used to aid in decorating <see cref="T:yWorks.Graph.IModelItem" />s from an <see cref="T:yWorks.Graph.IGraph" /> instance.</para>
      </summary>
      <remarks>
        <para>This class servers as a factory for lookup decorators for the various items that make up an <see cref="T:yWorks.Graph.IGraph" />. This is a convenience class that obtains the <see cref="T:yWorks.Graph.ILookupDecorator" /> from the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> and passes that to the various specialized decorator convenience classes like e.g. <see cref="T:yWorks.Graph.NodeDecorator" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphDecorator.NodeDecorator" />
      <seealso cref="T:yWorks.Graph.NodeDecorator" />
      <seealso cref="P:yWorks.Graph.GraphDecorator.EdgeDecorator" />
      <seealso cref="T:yWorks.Graph.EdgeDecorator" />
      <seealso cref="P:yWorks.Graph.GraphDecorator.LabelDecorator" />
      <seealso cref="T:yWorks.Graph.LabelDecorator" />
      <seealso cref="P:yWorks.Graph.GraphDecorator.PortDecorator" />
      <seealso cref="T:yWorks.Graph.PortDecorator" />
      <seealso cref="P:yWorks.Graph.GraphDecorator.BendDecorator" />
      <seealso cref="T:yWorks.Graph.BendDecorator" />
    </member>
    <member name="M:yWorks.Graph.GraphDecorator.#ctor(yWorks.Graph.IGraph)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.GraphDecorator" /> class.</para>
      </summary>
      <param name="graph">
        <para>The graph.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.GraphDecorator.NodeDecorator">
      <summary>
        <para>Gets a <see cref="P:yWorks.Graph.GraphDecorator.NodeDecorator" /> instance that can be used to decorate the <see cref="T:yWorks.Graph.INode" /> instances in the graph that this decorator has been created for.</para>
      </summary>
      <remarks>
        <para>This will obtain the <see cref="T:yWorks.Graph.ILookupDecorator" /> instance from the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method and use it to initialize the <see cref="T:yWorks.Graph.NodeDecorator" /></para>
      </remarks>
      <value>
        <para>The decorator for <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.GraphDecorator.EdgeDecorator">
      <summary>
        <para>Gets an <see cref="P:yWorks.Graph.GraphDecorator.EdgeDecorator" /> instance that can be used to decorate the <see cref="T:yWorks.Graph.IEdge" /> instances in the graph that this decorator has been created for.</para>
      </summary>
      <remarks>
        <para>This will obtain the <see cref="T:yWorks.Graph.ILookupDecorator" /> instance from the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method and use it to initialize the <see cref="T:yWorks.Graph.EdgeDecorator" /></para>
      </remarks>
      <value>
        <para>The decorator for <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.GraphDecorator.LabelDecorator">
      <summary>
        <para>Gets a <see cref="P:yWorks.Graph.GraphDecorator.LabelDecorator" /> instance that can be used to decorate the <see cref="T:yWorks.Graph.ILabel" /> instances in the graph that this decorator has been created for.</para>
      </summary>
      <remarks>
        <para>This will obtain the <see cref="T:yWorks.Graph.ILookupDecorator" /> instance from the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method and use it to initialize the <see cref="T:yWorks.Graph.LabelDecorator" /></para>
      </remarks>
      <value>
        <para>The decorator for <see cref="T:yWorks.Graph.ILabel" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.GraphDecorator.PortDecorator">
      <summary>
        <para>Gets a <see cref="P:yWorks.Graph.GraphDecorator.PortDecorator" /> instance that can be used to decorate the <see cref="T:yWorks.Graph.IPort" /> instances in the graph that this decorator has been created for.</para>
      </summary>
      <remarks>
        <para>This will obtain the <see cref="T:yWorks.Graph.ILookupDecorator" /> instance from the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method and use it to initialize the <see cref="T:yWorks.Graph.PortDecorator" /></para>
      </remarks>
      <value>
        <para>The decorator for <see cref="T:yWorks.Graph.IPort" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.GraphDecorator.BendDecorator">
      <summary>
        <para>Gets a <see cref="P:yWorks.Graph.GraphDecorator.BendDecorator" /> instance that can be used to decorate the <see cref="T:yWorks.Graph.IBend" /> instances in the graph that this decorator has been created for.</para>
      </summary>
      <remarks>
        <para>This will obtain the <see cref="T:yWorks.Graph.ILookupDecorator" /> instance from the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method and use it to initialize the <see cref="T:yWorks.Graph.BendDecorator" /></para>
      </remarks>
      <value>
        <para>The decorator for <see cref="T:yWorks.Graph.IBend" />s.</para>
      </value>
    </member>
    <member name="T:yWorks.Graph.LabelDecorator">
      <summary>
        <para>A utility class that helps in <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">decorating</see> the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method of <see cref="T:yWorks.Graph.ILabel" /> instances that are contained in an <see cref="T:yWorks.Graph.IGraph" /> which are managed by an <see cref="T:yWorks.Graph.ILookupDecorator" />.</para>
      </summary>
      <remarks>
        <para>This decorator can be used to conveniently <see cref="T:yWorks.Graph.ILookupDecorator">decorate the lookup</see> of <see cref="T:yWorks.Graph.ILabel" />s in an <see cref="T:yWorks.Graph.IGraph" />. It serves as a factory for predefined <see cref="T:yWorks.Graph.LookupDecorator`2" /> instances that are specifically useful for the <see cref="T:yWorks.Graph.ILabel" /> type. Note that the list of possible decorations that are available using this class is not exhaustive in any way. This is merely a way to provide access to those interfaces that are more commonly being decorated by the developer.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.GraphDecorator" />
      <seealso cref="T:yWorks.Graph.GraphDecoratorExtensions" />
      <seealso cref="T:yWorks.Graph.LookupDecorator`2" />
    </member>
    <member name="M:yWorks.Graph.LabelDecorator.#ctor(yWorks.Graph.ILookupDecorator)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LabelDecorator" /> class.</para>
      </summary>
      <param name="decorator">
        <para>The decorator to use, which can be <c>null</c>.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.LabelDecorator.GetDecoratorFor``1(System.Boolean,System.Boolean)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Graph.LookupDecorator`2" /> for <see cref="T:yWorks.Graph.ILabel" />s that can be used to decorate <typeparamref name="TInterface" /> types of the labels.</para>
      </summary>
      <typeparam name="TInterface">
        <para>The type of the interface that should be decorated of the instances' <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </typeparam>
      <param name="decorateNulls">
        <para>if set to <c>true</c> <c>null</c> values will be decorated, otherwise not.</para>
      </param>
      <param name="nullIsFallback">
        <para>if set to <c>true</c> <c>null</c> values will be treated as fallback values, otherwise they will be used as the final result.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Graph.LookupDecorator`2" /> for the specified interface.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.PositionHandlerDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IPositionHandler" /> implementations can be used to restrict or enhance the way the user moves elements interactively in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.MoveInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IPositionHandler" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.ClipboardHelperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IClipboardHelper" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IClipboardHelper" /> implementations can be used to customize the way the clipboard operations are performed by <see cref="T:yWorks.Graph.GraphClipboard" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IClipboardHelper" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.MarqueeTestableDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> implementations can be used to change the way tests for marquee inclusions are performed on the items in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.MementoSupportDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IMementoSupport" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IMementoSupport" /> implementations can be used to make the <see cref="T:yWorks.Graph.UndoEngine" /> aware of changes to data that is associated with the model items. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IMementoSupport" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.SelectionDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> implementations can be used change the way the selection of an item is represented in a <see cref="T:yWorks.Controls.CanvasControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.SelectionIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.HighlightDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> implementations can be used change the way the highlighting of an item is represented in a <see cref="T:yWorks.Controls.CanvasControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.HighlightIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.FocusIndicatorDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> implementations can be used change the way the focus of an item is represented in a <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.FocusIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.HandleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IHandleProvider" /> implementations provide interactive draggable handles for the user to change the geometry or other aspects of items in the <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> in the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IHandleProvider" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.ObstacleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IObstacleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IObstacleProvider" /> implementations provide information about obstacles that will be considered by <see cref="T:yWorks.Controls.GraphObstacleProvider" /> which itself serves as a provider for geometric obstacles to <see cref="T:yWorks.Controls.BridgeManager" /> that manages the rendering of bridges in edge paths. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IObstacleProvider" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
      <seealso cref="T:yWorks.Controls.GraphObstacleProvider" />
      <seealso cref="T:yWorks.Controls.BridgeManager" />
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.LabelModelParameterFinderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder" /> type for the <see cref="T:yWorks.Graph.ILabel" />s of the graph this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder" /> implementations can be used change the way <see cref="T:yWorks.Graph.ILabel" />s can be dragged interactively by the user. It helps in determining the right <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> for a given location that has been chosen by the user. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.LabelPositionHandler" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder" /> instances on <see cref="T:yWorks.Graph.ILabel" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.EditLabelHelperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> type for the <see cref="T:yWorks.Graph.ILabel" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> implementations can be used to change or customize interactive label editing. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> which uses the callbacks from the implementation to determine whether the label can be edited, as well as to customize the <see cref="T:yWorks.Controls.Input.TextEditorInputMode" /> appearance for the upcoming edit. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> instances on <see cref="T:yWorks.Graph.ILabel" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.LabelModelParameterProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterProvider" /> type for the <see cref="T:yWorks.Graph.ILabel" />s of the graph this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterProvider" /> implementations can be used to change the set of possible <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" />s that the user can assign to a label interactively by dragging it in a <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.LabelPositionHandler" /> and <see cref="T:yWorks.Controls.Input.MoveLabelInputMode" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterProvider" /> instances on <see cref="T:yWorks.Graph.ILabel" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelDecorator.LabelSnapContextHelperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.ILabelSnapContextHelper" /> for the <see cref="T:yWorks.Graph.ILabel" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.ILabelSnapContextHelper" /> implementations can be used to provide custom <see cref="T:yWorks.Controls.Input.SnapLine">snap lines</see> and <see cref="T:yWorks.Controls.Input.SnapResult">snap results</see> based on the <see cref="T:yWorks.Graph.ILabel" />s this instance has been created for. This interface is mainly used by the label's <see cref="T:yWorks.Controls.Input.IPositionHandler" /> to collect snap results during a drag gesture for the label. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify queries for <see cref="T:yWorks.Controls.Input.ILabelSnapContextHelper" /> instances on an <see cref="T:yWorks.Graph.ILabel" />.</para>
      </value>
    </member>
    <member name="T:yWorks.Graph.EdgeDecorator">
      <summary>
        <para>A utility class that helps in <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">decorating</see> the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method of <see cref="T:yWorks.Graph.IEdge" /> instances that are contained in an <see cref="T:yWorks.Graph.IGraph" /> which are managed by an <see cref="T:yWorks.Graph.ILookupDecorator" />.</para>
      </summary>
      <remarks>
        <para>This decorator can be used to conveniently <see cref="T:yWorks.Graph.ILookupDecorator">decorate the lookup</see> of <see cref="T:yWorks.Graph.IEdge" />s in an <see cref="T:yWorks.Graph.IGraph" />. It serves as a factory for predefined <see cref="T:yWorks.Graph.LookupDecorator`2" /> instances that are specifically useful for the <see cref="T:yWorks.Graph.IEdge" /> type. Note that the list of possible decorations that are available using this class is not exhaustive in any way. This is merely a way to provide access to those interfaces that are more commonly being decorated by the developer.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.GraphDecorator" />
      <seealso cref="T:yWorks.Graph.GraphDecoratorExtensions" />
      <seealso cref="T:yWorks.Graph.LookupDecorator`2" />
    </member>
    <member name="M:yWorks.Graph.EdgeDecorator.#ctor(yWorks.Graph.ILookupDecorator)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.EdgeDecorator" /> class.</para>
      </summary>
      <param name="decorator">
        <para>The decorator to use, which can be <c>null</c>.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.EdgeReconnectionPortCandidateProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> type for the <see cref="T:yWorks.Graph.IEdge" />s of the graph this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> implementations can be used to change the set of possible <see cref="T:yWorks.Controls.Input.IPortCandidate" />s that are available for an existing edge in the <see cref="T:yWorks.Graph.IGraph" /> if the user interactively tries to <see cref="M:yWorks.Graph.IGraph.SetEdgePorts(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">change the ports</see> of an <see cref="T:yWorks.Graph.IEdge" /> in a <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.PortRelocationHandle" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> instances on <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.PortCandidateProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> for the <see cref="T:yWorks.Graph.IEdge" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> implementations can be used to present the user with a set of <see cref="T:yWorks.Controls.Input.IPortCandidate" />s that newly created edges can use as their <see cref="P:yWorks.Graph.IEdge.SourcePort">source</see> and <see cref="P:yWorks.Graph.IEdge.TargetPort">target</see> <see cref="T:yWorks.Graph.IPort" />s. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.CreateEdgeInputMode" /> mode of <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> if <see cref="P:yWorks.Controls.Input.CreateEdgeInputMode.AllowEdgeToEdgeConnections" /> is enabled. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> instances on <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.EdgePortHandleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IEdgePortHandleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IEdgePortHandleProvider" /> implementations can be used provide interactive draggable handles for the source and target end points of an edge. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> in the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> and by the implementations that work with <see cref="T:yWorks.Controls.Input.OrthogonalEdgeEditingContext" />. Implementations may decide, e.g. whether to yield <see cref="T:yWorks.Controls.Input.IHandle" /> implementations that either move the edge to another port(-<see cref="T:yWorks.Controls.Input.IPortCandidate">candidate</see>) using <see cref="M:yWorks.Graph.IGraph.SetEdgePorts(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)" /> or whether to move the port the edge is currently connected to itself, instead. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IEdgePortHandleProvider" /> instances on edges.</para>
      </value>
      <seealso cref="T:yWorks.Controls.Input.PortRelocationHandle" />
      <seealso cref="T:yWorks.Controls.Input.IHandle" />
      <seealso cref="T:yWorks.Controls.Input.IHandleProvider" />
      <seealso cref="T:yWorks.Controls.Input.OrthogonalEdgeEditingContext" />
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.OrthogonalEdgeHelperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IOrthogonalEdgeHelper" /> type for the <see cref="T:yWorks.Graph.IEdge" />s of the graph this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IOrthogonalEdgeHelper" /> implementations can be used to change the orthogonal edge editing behavior in the context of <see cref="T:yWorks.Controls.Input.OrthogonalEdgeEditingContext" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IOrthogonalEdgeHelper" /> instances on <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.EdgeSnapResultProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IEdgeSnapResultProvider" /> type for the <see cref="T:yWorks.Graph.IEdge" />s of the graph this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IEdgeSnapResultProvider" /> implementations can be used to change the snapping behavior of edges while they are being moved in the context of a <see cref="T:yWorks.Controls.Input.GraphSnapContext" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IEdgeSnapResultProvider" /> instances on <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.EditLabelHelperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> type for the <see cref="T:yWorks.Graph.IEdge" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> implementations can be used to change or customize interactive label editing and label creation. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> which uses the callbacks from the implementation to determine the label to add or edit, as well as to customize the <see cref="T:yWorks.Controls.Input.TextEditorInputMode" /> appearance for the upcoming edit. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> instances on <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.BendCreatorDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IBendCreator" /> type for the <see cref="T:yWorks.Graph.IEdge" />s of the graph this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IBendCreator" /> implementations can be used to influence the interactive creation of new <see cref="T:yWorks.Graph.IBend" />s. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.CreateBendInputMode" /> in <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IBendCreator" /> instances on <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.BendSelectionTesterDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IBendSelectionTester" /> type for the <see cref="T:yWorks.Graph.IEdge" />s of the graph this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IBendSelectionTester" /> implementations can be used to influence hit test behavior for bends on edges. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> and <see cref="T:yWorks.Controls.Input.CreateBendInputMode" /> to determine whether an existing bend has been hit. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IBendSelectionTester" /> instances on <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.SnapLineProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> for the <see cref="T:yWorks.Graph.IEdge" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> implementations can be used to provide custom <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s based on the <see cref="T:yWorks.Graph.IEdge" />s this instance has been created for. This could e.g. be a horizontal <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" /> vertically centered between two horizontal segments of one of these edges. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> to collect all available <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s of orthogonal edge segments. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify queries for <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> instances on <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.PositionHandlerDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IPositionHandler" /> implementations can be used to restrict or enhance the way the user moves elements interactively in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.MoveInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IPositionHandler" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.ClipboardHelperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IClipboardHelper" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IClipboardHelper" /> implementations can be used to customize the way the clipboard operations are performed by <see cref="T:yWorks.Graph.GraphClipboard" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IClipboardHelper" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.MarqueeTestableDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> implementations can be used to change the way tests for marquee inclusions are performed on the items in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.MementoSupportDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IMementoSupport" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IMementoSupport" /> implementations can be used to make the <see cref="T:yWorks.Graph.UndoEngine" /> aware of changes to data that is associated with the model items. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IMementoSupport" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.SelectionDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> implementations can be used change the way the selection of an item is represented in a <see cref="T:yWorks.Controls.CanvasControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.SelectionIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.HighlightDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> implementations can be used change the way the highlighting of an item is represented in a <see cref="T:yWorks.Controls.CanvasControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.HighlightIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.FocusIndicatorDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> implementations can be used change the way the focus of an item is represented in a <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.FocusIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.HandleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IHandleProvider" /> implementations provide interactive draggable handles for the user to change the geometry or other aspects of items in the <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> in the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IHandleProvider" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeDecorator.ObstacleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IObstacleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IObstacleProvider" /> implementations provide information about obstacles that will be considered by <see cref="T:yWorks.Controls.GraphObstacleProvider" /> which itself serves as a provider for geometric obstacles to <see cref="T:yWorks.Controls.BridgeManager" /> that manages the rendering of bridges in edge paths. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IObstacleProvider" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
      <seealso cref="T:yWorks.Controls.GraphObstacleProvider" />
      <seealso cref="T:yWorks.Controls.BridgeManager" />
    </member>
    <member name="M:yWorks.Graph.EdgeDecorator.GetDecoratorFor``1(System.Boolean,System.Boolean)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Graph.LookupDecorator`2" /> for <see cref="T:yWorks.Graph.IEdge" />s that can be used to decorate <typeparamref name="TInterface" /> types of the edges.</para>
      </summary>
      <typeparam name="TInterface">
        <para>The type of the interface that should be decorated of the instances' <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </typeparam>
      <param name="decorateNulls">
        <para>if set to <c>true</c> <c>null</c> values will be decorated, otherwise not.</para>
      </param>
      <param name="nullIsFallback">
        <para>if set to <c>true</c> <c>null</c> values will be treated as fallback values, otherwise they will be used as the final result.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Graph.LookupDecorator`2" /> for the specified interface.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.BendDecorator">
      <summary>
        <para>A utility class that helps in <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">decorating</see> the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method of <see cref="T:yWorks.Graph.IBend" /> instances that are contained in an <see cref="T:yWorks.Graph.IGraph" /> which are managed by an <see cref="T:yWorks.Graph.ILookupDecorator" />.</para>
      </summary>
      <remarks>
        <para>This decorator can be used to conveniently <see cref="T:yWorks.Graph.ILookupDecorator">decorate the lookup</see> of <see cref="T:yWorks.Graph.IBend" />s in an <see cref="T:yWorks.Graph.IGraph" />. It serves as a factory for predefined <see cref="T:yWorks.Graph.LookupDecorator`2" /> instances that are specifically useful for the <see cref="T:yWorks.Graph.IBend" /> type. Note that the list of possible decorations that are available using this class is not exhaustive in any way. This is merely a way to provide access to those interfaces that are more commonly being decorated by the developer.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.GraphDecorator" />
      <seealso cref="T:yWorks.Graph.GraphDecoratorExtensions" />
      <seealso cref="T:yWorks.Graph.LookupDecorator`2" />
    </member>
    <member name="M:yWorks.Graph.BendDecorator.#ctor(yWorks.Graph.ILookupDecorator)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.BendDecorator" /> class.</para>
      </summary>
      <param name="decorator">
        <para>The decorator to use, which can be <c>null</c>.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.HandleDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IHandle" /> type for the <see cref="T:yWorks.Graph.IBend" />s of the graph this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IHandle" /> implementations can be used to change the way the user can drag a bend interactively to change its position in a <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> in <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IHandle" /> instances on <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.BendSnapResultProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IBendSnapResultProvider" /> for the <see cref="T:yWorks.Graph.IBend" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IBendSnapResultProvider" /> implementations can be used to provide custom <see cref="T:yWorks.Controls.Input.SnapResult" />s based on the <see cref="T:yWorks.Graph.IBend" />s this instance has been created for. This could e.g. be a <see cref="T:yWorks.Controls.Input.SnapResult" /> describing that the bend wants to snap vertically to the top border of a node. This interface is mainly used by the bend <see cref="T:yWorks.Controls.Input.IHandle" />s to collect <see cref="T:yWorks.Controls.Input.SnapResult" />s during a drag gesture for the bend. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify queries for <see cref="T:yWorks.Controls.Input.IBendSnapResultProvider" /> instances on <see cref="T:yWorks.Graph.IBend" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.PositionHandlerDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IPositionHandler" /> implementations can be used to restrict or enhance the way the user moves elements interactively in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.MoveInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IPositionHandler" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.ClipboardHelperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IClipboardHelper" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IClipboardHelper" /> implementations can be used to customize the way the clipboard operations are performed by <see cref="T:yWorks.Graph.GraphClipboard" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IClipboardHelper" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.MarqueeTestableDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> implementations can be used to change the way tests for marquee inclusions are performed on the items in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.MementoSupportDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IMementoSupport" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IMementoSupport" /> implementations can be used to make the <see cref="T:yWorks.Graph.UndoEngine" /> aware of changes to data that is associated with the model items. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IMementoSupport" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.SelectionDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> implementations can be used change the way the selection of an item is represented in a <see cref="T:yWorks.Controls.CanvasControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.SelectionIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.HighlightDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> implementations can be used change the way the highlighting of an item is represented in a <see cref="T:yWorks.Controls.CanvasControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.HighlightIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.FocusIndicatorDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> implementations can be used change the way the focus of an item is represented in a <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.FocusIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.HandleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IHandleProvider" /> implementations provide interactive draggable handles for the user to change the geometry or other aspects of items in the <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> in the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IHandleProvider" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendDecorator.ObstacleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IObstacleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IObstacleProvider" /> implementations provide information about obstacles that will be considered by <see cref="T:yWorks.Controls.GraphObstacleProvider" /> which itself serves as a provider for geometric obstacles to <see cref="T:yWorks.Controls.BridgeManager" /> that manages the rendering of bridges in edge paths. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IObstacleProvider" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
      <seealso cref="T:yWorks.Controls.GraphObstacleProvider" />
      <seealso cref="T:yWorks.Controls.BridgeManager" />
    </member>
    <member name="M:yWorks.Graph.BendDecorator.GetDecoratorFor``1(System.Boolean,System.Boolean)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Graph.LookupDecorator`2" /> for <see cref="T:yWorks.Graph.IBend" />s that can be used to decorate <typeparamref name="TInterface" /> types of the bends.</para>
      </summary>
      <typeparam name="TInterface">
        <para>The type of the interface that should be decorated of the instances' <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </typeparam>
      <param name="decorateNulls">
        <para>if set to <c>true</c> <c>null</c> values will be decorated, otherwise not.</para>
      </param>
      <param name="nullIsFallback">
        <para>if set to <c>true</c> <c>null</c> values will be treated as fallback values, otherwise they will be used as the final result.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Graph.LookupDecorator`2" /> for the specified interface.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.PortDecorator">
      <summary>
        <para>A utility class that helps in <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">decorating</see> the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method of <see cref="T:yWorks.Graph.IPort" /> instances that are contained in an <see cref="T:yWorks.Graph.IGraph" /> which are managed by an <see cref="T:yWorks.Graph.ILookupDecorator" />.</para>
      </summary>
      <remarks>
        <para>This decorator can be used to conveniently <see cref="T:yWorks.Graph.ILookupDecorator">decorate the lookup</see> of <see cref="T:yWorks.Graph.IPort" />s in an <see cref="T:yWorks.Graph.IGraph" />. It serves as a factory for predefined <see cref="T:yWorks.Graph.LookupDecorator`2" /> instances that are specifically useful for the <see cref="T:yWorks.Graph.IPort" /> type. Note that the list of possible decorations that are available using this class is not exhaustive in any way. This is merely a way to provide access to those interfaces that are more commonly being decorated by the developer.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.GraphDecorator" />
      <seealso cref="T:yWorks.Graph.GraphDecoratorExtensions" />
      <seealso cref="T:yWorks.Graph.LookupDecorator`2" />
    </member>
    <member name="M:yWorks.Graph.PortDecorator.#ctor(yWorks.Graph.ILookupDecorator)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.PortDecorator" /> class.</para>
      </summary>
      <param name="decorator">
        <para>The decorator to use, which can be <c>null</c>.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.HandleDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IHandle" /> type for the <see cref="T:yWorks.Graph.IPort" />s of the graph this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IHandle" /> implementations can be used to change the way the user can drag a port interactively to change its position in a <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> in <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> which obtains the <see cref="T:yWorks.Controls.Input.IHandle" /> from the <see cref="T:yWorks.Graph.IPort" /> by querying the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> from it, which in turn will query the <see cref="T:yWorks.Controls.Input.IHandle" /> from itself. Alternatively, selected nodes can put the <see cref="T:yWorks.Controls.Input.IHandle" /> of their ports into their <see cref="T:yWorks.Controls.Input.IHandleProvider" /> implementation. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IHandle" /> instances on <see cref="T:yWorks.Graph.IPort" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.EdgePathCropperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.Styles.IEdgePathCropper" /> type for the <see cref="T:yWorks.Graph.IPort" />s of the graph this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.Styles.IEdgePathCropper" /> implementations can be used to change the way the path of <see cref="T:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1" /> implementations calculate the <see cref="T:yWorks.Geometry.GeneralPath" /> of the visual representation of an <see cref="T:yWorks.Graph.IEdge" /> in a <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1" /> to find the intersection of an edge with the bounds of the adjacent node to properly crop the edge path. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.Styles.IEdgePathCropper" /> instances on <see cref="T:yWorks.Graph.IPort" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.SnapLineProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> for the <see cref="T:yWorks.Graph.IPort" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> implementations can be used to provide custom <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s based on the <see cref="T:yWorks.Graph.IPort" />s this instance has been created for. This could e.g. be a <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" /> with a horizontal or vertical offset to the port's location. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> to collect all available <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify queries for <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> instances on <see cref="T:yWorks.Graph.IPort" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.PortSnapResultProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IPortSnapResultProvider" /> for the <see cref="T:yWorks.Graph.IPort" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IPortSnapResultProvider" /> implementations can be used to provide custom <see cref="T:yWorks.Controls.Input.SnapResult" />s based on the <see cref="T:yWorks.Graph.IPort" />s this instance has been created for. This could e.g. be a <see cref="T:yWorks.Controls.Input.SnapResult" /> describing that the port wants to snap to a grid point. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.PortLocationModelParameterHandle" /> to collect <see cref="T:yWorks.Controls.Input.SnapResult" />s during a drag gesture for the port. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify queries for <see cref="T:yWorks.Controls.Input.IPortSnapResultProvider" /> instances on <see cref="T:yWorks.Graph.IPort" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.PositionHandlerDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IPositionHandler" /> implementations can be used to restrict or enhance the way the user moves elements interactively in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.MoveInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IPositionHandler" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.ClipboardHelperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IClipboardHelper" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IClipboardHelper" /> implementations can be used to customize the way the clipboard operations are performed by <see cref="T:yWorks.Graph.GraphClipboard" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IClipboardHelper" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.MarqueeTestableDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> implementations can be used to change the way tests for marquee inclusions are performed on the items in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.MementoSupportDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IMementoSupport" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IMementoSupport" /> implementations can be used to make the <see cref="T:yWorks.Graph.UndoEngine" /> aware of changes to data that is associated with the model items. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IMementoSupport" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.SelectionDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> implementations can be used change the way the selection of an item is represented in a <see cref="T:yWorks.Controls.CanvasControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.SelectionIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.HighlightDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> implementations can be used change the way the highlighting of an item is represented in a <see cref="T:yWorks.Controls.CanvasControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.HighlightIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.FocusIndicatorDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> implementations can be used change the way the focus of an item is represented in a <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.FocusIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.HandleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IHandleProvider" /> implementations provide interactive draggable handles for the user to change the geometry or other aspects of items in the <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> in the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IHandleProvider" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.PortDecorator.ObstacleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IObstacleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IObstacleProvider" /> implementations provide information about obstacles that will be considered by <see cref="T:yWorks.Controls.GraphObstacleProvider" /> which itself serves as a provider for geometric obstacles to <see cref="T:yWorks.Controls.BridgeManager" /> that manages the rendering of bridges in edge paths. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IObstacleProvider" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
      <seealso cref="T:yWorks.Controls.GraphObstacleProvider" />
      <seealso cref="T:yWorks.Controls.BridgeManager" />
    </member>
    <member name="M:yWorks.Graph.PortDecorator.GetDecoratorFor``1(System.Boolean,System.Boolean)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Graph.LookupDecorator`2" /> for <see cref="T:yWorks.Graph.IPort" />s that can be used to decorate <typeparamref name="TInterface" /> types of the ports.</para>
      </summary>
      <typeparam name="TInterface">
        <para>The type of the interface that should be decorated of the instances' <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </typeparam>
      <param name="decorateNulls">
        <para>if set to <c>true</c> <c>null</c> values will be decorated, otherwise not.</para>
      </param>
      <param name="nullIsFallback">
        <para>if set to <c>true</c> <c>null</c> values will be treated as fallback values, otherwise they will be used as the final result.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Graph.LookupDecorator`2" /> for the specified interface.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.NodeDecorator">
      <summary>
        <para>A utility class that helps in <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">decorating</see> the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method of <see cref="T:yWorks.Graph.INode" /> instances that are contained in an <see cref="T:yWorks.Graph.IGraph" /> which are managed by an <see cref="T:yWorks.Graph.ILookupDecorator" />.</para>
      </summary>
      <remarks>
        <para>This decorator can be used to conveniently <see cref="T:yWorks.Graph.ILookupDecorator">decorate the lookup</see> of <see cref="T:yWorks.Graph.INode" />s in an <see cref="T:yWorks.Graph.IGraph" />. It serves as a factory for predefined <see cref="T:yWorks.Graph.LookupDecorator`2" /> instances that are specifically useful for the <see cref="T:yWorks.Graph.INode" /> type. Note that the list of possible decorations that are available using this class is not exhaustive in any way. This is merely a way to provide access to those interfaces that are more commonly being decorated by the developer.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.GraphDecorator" />
      <seealso cref="T:yWorks.Graph.GraphDecoratorExtensions" />
      <seealso cref="T:yWorks.Graph.LookupDecorator`2" />
    </member>
    <member name="M:yWorks.Graph.NodeDecorator.#ctor(yWorks.Graph.ILookupDecorator)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.NodeDecorator" /> class.</para>
      </summary>
      <param name="decorator">
        <para>The decorator to use, which can be <c>null</c>.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.ReshapeHandleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IReshapeHandleProvider" /> type for the <see cref="T:yWorks.Graph.INode" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IReshapeHandleProvider" /> implementations can be used to change the number and type of <see cref="T:yWorks.Controls.Input.IHandle" />s that can be used by the user to reshape the <see cref="T:yWorks.Graph.INode" />s in interactively in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> which passes the <see cref="T:yWorks.Controls.Input.IHandle" />s to the <see cref="T:yWorks.Controls.Input.HandleInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IReshapeHandleProvider" /> instances on <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.EditLabelHelperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> type for the <see cref="T:yWorks.Graph.INode" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> implementations can be used to change or customize interactive label editing and label creation. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> which uses the callbacks from the implementation to determine the label to add or edit, as well as to customize the <see cref="T:yWorks.Controls.Input.TextEditorInputMode" /> appearance for the upcoming edit. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IEditLabelHelper" /> instances on <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.ShapeGeometryDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.Styles.IShapeGeometry" /> type for the type <see cref="T:yWorks.Graph.INode" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.Styles.IShapeGeometry" /> implementations can be used to change the way different code parts interpret the <see cref="P:yWorks.Graph.INode.Layout" /> of an <see cref="T:yWorks.Graph.INode" />. This interface is mainly used by the <see cref="T:yWorks.Graph.Styles.DefaultEdgePathCropper" />, and a custom <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> that can be obtained from <see cref="M:yWorks.Controls.Input.PortCandidateProviders.FromShapeGeometry(yWorks.Graph.IPortOwner,System.Double[])" />. Note that decorating the <see cref="T:yWorks.Graph.Styles.IShapeGeometry" /> for an <see cref="T:yWorks.Graph.INode" /> will not change the result of a call to <see cref="M:yWorks.Graph.Styles.INodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> of the <see cref="P:yWorks.Graph.INode.Style" />. So standard hit tests will not be influenced by such a change. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.Styles.IShapeGeometry" /> instances on <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.SizeConstraintProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.INodeSizeConstraintProvider" /> type for the type <see cref="T:yWorks.Graph.INode" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.INodeSizeConstraintProvider" /> implementations can be used to add constraints to the size of a node. These constraints are used by the default <see cref="T:yWorks.Controls.Input.IReshapeHandleProvider" /> implementation for nodes to enforce size constraints for interactive resize gestures. Also <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> uses this interface to constrain the size of a node whenever its labels are being edited interactively. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.INodeSizeConstraintProvider" /> instances on <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.GroupBoundsCalculatorDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IGroupBoundsCalculator" /> type for the <see cref="T:yWorks.Graph.INode" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IGroupBoundsCalculator" /> implementations can be used to change the way the bounds of <see cref="M:yWorks.Graph.IGraph.CreateGroupNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">group nodes</see> are being calculated if the geometry of child nodes is changed by the user. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IGroupBoundsCalculator" /> instances on <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.InsetsProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.INodeInsetsProvider" /> (tied to the <see cref="T:yWorks.Graph.INode" /> type parameter) for the <see cref="T:yWorks.Graph.INode" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.INodeInsetsProvider" /> implementations can be used to change the way the bounds of <see cref="M:yWorks.Graph.IGraph.CreateGroupNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">group nodes</see> are being calculated if the geometry of child nodes is changed by the user. This interface will be used if there is no custom <see cref="T:yWorks.Graph.IGroupBoundsCalculator" /> associated with the nodes (see <see cref="P:yWorks.Graph.NodeDecorator.GroupBoundsCalculatorDecorator" />). This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />. Note that many <see cref="T:yWorks.Graph.Styles.INodeStyle" /> implementations provide an <see cref="P:yWorks.Graph.Styles.PanelNodeStyle.Insets">Insets</see> property whose value will be reported by a <see cref="T:yWorks.Controls.Input.INodeInsetsProvider" /> implementation that is provided by the corresponding <see cref="T:yWorks.Graph.Styles.INodeStyleRenderer" />. Using this property instead of decorating the lookup of the <see cref="T:yWorks.Graph.INode" /> is thus often simpler.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.INodeInsetsProvider" /> instances on <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.PortCandidateProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> for the <see cref="T:yWorks.Graph.INode" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> implementations can be used to present the user with a set of <see cref="T:yWorks.Controls.Input.IPortCandidate" />s that newly created edges can use as their <see cref="P:yWorks.Graph.IEdge.SourcePort">source</see> and <see cref="P:yWorks.Graph.IEdge.TargetPort">target</see> <see cref="T:yWorks.Graph.IPort" />s. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.CreateEdgeInputMode" /> mode of <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. Also the default implementation of <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> will use this interface to determine the candidates that are available if the user interactively moves the ports using <see cref="T:yWorks.Controls.Input.PortRelocationHandle" /> (see <see cref="P:yWorks.Graph.PortDecorator.HandleDecorator" />). This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> instances on <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.SnapLineProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> for the <see cref="T:yWorks.Graph.INode" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> implementations can be used to provide custom <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s based on the <see cref="T:yWorks.Graph.INode" />s this instance has been created for. This could e.g. be a horizontal <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" /> at the vertical center of the node to which other nodes should snap with their top border. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> to collect all available <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify queries for <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> instances on <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.NodeSnapResultProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.INodeSnapResultProvider" /> for the <see cref="T:yWorks.Graph.INode" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.INodeSnapResultProvider" /> implementations can be used to provide custom <see cref="T:yWorks.Controls.Input.SnapResult" />s based on the <see cref="T:yWorks.Graph.INode" />s this instance has been created for. This could e.g. be a <see cref="T:yWorks.Controls.Input.SnapResult" /> describing that the top left corner of the node wants to snap to a grid point. This interface is mainly used by the node's <see cref="T:yWorks.Controls.Input.IPositionHandler" /> to collect <see cref="T:yWorks.Controls.Input.SnapResult" />s during a drag gesture for the node. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify queries for <see cref="T:yWorks.Controls.Input.INodeSnapResultProvider" /> instances on <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.NodeReshapeSnapResultProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> for the <see cref="T:yWorks.Graph.INode" />s this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.INodeReshapeSnapResultProvider" /> implementations can be used to provide custom <see cref="T:yWorks.Controls.Input.SnapResult" />s based on the <see cref="T:yWorks.Graph.INode" />s this instance has been created for. This could e.g. be a <see cref="T:yWorks.Controls.Input.SnapResult" /> describing that the top left corner of the node wants to snap to a grid point. This interface is mainly used by the node reshape <see cref="T:yWorks.Controls.Input.IHandle" />s to collect <see cref="T:yWorks.Controls.Input.SnapResult" />s during a resize gesture for the node. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify queries for <see cref="T:yWorks.Controls.Input.ISnapLineProvider" /> instances on <see cref="T:yWorks.Graph.INode" />s.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.PositionHandlerDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IPositionHandler" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IPositionHandler" /> implementations can be used to restrict or enhance the way the user moves elements interactively in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.MoveInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IPositionHandler" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.ClipboardHelperDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IClipboardHelper" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IClipboardHelper" /> implementations can be used to customize the way the clipboard operations are performed by <see cref="T:yWorks.Graph.GraphClipboard" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IClipboardHelper" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.MarqueeTestableDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> implementations can be used to change the way tests for marquee inclusions are performed on the items in the editor. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.MementoSupportDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Graph.IMementoSupport" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Graph.IMementoSupport" /> implementations can be used to make the <see cref="T:yWorks.Graph.UndoEngine" /> aware of changes to data that is associated with the model items. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Graph.IMementoSupport" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.SelectionDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> implementations can be used change the way the selection of an item is represented in a <see cref="T:yWorks.Controls.CanvasControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.SelectionIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.ISelectionIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.HighlightDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> implementations can be used change the way the highlighting of an item is represented in a <see cref="T:yWorks.Controls.CanvasControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.HighlightIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IHighlightIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.FocusIndicatorDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> implementations can be used change the way the focus of an item is represented in a <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.FocusIndicatorManager`1" /> in the <see cref="T:yWorks.Controls.GraphControl" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IFocusIndicatorInstaller" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.HandleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.Input.IHandleProvider" /> implementations provide interactive draggable handles for the user to change the geometry or other aspects of items in the <see cref="T:yWorks.Controls.GraphControl" />. This interface is mainly used by the <see cref="T:yWorks.Controls.Input.HandleInputMode" /> in the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" />. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.Input.IHandleProvider" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.NodeDecorator.ObstacleProviderDecorator">
      <summary>
        <para>Gets a <see cref="T:yWorks.Graph.LookupDecorator`2" /> that decorates the <see cref="T:yWorks.Controls.IObstacleProvider" /> type for the type of items this instance has been created for.</para>
      </summary>
      <remarks>
        <para>Custom <see cref="T:yWorks.Controls.IObstacleProvider" /> implementations provide information about obstacles that will be considered by <see cref="T:yWorks.Controls.GraphObstacleProvider" /> which itself serves as a provider for geometric obstacles to <see cref="T:yWorks.Controls.BridgeManager" /> that manages the rendering of bridges in edge paths. This is a convenient alternative to the direct usage of the <see cref="T:yWorks.Graph.ILookupDecorator" /> that is provided by the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </remarks>
      <value>
        <para>A decorator that can be used to modify the queries for <see cref="T:yWorks.Controls.IObstacleProvider" /> instances on items that implement the <c>TModelItem</c> interface this instance uses as the generic type parameter.</para>
      </value>
      <seealso cref="T:yWorks.Controls.GraphObstacleProvider" />
      <seealso cref="T:yWorks.Controls.BridgeManager" />
    </member>
    <member name="M:yWorks.Graph.NodeDecorator.GetDecoratorFor``1(System.Boolean,System.Boolean)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Graph.LookupDecorator`2" /> for <see cref="T:yWorks.Graph.INode" />s that can be used to decorate <typeparamref name="TInterface" /> types of the nodes.</para>
      </summary>
      <typeparam name="TInterface">
        <para>The type of the interface that should be decorated of the instances' <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </typeparam>
      <param name="decorateNulls">
        <para>if set to <c>true</c> <c>null</c> values will be decorated, otherwise not.</para>
      </param>
      <param name="nullIsFallback">
        <para>if set to <c>true</c> <c>null</c> values will be treated as fallback values, otherwise they will be used as the final result.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Graph.LookupDecorator`2" /> for the specified interface.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.LookupDecorator`2">
      <summary>
        <para>A convenience class that simplifies using an <see cref="T:yWorks.Graph.ILookupDecorator" />.</para>
      </summary>
      <remarks>
        <para>This class provides convenience methods that help in performing common tasks related to decorating the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method for a certain <typeparamref name="TDecoratedType" />.</para>
      </remarks>
      <typeparam name="TDecoratedType">
        <para>The type of the instances whose <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> behavior should be modified.</para>
      </typeparam>
      <typeparam name="TInterface">
        <para>The interface or type that clients will use during the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> call. Note that this is normally an interface and not the implementation of the interface since client code will use the interface for the query.</para>
      </typeparam>
      <seealso cref="T:yWorks.Graph.ILookup" />
      <seealso cref="T:yWorks.Graph.GraphDecorator" />
      <seealso cref="T:yWorks.Graph.LookupExtensions" />
    </member>
    <member name="M:yWorks.Graph.LookupDecorator`2.#ctor(yWorks.Graph.ILookupDecorator,System.Boolean,System.Boolean)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LookupDecorator`2" /> class.</para>
      </summary>
      <param name="decorator">
        <para>The decorator instance that will be used to <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">extend the Lookup mechanism</see>.</para>
      </param>
      <param name="decorateNulls">
        <para>The initial value of the <see cref="P:yWorks.Graph.LookupDecorator`2.DecorateNulls" /> property.</para>
      </param>
      <param name="nullIsFallback">
        <para>The initial value of the <see cref="P:yWorks.Graph.LookupDecorator`2.NullIsFallback" /> property.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.LookupDecorator`2.Decorator">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.ILookupDecorator" /> instance that is used.</para>
      </summary>
      <remarks>
        <para>This can be <c>null</c>. In this case all methods of this class do nothing.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.LookupDecorator`2.DecorateNulls">
      <summary>
        <para>Gets or sets a value indicating whether wrapping implementations will wrap <c>null</c> values from the rest of the lookup chain or those values will simply be returned instead.</para>
      </summary>
      <remarks>
        <para>If this is <c>true</c>, then the <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementationWrapper(System.Predicate{`0},System.Func{`0,`1,`1})">SetImplementationWrapper</see> methods will not wrap <c>null</c> values from the rest of the lookup chain and the result of the call to <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> will simply be <c>null</c>. If this is <c>false</c>, the wrapper will get <c>null</c> as the implementation to wrap and should handle this accordingly.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.LookupDecorator`2.NullIsFallback">
      <summary>
        <para>Gets or sets a value indicating whether a <c>null</c> result value of the methods <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(System.Predicate{`0},`1)" /> and <see cref="M:yWorks.Graph.LookupDecorator`2.SetFactory(System.Func{`0,`1})" /> should be interpreted as taking the fallback value, or actually return <c>null</c>.</para>
      </summary>
      <remarks>
        <para>If this is <c>true</c>, then <c>null</c> values returned from the implementation or factory set with <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`1)" /> or <see cref="M:yWorks.Graph.LookupDecorator`2.SetFactory(System.Func{`0,`1})" /> are not returned, but rather interpreted as a hint to query the rest of the lookup chain. If this is <c>false</c>, then <c>null</c> values are returned as is.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`0,`1)">
      <summary>
        <para>Amends the <see cref="T:yWorks.Graph.IContextLookupChainLink">lookup chain</see> for a single item with a fixed <typeparamref name="TInterface" /> <paramref name="implementation" /> if <typeparamref name="TInterface" /> is queried on the <paramref name="item" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </summary>
      <remarks>
        <para>This can be used to modify the lookup of a single item only.</para>
        <para>To adjust the lookup of all items matching a predicate, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(System.Predicate{`0},`1)" /> instead. To adjust the lookup of all items, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`1)" />.</para>
        <para>The effects of this method call can be undone by passing the return value to <see cref="M:yWorks.Graph.ILookupDecorator.RemoveLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />.</para>
      </remarks>
      <param name="item">
        <para>The item for which the implementation shall be returned.</para>
      </param>
      <param name="implementation">
        <para>The implementation to return if <paramref name="item" /> is queried for <typeparamref name="TInterface" />.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IContextLookupChainLink" /> that has been <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">added</see> to the <see cref="P:yWorks.Graph.LookupDecorator`2.Decorator" /> as a result of this call, or <c>null</c> if decoration was unsuccessful.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="T:yWorks.Graph.LookupExtensions" />
    </member>
    <member name="M:yWorks.Graph.LookupDecorator`2.SetImplementation(System.Predicate{`0},`1)">
      <summary>
        <para>Amends the <see cref="T:yWorks.Graph.IContextLookupChainLink">lookup chain</see> for all items matching a <paramref name="predicate" /> with a fixed <typeparamref name="TInterface" /> <paramref name="implementation" /> if <typeparamref name="TInterface" /> is queried on an item's <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </summary>
      <remarks>
        <para>This can be used to modify the lookup of all items matching a certain predicate in the same way.</para>
        <para>To adjust the lookup of only a single item, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`0,`1)" /> instead. To adjust the lookup of all items, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`1)" />.</para>
        <para>The effects of this method call can be undone by passing the return value to <see cref="M:yWorks.Graph.ILookupDecorator.RemoveLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />.</para>
      </remarks>
      <param name="predicate">
        <para>A predicate that determines which items are affected.</para>
      </param>
      <param name="implementation">
        <para>The implementation to return if the <paramref name="predicate" /> matches and <typeparamref name="TInterface" /> is queried.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IContextLookupChainLink" /> that has been <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">added</see> to the <see cref="P:yWorks.Graph.LookupDecorator`2.Decorator" /> as a result of this call, or <c>null</c> if decoration was unsuccessful.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="T:yWorks.Graph.LookupExtensions" />
    </member>
    <member name="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`1)">
      <summary>
        <para>Amends the <see cref="T:yWorks.Graph.IContextLookupChainLink">lookup chain</see>, so that <paramref name="implementation" /> is always returned if <typeparamref name="TInterface" /> is queried on an item's <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </summary>
      <remarks>
        <para>This can be used to modify the lookup of all items in the same way.</para>
        <para>To adjust the lookup of only a single item, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`0,`1)" /> instead. To adjust the lookup of all items matching a certain predicate, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(System.Predicate{`0},`1)" />.</para>
        <para>The effects of this method call can be undone by passing the return value to <see cref="M:yWorks.Graph.ILookupDecorator.RemoveLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />.</para>
      </remarks>
      <param name="implementation">
        <para>The implementation to return unconditionally.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IContextLookupChainLink" /> that has been <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">added</see> to the <see cref="P:yWorks.Graph.LookupDecorator`2.Decorator" /> as a result of this call, or <c>null</c> if decoration was unsuccessful.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="T:yWorks.Graph.LookupExtensions" />
    </member>
    <member name="M:yWorks.Graph.LookupDecorator`2.SetFactory(System.Predicate{`0},System.Func{`0,`1})">
      <summary>
        <para>Amends the <see cref="T:yWorks.Graph.IContextLookupChainLink">lookup chain</see> for items matching a <paramref name="predicate" /> with a <paramref name="factory" /> that creates a <typeparamref name="TInterface" /> instance if <typeparamref name="TInterface" /> is queried during the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </summary>
      <remarks>
        <para>This can be used to modify the lookup of all items matching a certain predicate where the returned instance either depends on the item or uses it in some way.</para>
        <para>To adjust the lookup of all items in this manner, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetFactory(System.Func{`0,`1})" /> instead. To adjust the lookup of a single item, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`1)" />.</para>
        <para>Note that depending on the value of the <see cref="P:yWorks.Graph.LookupDecorator`2.NullIsFallback" /> property a <c>null</c> return value from the <paramref name="factory" /> will be either returned directly, or interpreted as a hint to return a fallback value which is obtained by querying the remainder of the lookup chain.</para>
        <para>The effects of this method call can be undone by passing the return value to <see cref="M:yWorks.Graph.ILookupDecorator.RemoveLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />.</para>
      </remarks>
      <param name="predicate">
        <para>The predicate that determines for which items the factory shall be called.</para>
      </param>
      <param name="factory">
        <para>The factory that is queried to create the result.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IContextLookupChainLink" /> that has been <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">added</see> to the <see cref="P:yWorks.Graph.LookupDecorator`2.Decorator" /> as a result of this call, or <c>null</c> if decoration was unsuccessful.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="T:yWorks.Graph.LookupExtensions" />
      <seealso cref="P:yWorks.Graph.LookupDecorator`2.NullIsFallback" />
    </member>
    <member name="M:yWorks.Graph.LookupDecorator`2.SetImplementationWrapper(System.Predicate{`0},System.Func{`0,`1,`1})">
      <summary>
        <para>Amends the <see cref="T:yWorks.Graph.IContextLookupChainLink">lookup chain</see> for all items matching a <paramref name="predicate" /> with a <paramref name="factory" /> callback that wraps the underlying implementation if <typeparamref name="TInterface" /> is queried during the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </summary>
      <remarks>
        <para>This can be used to modify the lookup of all items matching a certain predicate where the factory implementation may delegate to the wrapped implementation in certain cases.</para>
        <para>To adjust the lookup for all items in this manner, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementationWrapper(System.Func{`0,`1,`1})" /> instead. To adjust the lookup of a single item, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`1)" />.</para>
        <para>Note that depending on the value of the <see cref="P:yWorks.Graph.LookupDecorator`2.DecorateNulls" /> property, the factory will not not be called to decorate <c>null</c> results.</para>
        <para>The effects of this method call can be undone by passing the return value to <see cref="M:yWorks.Graph.ILookupDecorator.RemoveLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />.</para>
      </remarks>
      <param name="predicate">
        <para>The predicate that determines for which items the wrapping shall be performed.</para>
      </param>
      <param name="factory">
        <para>The factory that will be passed the underlying implementation and that is queried to create the result.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IContextLookupChainLink" /> that has been <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">added</see> to the <see cref="P:yWorks.Graph.LookupDecorator`2.Decorator" /> as a result of this call, or <c>null</c> if decoration was unsuccessful.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="T:yWorks.Graph.LookupExtensions" />
    </member>
    <member name="M:yWorks.Graph.LookupDecorator`2.SetFactory(System.Func{`0,`1})">
      <summary>
        <para>Amends the <see cref="T:yWorks.Graph.IContextLookupChainLink">lookup chain</see> for all <typeparamref name="TDecoratedType" /> items, so that <paramref name="factory" /> is used to create a <typeparamref name="TInterface" /> instance if <typeparamref name="TInterface" /> is queried during the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </summary>
      <remarks>
        <para>This can be used to modify the lookup of all items where the returned instance either depends on the item or uses it in some way.</para>
        <para>To only adjust the lookup of items matching a predicate in this manner, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetFactory(System.Predicate{`0},System.Func{`0,`1})" /> instead. To adjust the lookup of a single item, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`1)" />.</para>
        <para>Note that depending on the value of the <see cref="P:yWorks.Graph.LookupDecorator`2.NullIsFallback" /> property a <c>null</c> return value from the <paramref name="factory" /> will be either returned directly, or interpreted as a hint to return a fallback value which is obtained by querying the remainder of the lookup chain.</para>
        <para>The effects of this method call can be undone by passing the return value to <see cref="M:yWorks.Graph.ILookupDecorator.RemoveLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />.</para>
      </remarks>
      <param name="factory">
        <para>The factory that is queried to create the result.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IContextLookupChainLink" /> that has been <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">added</see> to the <see cref="P:yWorks.Graph.LookupDecorator`2.Decorator" /> as a result of this call, or <c>null</c> if decoration was unsuccessful.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="T:yWorks.Graph.LookupExtensions" />
      <seealso cref="P:yWorks.Graph.LookupDecorator`2.NullIsFallback" />
    </member>
    <member name="M:yWorks.Graph.LookupDecorator`2.SetImplementationWrapper(System.Func{`0,`1,`1})">
      <summary>
        <para>Amends the <see cref="T:yWorks.Graph.IContextLookupChainLink">lookup chain</see> for all items with a <paramref name="factory" /> callback that wraps the underlying implementation if <typeparamref name="TInterface" /> is queried during the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </summary>
      <remarks>
        <para>This can be used to modify the lookup of all items matching where the factory implementation may delegate to the wrapped implementation in certain cases.</para>
        <para>To adjust the lookup in this manner only for items matching a predicate, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementationWrapper(System.Predicate{`0},System.Func{`0,`1,`1})" /> instead. To adjust the lookup of a single item, use <see cref="M:yWorks.Graph.LookupDecorator`2.SetImplementation(`1)" />.</para>
        <para>Note that depending on the value of the <see cref="P:yWorks.Graph.LookupDecorator`2.DecorateNulls" /> property, the factory will not not be called to decorate <c>null</c> results.</para>
        <para>The effects of this method call can be undone by passing the return value to <see cref="M:yWorks.Graph.ILookupDecorator.RemoveLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />.</para>
      </remarks>
      <param name="factory">
        <para>The factory that will be passed the underlying implementation and that is queried to create the result.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IContextLookupChainLink" /> that has been <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">added</see> to the <see cref="P:yWorks.Graph.LookupDecorator`2.Decorator" /> as a result of this call, or <c>null</c> if decoration was unsuccessful.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="T:yWorks.Graph.LookupExtensions" />
    </member>
    <member name="M:yWorks.Graph.LookupDecorator`2.HideImplementation(System.Predicate{`0})">
      <summary>
        <para>Amends the <see cref="T:yWorks.Graph.IContextLookupChainLink">lookup chain</see> for all <typeparamref name="TDecoratedType" /> items matching a <paramref name="predicate" /> to return <c>null</c> if <typeparamref name="TInterface" /> is queried during the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </summary>
      <remarks>
        <para>This can be used to temporarily or permanently disable a certain behavior for all items. To do this only for items matching a predicate, use <see cref="M:yWorks.Graph.LookupDecorator`2.HideImplementation(System.Predicate{`0})" /> instead.</para>
        <para>The effects of this method call can be undone by passing the return value to <see cref="M:yWorks.Graph.ILookupDecorator.RemoveLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />.</para>
      </remarks>
      <param name="predicate">
        <para>The predicate that determines for which items the implementation shall be hidden.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Graph.IContextLookupChainLink" /> that has been <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">added</see> to the <see cref="P:yWorks.Graph.LookupDecorator`2.Decorator" /> as a result of this call, or <c>null</c> if decoration was unsuccessful.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="T:yWorks.Graph.LookupExtensions" />
    </member>
    <member name="M:yWorks.Graph.LookupDecorator`2.AddChainLink(yWorks.Graph.IContextLookupChainLink)">
      <summary>
        <para>Simple helper method that tries to add the provided chain link to the <see cref="P:yWorks.Graph.LookupDecorator`2.Decorator" />.</para>
      </summary>
      <param name="lookup">
        <para>The link to add.</para>
      </param>
      <returns>
        <para>The <paramref name="lookup" /> that has been <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">added</see> to the <see cref="P:yWorks.Graph.LookupDecorator`2.Decorator" /> as a result of this call, or <c>null</c> if the decoration was unsuccessful.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="T:yWorks.Graph.LookupExtensions" />
    </member>
    <member name="T:yWorks.Graph.FoldingViewExtensions">
      <summary>
        <para>Provides utility methods for the <see cref="T:yWorks.Graph.IFoldingView" /> interface.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.GroupingSupport">
      <summary>
        <para>Provides less frequently used methods for analyzing and managing grouped graphs.</para>
      </summary>
      <remarks>
        <para>An instance of this class which is configured for a given <see cref="T:yWorks.Graph.IGraph" /> instance can be obtained via <see cref="M:yWorks.Graph.GroupedGraphExtensions.GetGroupingSupport(yWorks.Graph.IGraph)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.#ctor(yWorks.Graph.IGraph)">
      <summary>
        <para>Creates a new instance which operates on the given <paramref name="graph" />.</para>
      </summary>
      <param name="graph">
        <para>The graph to use for operations on this instance.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.HasGroupNodes">
      <summary>
        <para>Determines whether there are group nodes in the graph.</para>
      </summary>
      <remarks>
        <para>This methods considers all <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">group</see> nodes, that is, nodes that could have children.</para>
      </remarks>
      <returns>
        <para>
          <c>true</c> if there are <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">group</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.EnlargeGroupNode(yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Enlarges the given group node to ensure that the <see cref="M:yWorks.Graph.GroupingSupport.CalculateMinimumEnclosedArea(yWorks.Graph.INode)">minimum enclosed</see> area is inside of its bounds.</para>
      </summary>
      <remarks>
        <para>This method can be used to resize a group node and all of its parent group nodes to fully contain its children, e.g. after a child node has changed its bounds. Note that this method will only enlarge the bounds of the group nodes, it will never reduce the size of a group node.</para>
      </remarks>
      <param name="groupNode">
        <para>The group node to resize.</para>
      </param>
      <param name="ancestors">
        <para>if set to <c>true</c> all ancestor group nodes will be resized, too, if necessary</para>
      </param>
      <seealso cref="M:yWorks.Graph.GroupingSupport.EnlargeGroupNode(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,System.Boolean)" />
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.EnlargeAllGroupNodes">
      <summary>
        <para>Enlarges all group nodes in the graph so that the <see cref="M:yWorks.Graph.GroupingSupport.CalculateMinimumEnclosedArea(yWorks.Graph.INode)">minimum enclosed area</see> is respected.</para>
      </summary>
      <seealso cref="M:yWorks.Graph.GroupingSupport.EnlargeGroupNode(yWorks.Graph.INode,System.Boolean)" />
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.EnlargeAllGroupNodes(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Enlarges all group nodes in the graph in an interactive scenario, so that the <see cref="M:yWorks.Graph.GroupingSupport.CalculateMinimumEnclosedArea(yWorks.Graph.INode)">minimum enclosed area</see> is respected.</para>
      </summary>
      <remarks>
        <para>This method should be used in an interactive editing scenario. It records an <see cref="T:yWorks.Graph.ICompoundEdit" /> to support undoability and uses the <see cref="T:yWorks.Controls.Input.IReshapeHandler" /> for the resizing of the nodes. That way, e.g. orthogonally edited edges will be properly reshaped.</para>
      </remarks>
      <param name="context">
        <para>The context to use for the <see cref="T:yWorks.Controls.Input.IReshapeHandler" />s.</para>
      </param>
      <seealso cref="M:yWorks.Graph.GroupingSupport.EnlargeGroupNode(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,System.Boolean)" />
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.EnlargeGroupNode(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Enlarges the group nodes in an interactive scenario, using <see cref="T:yWorks.Controls.Input.IReshapeHandler" /> implementations of the group nodes to perform the actual resizing.</para>
      </summary>
      <remarks>
        <para>This method should be used in an interactive editing scenario. It records an <see cref="T:yWorks.Graph.ICompoundEdit" /> to support undoability and uses the <see cref="T:yWorks.Controls.Input.IReshapeHandler" /> for the resizing of the nodes. That way, e.g. orthogonally edited edges will be properly reshaped.</para>
      </remarks>
      <param name="context">
        <para>The context to use for the <see cref="T:yWorks.Controls.Input.IReshapeHandler" />s.</para>
      </param>
      <param name="node">
        <para>The node to enlarge appropriately.</para>
      </param>
      <param name="ancestors">
        <para>if set to <c>true</c> ancestors the ancestor group nodes will be adjusted, too, if necessary.</para>
      </param>
      <seealso cref="T:yWorks.Controls.Input.IReshapeHandler" />
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.CalculateMinimumEnclosedArea(yWorks.Graph.INode)">
      <summary>
        <para>Calculates the minimum area to enclose by the given group node with respect to its <see cref="T:yWorks.Graph.IGroupBoundsCalculator" />.</para>
      </summary>
      <param name="groupNode">
        <para>The group node to calculate the minimum enclosed area of.</para>
      </param>
      <returns>
        <para>The area to enclose for the given group node. This is <see cref="F:yWorks.Geometry.RectD.Empty" /> if the node is not a group node, or if it hasn't any children.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.GetDescendants(yWorks.Graph.INode)">
      <summary>
        <para>Returns all descendants of the provided node that are part of the grouped graph.</para>
      </summary>
      <remarks>
        <para>The enumeration will be top down, i.e. all of a node's ancestors will be enumerated before the respective node.</para>
      </remarks>
      <example />
      <param name="node">
        <para>The root node to get the descendants from.</para>
      </param>
      <returns>
        <para>An enumeration of the children of the node at the time of this invocation in reverse DFS prefix order.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.GetPathToRoot(yWorks.Graph.INode)">
      <summary>
        <para>Gets the path to root traversing all <see cref="M:yWorks.Graph.IGraph.GetParent(yWorks.Graph.INode)">parents</see> of the given item.</para>
      </summary>
      <example />
      <param name="node">
        <para>The node to start.</para>
      </param>
      <returns>
        <para>A list that includes the node but not the root, unless they are identical and all parents in between them.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.GetDescendantsBottomUp(yWorks.Graph.INode)">
      <summary>
        <para>Returns all descendants of the provided node that are part of the grouped graph.</para>
      </summary>
      <remarks>
        <para>The enumeration will be bottom up, i.e. all of a node's children will be enumerated before the respective node.</para>
      </remarks>
      <example />
      <param name="node">
        <para>The root node to get the descendants from.</para>
      </param>
      <returns>
        <para>An enumeration of the children of the node at the time of this invocation in DFS postfix order.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.IsDescendant(yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Determines whether <paramref name="ancestor" /> is an ancestor of <paramref name="node" /> in the grouped graph.</para>
      </summary>
      <example />
      <param name="node">
        <para>The node to check.</para>
      </param>
      <param name="ancestor">
        <para>The ancestor to check.</para>
      </param>
      <returns>
        <para>Whether <paramref name="ancestor" /> is an ancestor of <paramref name="node" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.GetNearestCommonAncestor(yWorks.Graph.INode[])">
      <summary>
        <para>Determines the nearest common ancestor of the provided nodes in the graph.</para>
      </summary>
      <example />
      <param name="nodes">
        <para>The nodes to find the nearest common ancestor of.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GroupingSupport.GetNearestCommonAncestor(System.Collections.Generic.IEnumerable{yWorks.Graph.INode})">
      <summary>
        <para>Determines the nearest common ancestor of the provided nodes in the graph.</para>
      </summary>
      <example />
      <param name="nodes">
        <para>The nodes to find the nearest common ancestor of.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.GroupedGraphExtensions">
      <summary>
        <para>Provides utility methods for managing grouped nodes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.GroupedGraphExtensions.GetGroupingSupport(yWorks.Graph.IGraph)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Graph.GroupingSupport" /> instance for the graph.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Graph.GroupingSupport" /> provides less frequently used methods for grouped graphs, such as methods for analyzing and walking the grouping hierarchy.</para>
      </remarks>
      <param name="graph">
        <para>The graph to create the <see cref="T:yWorks.Graph.GroupingSupport" /> for.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Graph.GroupingSupport" /> for the graph.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GroupedGraphExtensions.AdjustGroupNodeLayout(yWorks.Graph.IGraph,yWorks.Graph.INode)">
      <summary>
        <para>Method to adjust the size of a group node.</para>
      </summary>
      <remarks>
        <para>This will resize the group node bounds such that the node requires the least amount of space. If the node does not have any <see cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)">children</see>, its bounds will be left unchanged. This will also respect any <see cref="T:yWorks.Controls.Input.INodeSizeConstraintProvider" />s for <see cref="T:yWorks.Graph.INode" />s, that are available in the lookup of the <paramref name="groupNode" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IGroupBoundsCalculator" />
      <seealso cref="T:yWorks.Controls.Input.INodeSizeConstraintProvider" />
      <seealso cref="M:yWorks.Graph.GroupingSupport.CalculateMinimumEnclosedArea(yWorks.Graph.INode)" />
      <seealso cref="M:yWorks.Graph.GroupingSupport.EnlargeGroupNode(yWorks.Graph.INode,System.Boolean)" />
      <seealso cref="M:yWorks.Graph.GroupingSupport.EnlargeAllGroupNodes" />
      <param name="graph">
        <para>The graph to operate on.</para>
      </param>
      <param name="groupNode">
        <para>The group node to adjust the size of.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="groupNode" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GroupedGraphExtensions.GroupNodes(yWorks.Graph.IGraph,yWorks.Graph.INode,System.Collections.Generic.IEnumerable{yWorks.Graph.INode})">
      <summary>
        <para>Groups the nodes in <paramref name="children" /> into the provided group node.</para>
      </summary>
      <remarks>
        <para>The <paramref name="parent" /> needs to be a group node at the time of the invocation. This operation is basically the same as calling <see cref="M:yWorks.Graph.IGraph.SetParent(yWorks.Graph.INode,yWorks.Graph.INode)" /> for each node in <paramref name="children" /> whose parent is not part of the set.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="parent" />.</para>
      </param>
      <param name="parent">
        <para>The node to use as the parent in the grouping hierarchy.</para>
      </param>
      <param name="children">
        <para>The children to group into the group node.</para>
      </param>
      <seealso cref="M:yWorks.Graph.GroupedGraphExtensions.GroupNodes(yWorks.Graph.IGraph,System.Collections.Generic.IEnumerable{yWorks.Graph.INode})" />
      <seealso cref="M:yWorks.Graph.IGraph.SetParent(yWorks.Graph.INode,yWorks.Graph.INode)" />
      <seealso cref="M:yWorks.Graph.IGraph.CreateGroupNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="parent" /> or one of <paramref name="children" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GroupedGraphExtensions.GroupNodes(yWorks.Graph.IGraph,yWorks.Graph.INode[])">
      <summary>
        <para>Groups the nodes into a newly created group node.</para>
      </summary>
      <remarks>
        <para>The group node will be created at the common ancestor level of all nodes in <paramref name="children" />.</para>
      </remarks>
      <param name="children">
        <para>The children to group into the new group node.</para>
      </param>
      <param name="graph">
        <para>The <see cref="T:yWorks.Graph.IGraph" /> instance to use.</para>
      </param>
      <returns>
        <para>The newly created group node.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GroupingSupport.GetNearestCommonAncestor(yWorks.Graph.INode[])" />
      <seealso cref="M:yWorks.Graph.GroupedGraphExtensions.GroupNodes(yWorks.Graph.IGraph,System.Collections.Generic.IEnumerable{yWorks.Graph.INode})" />
      <exception cref="T:System.ArgumentException">
        <para>One of <paramref name="children" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GroupedGraphExtensions.GroupNodes(yWorks.Graph.IGraph,System.Collections.Generic.IEnumerable{yWorks.Graph.INode})">
      <summary>
        <para>Groups the nodes in <paramref name="children" /> into a newly created group node.</para>
      </summary>
      <remarks>
        <para>The group node will be created at the common ancestor level of all nodes in <paramref name="children" />.</para>
      </remarks>
      <param name="children">
        <para>The children to group into the new group node.</para>
      </param>
      <param name="graph">
        <para>The <see cref="T:yWorks.Graph.IGraph" /> instance to use.</para>
      </param>
      <returns>
        <para>The newly created group node.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GroupingSupport.GetNearestCommonAncestor(yWorks.Graph.INode[])" />
      <seealso cref="M:yWorks.Graph.GroupedGraphExtensions.GroupNodes(yWorks.Graph.IGraph,System.Collections.Generic.IEnumerable{yWorks.Graph.INode})" />
      <exception cref="T:System.ArgumentException">
        <para>One of <paramref name="children" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="T:yWorks.Graph.GraphExtensions">
      <summary>
        <para>Provides utility methods for working with <see cref="T:yWorks.Graph.IGraph" />s.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.IGraph" />
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.Clear(yWorks.Graph.IGraph)">
      <summary>
        <para>Clears the graph, removing all items in proper order.</para>
      </summary>
      <param name="graph">
        <para>The graph to remove all items from.</para>
      </param>
      <seealso cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetGraph(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Tries to retrieve an <see cref="T:yWorks.Graph.IGraph" /> instance from an <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </summary>
      <remarks>
        <para>This will use the <see cref="T:yWorks.Graph.ILookup" /> and if this yields nothing, it will use the <see cref="T:yWorks.Graph.ILookup" /> of the <see cref="P:yWorks.Controls.ICanvasContext.CanvasControl" /> or finally test if it is a <see cref="T:yWorks.Controls.GraphControl" /> to obtain the graph from.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve the graph from.</para>
      </param>
      <returns>
        <para>Return the graph or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.InvalidateDisplays(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Tries to call <see cref="M:yWorks.Graph.IGraph.InvalidateDisplays" /> on the <see cref="M:yWorks.Graph.GraphExtensions.GetGraph(yWorks.Controls.Input.IInputModeContext)">graph</see> obtains from the <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </summary>
      <remarks>
        <para>If the graph instance cannot be found, <see cref="M:yWorks.Controls.CanvasControl.Invalidate" /> will be called instead.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve the graph from.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetSourceNode(yWorks.Graph.IEdge)">
      <summary>
        <para>Gets the source node for the given edge or <c>null</c>.</para>
      </summary>
      <param name="edge">
        <para>The edge to get the <see cref="P:yWorks.Graph.IEdge.SourcePort">source port's</see> <see cref="P:yWorks.Graph.IPort.Owner">owner</see> from.</para>
      </param>
      <returns>
        <para>The source node or <c>null</c> if the port's owner is not an <see cref="T:yWorks.Graph.INode" /> instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetTargetNode(yWorks.Graph.IEdge)">
      <summary>
        <para>Gets the target node for the given edge or <c>null</c>.</para>
      </summary>
      <param name="edge">
        <para>The edge to get the <see cref="P:yWorks.Graph.IEdge.TargetPort">target port's</see> <see cref="P:yWorks.Graph.IPort.Owner">owner</see> from.</para>
      </param>
      <returns>
        <para>The target node or <c>null</c> if the port's owner is not an <see cref="T:yWorks.Graph.INode" /> instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.IsSelfloop(yWorks.Graph.IEdge)">
      <summary>
        <para>Determines whether an <see cref="T:yWorks.Graph.IEdge">edge</see> is a self-loop, that is, it starts and ends at the same port owner.</para>
      </summary>
      <param name="edge">
        <para>The edge for which to determine whether it's a self-loop.</para>
      </param>
      <returns>
        <para>
          <c>true</c>, if the edge is a self-loop, <c>false</c> if not.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.Reverse(yWorks.Graph.IGraph,yWorks.Graph.IEdge)">
      <summary>
        <para>Reverses an edge by <see cref="M:yWorks.Graph.IGraph.SetEdgePorts(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">setting source and target port</see> to <see cref="P:yWorks.Graph.IEdge.TargetPort" /> and <see cref="P:yWorks.Graph.IEdge.SourcePort" />.</para>
      </summary>
      <remarks>
        <para>This also reverses the bends by clearing them and reinserting them in reverse order if there is more than one bend.</para>
      </remarks>
      <param name="edge">
        <para>The edge to reverse.</para>
      </param>
      <param name="graph">
        <para>The graph that contains the edge.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="edge" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetIndex(yWorks.Graph.IBend)">
      <summary>
        <para>Gets the index of the bend at its <see cref="P:yWorks.Graph.IBend.Owner" />.</para>
      </summary>
      <param name="bend">
        <para>The bend to get the index of.</para>
      </param>
      <returns>
        <para>The zero-based index of the bend in the <see cref="P:yWorks.Graph.IEdge.Bends" /> list; <c>-1</c> if the bend is not part of an edge.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetIndex(yWorks.Graph.ILabel)">
      <summary>
        <para>Gets the index of the label at its <see cref="P:yWorks.Graph.ILabel.Owner" />.</para>
      </summary>
      <param name="label">
        <para>The label to get the index of.</para>
      </param>
      <returns>
        <para>The zero-based index of the label in the <see cref="P:yWorks.Graph.ILabelOwner.Labels" /> list; <c>-1</c> if the label is not part of a label owner.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.AddBends(yWorks.Graph.IGraph,yWorks.Graph.IEdge,System.Collections.Generic.IEnumerable{yWorks.Geometry.PointD})">
      <summary>
        <para>Adds bends with the given locations to the end of the bend list of the given edge.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains <paramref name="edge" />.</para>
      </param>
      <param name="edge">
        <para>The edge to add the bends to.</para>
      </param>
      <param name="locations">
        <para>The locations of the bends.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="edge" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.BeginEdit``1(yWorks.Graph.IGraph,System.String,System.String,System.Collections.Generic.IEnumerable{``0},yWorks.Graph.MementoSupportProvider{``0})">
      <summary>
        <para>Starts an <see cref="T:yWorks.Graph.ICompoundEdit" /> that uses the <see cref="T:yWorks.Graph.IMementoSupport">memento design pattern</see> to record changes to the items in the given <paramref name="items" /> collection.</para>
      </summary>
      <remarks>
        <para>This method uses the <see cref="T:yWorks.Graph.IMementoSupport" /> returned by the <paramref name="provider" /> to record the state of an item at the beginning of the edit and when <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> is called to create an <see cref="T:yWorks.Graph.IUndoUnit" /> that can revert the item to the recorded state and back. If no <paramref name="provider" /> is given, this method uses the <see cref="T:yWorks.Graph.IMementoSupport" /> returned by the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> implementation of the items to record the state of an item at the beginning of the edit and when <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> is called to create an <see cref="T:yWorks.Graph.IUndoUnit" /> that can revert the item to the recorded state and back.</para>
        <para>Calling this method will immediately enqueue an <see cref="T:yWorks.Graph.IUndoUnit" /> into the undo queue. Subsequent additions to the queue will be added after the created instance, even if they are added to the queue before the <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> method has been called.</para>
      </remarks>
      <example>
        <para>The following is an example implementation of an item that is being managed using <see cref="T:yWorks.Graph.IMementoSupport" />:</para>
        <para>A collection of items from this type can then be watched using the following code snippet:</para>
        <para>Alternatively, when using a specific provider, consider the following examples. The following is an example implementation of an item that is being managed using <see cref="T:yWorks.Graph.IMementoSupport" />:</para>
        <para>A collection of items from this type can then be watched using the following code snippet, using the <paramref name="provider" /> to return an appropriate <see cref="T:yWorks.Graph.IMementoSupport" /> implementation:</para>
        <para>Implementing the <see cref="T:yWorks.Graph.IMementoSupport" /> interface is quite unrestrained, the type of the state returned by <see cref="M:yWorks.Graph.IMementoSupport.GetState(System.Object)" /> method can by anything as long as the <see cref="M:yWorks.Graph.IMementoSupport.ApplyState(System.Object,System.Object)" /> and <see cref="M:yWorks.Graph.IMementoSupport.StateEquals(System.Object,System.Object)" /> methods can deal with it:</para>
        <para>In summary, use this concept when you want to track the state of items during certain operations for undo/redo. This is efficient if it's easier to handle an item's state than the changes to the item themselves. If you want to focus on the changes or on certain events, you should use custom <see cref="T:yWorks.Graph.IUndoUnit" /></para>
      </example>
      <typeparam name="T">
        <para>The type of the items that will be modified subsequently.</para>
      </typeparam>
      <param name="graph">
        <para>The graph to begin an edit on.</para>
      </param>
      <param name="undoName">
        <para>The <see cref="P:yWorks.Graph.IUndoUnit.UndoName" /> of the <see cref="T:yWorks.Graph.IUndoUnit" /> that will be placed into the undo queue after <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> has been called.</para>
      </param>
      <param name="redoName">
        <para>The <see cref="P:yWorks.Graph.IUndoUnit.RedoName" /> of the <see cref="T:yWorks.Graph.IUndoUnit" /> that will be placed into the undo queue after <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> has been called.</para>
      </param>
      <param name="items">
        <para>The items that will be changed after this call and before the call to <see cref="M:yWorks.Graph.ICompoundEdit.Commit" />.</para>
      </param>
      <param name="provider">
        <para>The provider for the <see cref="T:yWorks.Graph.IMementoSupport" /> of the <paramref name="items" />. if the provider returns <c>null</c> for a given item, changes to this item are not being recorded.</para>
      </param>
      <returns>
        <para>An implementation of the <see cref="T:yWorks.Graph.ICompoundEdit" /> interface whose <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> or <see cref="M:yWorks.Graph.ICompoundEdit.Cancel" /> methods need to be called after the items have been modified.</para>
      </returns>
      <seealso cref="T:yWorks.Graph.IMementoSupport" />
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.BeginEdit(yWorks.Graph.IGraph,System.String,System.String)">
      <summary>
        <para>Starts an <see cref="T:yWorks.Graph.ICompoundEdit" /> that records graph changes and <see cref="M:yWorks.Graph.GraphExtensions.AddUndoUnit(yWorks.Graph.IGraph,System.String,System.String,System.Action,System.Action)">custom undo units</see> in a single compound unit.</para>
      </summary>
      <remarks>
        <para>This method can be used to bracket several undo units. All edits added to the queue after this call and before a call to <see cref="M:yWorks.Graph.ICompoundEdit.Cancel" /> or <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> will be placed into the queue as a single block.</para>
        <para>Client code needs to make sure that either the <see cref="M:yWorks.Graph.ICompoundEdit.Cancel" /> or <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> method is called on the returned instance.</para>
        <para>The returned instance implements <see cref="T:System.IDisposable" /> which enables the use of a <c>using</c> statement to automatically call the <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> method after a set of changes:</para>
      </remarks>
      <param name="graph">
        <para>The graph to begin an edit on.</para>
      </param>
      <param name="undoName">
        <para>The undo name for the compound edit.</para>
      </param>
      <param name="redoName">
        <para>The redo name for the compound edit.</para>
      </param>
      <returns>
        <para>The handle to stop the recording by calling <see cref="M:yWorks.Graph.ICompoundEdit.Cancel" /> or <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> on it.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.AddUndoUnit(yWorks.Graph.IGraph,System.String,System.String,System.Action,System.Action)">
      <summary>
        <para>Convenience method that uses the <see cref="T:yWorks.Graph.UndoEngine" /> from the <see cref="T:yWorks.Graph.IGraph" />'s <see cref="T:yWorks.Graph.ILookup" /> to <see cref="M:yWorks.Graph.UndoEngine.AddUnit(yWorks.Graph.IUndoUnit)">add a unit</see>.</para>
      </summary>
      <param name="graph">
        <para>The graph to add an undo unit for.</para>
      </param>
      <param name="undoName">
        <para>The name of the undo operation.</para>
      </param>
      <param name="redoName">
        <para>The name of the redo operation.</para>
      </param>
      <param name="undo">
        <para>The undo action.</para>
      </param>
      <param name="redo">
        <para>The redo action.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.SetNodeCenter(yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD)">
      <summary>
        <para>Sets the center of a node to the given world coordinates.</para>
      </summary>
      <remarks>
        <para>This implementation delegates to <see cref="M:yWorks.Graph.IGraph.SetNodeLayout(yWorks.Graph.INode,yWorks.Geometry.RectD)" /></para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="node" />.</para>
      </param>
      <param name="node">
        <para>The node to recenter.</para>
      </param>
      <param name="center">
        <para>The new center coordinates of the node in the world coordinate system.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.AdjustLabelPreferredSize(yWorks.Graph.IGraph,yWorks.Graph.ILabel)">
      <summary>
        <para>Adjusts the <see cref="P:yWorks.Graph.ILabel.PreferredSize" /> property of a label to fit the suggested size of its <see cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" />.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Graph.ILabel.Style">style's</see> renderer for the label to determine the preferred rendering size. This is useful after the label's content or style have been changed.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="label" />.</para>
      </param>
      <seealso cref="P:yWorks.Graph.ILabelDefaults.AutoAdjustPreferredSize" />
      <param name="label">
        <para>The label to adjust the size for.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.CalculateLabelPreferredSize(yWorks.Graph.IGraph,yWorks.Graph.ILabelOwner,System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,System.Object)">
      <summary>
        <para>Calculates the preferred size of a label with the given properties.</para>
      </summary>
      <param name="graph">
        <para>The graph to which the label will be added.</para>
      </param>
      <param name="owner">
        <para>The item that will own the label.</para>
      </param>
      <param name="text">
        <para>The text.</para>
      </param>
      <param name="layoutParameter">
        <para>The label model parameter.</para>
      </param>
      <param name="style">
        <para>The label style.</para>
      </param>
      <param name="tag">
        <para>The tag for the label.</para>
      </param>
      <returns>
        <para>The size as calculated by the <see cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.Neighbors``1(yWorks.Graph.IGraph,``0)">
      <summary>
        <para>Enumerates the neighbors of a given <see cref="T:yWorks.Graph.IPortOwner" />.</para>
      </summary>
      <remarks>
        <para>Neighbors are calculated by going through all <see cref="P:yWorks.Graph.IPortOwner.Ports" /> and inspecting the <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)">edges at these ports</see>, collecting the <see cref="M:yWorks.Graph.GraphExtensions.Opposite(yWorks.Graph.IEdge,yWorks.Graph.IPort)" />s.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the <see cref="T:yWorks.Graph.IPortOwner" /></para>
      </typeparam>
      <param name="graph">
        <para>The graph to use for obtaining the <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)">adjacent edges</see></para>
      </param>
      <param name="owner">
        <para>The port owner.</para>
      </param>
      <returns>
        <para>An enumerable over all neighbors.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.Successors``1(yWorks.Graph.IGraph,``0)">
      <summary>
        <para>Enumerates the successors of a given <see cref="T:yWorks.Graph.IPortOwner" />.</para>
      </summary>
      <remarks>
        <para>Successors are calculated by going through all <see cref="P:yWorks.Graph.IPortOwner.Ports" /> and inspecting the <see cref="M:yWorks.Graph.GraphExtensions.OutEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">outgoing edges at these ports</see>, collecting the <see cref="P:yWorks.Graph.IEdge.TargetPort" /> <see cref="P:yWorks.Graph.IPort.Owner" />s.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the <see cref="T:yWorks.Graph.IPortOwner" /></para>
      </typeparam>
      <param name="graph">
        <para>The graph to use for obtaining the <see cref="M:yWorks.Graph.GraphExtensions.OutEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">outgoing edges</see></para>
      </param>
      <param name="owner">
        <para>The port owner.</para>
      </param>
      <returns>
        <para>An enumerable over all successors.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.Predecessors``1(yWorks.Graph.IGraph,``0)">
      <summary>
        <para>Enumerates the predecessors of a given <see cref="T:yWorks.Graph.IPortOwner" />.</para>
      </summary>
      <remarks>
        <para>Predecessors are calculated by going through all <see cref="P:yWorks.Graph.IPortOwner.Ports" /> and inspecting the <see cref="M:yWorks.Graph.GraphExtensions.InEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">incoming edges at these ports</see>, collecting the <see cref="P:yWorks.Graph.IEdge.SourcePort" /> <see cref="P:yWorks.Graph.IPort.Owner" />s.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the <see cref="T:yWorks.Graph.IPortOwner" /></para>
      </typeparam>
      <param name="graph">
        <para>The graph to use for obtaining the <see cref="M:yWorks.Graph.GraphExtensions.InEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">incoming edges</see></para>
      </param>
      <param name="owner">
        <para>The port owner.</para>
      </param>
      <returns>
        <para>An enumerable over all predecessors.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.Opposite(yWorks.Graph.IEdge,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Gets the opposite port owner of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </summary>
      <param name="edge">
        <para>The edge to get the opposite <see cref="T:yWorks.Graph.IPortOwner" /> of <paramref name="owner" /> from.</para>
      </param>
      <param name="owner">
        <para>The owner of the port that the <see cref="T:yWorks.Graph.IEdge" /> is connected to.</para>
      </param>
      <returns>
        <para>The owner of the opposite port.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>If <paramref name="owner" /> is neither the source or target of the edge.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.Opposite(yWorks.Graph.IEdge,yWorks.Graph.IPort)">
      <summary>
        <para>Gets the opposite port of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </summary>
      <param name="edge">
        <para>The edge to get the opposite <see cref="T:yWorks.Graph.IPort" /> of <paramref name="port" /> from.</para>
      </param>
      <param name="port">
        <para>The port that the <see cref="T:yWorks.Graph.IEdge" /> is connected to.</para>
      </param>
      <returns>
        <para>The opposite port.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>If <paramref name="port" /> is neither the source or target of the edge.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetLocation(yWorks.Graph.IPort)">
      <summary>
        <para>Gets a snapshot of the current location of the port.</para>
      </summary>
      <param name="port">
        <para>The port to retrieve the location from.</para>
      </param>
      <returns>
        <para>The current port location.</para>
      </returns>
      <remarks>
        <para>Unlike <see cref="M:yWorks.Graph.GraphExtensions.GetDynamicLocation(yWorks.Graph.IPort)" /> this does not return a dynamic point that always refers to the current location.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetDynamicLocation(yWorks.Graph.IPort)">
      <summary>
        <para>Gets a live view of the location of the port in world coordinates.</para>
      </summary>
      <remarks>
        <para>The location is the anchor for the edges, that connect to this port, however it is up to the visualization logic where exactly the visual part of an edge will end. As this will yield a live view, it is up to the client to copy the values if a snapshot of the state is needed. In order to modify the location of a port, use the <see cref="M:yWorks.Graph.IGraph.SetPortLocationParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" /> in <see cref="T:yWorks.Graph.IGraph" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.IPort.LocationParameter" />
      <param name="port" />
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">
      <summary>
        <para>Gets a snapshot of the current layout of the label.</para>
      </summary>
      <remarks>
        <para>Labels have a <see cref="T:yWorks.Geometry.ISize">size</see> and are anchored at a given location in world coordinate space. The anchor is the point around which the oriented rectangle is rotated in the world coordinate system. If the oriented rectangle has default orientation, i.e. its up vector points north (<c>&lt;0,-1&gt;</c>), it coincides with its lower left corner. The positioning of the label is determined using a pair of <see cref="T:yWorks.Graph.LabelModels.ILabelModel" /> and <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" />. In order to modify the layout of a label instance, set another <see cref="P:yWorks.Graph.ILabel.LayoutParameter" /> for this label or modify its associated instance.</para>
      </remarks>
      <param name="label">
        <para>The label to retrieve the layout from.</para>
      </param>
      <returns>
        <para>The current label layout.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.Degree(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Calculates the number of edges at the given <see cref="T:yWorks.Graph.IPortOwner" /> for this graph.</para>
      </summary>
      <remarks>
        <para>Note that an edge that is both incoming and outgoing will be counted twice.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="owner" />.</para>
      </param>
      <param name="owner">
        <para>The port owner to count the degree of.</para>
      </param>
      <returns>
        <para>The number of edges that are incident to the port owner.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.InDegree(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Calculates the number of incoming edges at the given <see cref="T:yWorks.Graph.IPortOwner" /> for this graph.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains <paramref name="owner" />.</para>
      </param>
      <param name="owner">
        <para>The port owner to count the incoming edges of.</para>
      </param>
      <returns>
        <para>The number of edges that have the port owner as their target port's owner.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.OutDegree(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Calculates the number of outgoing edges at the given <see cref="T:yWorks.Graph.IPortOwner" /> for this graph.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains <paramref name="owner" />.</para>
      </param>
      <param name="owner">
        <para>The port owner to count the outgoing edges of.</para>
      </param>
      <returns>
        <para>The number of edges that have the port owner as their source port's owner.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.Degree(yWorks.Graph.IGraph,yWorks.Graph.IPort)">
      <summary>
        <para>Calculates the number of edges at the given <see cref="T:yWorks.Graph.IPort" /> for this graph.</para>
      </summary>
      <remarks>
        <para>Note that an edge that is both incoming and outgoing will be counted twice.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="port" />.</para>
      </param>
      <param name="port">
        <para>The port owner to count the degree of.</para>
      </param>
      <returns>
        <para>The number of edges that are incident to the port.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="port" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.InDegree(yWorks.Graph.IGraph,yWorks.Graph.IPort)">
      <summary>
        <para>Calculates the number of incoming edges at the given <see cref="T:yWorks.Graph.IPort" /> for this graph.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains <paramref name="port" />.</para>
      </param>
      <param name="port">
        <para>The port to count the incoming edges of.</para>
      </param>
      <returns>
        <para>The number of edges that have the port as their target port.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="port" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.OutDegree(yWorks.Graph.IGraph,yWorks.Graph.IPort)">
      <summary>
        <para>Calculates the number of outgoing edges at the given <see cref="T:yWorks.Graph.IPort" /> for this graph.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains <paramref name="port" />.</para>
      </param>
      <param name="port">
        <para>The port to count the outgoing edges of.</para>
      </param>
      <returns>
        <para>The number of edges that have the port as their source port.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="port" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.ClearBends(yWorks.Graph.IGraph,yWorks.Graph.IEdge)">
      <summary>
        <para>Removes all bends from the given edge.</para>
      </summary>
      <remarks>
        <para>The edge must be part of this graph at the time of the invocation. This will trigger the corresponding events.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="edge" />.</para>
      </param>
      <param name="edge">
        <para>the edge whose bends will be removed</para>
      </param>
      <seealso cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)" />
      <seealso cref="E:yWorks.Graph.IGraph.BendRemoved" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="edge" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.SetPortLocation(yWorks.Graph.IGraph,yWorks.Graph.IPort,yWorks.Geometry.PointD)">
      <summary>
        <para>Convenience method that tries to set the absolute coordinates of the given port to the given values.</para>
      </summary>
      <remarks>
        <para>For full control over the placement of the ports, the <see cref="M:yWorks.Graph.IGraph.SetPortLocationParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" /> method should be used instead. This implementation will use the port's <see cref="P:yWorks.Graph.IPort.LocationParameter" />'s <see cref="P:yWorks.Graph.PortLocationModels.IPortLocationModelParameter.Model" /> to obtain a new <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> via the <see cref="M:yWorks.Graph.PortLocationModels.IPortLocationModel.CreateParameter(yWorks.Graph.IPortOwner,yWorks.Geometry.PointD)" /> method. This might result in the port using a different location, because the model might not support parameters that result in the given location. This will also trigger an <see cref="M:yWorks.Graph.IGraph.InvalidateDisplays" /> call.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.AddPort(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)" />
      <param name="graph">
        <para>The graph that contains <paramref name="port" />.</para>
      </param>
      <param name="port">
        <para>The port to modify</para>
      </param>
      <param name="location">
        <para>the new absolute coordinates of the port</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="port" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.AddPort(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner,yWorks.Geometry.PointD,yWorks.Graph.Styles.IPortStyle,System.Object)">
      <summary>
        <para>Add a port to the given port owner using the absolute coordinates as the new initial position of the port anchor.</para>
      </summary>
      <param name="owner">
        <para>the owner to add the port instance to.</para>
      </param>
      <param name="location">
        <para>the location to use for the port to determine its location. This is passed to the <see cref="M:yWorks.Graph.GraphExtensions.CreateDefaultPortLocationParameter(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner,System.Nullable{yWorks.Geometry.PointD})" /> method to determine the initial <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> to use.</para>
      </param>
      <param name="style">
        <para>the style to initially assign to the <see cref="P:yWorks.Graph.IPort.Style" /> property, e.g. <see cref="F:yWorks.Graph.Styles.VoidPortStyle.Instance" />.</para>
      </param>
      <param name="graph">
        <para>The graph that contains <paramref name="owner" />.</para>
      </param>
      <param name="tag">
        <para>the initial <see cref="P:yWorks.Graph.ITagOwner.Tag" /> to assign.</para>
      </param>
      <returns>
        <para>the newly created port</para>
      </returns>
      <exception cref="T:System.NotSupportedException">
        <para>If this instance cannot add a port to <paramref name="owner" />.</para>
      </exception>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetEdge(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Finds an edge that connects <paramref name="from" /> and <paramref name="to" /> in the given graph.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains <paramref name="from" /> and <paramref name="to" />.</para>
      </param>
      <param name="from">
        <para>The <see cref="P:yWorks.Graph.IEdge.SourcePort" /> owner of the edge to find.</para>
      </param>
      <param name="to">
        <para>The <see cref="P:yWorks.Graph.IEdge.TargetPort" /> owner of the edge to find.</para>
      </param>
      <returns>
        <para>An edge that satisfies the constraints or <c>null</c>, if none was found.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="from" /> or <paramref name="to" /> are not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetEdge(yWorks.Graph.IGraph,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Finds an edge that connects <paramref name="sourcePort" /> and <paramref name="targetPort" /> in the given graph.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains <paramref name="sourcePort" /> and <paramref name="targetPort" />.</para>
      </param>
      <param name="sourcePort">
        <para>The <see cref="P:yWorks.Graph.IEdge.SourcePort" /> of the edge to find.</para>
      </param>
      <param name="targetPort">
        <para>The <see cref="P:yWorks.Graph.IEdge.TargetPort" /> of the edge to find.</para>
      </param>
      <returns>
        <para>An edge that satisfies the constraints or <c>null</c>, if none was found.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="sourcePort" /> or <paramref name="targetPort" /> are not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.SetRelativePortLocation(yWorks.Graph.IGraph,yWorks.Graph.IPort,yWorks.Geometry.PointD)">
      <summary>
        <para>Tries to set the location of the port relative to its <see cref="P:yWorks.Graph.IPort.Owner">owner</see> if the owner is a <see cref="T:yWorks.Graph.INode">node</see>.</para>
      </summary>
      <remarks>
        <para>If the port is not owned by a node that is part of this graph, this method will throw an <see cref="T:System.ArgumentOutOfRangeException" />. This method will delegate to <see cref="M:yWorks.Graph.GraphExtensions.SetPortLocation(yWorks.Graph.IGraph,yWorks.Graph.IPort,yWorks.Geometry.PointD)" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="port" />.</para>
      </param>
      <param name="port">
        <para>the port</para>
      </param>
      <param name="relativeLocation">
        <para>the new coordinate offsets relative to the center of the node's <see cref="P:yWorks.Graph.INode.Layout" />'s center.</para>
      </param>
      <seealso cref="P:yWorks.Graph.INode.Layout">The owner's layout</seealso>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="port" /> is not in this graph or has no owner.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.InEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Convenience method that yields the incoming edges at the given owner.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPortOwner,yWorks.Graph.AdjacencyTypes)" /> using <see cref="F:yWorks.Graph.AdjacencyTypes.Incoming" />.</para>
        <para>Note that even though edges can be accessed via index, the underlying graph structure in the default <see cref="T:yWorks.Graph.IGraph" /> implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in your own list, if possible. This is not necessary for the first or last element or when iterating over the incoming edges via a <c>foreach</c> loop.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="owner" />.</para>
      </param>
      <param name="owner">
        <para>The owner of the edges.</para>
      </param>
      <returns>
        <para>An enumerable for the edges.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.OutEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Convenience method that yields the outgoing edges at the given owner.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPortOwner,yWorks.Graph.AdjacencyTypes)" /> using <see cref="F:yWorks.Graph.AdjacencyTypes.Outgoing" />.</para>
        <para>Note that even though edges can be accessed via index, the underlying graph structure in the default <see cref="T:yWorks.Graph.IGraph" /> implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in your own list, if possible. This is not necessary for the first or last element or when iterating over the outgoing edges via a <c>foreach</c> loop.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="owner" />.</para>
      </param>
      <param name="owner">
        <para>The owner of the edges.</para>
      </param>
      <returns>
        <para>An enumerable for the edges.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.InEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPort)">
      <summary>
        <para>Convenience method that yields the incoming edges at the given port.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)" /> using <see cref="F:yWorks.Graph.AdjacencyTypes.Incoming" />.</para>
        <para>Note that even though edges can be accessed via index, the underlying graph structure in the default <see cref="T:yWorks.Graph.IGraph" /> implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in your own list, if possible. This is not necessary for the first or last element or when iterating over the incoming edges via a <c>foreach</c> loop.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="port" />.</para>
      </param>
      <param name="port">
        <para>The port of the edges.</para>
      </param>
      <returns>
        <para>An enumerable for the edges.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="port" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.OutEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPort)">
      <summary>
        <para>Convenience method that yields the outgoing edges at the given port.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)" /> using <see cref="F:yWorks.Graph.AdjacencyTypes.Outgoing" />.</para>
        <para>Note that even though edges can be accessed via index, the underlying graph structure in the default <see cref="T:yWorks.Graph.IGraph" /> implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in your own list, if possible. This is not necessary for the first or last element or when iterating over the outgoing edges via a <c>foreach</c> loop.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="port" />.</para>
      </param>
      <param name="port">
        <para>The owner of the edges.</para>
      </param>
      <returns>
        <para>An enumerable for the edges.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="port" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.AddRelativePort(yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Geometry.PointD)">
      <summary>
        <para>Adds a new port to the graph at the node using a location that is relative to the center of the node.</para>
      </summary>
      <remarks>
        <para>The port style for the newly-created port is taken from the graph's defaults. The location parameter is determined by delegating to <see cref="M:yWorks.Graph.GraphExtensions.AddPort(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner,yWorks.Geometry.PointD,yWorks.Graph.Styles.IPortStyle,System.Object)" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph to add the port to.</para>
      </param>
      <param name="node">
        <para>The owner of the port.</para>
      </param>
      <param name="relativeLocation">
        <para>The offset of the port relative to the center of the <see cref="P:yWorks.Graph.INode.Layout" />.</para>
      </param>
      <returns>
        <para>The newly added port instance.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="node" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.CreateNode(yWorks.Graph.IGraph,yWorks.Geometry.PointD,yWorks.Graph.Styles.INodeStyle,System.Object)">
      <summary>
        <para>Creates and returns a node using the specified initial center location and style, as well as the tag.</para>
      </summary>
      <remarks>
        <para>The node will be a part of this graph after the method returns. This will trigger the corresponding events.</para>
      </remarks>
      <param name="graph">
        <para>The graph to create the node in.</para>
      </param>
      <param name="location">
        <para>the initial coordinates of the center of the node's <see cref="P:yWorks.Graph.INode.Layout">Layout</see> property</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the newly created instance. This is done by reference.</para>
      </param>
      <param name="tag">
        <para>The initial value of the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> that will be assigned to the new node.</para>
      </param>
      <returns>
        <para>A newly created node instance</para>
      </returns>
      <seealso cref="E:yWorks.Graph.IGraph.NodeCreated" />
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.CreateDefaultPortLocationParameter(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner,System.Nullable{yWorks.Geometry.PointD})">
      <summary>
        <para>Creates a location model parameter for a newly created <see cref="T:yWorks.Graph.IPort" /> at the <paramref name="owner" /> that matches the <paramref name="location" />.</para>
      </summary>
      <remarks>
        <para>If <paramref name="location" /> is <c>null</c>, this method uses the <see cref="M:yWorks.Graph.GraphExtensions.GetPortDefaults(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">port defaults</see> for the <paramref name="owner" /> to obtain the <see cref="M:yWorks.Graph.IPortDefaults.GetLocationParameterInstance(yWorks.Graph.IPortOwner)">location parameter</see>.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="owner" />.</para>
      </param>
      <param name="owner">
        <para>The owner of the port.</para>
      </param>
      <param name="location">
        <para>The location in the world coordinate system where the port should be added.</para>
      </param>
      <returns>
        <para>Either a location model parameter that matches the location, or the default parameter to use for the <see cref="T:yWorks.Graph.IPortOwner" /> as returned by <see cref="M:yWorks.Graph.IPortDefaults.GetLocationParameterInstance(yWorks.Graph.IPortOwner)" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.PortLocationModels.IPortLocationModel.CreateParameter(yWorks.Graph.IPortOwner,yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Graph.GraphExtensions.GetPortDefaults(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)" />
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.CreateDefaultLabelLayoutParameter(yWorks.Graph.IGraph,yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Creates the label layout parameter for a given <see cref="T:yWorks.Graph.ILabelOwner" />.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:yWorks.Graph.GraphExtensions.GetLabelDefaults(yWorks.Graph.IGraph,yWorks.Graph.ILabelOwner)">label defaults</see> for the <paramref name="graph" /> to <see cref="M:yWorks.Graph.ILabelDefaults.GetLayoutParameterInstance(yWorks.Graph.ILabelOwner)">obtain the parameter instance</see>.</para>
      </remarks>
      <param name="graph">
        <para>The graph that contains <paramref name="owner" />.</para>
      </param>
      <param name="owner">
        <para>The item that is the <see cref="P:yWorks.Graph.ILabel.Owner" /> of the label in question.</para>
      </param>
      <returns>
        <para>The default label layout parameter to use for newly created labels at the item.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILabelDefaults.GetLayoutParameterInstance(yWorks.Graph.ILabelOwner)" />
      <seealso cref="M:yWorks.Graph.GraphExtensions.GetLabelDefaults(yWorks.Graph.IGraph,yWorks.Graph.ILabelOwner)" />
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetLabelDefaults(yWorks.Graph.IGraph,yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.ILabelDefaults">label defaults</see> for a given <see cref="T:yWorks.Graph.ILabelOwner" /> in the context of the <paramref name="graph" />.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains <paramref name="owner" />.</para>
      </param>
      <param name="owner">
        <para>The item that the label defaults are returned for. If this is a group node, the <see cref="P:yWorks.Graph.IGraph.GroupNodeDefaults" />'s <see cref="P:yWorks.Graph.INodeDefaults.Labels">label defaults</see> will be returned, otherwise the <see cref="P:yWorks.Graph.IGraph.NodeDefaults" /> or <see cref="P:yWorks.Graph.IGraph.EdgeDefaults" /> <see cref="P:yWorks.Graph.INodeDefaults.Labels">labels</see> will be returned.</para>
      </param>
      <returns>
        <para>Appropriate <see cref="T:yWorks.Graph.ILabelDefaults" /> for the provided <paramref name="owner" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetPortDefaults(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.IPortDefaults">port defaults</see> for a given <see cref="T:yWorks.Graph.IPortOwner" /> in the context of the <paramref name="graph" />.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains <paramref name="owner" />.</para>
      </param>
      <param name="owner">
        <para>The item that the label defaults are returned for. If this is a group node, the <see cref="P:yWorks.Graph.IGraph.GroupNodeDefaults" />'s <see cref="P:yWorks.Graph.INodeDefaults.Ports">port defaults</see> will be returned, otherwise the <see cref="P:yWorks.Graph.IGraph.NodeDefaults" /> or <see cref="P:yWorks.Graph.IGraph.EdgeDefaults" /> <see cref="P:yWorks.Graph.INodeDefaults.Ports">ports</see> will be returned.</para>
      </param>
      <returns>
        <para>Appropriate <see cref="T:yWorks.Graph.IPortDefaults" /> for the provided <paramref name="owner" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetFoldingView(yWorks.Graph.IGraph)">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.IFoldingView">folding view</see> instance associated with this <see cref="T:yWorks.Graph.IGraph" /> or <c>null</c> if none is associated with it.</para>
      </summary>
      <remarks>
        <para>This convenience method uses the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the <see cref="T:yWorks.Graph.IGraph" /> to obtain the <see cref="T:yWorks.Graph.IFoldingView" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph to look up the <see cref="T:yWorks.Graph.IFoldingView" /> instance on.</para>
      </param>
      <returns>
        <para>The implementation of the <see cref="T:yWorks.Graph.IFoldingView" /> or <c>null</c> if the graph has not been created by a <see cref="T:yWorks.Graph.FoldingManager" />.</para>
      </returns>
      <seealso cref="T:yWorks.Graph.FoldingManager" />
      <seealso cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})" />
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetUndoEngine(yWorks.Graph.IGraph)">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.UndoEngine" /> instance associated with this <see cref="T:yWorks.Graph.IGraph" /> or <c>null</c> if none is associated with it.</para>
      </summary>
      <remarks>
        <para>This convenience method uses the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the <see cref="T:yWorks.Graph.IGraph" /> to obtain the <see cref="T:yWorks.Graph.UndoEngine" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph to look up the <see cref="T:yWorks.Graph.UndoEngine" /> from.</para>
      </param>
      <returns>
        <para>The implementation of the <see cref="T:yWorks.Graph.UndoEngine" /> or <c>null</c> if <see cref="P:yWorks.Graph.DefaultGraph.UndoEngineEnabled">undo is not supported</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.IsUndoEngineEnabled(yWorks.Graph.IGraph)">
      <summary>
        <para>Checks whether undo capabilities are enabled for this graph.</para>
      </summary>
      <param name="graph">
        <para>The graph to check undo capabilities for.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.SetUndoEngineEnabled(yWorks.Graph.IGraph,System.Boolean)">
      <summary>
        <para>Enables or disables undo capabilities for this graph.</para>
      </summary>
      <remarks>
        <para>If undo support is set to <c>true</c>, an instance of <see cref="T:yWorks.Graph.UndoEngine" /> can be queried from this graph's <see cref="T:System.Linq.Lookup`2" /> method.</para>
      </remarks>
      <param name="graph" />
      <param name="enabled" />
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetBends(yWorks.Graph.IGraph)">
      <summary>
        <para>Gets a live view of all bends contained in this <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <param name="graph">
        <para>The graph to obtain all bends from.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetEdgeLabels(yWorks.Graph.IGraph)">
      <summary>
        <para>Gets a live view of all edge labels contained in this <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <param name="graph">
        <para>The graph to obtain all edge labels from.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.GetNodeLabels(yWorks.Graph.IGraph)">
      <summary>
        <para>Gets a live view of all node labels contained in this <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <param name="graph">
        <para>The graph to obtain all node labels from.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphExtensions.SetDpiScale(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Sets the <see cref="P:yWorks.Controls.CanvasControl.Scale" /> property to a value that ensures proper scaling with the current display DPI value.</para>
      </summary>
      <remarks>
        <para>E.g. when the user has DPI scaling in Windows set to 150 % (144 dpi), then the <see cref="T:yWorks.Controls.CanvasControl" />'s <see cref="P:yWorks.Controls.CanvasControl.Scale" /> will be set to 1.5. 96 dpi correspond to a scaling factor of 1.</para>
      </remarks>
      <param name="canvasControl">
        <para>The canvas control to configure for the current display DPI.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.GraphModelManager">
      <summary>
        <para>Manages the visual appearance of an <see cref="T:yWorks.Graph.IGraph" /> instance in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>This class monitors the structural changes of an <see cref="T:yWorks.Graph.IGraph" /> implementation and installs the necessary <see cref="T:yWorks.Controls.ICanvasObject" /> instance in the canvas for each item in the graph. Note that <see cref="T:yWorks.Controls.GraphControl" /> has an instance of this type built-in already and usually it is not necessary to create an own one. This class will also <see cref="P:yWorks.Controls.GraphModelManager.UseHierarchicNodeNesting">use the node hierarchy</see> to nest the nodes <see cref="P:yWorks.Controls.GraphModelManager.UseHierarchicEdgeNesting">and edges</see> accordingly.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphModelManager.NodeGroup" />
      <seealso cref="P:yWorks.Controls.GraphModelManager.UseHierarchicEdgeNesting" />
      <seealso cref="P:yWorks.Controls.GraphModelManager.UseHierarchicNodeNesting" />
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.#ctor(yWorks.Controls.CanvasControl)">
      <summary>
        <para>Creates a manager instance for the given control.</para>
      </summary>
      <remarks>
        <para>The contents of the graph will be added to a newly created group that is added to the root of the scene graph.</para>
        <para>In order to get anything useful out of this instance the <see cref="P:yWorks.Controls.GraphModelManager.Graph" /> property should be set to an instance after construction.</para>
      </remarks>
      <param name="canvas">
        <para>the canvas to manage the visual appearance of a graph for.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.#ctor(yWorks.Controls.CanvasControl,yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Creates a manager instance for the given control.</para>
      </summary>
      <remarks>
        <para>The contents of the graph will be added to given group that is must be part of the canvas.</para>
        <para>In order to get anything useful out of this instance the <see cref="P:yWorks.Controls.GraphModelManager.Graph" /> property should be set to an instance after construction.</para>
      </remarks>
      <param name="canvas">
        <para>the canvas to manage the visual appearance of a graph for.</para>
      </param>
      <param name="contentGroup">
        <para>the group to add the graph's visual content to. Can be null, in which case <see cref="P:yWorks.Controls.GraphModelManager.ContentGroup" /> should be set afterwards or <see cref="M:yWorks.Controls.GraphModelManager.CreateContentGroup" /> will automatically create a group lazily.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.Update(yWorks.Graph.IModelItem)">
      <summary>
        <para>
          <see cref="M:yWorks.Controls.CollectionModelManager`1.Update(`0)">Updates</see> the visual representation of the given item.</para>
      </summary>
      <param name="item">
        <para>The item to update the visual representation</para>
      </param>
      <seealso cref="M:yWorks.Controls.CollectionModelManager`1.Update(`0)" />
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.NodeGroup">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> instance that will be used for installing node styles.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphModelManager.CreateNodeGroup" /> will be called. Note that in the case of <see cref="P:yWorks.Controls.GraphModelManager.UseHierarchicNodeNesting">hierarchic node nesting</see>, nodes will not be installed at the top-level of this group. Rather a more complicated nesting of dynamically created <see cref="T:yWorks.Controls.ICanvasObjectGroup" />s will be used.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.GraphModelManager.GetCanvasObjectGroup(yWorks.Graph.INode)" />
      <seealso cref="P:yWorks.Controls.GraphModelManager.NodeDescriptor" />
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.CreateNodeGroup">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.GraphModelManager.NodeGroup" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the property.</para>
      </remarks>
      <returns>
        <para>a new group that has been added to the <see cref="P:yWorks.Controls.GraphModelManager.ContentGroup" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.EdgeGroup">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> instance that will be used for installing edge styles.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphModelManager.CreateEdgeGroup" /> will be called. Note that in the case of <see cref="P:yWorks.Controls.GraphModelManager.UseHierarchicNodeNesting">hierarchically nested graphs</see> edges will only be put directly in this <see cref="T:yWorks.Controls.ICanvasObjectGroup" />, if the <see cref="P:yWorks.Controls.GraphModelManager.UseHierarchicEdgeNesting" /> property is set to <c>false</c>. Otherwise edges will actually be nested in the subtree of the <see cref="P:yWorks.Controls.GraphModelManager.NodeGroup" /> according to the node nesting.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.GraphModelManager.GetCanvasObjectGroup(yWorks.Graph.IEdge)" />
      <seealso cref="P:yWorks.Controls.GraphModelManager.EdgeDescriptor" />
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.CreateEdgeGroup">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.GraphModelManager.EdgeGroup" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the property.</para>
      </remarks>
      <returns>
        <para>a new group that has been added to the <see cref="P:yWorks.Controls.GraphModelManager.ContentGroup" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.EdgeLabelGroup">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> instance that will be used for installing edge label styles.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphModelManager.CreateEdgeLabelGroup" /> will be called.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.GraphModelManager.GetCanvasObjectGroup(yWorks.Graph.ILabel)" />
      <seealso cref="P:yWorks.Controls.GraphModelManager.EdgeLabelDescriptor" />
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.CreateEdgeLabelGroup">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.GraphModelManager.EdgeLabelGroup" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the property.</para>
      </remarks>
      <returns>
        <para>a new group that has been added to the <see cref="P:yWorks.Controls.GraphModelManager.ContentGroup" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.NodeLabelGroup">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> instance that will be used for installing node label styles.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphModelManager.CreateNodeLabelGroup" /> will be called.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.GraphModelManager.GetCanvasObjectGroup(yWorks.Graph.ILabel)" />
      <seealso cref="P:yWorks.Controls.GraphModelManager.NodeLabelDescriptor" />
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.CreateNodeLabelGroup">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.GraphModelManager.NodeLabelGroup" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the property.</para>
      </remarks>
      <returns>
        <para>a new group that has been added to the <see cref="P:yWorks.Controls.GraphModelManager.ContentGroup" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.PortGroup">
      <summary>
        <para>Gets the <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> instance that will be used for installing port styles.</para>
      </summary>
      <remarks>
        <para>If the field has not yet been initialized upon first access, the factory method <see cref="M:yWorks.Controls.GraphModelManager.CreatePortGroup" /> will be called.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.GraphModelManager.GetCanvasObjectGroup(yWorks.Graph.IPort)" />
      <seealso cref="P:yWorks.Controls.GraphModelManager.PortDescriptor" />
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.CreatePortGroup">
      <summary>
        <para>Factory method for the <see cref="P:yWorks.Controls.GraphModelManager.PortGroup" /> property.</para>
      </summary>
      <remarks>
        <para>This method will be called upon first access to the property.</para>
      </remarks>
      <returns>
        <para>a new group that has been added to the <see cref="P:yWorks.Controls.GraphModelManager.ContentGroup" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.EdgeDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> instance used for installing an <see cref="T:yWorks.Graph.IEdge" /> into the canvas.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.PortDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> instance used for installing an <see cref="T:yWorks.Graph.IPort" /> into the canvas.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.EdgeLabelDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> instance used for installing an <see cref="T:yWorks.Graph.ILabel" /> of an <see cref="T:yWorks.Graph.IEdge" /> into the canvas.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.NodeLabelDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> instance used for installing an <see cref="T:yWorks.Graph.ILabel" /> of an <see cref="T:yWorks.Graph.INode" /> into the canvas.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.UseHierarchicEdgeNesting">
      <summary>
        <para>Gets or sets whether this instance should nest the edges accordingly if the graph is grouped.</para>
      </summary>
      <remarks>
        <para>Hierarchic nesting for edges requires that <see cref="P:yWorks.Controls.GraphModelManager.UseHierarchicNodeNesting">hierarchic nesting for nodes</see> is enabled as well. If both properties are enabled (the default) the edges will actually be interleaved with the nodes in the nested canvas object subtree so the <see cref="P:yWorks.Controls.GraphModelManager.EdgeGroup" /> will be empty.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.GraphModelManager.UseHierarchicNodeNesting" />
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.NodeDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> instance used for installing an <see cref="T:yWorks.Graph.INode" /> into the canvas.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.ContentGroup">
      <summary>
        <para>Gets or sets the content group this manager instance uses to add visual representation of the graph to.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.CreateContentGroup">
      <summary>
        <para>Factory method that creates the <see cref="P:yWorks.Controls.GraphModelManager.ContentGroup" /></para>
      </summary>
      <remarks>
        <para>The default implementation will just add another group to the <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </remarks>
      <returns>
        <para>The group to use for adding the content.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.Comparer">
      <summary>
        <para>Gets an <see cref="T:System.Collections.Generic.IComparer`1" /> instance that can be used to compare two model items with respect to their visual display order.</para>
      </summary>
      <remarks>
        <para>An item is considered to be greater than another item if it is rendered on top of it.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.HitTester">
      <summary>
        <para>Gets a <see cref="T:yWorks.Controls.Input.IHitTester`1" /> that can be used to enumerate hits on the canvas at a given world coordinate position.</para>
      </summary>
      <remarks>
        <para>This enumerator will enumerate hits in the order so that the visually topmost element will be reported first.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.CreateHitTester``1">
      <summary>
        <para>Gets a <see cref="T:yWorks.Controls.Input.IHitTester`1" /> that can be used to enumerate hits on the canvas at a given world coordinate position.</para>
      </summary>
      <remarks>
        <para>This enumerator will enumerate hits in the order so that the visually topmost element will be reported first.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.Compare(yWorks.Graph.IModelItem,yWorks.Graph.IModelItem)">
      <summary>
        <para>Compares two items with respect to their visibility order.</para>
      </summary>
      <param name="item1">
        <para>the first item to compare</para>
      </param>
      <param name="item2">
        <para>the second item to compare</para>
      </param>
      <returns>
        <para>an integer value indicating the relative painting order of the two items</para>
      </returns>
      <seealso cref="P:yWorks.Controls.GraphModelManager.Comparer" />
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.GetCanvasObject(yWorks.Graph.IModelItem)">
      <summary>
        <para>Retrieves the <see cref="T:yWorks.Controls.ICanvasObject" /> for a given model item managed by this instance.</para>
      </summary>
      <param name="item">
        <para>the item</para>
      </param>
      <returns>
        <para>the canvas object for the given item or <c>null</c></para>
      </returns>
      <seealso cref="M:yWorks.Controls.ItemModelManager`1.GetCanvasObject(`0)" />
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.HitElementsAt(yWorks.Geometry.PointD)">
      <summary>
        <para>Enumerates hits on the canvas at a given world coordinate position.</para>
      </summary>
      <remarks>
        <para>The instance returned will enumerate hits in the order so that the topmost visual element will be reported first. The enumeration is performed lazily.</para>
      </remarks>
      <param name="location">
        <para>the world coordinates to perform the hit test</para>
      </param>
      <returns>
        <para>an enumerable that will enumerate the hits at the given coordinates</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.HitElementsAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Enumerates hits on the canvas at a given world coordinate position for a given context.</para>
      </summary>
      <remarks>
        <para>The instance returned will enumerate hits in the order so that the topmost visual element will be reported first. The enumeration is performed lazily.</para>
      </remarks>
      <param name="context">
        <para>The context to provide to <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /></para>
      </param>
      <param name="location">
        <para>the world coordinates to perform the hit test</para>
      </param>
      <param name="root">
        <para>The group to search the subtree of.</para>
      </param>
      <returns>
        <para>an enumerable that will enumerate the hits at the given coordinates</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.TypedHitElementsAt``1(yWorks.Geometry.PointD)">
      <summary>
        <para>Enumerates hits on the canvas at a given world coordinate position.</para>
      </summary>
      <remarks>
        <para>The instance returned will enumerate hits in the order so that the topmost visual element will be reported first. The enumeration is performed lazily.</para>
      </remarks>
      <param name="location">
        <para>the world coordinates to perform the hit test</para>
      </param>
      <returns>
        <para>an enumerable that will enumerate the hits at the given coordinates</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.TypedHitElementsAt``1(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Controls.ICanvasObjectGroup)">
      <summary>
        <para>Enumerates hits on the canvas at a given world coordinate position in a given context.</para>
      </summary>
      <remarks>
        <para>The instance returned will enumerate hits in the order so that the topmost visual element will be reported first. The enumeration is performed lazily.</para>
      </remarks>
      <param name="context">
        <para>The context to provide to <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /></para>
      </param>
      <param name="location">
        <para>the world coordinates to perform the hit test</para>
      </param>
      <param name="root">
        <para>The group to search the subtree of.</para>
      </param>
      <returns>
        <para>an enumerable that will enumerate the hits at the given coordinates</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.GetModelItem(yWorks.Controls.ICanvasObject)">
      <summary>
        <para>Retrieves the corresponding <see cref="T:yWorks.Graph.IModelItem" /> for the given canvas object.</para>
      </summary>
      <param name="canvasObject">
        <para>the instance to use for the query</para>
      </param>
      <returns>
        <para>The item that is associated with the object or <c>null</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.Graph">
      <summary>
        <para>Gets or sets the graph this manager manages.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.GraphModelManager.OnGraphChanged(yWorks.Graph.IGraph,yWorks.Graph.IGraph)" />
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.OnGraphChanged(yWorks.Graph.IGraph,yWorks.Graph.IGraph)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Controls.GraphModelManager.Graph" /> property changes.</para>
      </summary>
      <remarks>
        <para>This method registers the collections of the graph instance with the <see cref="T:yWorks.Controls.CollectionModelManager`1">mechanism</see> that manages the mapping between the elements and the <see cref="T:yWorks.Controls.ICanvasObject" />s. Subclasses should call the base method if they want to use the default mechanisms.</para>
      </remarks>
      <param name="oldGraph">
        <para>The old graph instance.</para>
      </param>
      <param name="newGraph">
        <para>The new graph instance.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.GraphModelManager.UseHierarchicNodeNesting">
      <summary>
        <para>Gets or sets whether this instance should nest the nodes <see cref="P:yWorks.Controls.GraphModelManager.UseHierarchicEdgeNesting">and optionally edges</see> accordingly if the graph is grouped.</para>
      </summary>
      <value>
        <para>
          <c>true</c> (the default) iff the hierarchy should be queried.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.GetCanvasObjectGroup(yWorks.Graph.INode)">
      <summary>
        <para>Retrieves the Canvas Object group to use for the given node.</para>
      </summary>
      <remarks>
        <para>This implementation is called by the default <see cref="P:yWorks.Controls.GraphModelManager.NodeDescriptor" /> instance.</para>
      </remarks>
      <param name="node">
        <para>The node that will be installed in the canvas.</para>
      </param>
      <returns>
        <para>The group to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.GetCanvasObjectGroup(yWorks.Graph.IEdge)">
      <summary>
        <para>Retrieves the Canvas Object group to use for the given edge.</para>
      </summary>
      <remarks>
        <para>This implementation is called by the default <see cref="P:yWorks.Controls.GraphModelManager.EdgeDescriptor" /> instance.</para>
      </remarks>
      <param name="edge">
        <para>The edge that will be installed in the canvas.</para>
      </param>
      <returns>
        <para>The group to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.GetCanvasObjectGroup(yWorks.Graph.IPort)">
      <summary>
        <para>Retrieves the Canvas Object group to use for the given port.</para>
      </summary>
      <remarks>
        <para>This implementation is called by the default <see cref="P:yWorks.Controls.GraphModelManager.PortDescriptor" /> instance.</para>
      </remarks>
      <param name="port">
        <para>The port that will be installed in the canvas.</para>
      </param>
      <returns>
        <para>The group to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphModelManager.GetCanvasObjectGroup(yWorks.Graph.ILabel)">
      <summary>
        <para>Retrieves the Canvas Object group to use for the given label.</para>
      </summary>
      <remarks>
        <para>This implementation is called by the default <see cref="P:yWorks.Controls.GraphModelManager.NodeLabelDescriptor" /> and <see cref="P:yWorks.Controls.GraphModelManager.EdgeLabelDescriptor" /> instances.</para>
      </remarks>
      <param name="label">
        <para>The label that will be installed in the canvas.</para>
      </param>
      <returns>
        <para>The group to use.</para>
      </returns>
    </member>
    <member name="F:yWorks.Controls.GraphModelManager.DefaultNodeDescriptor">
      <summary>
        <para>The immutable instance of the default <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> for <see cref="T:yWorks.Graph.INode" />s which simply defers to the node's <see cref="T:yWorks.Graph.Styles.INodeStyle" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.GraphModelManager.DefaultEdgeDescriptor">
      <summary>
        <para>The immutable instance of the default <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> for <see cref="T:yWorks.Graph.IEdge" />s which simply defers to the edge's <see cref="T:yWorks.Graph.Styles.IEdgeStyle" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.GraphModelManager.DefaultPortDescriptor">
      <summary>
        <para>The immutable instance of the default <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> for <see cref="T:yWorks.Graph.IPort" />s which simply defers to the port's <see cref="T:yWorks.Graph.Styles.IPortStyle" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.GraphModelManager.DefaultLabelDescriptor">
      <summary>
        <para>The immutable instance of the default <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> for <see cref="T:yWorks.Graph.ILabel" />s which simply defers to the label's <see cref="T:yWorks.Graph.Styles.ILabelStyle" />.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.GraphObstacleProvider">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.Controls.IObstacleProvider" /> interface that uses the <see cref="P:yWorks.Graph.IGraph.Edges">edges</see> and <see cref="P:yWorks.Graph.IGraph.Nodes">nodes</see> of an <see cref="T:yWorks.Graph.IGraph" /> as obstacles.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Controls.BridgeManager" /> then calculates bridges for edge paths that cross these obstacles.</para>
        <para>This class can be used to add bridge support via the <see cref="T:yWorks.Controls.BridgeManager" /> to a rendered <see cref="T:yWorks.Graph.IGraph" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.BridgeManager.AddObstacleProvider(yWorks.Controls.IObstacleProvider)" />
      <seealso cref="T:yWorks.Controls.BridgeManager" />
      <seealso cref="T:yWorks.Controls.IObstacleProvider" />
    </member>
    <member name="P:yWorks.Controls.GraphObstacleProvider.QueryEdges">
      <summary>
        <para>Gets or sets a value indicating whether to query the <see cref="P:yWorks.Graph.IGraph.Edges" /> for an <see cref="T:yWorks.Controls.IObstacleProvider" /> implementation.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.GraphObstacleProvider.QueryNodes">
      <summary>
        <para>Gets or sets a value indicating whether to query the <see cref="P:yWorks.Graph.IGraph.Nodes" /> for an <see cref="T:yWorks.Controls.IObstacleProvider" /> implementation.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if nodes should be queried at all; <c>false</c> otherwise. The default is <c>false</c>.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.GraphObstacleProvider.GetObstacles(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Iterates over all <see cref="P:yWorks.Graph.IGraph.Edges" /> and <see cref="P:yWorks.Graph.IGraph.Nodes" /> to query an <see cref="T:yWorks.Controls.IObstacleProvider" /> from the <see cref="T:yWorks.Graph.IModelItem" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />.</para>
      </summary>
      <remarks>
        <para>This method will depending on the <see cref="P:yWorks.Controls.GraphObstacleProvider.QueryEdges" /> and <see cref="P:yWorks.Controls.GraphObstacleProvider.QueryNodes" /> property query the items for an implementation of <see cref="T:yWorks.Controls.IObstacleProvider" /> and concatenate all resulting <see cref="T:yWorks.Geometry.GeneralPath" /> obstacles into one path that will then be returned.</para>
      </remarks>
      <param name="context">
        <para>The context where the obstacles are queried for.</para>
      </param>
      <returns>
        <para>A path that is the concatenated path of all obstacles for the given context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphObstacleProvider.GetGraph(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Helper method that retrieves the <see cref="T:yWorks.Graph.IGraph" /> to use from the <paramref name="context" /></para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the <see cref="P:yWorks.Controls.ICanvasContext.CanvasControl" /> to query the <see cref="T:yWorks.Graph.IGraph" /> implementation.</para>
      </remarks>
      <param name="context">
        <para>The context to retrieve the implementation from.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.IGraph" /> instance to query or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.GraphSelection">
      <summary>
        <para>Simple implementation of the <see cref="T:yWorks.Controls.IGraphSelection" /> interface.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphSelection.#ctor">
      <summary>
        <para>Creates a new instance with no initial <see cref="P:yWorks.Controls.GraphSelection.Graph" /> assigned.</para>
      </summary>
      <remarks>
        <para>In order to be always in sync with the structural changes in a graph, an instance should be associated with an <see cref="T:yWorks.Graph.IGraph" /> using the <see cref="P:yWorks.Controls.GraphSelection.Graph" /> property.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.GraphSelection.#ctor(yWorks.Graph.IGraph)">
      <summary>
        <para>Instantiates an instance using the the graph as the model.</para>
      </summary>
      <param name="graph" />
    </member>
    <member name="M:yWorks.Controls.GraphSelection.OnItemSelectionChanged(yWorks.Controls.ItemSelectionChangedEventArgs{yWorks.Graph.IModelItem})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.GraphSelection.ItemSelectionChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.GraphSelection.CreatePortSelectionModel">
      <summary>
        <para>Factory method that creates the <see cref="T:yWorks.Controls.DefaultSelectionModel`1" /> to use for the ports.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphSelection.CreateBendSelectionModel">
      <summary>
        <para>Factory method that creates the <see cref="T:yWorks.Controls.DefaultSelectionModel`1" /> to use for the bends.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphSelection.CreateLabelSelectionModel">
      <summary>
        <para>Factory method that creates the <see cref="T:yWorks.Controls.DefaultSelectionModel`1" /> to use for the labels.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphSelection.CreateNodeSelectionModel">
      <summary>
        <para>Factory method that creates the <see cref="T:yWorks.Controls.DefaultSelectionModel`1" /> to use for the nodes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphSelection.CreateEdgeSelectionModel">
      <summary>
        <para>Factory method that creates the <see cref="T:yWorks.Controls.DefaultSelectionModel`1" /> to use for the edges.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphSelection.IsSelected(yWorks.Graph.IModelItem)">
      <param name="item" />
    </member>
    <member name="M:yWorks.Controls.GraphSelection.SetSelected(yWorks.Graph.IModelItem,System.Boolean)">
      <param name="item" />
      <param name="selected" />
    </member>
    <member name="P:yWorks.Controls.GraphSelection.Graph">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.IGraph" /> this instance is using as the domain for the selection.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.GraphSelection.GetEnumerator">
      <summary>
        <para>Returns an enumerator that iterates through the collection of all selected elements.</para>
      </summary>
      <returns>
        <para>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through all selected elements.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.GraphSelection.Clear" />
    <member name="T:yWorks.Graph.GraphWrapperBase">
      <summary>
        <para>An abstract <see cref="T:yWorks.Graph.IGraph" /> implementation that delegates all of its work to an existing implementation.</para>
      </summary>
      <remarks>
        <para>Subclasses can override all of the methods to customize the behavior of this instance. Note that this instance will register listeners with the wrapped graph instance, so <see cref="M:yWorks.Graph.GraphWrapperBase.Dispose" /> should be called if this instance is not used any more.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.#ctor(yWorks.Graph.IGraph)">
      <summary>
        <para>Creates a new instance that wraps a given <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <remarks>
        <para>Note that this instance will <see cref="M:yWorks.Graph.GraphWrapperBase.AddEventHandlers(yWorks.Graph.IGraph)">register listeners</see> with the <paramref name="graph" />, so <see cref="M:yWorks.Graph.GraphWrapperBase.Dispose" /> should be called if this instance is not used any more.</para>
      </remarks>
      <param name="graph">
        <para>The graph to wrap.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.Dispose" />
    <member name="P:yWorks.Graph.GraphWrapperBase.WrappedGraph">
      <summary>
        <para>Gets the graph that has been wrapped by this instance.</para>
      </summary>
      <value>
        <para>The graph this instance is decorating.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnGraphChanged(yWorks.Graph.IGraph,yWorks.Graph.IGraph)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Graph.GraphWrapperBase.WrappedGraph" /> property value changes and after initialization of the field.</para>
      </summary>
      <remarks>
        <para>Delegates to <see cref="M:yWorks.Graph.GraphWrapperBase.AddEventHandlers(yWorks.Graph.IGraph)" /> for <paramref name="newGraph" /> and to <see cref="M:yWorks.Graph.GraphWrapperBase.RemoveEventHandlers(yWorks.Graph.IGraph)" /> for <paramref name="oldGraph" />.</para>
      </remarks>
      <param name="oldGraph">
        <para>the old value, which may be <c>null</c> the first time</para>
      </param>
      <param name="newGraph">
        <para>the new value</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.AddEventHandlers(yWorks.Graph.IGraph)">
      <summary>
        <para>Adds event handlers that propagate graph events from <paramref name="graph" /> to listeners on this instance.</para>
      </summary>
      <param name="graph">
        <para>The graph for which event propagators should be created</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.RemoveEventHandlers(yWorks.Graph.IGraph)">
      <summary>
        <para>Removes event handlers for <paramref name="graph" /> that have been added with <see cref="M:yWorks.Graph.GraphWrapperBase.AddEventHandlers(yWorks.Graph.IGraph)" />.</para>
      </summary>
      <param name="graph">
        <para>The graph for which event propagators should be removed</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.InvalidateDisplays" />
    <member name="M:yWorks.Graph.GraphWrapperBase.CreateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort,yWorks.Graph.Styles.IEdgeStyle,System.Object)">
      <param name="sourcePort" />
      <param name="targetPort" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.CreateEdge(yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Graph.Styles.IEdgeStyle,System.Object)">
      <param name="source" />
      <param name="target" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.Remove(yWorks.Graph.IModelItem)">
      <param name="item" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetEdgePorts(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <param name="edge" />
      <param name="sourcePort" />
      <param name="targetPort" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)">
      <param name="port" />
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.EdgesAt(yWorks.Graph.IPortOwner,yWorks.Graph.AdjacencyTypes)">
      <param name="owner" />
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetStyle(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <param name="label" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetStyle(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <param name="edge" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetStyle(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <param name="port" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.Contains(yWorks.Graph.IModelItem)">
      <param name="item" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.AddBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD,System.Int32)">
      <param name="edge" />
      <param name="location" />
      <param name="index" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.AddPort(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)">
      <param name="owner" />
      <param name="locationParameter" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.AddLabel(yWorks.Graph.ILabelOwner,System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,System.Nullable{yWorks.Geometry.SizeD},System.Object)">
      <param name="owner" />
      <param name="text" />
      <param name="layoutParameter" />
      <param name="style" />
      <param name="preferredSize" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetLabelText(yWorks.Graph.ILabel,System.String)">
      <param name="label" />
      <param name="text" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetBendLocation(yWorks.Graph.IBend,yWorks.Geometry.PointD)">
      <param name="bend" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetLabelPreferredSize(yWorks.Graph.ILabel,yWorks.Geometry.SizeD)">
      <param name="label" />
      <param name="preferredSize" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetLabelLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetPortLocationParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="port" />
      <param name="locationParameter" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetNodeLayout(yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <param name="node" />
      <param name="layout" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetLookup(yWorks.Graph.ILookup)">
      <summary>
        <para>Sets the lookup instance to use in <see cref="M:yWorks.Graph.GraphWrapperBase.Lookup(System.Type)" /></para>
      </summary>
      <param name="lookup" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.GetLookup">
      <summary>
        <para>Gets the lookup instance to use in <see cref="M:yWorks.Graph.GraphWrapperBase.Lookup(System.Type)" /></para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.CreateNode(yWorks.Geometry.RectD,yWorks.Graph.Styles.INodeStyle,System.Object)">
      <param name="layout" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.CreateGroupNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">
      <param name="parent" />
      <param name="layout" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetParent(yWorks.Graph.INode,yWorks.Graph.INode)">
      <param name="node" />
      <param name="parent" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.CreateNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">
      <param name="parent" />
      <param name="layout" />
      <param name="style" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.GetChildren(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.GetParent(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.IsGroupNode(yWorks.Graph.INode)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.SetIsGroupNode(yWorks.Graph.INode,System.Boolean)">
      <param name="node" />
      <param name="isGroupNode" />
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnIsGroupNodeChanged(yWorks.Graph.NodeEventArgs)">
      <summary>
        <para>Dispatches the <see cref="E:yWorks.Graph.GraphWrapperBase.IsGroupNodeChanged" /> event.</para>
      </summary>
      <param name="args">
        <para>The event args to dispatch.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnParentChanged(yWorks.Graph.NodeEventArgs)">
      <summary>
        <para>Dispatches the <see cref="E:yWorks.Graph.GraphWrapperBase.ParentChanged" /> event.</para>
      </summary>
      <param name="args">
        <para>The event args to dispatch.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnGraphTagChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.IGraph,System.Object})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.GraphTagChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnBendAdded(yWorks.Utils.ItemEventArgs{yWorks.Graph.IBend})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.BendAdded" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnBendRemoved(yWorks.Graph.BendEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.BendRemoved" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnBendLocationChanged(yWorks.Graph.IBend,yWorks.Geometry.PointD)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.BendLocationChanged" /> event</para>
      </summary>
      <param name="bend">
        <para>The bend whose location changed</para>
      </param>
      <param name="oldLocation">
        <para>The bend location before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnBendTagChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.IBend,System.Object})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.BendTagChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnPortAdded(yWorks.Utils.ItemEventArgs{yWorks.Graph.IPort})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.PortAdded" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnPortRemoved(yWorks.Graph.PortEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.PortRemoved" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnLabelAdded(yWorks.Utils.ItemEventArgs{yWorks.Graph.ILabel})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.LabelAdded" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnLabelRemoved(yWorks.Graph.LabelEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.LabelRemoved" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnNodeRemoved(yWorks.Graph.NodeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.NodeRemoved" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnEdgeRemoved(yWorks.Graph.EdgeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.EdgeRemoved" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnNodeCreated(yWorks.Utils.ItemEventArgs{yWorks.Graph.INode})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.NodeCreated" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnEdgeStyleChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.EdgeStyleChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnEdgePortsChanged(yWorks.Graph.EdgeEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.EdgePortsChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnEdgeTagChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.IEdge,System.Object})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.EdgeTagChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnEdgeCreated(yWorks.Utils.ItemEventArgs{yWorks.Graph.IEdge})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.EdgeCreated" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnNodeStyleChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.NodeStyleChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnNodeLayoutChanged(yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.NodeLayoutChanged" /> event</para>
      </summary>
      <param name="node">
        <para>The node whose layout changed</para>
      </param>
      <param name="oldLayout">
        <para>The node layout before the change</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnNodeTagChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.INode,System.Object})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.NodeTagChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnPortStyleChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.PortStyleChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnPortLocationParameterChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.PortLocationParameterChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnPortTagChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.IPort,System.Object})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.PortTagChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnLabelStyleChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.LabelStyleChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnLabelTextChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.ILabel,System.String})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.LabelTextChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnLabelLayoutParameterChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.LabelLayoutParameterChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnLabelPreferredSizeChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.ILabel,yWorks.Geometry.SizeD})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.LabelPreferredSizeChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnLabelTagChanged(yWorks.Graph.ItemChangedEventArgs{yWorks.Graph.ILabel,System.Object})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.LabelTagChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphWrapperBase.OnInvalidateDisplays(System.EventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.GraphWrapperBase.DisplaysInvalidated" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.GroupingNodePositionHandler">
      <summary>
        <para>The <see cref="T:yWorks.Controls.Input.IPositionHandler" /> implementation used in the context of <see cref="T:yWorks.Graph.IGraph" />s where there is a <see cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)">active hierarchy</see>.</para>
      </summary>
      <remarks>
        <para>This implementation delegates through to a simpler implementation that only deals with the geometric relocation of the node. In addition to that it finds the <see cref="T:yWorks.Controls.Input.IReparentNodeHandler" /> from the <see cref="T:yWorks.Controls.Input.IInputModeContext" /> to detect <see cref="M:yWorks.Controls.Input.IReparentNodeHandler.IsReparentGesture(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode)">a reparenting gesture</see> by the user. If such a gesture is recognized, the node can be moved freely until a <see cref="M:yWorks.Controls.Input.IReparentNodeHandler.IsValidParent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Graph.INode)">valid new parent node</see> is found. This implementation then temporarily sets that node as a new visual parent and highlight the node. When the gesture is finished, the <see cref="M:yWorks.Controls.Input.IReparentNodeHandler.Reparent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Graph.INode)" /> method is called to perform the actual reparenting.</para>
        <para>In order to customize this default behavior, subclasses of this type can be <see cref="P:yWorks.Graph.NodeDecorator.PositionHandlerDecorator">decorated</see> to the <see cref="T:yWorks.Graph.INode" />s in the graph.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GroupingNodePositionHandler.#ctor(yWorks.Graph.INode,yWorks.Controls.Input.IPositionHandler)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.GroupingNodePositionHandler" /> class.</para>
      </summary>
      <remarks>
        <para>This implementation uses the provided <paramref name="wrappedHandler" /> to delegate the handling of the node's <see cref="P:yWorks.Graph.INode.Layout" /> changes.</para>
      </remarks>
      <param name="node">
        <para>The node to reposition.</para>
      </param>
      <param name="wrappedHandler">
        <para>The positionhandler to</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.GroupingNodePositionHandler.Location">
      <summary>
        <para>Gets a view of the location of the item.</para>
      </summary>
      <remarks>
        <para>Delegates to the wrapped <see cref="T:yWorks.Controls.Input.IPositionHandler" />'s <see cref="P:yWorks.Controls.Input.IDragHandler.Location">location</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.GroupingNodePositionHandler.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.GroupingNodePositionHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.GroupingNodePositionHandler.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.GroupingNodePositionHandler.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.GroupingNodePositionHandler.SetCurrentParent(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Sets a temporary visual parent for the node during reparenting.</para>
      </summary>
      <remarks>
        <para>This is used to show the grouping hierarchy level a node would end in after finishing the reparenting gesture. Override this method with an empty implementation to not change the z-order of the dragged node during the gesture.</para>
      </remarks>
      <param name="context">
        <para>The current <see cref="T:yWorks.Controls.Input.IInputModeContext" />.</para>
      </param>
      <param name="node">
        <para>The node being reparented.</para>
      </param>
      <param name="parent">
        <para>The temporary parent for the node.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.Styles.IArrow">
      <summary>
        <para>The interface for the visual representation of an arrow that is normally used to decorate the visual representation of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </summary>
      <remarks>
        <para>Instances of this class are used by <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> implementations.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.IArrow.Length">
      <summary>
        <para>Gets the length of the arrow (the distance from the arrow's tip to the position where the visual representation of the edge's path should begin).</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.IArrow.CropLength">
      <summary>
        <para>Gets the cropping length associated with this instance.</para>
      </summary>
      <remarks>
        <para>This value is used by <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> implementations to let the edge appear to end shortly before its actual target.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.IArrow.GetVisualCreator(yWorks.Graph.IEdge,System.Boolean,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.IVisualCreator" /> implementation that will paint this arrow at the given location using the given direction for the given edge.</para>
      </summary>
      <param name="edge">
        <para>the edge this arrow belongs to</para>
      </param>
      <param name="atSource">
        <para>whether this will be the source arrow</para>
      </param>
      <param name="anchor">
        <para>the anchor point for the tip of the arrow</para>
      </param>
      <param name="direction">
        <para>the direction the arrow is pointing in</para>
      </param>
      <returns>
        <para>an implementation of the <see cref="T:yWorks.Controls.IVisualCreator" /> interface that can subsequently be used to perform the actual painting. Clients will always call this method before using the implementation and may not cache the instance returned. This allows for applying the flyweight design pattern to implementations.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IArrow.GetBoundsProvider(yWorks.Graph.IEdge,System.Boolean,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.IBoundsProvider" /> implementation that can yield this arrow's bounds if painted at the given location using the given direction for the given edge.</para>
      </summary>
      <param name="edge">
        <para>the edge this arrow belongs to</para>
      </param>
      <param name="atSource">
        <para>whether this will be the source arrow</para>
      </param>
      <param name="anchor">
        <para>the anchor point for the tip of the arrow</para>
      </param>
      <param name="directionVector">
        <para>the direction the arrow is pointing in</para>
      </param>
      <returns>
        <para>an implementation of the <see cref="T:yWorks.Controls.IBoundsProvider" /> interface that can subsequently be used to query the bounds. Clients will always call this method before using the implementation and may not cache the instance returned. This allows for applying the flyweight design pattern to implementations.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.IBend">
      <summary>
        <para>The interface used in an <see cref="T:yWorks.Graph.IGraph" /> implementation to control the layout of <see cref="T:yWorks.Graph.IEdge">edges</see>.</para>
      </summary>
      <remarks>
        <para>This interface provides read-only access to the properties of a bend. In order to modify the state of an instance use the various methods provided by the <see cref="T:yWorks.Graph.IGraph" /> this instance belongs to. Bends are stored in <see cref="T:yWorks.Utils.IListEnumerable`1">IListEnumerable&lt;IBend&gt;</see>s, that can be obtained from the <see cref="T:yWorks.Graph.IEdge" /> implementation that owns this bend. Like all items in an <c>IGraph</c>, this item supports the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method that can be used to query additional aspects of the item.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IBend.Owner">
      <summary>
        <para>Gets the edge this bend instance belongs to.</para>
      </summary>
      <remarks>
        <para>This implies that <c>Owner.Bends</c> contains this instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IBend.Location">
      <summary>
        <para>Gets a view of the location of the bend in the world coordinate system.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Geometry.IPoint.X" /> and <see cref="P:yWorks.Geometry.IPoint.Y" /> properties describe the location of the bend in the world coordinate system. This property is a live view of the location and will be updated in the future if the location changes. To keep the current state of the location, callers need to create a copy of it</para>
      </remarks>
      <seealso cref="M:yWorks.Geometry.PointExtensions.ToPointD(yWorks.Geometry.IPoint)" />
    </member>
    <member name="T:yWorks.Controls.Input.IBendCreator">
      <summary>
        <para>Callback interface for instances that can create bends for a given edge and graph.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface may be found in the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of <see cref="T:yWorks.Graph.IEdge" /> instances. This interface is used by <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> to create new bends for an edge as soon as the user performs the bend creation gesture.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.GraphEditorInputMode.OnCreateBendInputModeBendCreated(System.Object,yWorks.Utils.ItemEventArgs{yWorks.Graph.IBend})" />
    </member>
    <member name="M:yWorks.Controls.Input.IBendCreator.CreateBend(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IGraph,yWorks.Graph.IEdge,yWorks.Geometry.PointD)">
      <summary>
        <para>Creates a bend at the given graph for the given edge at the position supplied.</para>
      </summary>
      <param name="context">
        <para>The context for which the bend should be created.</para>
      </param>
      <param name="graph">
        <para>The graph, the edge belongs to.</para>
      </param>
      <param name="edge">
        <para>The edge.</para>
      </param>
      <param name="location">
        <para>The preferred coordinates of the bend.</para>
      </param>
      <returns>
        <para>The index of the bend in the edges' <see cref="P:yWorks.Graph.IEdge.Bends" /> or <c>-1</c> if no bend has been created.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.IBendSelectionTester">
      <summary>
        <para>Interface that can be used to find bends at specific locations in the canvas.</para>
      </summary>
      <remarks>
        <para>This interface is usually provided through the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of <see cref="T:yWorks.Graph.IEdge" /> implementations.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IBendSelectionTester.GetHitBend(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Returns the bend at the given world coordinate position.</para>
      </summary>
      <param name="context">
        <para>The input mode context to use for querying the position.</para>
      </param>
      <param name="location">
        <para>A location in world coordinates.</para>
      </param>
      <returns>
        <para>The bend at the position or <c>null</c> if there is no bend.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IBendSelectionTester.GetBendsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Returns the bends within the given rectangle.</para>
      </summary>
      <param name="context">
        <para>The input mode context to use for querying the position.</para>
      </param>
      <param name="rectangle">
        <para>A rectangle in world coordinates.</para>
      </param>
      <returns>
        <para>The bends inside of <paramref name="rectangle" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.IContainsBendTester">
      <summary>
        <para>An interface that checks for containment of an <see cref="T:yWorks.Graph.IBend" /> in 2D coordinate space.</para>
      </summary>
      <remarks>
        <para>This interface is used to determine which bends of edges that connect child nodes are moved when the parent node is moved. Therefore, special care has to be taken if you want to provide this interface in the <b>node lookup</b> for other purposes, as this can also affect implicit bend movement.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IContainsBendTester.Contains(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IBend)">
      <summary>
        <para>Determines whether the provided <paramref name="bend" /> is deemed to lie within the shape this test is implemented for.</para>
      </summary>
      <remarks>
        <para>This method is used to determine which bends of edges that connect child nodes are moved when the parent node is moved. If an implementation of <see cref="T:yWorks.Controls.Input.IContainsBendTester" /> is present in the node's <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />, this method is called with the bend and the bend will be moved together with the parent node iff <c>true</c> is returned. If no implemention is provided, only bends that lie inside the bounds of the parent node are moved.</para>
      </remarks>
      <param name="context">
        <para>The input mode context to use.</para>
      </param>
      <param name="bend">
        <para>The bend to test</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff the bend is contained within the shape.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.IEdge">
      <summary>
        <para>The interface used to model edges in an <see cref="T:yWorks.Graph.IGraph" /> implementation.</para>
      </summary>
      <remarks>
        <para>This interface provides read-only access to the properties of an edge. In order to modify the state of an instance use the various methods provided by the <see cref="T:yWorks.Graph.IGraph" /> this instance belongs to. An edge connects to two ports and may consist of a number of bends. Also it can have zero or more labels. This interface combines the functionality of <see cref="T:yWorks.Graph.IPortOwner" /> to get access to the ports that edges can optionally have, <see cref="T:yWorks.Graph.ILabelOwner" /> to get access to the labels, and, like all items in an <c>IGraph</c>, edges support the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method inherited from the <see cref="T:yWorks.Graph.IModelItem" /> interface that can be used to query additional aspects of each instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IEdge.Bends">
      <summary>
        <para>Gets a collection of <see cref="T:yWorks.Graph.IBend">bends</see> that describe the geometry of this edge.</para>
      </summary>
      <remarks>
        <para>This gives access to a read-only live view of the bends, i.e. the collection can change over time, as well as the bends contained in it. If a snapshot of the current state is needed, one needs to copy the collection. In order to modify the bend collection of an edge, use the <see cref="M:yWorks.Graph.IGraph.AddBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD,System.Int32)">various methods</see> in <see cref="T:yWorks.Graph.IGraph" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IEdge.SourcePort">
      <summary>
        <para>Gets the source port instance this edge is connected to.</para>
      </summary>
      <remarks>
        <para>Although the notion of source and target port is used for directed edges, it is still up to the client to decide whether the edge should be treated as such.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IEdge.TargetPort">
      <summary>
        <para>Gets the target port instance this edge is connected to.</para>
      </summary>
      <remarks>
        <para>Although the notion of source and target port is used for directed edges, it is still up to the client to decide whether the edge should be treated as such.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IEdge.Style">
      <summary>
        <para>Gets the style that is responsible for the visual representation of this edge in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>In order to set the style on an instance, use the <see cref="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" /> method. Note that the style instance associated with an edge instance may be shared between multiple edge instances and that the modification of this style will result in a change of the appearance of all edges that are associated with the same style instance.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.IEdgeDefaults">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.IGraph" /> to declare and obtain the defaults for edges and their labels and ports.</para>
      </summary>
      <remarks>
        <para>Note that changing these defaults does <i>not</i> change properties of already created model items. Rather, only items created after the change are affected.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.IGraph.EdgeDefaults" />
    </member>
    <member name="P:yWorks.Graph.IEdgeDefaults.Ports">
      <summary>
        <para>Gets or sets the defaults for ports at edges.</para>
      </summary>
      <remarks>
        <para>Note that these are not the <see cref="P:yWorks.Graph.IEdge.SourcePort" />s or <see cref="P:yWorks.Graph.IEdge.TargetPort" />s, because conceptually they belong to the nodes (and their <see cref="T:yWorks.Graph.INodeDefaults" />), but rather for ports at edges to which other edges can connect.</para>
      </remarks>
      <value>
        <para>The port defaults.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.IEdgeDefaults.Labels">
      <summary>
        <para>Gets or sets the defaults for labels at edges.</para>
      </summary>
      <value>
        <para>The label defaults.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.IEdgeDefaults.Style">
      <summary>
        <para>Gets or sets the style to use for edges.</para>
      </summary>
      <remarks>
        <para>Depending on the setting of <see cref="P:yWorks.Graph.IEdgeDefaults.ShareStyleInstance" />, the <see cref="M:yWorks.Graph.IEdgeDefaults.GetStyleInstance" /> method should return a <see cref="M:System.ICloneable.Clone">clone</see> of this instance or the very same instance.</para>
      </remarks>
      <value>
        <para>The style to use as a template.</para>
      </value>
      <seealso cref="P:yWorks.Graph.IEdgeDefaults.ShareStyleInstance" />
    </member>
    <member name="M:yWorks.Graph.IEdgeDefaults.GetStyleInstance">
      <summary>
        <para>Factory method that returns a style instance for use with newly created edges.</para>
      </summary>
      <remarks>
        <para>Most implementations will yield either, a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.IEdgeDefaults.Style" /> property, if <see cref="P:yWorks.Graph.IEdgeDefaults.ShareStyleInstance" /> is enabled, but they might use more complicated logic, too.</para>
      </remarks>
      <returns>
        <para>The style to use, which for most implementations is either a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.IEdgeDefaults.Style" /> property, if <see cref="P:yWorks.Graph.IEdgeDefaults.ShareStyleInstance" /> is enabled.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.IEdgeDefaults.ShareStyleInstance">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.IEdgeDefaults.Style" /> instance should be shared referentially or <see cref="M:System.ICloneable.Clone">cloned</see> upon a call to <see cref="M:yWorks.Graph.IEdgeDefaults.GetStyleInstance" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the reference should be shared; <c>false</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Graph.IEdgeDefaults.GetStyleInstance" />
      <seealso cref="P:yWorks.Graph.IEdgeDefaults.Style" />
    </member>
    <member name="T:yWorks.Graph.Styles.VoidEdgeStyle">
      <summary>
        <para>A void implementation of an edge style that does nothing and behaves like an invisible style.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidEdgeStyle.Instance" /> of this class instead of <c>null</c> where <c>null</c> is not allowed. For example you cannot assign <c>null</c> to the <see cref="P:yWorks.Graph.IEdge.Style" /> property of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidEdgeStyle.Instance">
      <summary>
        <para>The <see cref="T:yWorks.Graph.Styles.VoidEdgeStyle" /> singleton.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.VoidEdgeStyle.Renderer">
      <summary>
        <para>Gets the <see cref="F:yWorks.Graph.Styles.VoidEdgeStyleRenderer.Instance">VoidEdgeStyleRenderer instance</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Graph.Styles.IEdgeStyle.Renderer">IEdgeStyle.Renderer</seealso>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidEdgeStyle.Clone">
      <summary>
        <para>Returns <c>this</c>.</para>
      </summary>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.VoidEdgeStyleRenderer">
      <summary>
        <para>A void implementation of an edge style renderer that does nothing.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidEdgeStyleRenderer.Instance" /> of this class instead of <c>null</c> where <c>null</c> is not allowed. For example you cannot assign <c>null</c> to the <see cref="P:yWorks.Graph.Styles.IEdgeStyle.Renderer" /> property of an <see cref="T:yWorks.Graph.Styles.IEdgeStyle" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidEdgeStyleRenderer.Instance">
      <summary>
        <para>The <see cref="T:yWorks.Graph.Styles.VoidEdgeStyleRenderer" /> singleton.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidEdgeStyleRenderer.GetPathGeometry(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>This method always returns the <see cref="F:yWorks.Graph.Styles.VoidPathGeometry.Instance">VoidPathGeometry instance</see>.</para>
      </summary>
      <param name="edge">
        <para>The edge to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the painting</para>
      </param>
      <returns>
        <para>The <see cref="F:yWorks.Graph.Styles.VoidPathGeometry.Instance">VoidPathGeometry instance</see>.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IEdgeStyleRenderer.GetPathGeometry(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidEdgeStyleRenderer.GetVisualCreator(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.VoidVisualCreator.Instance" /> that will do nothing.</para>
      </summary>
      <param name="edge" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidEdgeStyleRenderer.GetBoundsProvider(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.BoundsProviders.Empty" /> that will return empty bounds.</para>
      </summary>
      <param name="edge" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidEdgeStyleRenderer.GetVisibilityTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.VisibilityTestables.Never" /> that will always claim invisibility.</para>
      </summary>
      <param name="edge" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidEdgeStyleRenderer.GetHitTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.Input.HitTestables.Never" /> that will always report misses.</para>
      </summary>
      <param name="edge" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidEdgeStyleRenderer.GetMarqueeTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.Input.MarqueeTestables.Never" /> that will always report misses.</para>
      </summary>
      <param name="edge" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidEdgeStyleRenderer.GetContext(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Graph.Lookups.Empty" /> that will not yield anything.</para>
      </summary>
      <param name="edge" />
      <param name="style" />
    </member>
    <member name="T:yWorks.Graph.Styles.VoidPathGeometry">
      <summary>
        <para>A void implementation of the <see cref="T:yWorks.Graph.Styles.IPathGeometry" /> interface that does nothing and behaves like an empty path.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidPathGeometry.Instance" /> of this class instead of <c>null</c> were <c>null</c> is not allowed. The <see cref="T:yWorks.Graph.Styles.VoidEdgeStyleRenderer" /> does so for example.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidPathGeometry.Instance">
      <summary>
        <para>The <see cref="T:yWorks.Graph.Styles.VoidPathGeometry" /> singleton.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.IEdgeStyle">
      <summary>
        <para>Style implementation for <see cref="T:yWorks.Graph.IEdge" /> instances in an <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <remarks>
        <para>Implementations are responsible for rendering <see cref="T:yWorks.Graph.IEdge" /> instances in a <see cref="T:yWorks.Controls.CanvasControl" />. It is up to the implementation to interpret the visual appearance of an edge. The framework uses the associated, possibly shared <see cref="P:yWorks.Graph.Styles.IEdgeStyle.Renderer" /> to perform the actual rendering of this style for a given edge. This interface extends the <see cref="T:System.ICloneable" /> interface. This allows clients to obtain a persistent copy of the current state of this style. Immutable style implementations may return themselves.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.IArrowOwner" />
    </member>
    <member name="P:yWorks.Graph.Styles.IEdgeStyle.Renderer">
      <summary>
        <para>Gets the renderer implementation that can be queried for implementations that provide details about the visual appearance and visual behavior for a given edge and this style instance.</para>
      </summary>
      <remarks>
        <para>The idiom for retrieving, e.g. an <see cref="T:yWorks.Controls.IVisualCreator" /> implementation for a given style is:</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.Styles.IArrowOwner">
      <summary>
        <para>Helper interface implemented by <see cref="T:yWorks.Graph.Styles.IEdgeStyle" />s that use <see cref="T:yWorks.Graph.Styles.IArrow" />s for displaying arrows.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.IArrowOwner.SourceArrow">
      <summary>
        <para>Gets the visual arrow at the source end of edges that use this style.</para>
      </summary>
      <remarks>
        <para>Arrow instances may be shared between multiple style instances.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.IArrowOwner.TargetArrow">
      <summary>
        <para>Gets the visual arrow at the target end of edges that use this style.</para>
      </summary>
      <remarks>
        <para>Arrow instances may be shared between multiple style instances.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.Styles.IEdgeStyleRenderer">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> implementations that can be used to query the actual <see cref="T:yWorks.Controls.IVisualCreator" />, <see cref="T:yWorks.Controls.IVisibilityTestable" />, <see cref="T:yWorks.Controls.IBoundsProvider" />, <see cref="T:yWorks.Controls.Input.IHitTestable" />, and <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> implementations for an edge and an associated style.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface should be designed to be sharable between multiple style instances and should therefore not contain style specific state.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.IEdgeStyle" />
      <seealso cref="T:yWorks.Graph.IEdge" />
      <seealso cref="T:yWorks.Graph.Styles.INodeStyleRenderer" />
      <seealso cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" />
      <seealso cref="T:yWorks.Graph.Styles.IPortStyleRenderer" />
    </member>
    <member name="M:yWorks.Graph.Styles.IEdgeStyleRenderer.GetPathGeometry(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Graph.Styles.IPathGeometry" /> interface that can handle the provided edge and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="edge">
        <para>The edge to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the painting</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query geometry information from. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IEdgeStyleRenderer.GetVisualCreator(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IVisualCreator" /> interface that can handle the provided edge and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation, but never <c>null</c>.</para>
      </remarks>
      <param name="edge">
        <para>The edge to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the creation of the visual</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently create or update the visual for the edge. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations. This method may not return <c>null</c> but should yield a <see cref="F:yWorks.Controls.VoidVisualCreator.Instance">void</see> implementation instead.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IEdgeStyleRenderer.GetBoundsProvider(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IBoundsProvider" /> interface that can handle the provided edge and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="edge">
        <para>The edge to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the calculating the painting bounds</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the edge's painting bounds. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IEdgeStyleRenderer.GetVisibilityTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IVisibilityTestable" /> interface that can handle the provided edge and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="edge">
        <para>The edge to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the testing the visibility</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the edge's visibility. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IEdgeStyleRenderer.GetHitTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.Input.IHitTestable" /> interface that can handle the provided edge and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="edge">
        <para>The edge to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the querying hit tests</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently perform hit tests. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations. This method may return <c>null</c> to indicate that the edge cannot be hit tested.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IEdgeStyleRenderer.GetMarqueeTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> interface that can handle the provided edge and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="edge">
        <para>The edge to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the querying marquee intersection test.</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the marquee intersections. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IEdgeStyleRenderer.GetContext(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Gets a temporary context instance that can be used to query additional information for the edge's style.</para>
      </summary>
      <remarks>
        <para>Implementations may return <see cref="F:yWorks.Graph.Lookups.Empty" /> if they don't support this, but may not return <c>null</c>.</para>
      </remarks>
      <param name="edge">
        <para>The edge to provide a context instance for.</para>
      </param>
      <param name="style">
        <para>The style to use for the context.</para>
      </param>
      <returns>
        <para>An non-<c>null</c> lookup implementation.</para>
      </returns>
      <seealso cref="F:yWorks.Graph.Lookups.Empty" />
      <seealso cref="T:yWorks.Graph.ILookup" />
    </member>
    <member name="T:yWorks.Graph.IFoldingEdgeConverter">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.FoldingManager" /> and <see cref="T:yWorks.Graph.IFoldingView" /> which is responsible for managing edges between folder nodes.</para>
      </summary>
      <remarks>
        <para>Since <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})" /> creates views that can potentially contain edges that connect to nodes which have a different set of attributes, these edges might need to have a separate set of attributes, too. Implementations of this interface are being called by the <see cref="T:yWorks.Graph.IFoldingView" />s to configure these kind of folding edges.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.DefaultFoldingEdgeConverter" />
      <seealso cref="P:yWorks.Graph.FoldingManager.FoldingEdgeConverter" />
      <seealso cref="T:yWorks.Graph.FoldingEdgeStateId" />
    </member>
    <member name="M:yWorks.Graph.IFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>This method gets called by the <see cref="T:yWorks.Graph.IFoldingView" /> implementation to determine whether a given edge in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> should be represented by a folding edge in the given view.</para>
      </summary>
      <remarks>
        <para>The implementation will be passed in a <paramref name="factory" /> object that implements the <see cref="T:yWorks.Graph.IFoldingEdgeFactory" /> interface, which needs to be used by the implementation to communicate the result of the query. The implementation needs to either call <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddAsSeparateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort)" />, <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddToExistingFoldingEdge(yWorks.Graph.IEdge)" />, or <see cref="M:yWorks.Graph.IFoldingEdgeFactory.ExcludeFoldingEdge" /> and return the values that these implementation yields to the caller. The implementation can optionally query the <see cref="M:yWorks.Graph.IFoldingEdgeFactory.GetExistingFoldingEdges(System.Boolean)">existing folding edges</see> between the source and target node and decide whether to add the edge <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddToExistingFoldingEdge(yWorks.Graph.IEdge)">to the existing folding edge</see>.</para>
      </remarks>
      <param name="factory">
        <para>The <see cref="T:yWorks.Graph.IFoldingEdgeFactory" /> implementation that needs to be called in order to communicate the results of this query.</para>
      </param>
      <param name="foldingView">
        <para>The instance into which the folding edge is going to be inserted.</para>
      </param>
      <param name="masterEdge">
        <para>The edge from the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> that needs to be represented by a folding edge. Note that you may not return this instance.</para>
      </param>
      <param name="source">
        <para>The source node that belongs to the <see cref="T:yWorks.Graph.IFoldingView" /> graph that will act as the local view node of the actual source node.</para>
      </param>
      <param name="sourceIsCollapsed">
        <para>Determines whether the <paramref name="source" /> is currently a folder node.</para>
      </param>
      <param name="target">
        <para>The target node that belongs to the <see cref="T:yWorks.Graph.IFoldingView" /> graph that will act as the local view node of the actual target node.</para>
      </param>
      <param name="targetIsCollapsed">
        <para>Determines whether the <paramref name="target" /> is currently a folder node.</para>
      </param>
      <returns>
        <para>The edge as returned by <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddAsSeparateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort)" />, or <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddToExistingFoldingEdge(yWorks.Graph.IEdge)" />, or <c>null</c> if the edge will be <see cref="M:yWorks.Graph.IFoldingEdgeFactory.ExcludeFoldingEdge">excluded</see> from the view.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IFoldingEdgeConverter.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback that is triggered by the <see cref="T:yWorks.Graph.IFoldingView">view</see> to adjust the appearance of a folding edge</para>
      </summary>
      <remarks>
        <para>For instance, it can be used to reflect a state change in the <see cref="M:yWorks.Graph.IFoldingView.GetMasterEdges(yWorks.Graph.IEdge)">master edges</see> that make up that folding edge.</para>
        <para>Implementations may not use the <see cref="T:yWorks.Graph.IFoldingView" />'s <see cref="P:yWorks.Graph.IFoldingView.Graph" /> instance to modify the <paramref name="foldingEdge" />, because this would create and enqueue undo events. Rather the properties provided by the <paramref name="state" /> implementation must be set.</para>
      </remarks>
      <param name="state">
        <para>The <see cref="T:yWorks.Graph.FoldingEdgeState" /> of the edge to change.</para>
      </param>
      <param name="foldingView">
        <para>The graph to which the folding edge belongs.</para>
      </param>
      <param name="foldingEdge">
        <para>The folding edge for which the appearance might need an update.</para>
      </param>
      <param name="masterEdges">
        <para>The list of <see cref="M:yWorks.Graph.IFoldingView.GetMasterEdges(yWorks.Graph.IEdge)">master edges</see>, that the folding edge currently represents.</para>
      </param>
      <seealso cref="M:yWorks.Graph.IFoldingEdgeConverter.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />
    </member>
    <member name="M:yWorks.Graph.IFoldingEdgeConverter.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})">
      <summary>
        <para>Callback that is triggered by the <see cref="T:yWorks.Graph.IFoldingView">view</see> to initially create the appearance of a folding edge.</para>
      </summary>
      <remarks>
        <para>Implementations may not use the <see cref="T:yWorks.Graph.IFoldingView" />'s <see cref="P:yWorks.Graph.IFoldingView.Graph" /> instance to modify the <paramref name="foldingEdge" />, because this would create and enqueue undo events. Rather the properties provided by the <paramref name="state" /> implementation must be set.</para>
      </remarks>
      <param name="state">
        <para>The <see cref="T:yWorks.Graph.FoldingEdgeState" /> of the edge to change.</para>
      </param>
      <param name="foldingView">
        <para>The graph to which the folding edge belongs.</para>
      </param>
      <param name="foldingEdge">
        <para>The folding edge for which the appearance shall be determined.</para>
      </param>
      <param name="masterEdges">
        <para>The list of <see cref="M:yWorks.Graph.IFoldingView.GetMasterEdges(yWorks.Graph.IEdge)">master edges</see>, that the folding edge initially represents.</para>
      </param>
      <seealso cref="M:yWorks.Graph.IFoldingEdgeConverter.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" />
    </member>
    <member name="T:yWorks.Graph.IFolderNodeConverter">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.FoldingManager" /> and <see cref="T:yWorks.Graph.IFoldingView" /> which is responsible for managing the appearance of folder nodes.</para>
      </summary>
      <remarks>
        <para>Since <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})" /> creates views that can potentially contain nodes which have a different set of attributes, these attributes need to be determined somehow. Implementations of this interface are being called by the <see cref="T:yWorks.Graph.IFoldingView">view</see>s to configure the appearance of these <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">folder nodes</see>.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.DefaultFolderNodeConverter" />
      <seealso cref="P:yWorks.Graph.FoldingManager.FolderNodeConverter" />
      <seealso cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Graph.IFolderNodeConverter.UpdateFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Callback that is used by <see cref="T:yWorks.Graph.IFoldingView">view</see> implementations to change the appearance of a <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">folder</see> node.</para>
      </summary>
      <remarks>
        <para>This method is called by the view to allow for adjusting the appearance of a local folder node in the view when the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">master</see> node for it has changed properties. This can be used, e.g. to synchronize the label or style properties with the corresponding properties of the <paramref name="masterNode" />.</para>
        <para>Note that changing the appearance has to be done on <paramref name="state" />.</para>
      </remarks>
      <param name="state">
        <para>The folder node state to update.</para>
      </param>
      <param name="foldingView">
        <para>The graph instance for which the folder node can be changed.</para>
      </param>
      <param name="viewNode">
        <para>The folder node instance in the view</para>
      </param>
      <param name="masterNode">
        <para>The node that represents the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)" /> of the viewstate to change.</para>
      </param>
      <seealso cref="M:yWorks.Graph.IFolderNodeConverter.InitializeFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Graph.IFolderNodeConverter.InitializeFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Callback that is used by <see cref="T:yWorks.Graph.IFoldingView">view</see> implementations to initially create the appearance of a <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">folder</see> node.</para>
      </summary>
      <remarks>
        <para>This method is called by the view to allow for initially creating the appearance of a local folder node in the view when it is included in the view for the first time. This can be used, e.g. to initialize the labels or style properties with the corresponding properties of the <paramref name="masterNode" />.</para>
        <para>By default the <paramref name="state" /> is an exact copy of the <paramref name="masterNode" />, including layout, style, labels, and ports.</para>
        <para>Note that changing the appearance has to be done on <paramref name="state" />.</para>
      </remarks>
      <param name="state">
        <para>The folder node state to initialize.</para>
      </param>
      <param name="foldingView">
        <para>The graph instance for which the folder node has been created.</para>
      </param>
      <param name="viewNode">
        <para>The folder node instance in the view</para>
      </param>
      <param name="masterNode">
        <para>The node that represents the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)" /> of the viewstate to change.</para>
      </param>
      <seealso cref="M:yWorks.Graph.IFolderNodeConverter.UpdateFolderNodeState(yWorks.Graph.FolderNodeState,yWorks.Graph.IFoldingView,yWorks.Graph.INode,yWorks.Graph.INode)" />
    </member>
    <member name="T:yWorks.Graph.IFoldingEdgeFactory">
      <summary>
        <para>The interface of the factory that is passed to implementations of the <see cref="T:yWorks.Graph.IFoldingEdgeConverter" />'s <see cref="M:yWorks.Graph.IFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)" /> method.</para>
      </summary>
      <remarks>
        <para>Implementors of the <see cref="T:yWorks.Graph.IFoldingEdgeConverter" /> need to use this interface to tell the calling <see cref="T:yWorks.Graph.IFoldingView" /> implementation how to add the folding edge to the given view. They need to call exactly one of the following methods for each factory:</para>
        <list type="bullet">
          <item>
            <term>
              <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddAsSeparateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort)" />
            </term>
            <description>Call this to add a separate folding edge for the given master edge to the view. Pass the return value of that method to the caller.</description>
          </item>
          <item>
            <term>
              <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddToExistingFoldingEdge(yWorks.Graph.IEdge)" />
            </term>
            <description>Call this to reuse a folding edge that is already part of the view as a representative for the master edge. Pass the return value of that method to the caller.</description>
          </item>
          <item>
            <term>
              <see cref="M:yWorks.Graph.IFoldingEdgeFactory.ExcludeFoldingEdge" />
            </term>
            <description>Call this in order not to add a folding edge for the master edge to the view at all. Pass <c>null</c> to the caller.</description>
          </item>
        </list>
      </remarks>
      <seealso cref="M:yWorks.Graph.IFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)" />
      <seealso cref="T:yWorks.Graph.IFoldingEdgeConverter" />
      <seealso cref="P:yWorks.Graph.FoldingManager.FoldingEdgeConverter" />
    </member>
    <member name="M:yWorks.Graph.IFoldingEdgeFactory.AddAsSeparateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Tells the <see cref="T:yWorks.Graph.IFoldingView" /> implementation to add the edge provided to the <see cref="M:yWorks.Graph.IFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)" /> method as a separate folding edge to the view at the given ports.</para>
      </summary>
      <param name="sourcePort">
        <para>The source port at the source node in the view to use or <c>null</c> if an extra <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">folding state</see> port should be added for the edge to connect to at the source.</para>
      </param>
      <param name="targetPort">
        <para>The target port at the target node in the view to use or <c>null</c> if an extra <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">folding state</see> port should be added for the edge to connect to at the target.</para>
      </param>
      <returns>
        <para>The folding edge that has been created in the view. Don't change the properties of the edge directly.</para>
      </returns>
      <remarks>
        <para>This tells the view that there is currently no <see cref="M:yWorks.Graph.IFoldingEdgeFactory.GetExistingFoldingEdges(System.Boolean)">existing folding edge</see> in the view to which the master edge should be added to. Instead the view should add a separate folding edge that represents the master edge. Use the result of this method call as the return value for the <see cref="M:yWorks.Graph.IFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)" /> call. Note that the returned folding edge should not be modified by this code, instead the <see cref="M:yWorks.Graph.IFoldingEdgeConverter.InitializeFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> and <see cref="M:yWorks.Graph.IFoldingEdgeConverter.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> callbacks need to be used to change the appearance of the folding edge. Existing ports at the provided source and target nodes may be specified to further influence the folding edge creation.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IFoldingEdgeConverter" />
      <seealso cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)" />
    </member>
    <member name="M:yWorks.Graph.IFoldingEdgeFactory.AddToExistingFoldingEdge(yWorks.Graph.IEdge)">
      <summary>
        <para>Tells the <see cref="T:yWorks.Graph.IFoldingView" /> implementation to logically add the edge provided to the <see cref="M:yWorks.Graph.IFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)" /> method to a folding edge that already exists in the view.</para>
      </summary>
      <remarks>
        <para>This tells the view that there is already an <see cref="M:yWorks.Graph.IFoldingEdgeFactory.GetExistingFoldingEdges(System.Boolean)">existing folding edge</see> in the view to which the master edge should be added logically added to. The given <paramref name="foldingEdge" /> will have the master edge added to its collection of <see cref="M:yWorks.Graph.IFoldingView.GetMasterEdges(yWorks.Graph.IEdge)">master edges</see>. Note that the returned folding edge should not be modified by this code, instead the <see cref="M:yWorks.Graph.IFoldingEdgeConverter.UpdateFoldingEdgeState(yWorks.Graph.FoldingEdgeState,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,System.Collections.Generic.IList{yWorks.Graph.IEdge})" /> callback needs to be used to change the appearance of the folding edge. Implementations can use the <see cref="M:yWorks.Graph.IFoldingEdgeFactory.GetExistingFoldingEdges(System.Boolean)" /> method to retrieve the current set of existing folding edges that interconnect the same source and target nodes. The range of valid parameters is constrained to this collection.</para>
      </remarks>
      <returns>
        <para>The folding edge that represents the edge in the view, which is the same as the <paramref name="foldingEdge" /> parameter. Don't change the properties of the edge directly.</para>
      </returns>
      <param name="foldingEdge">
        <para>One of the <see cref="M:yWorks.Graph.IFoldingEdgeFactory.GetExistingFoldingEdges(System.Boolean)">existing folding edges</see> from the view which has been chosen to represent the master edge in this view.</para>
      </param>
      <seealso cref="T:yWorks.Graph.IFoldingEdgeConverter" />
      <seealso cref="M:yWorks.Graph.IFoldingEdgeFactory.GetExistingFoldingEdges(System.Boolean)" />
    </member>
    <member name="M:yWorks.Graph.IFoldingEdgeFactory.ExcludeFoldingEdge">
      <summary>
        <para>Tells the <see cref="T:yWorks.Graph.IFoldingView" /> implementation not to add a folding edge for the edge provided to the <see cref="M:yWorks.Graph.IFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)" /> method in this view.</para>
      </summary>
      <remarks>
        <para>This tells the view that there should not be a representation of the master edge in this view. If this method is called, <c>null</c> should be returned as the result of a <see cref="M:yWorks.Graph.IFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)" /> call, which is the same as the return value of this method. So it is possible to just pass the return value on to the caller.</para>
      </remarks>
      <returns>
        <para>This method will always return <c>null</c>. This is for symmetry reasons to be easily exchangeable with the other methods.</para>
      </returns>
      <seealso cref="T:yWorks.Graph.IFoldingEdgeConverter" />
    </member>
    <member name="M:yWorks.Graph.IFoldingEdgeFactory.GetExistingFoldingEdges(System.Boolean)">
      <summary>
        <para>Helper methods that can be used by the implementation of the <see cref="M:yWorks.Graph.IFoldingEdgeConverter.AddFoldingEdge(yWorks.Graph.IFoldingEdgeFactory,yWorks.Graph.IFoldingView,yWorks.Graph.IEdge,yWorks.Graph.INode,System.Boolean,yWorks.Graph.INode,System.Boolean)" /> method to determine the folding edges that are currently part of the view and interconnect the same nodes as the folding edge would, if it was included in the view.</para>
      </summary>
      <remarks>
        <para>This method will yield all <see cref="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">folding edges</see> that interconnect the same source and target node as that the folding edge would, if it was included in this view. One of the items in the returned collection can be passed to the <see cref="M:yWorks.Graph.IFoldingEdgeFactory.AddToExistingFoldingEdge(yWorks.Graph.IEdge)" /> method.</para>
      </remarks>
      <param name="ignoreDirection">
        <para>Whether the direction of the edges should be ignored so that reverse edges are included in the enumeration, too.</para>
      </param>
      <returns>
        <para>An collection of currently existing folding edges in the view that interconnects the same source and target node.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.IFoldingView">
      <summary>
        <para>Interface that is used for manipulating a <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})">managed view</see> of an <see cref="T:yWorks.Graph.IGraph" /> that supports folding operations like <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)">expanding</see> and <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsing</see> of nodes.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Graph.FoldingManager" /> creates views of a <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> which is created using copies of the original "master" entities. The views are being synchronized via the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />, but may contain additional <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)">view state</see>. Typically nodes and edges are being copied from the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> and they share many of their properties by reference (e.g. <see cref="P:yWorks.Graph.INode.Style" />). However if group nodes are being represented by <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> group nodes in this view, they maintain a separate set of <see cref="T:yWorks.Graph.ILabel">labels</see>, <see cref="T:yWorks.Graph.IPort">ports</see>, <see cref="T:yWorks.Graph.IBend">bends</see>, and <see cref="P:yWorks.Graph.INode.Layout">geometry</see>. This view-local state is shared between all views that have been <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})">created</see> by the same <see cref="P:yWorks.Graph.IFoldingView.Manager" /> and can be obtained and modified via the <see cref="T:yWorks.Graph.FoldingManager" />'s <c>GetFoldingEdgeState</c> methods for <see cref="M:yWorks.Graph.FoldingManager.GetFoldingEdgeState(yWorks.Graph.FoldingEdgeStateId)">folding edges</see> and <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)">folder nodes</see> in the absence of a corresponding <see cref="T:yWorks.Graph.IFoldingView" /> view instance. Developers typically don't need to implement this interface themselves, rather an implementation is provided by the framework and can be obtained from the <see cref="T:yWorks.Graph.FoldingManager" />. Use <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})" /> to obtain an <see cref="T:yWorks.Graph.IGraph" /> implementation that contains an implementation of this class in its <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method:</para>
        <para>This interface extends the <see cref="T:System.ComponentModel.INotifyPropertyChanged" /> interface. This can be used to easily monitor the <see cref="P:yWorks.Graph.IFoldingView.Invalid">validity</see> of this view. Also changes to the <see cref="P:yWorks.Graph.IFoldingView.LocalRoot" /> property will be published via this event.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.FoldingManager" />
    </member>
    <member name="E:yWorks.Graph.IFoldingView.GroupCollapsed">
      <summary>
        <para>Occurs whenever a group has been <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)" />d.</para>
      </summary>
    </member>
    <member name="E:yWorks.Graph.IFoldingView.GroupExpanded">
      <summary>
        <para>Occurs whenever a group has been <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)" />ed.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.IFoldingView.Manager">
      <summary>
        <para>Gets the manager that created this view and that contains a reference to the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.IFoldingView.Graph">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.IGraph" /> implementation that provides the actual view data.</para>
      </summary>
      <remarks>
        <para>The instance has an implementation of this interface in its <see cref="T:yWorks.Graph.ILookup" /> that has been obtained from the <see cref="T:yWorks.Graph.FoldingManager" />'s <see cref="M:yWorks.Graph.FoldingManager.CreateFoldingView(yWorks.Graph.INode,System.Predicate{yWorks.Graph.INode})" /> set of methods. The instance holds the elements in the view only, which in general is a subset of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />. Also note that the elements are not the same references as their <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">masters</see>, they are copies that may share the same attributes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IFoldingView.AutoSwitchToAncestor">
      <summary>
        <para>Gets or sets whether this instance should automatically switch the <see cref="P:yWorks.Graph.IFoldingView.LocalRoot" /> to an ancestor of the current root, if this view becomes <see cref="P:yWorks.Graph.IFoldingView.Invalid" />.</para>
      </summary>
      <remarks>
        <para>By default this property is set to <c>true</c> which assures that this view will never become <see cref="P:yWorks.Graph.IFoldingView.Invalid" />. It is the responsibility of the client code to check for the validity of this view before trying to modify it if this feature is disabled.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IFoldingView.Invalid">
      <summary>
        <para>Gets whether this view is currently valid and can be edited.</para>
      </summary>
      <remarks>
        <para>A view is invalid if the <see cref="P:yWorks.Graph.IFoldingView.LocalRoot" /> is not currently part of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> hierarchy. This can happen if the root node is removed from the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />. Note that the view can become valid again if the removal is undone.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.IFoldingView.AutoSwitchToAncestor" />
    </member>
    <member name="P:yWorks.Graph.IFoldingView.EnqueueNavigationalUndoUnits">
      <summary>
        <para>Gets or sets whether changes to the <see cref="P:yWorks.Graph.IFoldingView.LocalRoot" /> property and calls to <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)" /> and <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)" /> should be recorded in undo history.</para>
      </summary>
      <remarks>
        <para>By default this property is set to <c>false</c>, however depending on the use case it may make sense to enqueue <see cref="T:yWorks.Graph.IUndoUnit" />s for this type of operations.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.IFoldingView.AutoSwitchToAncestor" />
    </member>
    <member name="P:yWorks.Graph.IFoldingView.LocalRoot">
      <summary>
        <para>Gets or sets an entity of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> hierarchy to serve as the virtual root for the view's local hierarchy.</para>
      </summary>
      <remarks>
        <para>This property can be set to any <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">group</see> node in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />'s hierarchy whose contents will then be represented in this view. Note that the root of the view's local hierarchy is not set to the same instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)">
      <summary>
        <para>This method will expand a previously <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> group node to make its contents appear in this view.</para>
      </summary>
      <remarks>
        <para>If a node that belongs to this view is in <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> state, calling this method will make the <see cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)">children</see> appear in this <see cref="P:yWorks.Graph.IFoldingView.Graph">view</see>. This method will do nothing if the node is already expanded. Note that expanding a collapsed group node will make the node a <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">group node</see>, whereas a collapsed group node is no group node in this hierarchy and thus cannot have visible children. The expanded group node has its own separate set of attributes, which may be different from the collapsed state that can be obtained using the <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)" /> method. The expanded state is always the same as the state of the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">master node</see>. Because of these differences it may appear that the node changes its location during an expand operation. This behavior ensures that expanding a node does not modify the state of the model by moving the node or its descendants (only the state in the view is changed), but depending on the application this may confuse the user because he might loose his mental map of the diagram. In order to customize the behavior custom code can register with the <see cref="E:yWorks.Graph.IFoldingView.GroupExpanded" /> event to perform the necessary modifications, like adjusting the view port or moving the node and its descendants to the desired location.</para>
        <para>In addition to that this method can also be used for <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master</see> nodes which are currently not represented in this view. In this case these nodes will be displayed as expanded the next time they will be included in this view.</para>
      </remarks>
      <param name="groupNode">
        <para>A group node that is part of the <see cref="P:yWorks.Graph.IFoldingView.Graph" /> or the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master graph</see>.</para>
      </param>
      <seealso cref="M:yWorks.Graph.IFoldingView.IsExpanded(yWorks.Graph.INode)" />
      <seealso cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">
      <summary>
        <para>This method will collapse the <see cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)">children</see> of a group node into the group node.</para>
      </summary>
      <remarks>
        <para>If a <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">group</see> node that belongs to this view's hierarchy is in <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)">expanded</see> state, calling this method will remove the <see cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)">children</see> from this <see cref="P:yWorks.Graph.IFoldingView.Graph">view</see>. This method will do nothing if the node is already collapsed. Note that collapsing a group node will make it a <see cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">non-group</see> node in the hierarchy. The collapsed group node has its own separate set of attributes, which can be obtained using the <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)" /> method. Therefore it may appear that the node changes its location during a collapse operation. This behavior ensures that collapsing a node does not modify the state of the model (only the state in the view is changed), but depending on the application this may confuse the user because he might loose his mental map of the diagram. In order to customize the behavior custom code can register with the <see cref="E:yWorks.Graph.IFoldingView.GroupCollapsed" /> event to perform the necessary modifications, like adjusting the view port or moving the node to the desired location.</para>
        <para>In addition to that this method can also be used for <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master</see> nodes which are currently not represented in this view. In this case these nodes will be displayed as collapsed the next time they will be included in this view.</para>
      </remarks>
      <param name="groupNode">
        <para>A group node that is part of the <see cref="P:yWorks.Graph.IFoldingView.Graph" /> or the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master graph</see>.</para>
      </param>
      <seealso cref="M:yWorks.Graph.IFoldingView.IsExpanded(yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Graph.IFoldingView.IsExpanded(yWorks.Graph.INode)">
      <summary>
        <para>Determines whether the provided node is currently expanded or will be displayed in <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)" />ed state the next time it will be included in this view.</para>
      </summary>
      <remarks>
        <para>Expanded group nodes will have all of their <see cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)">children</see> visible in this <see cref="P:yWorks.Graph.IFoldingView.Graph">view</see>.</para>
        <para>The <paramref name="groupNode" /> can be either a node of the <see cref="P:yWorks.Graph.IFoldingView.Graph">view</see> or the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master graph</see>. If the node is from the master graph and is currently not represented in this view, this method will return the <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)" />ed state it will have the next time it will be included in this view.</para>
      </remarks>
      <param name="groupNode">
        <para>The group node for which the <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)">expanded</see> state will be returned.</para>
      </param>
      <returns>
        <para>
          <c>true</c>, if the group node can be <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">
      <summary>
        <para>Helper method that can be used to retrieve the original "master" items in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> that is managed by the <see cref="P:yWorks.Graph.IFoldingView.Manager" /> associated with this view.</para>
      </summary>
      <remarks>
        <para>Since the <see cref="P:yWorks.Graph.IFoldingView.Graph" /> view that is associated with this instance maintains a copy of the entities in the <see cref="P:yWorks.Graph.IFoldingView.Manager" />'s <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />, there is a mapping between elements that belong to this view's <see cref="P:yWorks.Graph.IFoldingView.Graph" /> and the elements in the master graph. This method can be called for the elements contained in this <see cref="T:yWorks.Graph.IGraph" /> and will return the corresponding item in the master graph that the element corresponds to, if any. Note that for some items in the <see cref="P:yWorks.Graph.IFoldingView.Graph" />, there is no master item in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />, e.g. the <see cref="T:yWorks.Graph.IPort" /> instances to which <see cref="T:yWorks.Graph.FoldingEdgeStateId">folding edges</see> connect have no corresponding ports in the master graph. The same holds true for the <see cref="T:yWorks.Graph.IBend">bends</see> and <see cref="T:yWorks.Graph.ILabel">labels</see> of folding edges and folder nodes. For folding edges, this method will yield the main representing edge in the master, if the folding edge represents more than one master edge. For nodes, the master node will be returned, no matter whether the node is currently <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> or not.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the argument, which is typically <see cref="T:yWorks.Graph.INode" />, <see cref="T:yWorks.Graph.IEdge" />, <see cref="T:yWorks.Graph.ILabel" />, <see cref="T:yWorks.Graph.IBend" />, or <see cref="T:yWorks.Graph.IPort" />.</para>
      </typeparam>
      <param name="item">
        <para>The item that is part of this <see cref="P:yWorks.Graph.IFoldingView.Graph" /> for which the original "master" item in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> will be returned.</para>
      </param>
      <returns>
        <para>An item in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> that corresponds to the <paramref name="item" /> or <c>null</c>, if there is no such item.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)" />
    </member>
    <member name="M:yWorks.Graph.IFoldingView.IsInFoldingState(yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether the specified item is a folding state in this view.</para>
      </summary>
      <remarks>
        <para>This method can be used to determine if an <see cref="T:yWorks.Graph.INode" />, <see cref="T:yWorks.Graph.IEdge" />, <see cref="T:yWorks.Graph.IPort" />, <see cref="T:yWorks.Graph.ILabel" />, or <see cref="T:yWorks.Graph.IBend" /> has a <see cref="M:yWorks.Graph.FoldingManager.GetFolderNodeState(yWorks.Graph.INode)">view local state</see> and is not a direct copy of the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">master item</see>, if any. Note that <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> group nodes are in folding state, even though they do have a <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)">master</see> item in the master graph and folding edges always have at least one <see cref="M:yWorks.Graph.IFoldingView.GetMasterEdges(yWorks.Graph.IEdge)">master edge</see>, while all other folding items don't have a corresponding master item in the master graph.</para>
      </remarks>
      <param name="item">
        <para>One of the items that are <see cref="M:yWorks.Graph.IGraph.Contains(yWorks.Graph.IModelItem)">contained</see> in the <see cref="P:yWorks.Graph.IFoldingView.Graph" />.</para>
      </param>
      <returns>
        <para>Whether the item is in folding state and is not an exact copy of an item in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IFoldingView.GetMasterEdges(yWorks.Graph.IEdge)">
      <summary>
        <para>Helper method that corresponds to the <see cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)" /> method, but is used for folding edges, only.</para>
      </summary>
      <remarks>
        <para>Since folding edges can represent more than one master edge, this method can be used to query all of the master edges that the provided folding edge represents. If the folding edge corresponds to a single master edge, the result will enumerate that edge, only.</para>
      </remarks>
      <param name="foldingEdge">
        <para>The folding edge for which the master edges should be returned.</para>
      </param>
      <returns>
        <para>An enumerable that can enumerate all of the edges in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> that are being represented by the folding edge in this <see cref="P:yWorks.Graph.IFoldingView.Graph">view</see>.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.IFoldingEdgeFactory.AddToExistingFoldingEdge(yWorks.Graph.IEdge)" />
      <seealso cref="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)" />
    </member>
    <member name="M:yWorks.Graph.IFoldingView.GetViewItem``1(``0)">
      <summary>
        <para>Helper method that can be used to retrieve the items in this <see cref="P:yWorks.Graph.IFoldingView.Graph" />-view for all items that are part of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> that is associated with the <see cref="P:yWorks.Graph.IFoldingView.Manager" /> of this instance.</para>
      </summary>
      <remarks>
        <para>Since the <see cref="P:yWorks.Graph.IFoldingView.Graph" /> view that is associated with this instance maintains a copy of the entities in the <see cref="P:yWorks.Graph.IFoldingView.Manager" />'s <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />, there is a mapping between elements that belong to master graph and the elements in the <see cref="P:yWorks.Graph.IFoldingView.Graph" /> of this view. This method can be called for the elements contained in this <see cref="P:yWorks.Graph.FoldingManager.MasterGraph">master graph's</see> items and will return the corresponding item in this view's <see cref="P:yWorks.Graph.IFoldingView.Graph" /> if the element is represented by an item in this view. Note that for some items in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" />, there may be no item in the <see cref="P:yWorks.Graph.IFoldingView.Graph" /> instance, e.g. those elements which are part of a <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> subtree in the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> hierarchy or those items that do not belong to the subtree that is induced by the <see cref="P:yWorks.Graph.IFoldingView.LocalRoot" /> of this view. Also, for nodes and edges that are being represented by dummies in this view, labels, ports, and bends are not being represented directly by corresponding entities in this graph. If more than one edge is represented by a folding edge in this view, this method will yield the same folding edge instance for each of them.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the argument, which is typically <see cref="T:yWorks.Graph.INode" />, <see cref="T:yWorks.Graph.IEdge" />, <see cref="T:yWorks.Graph.ILabel" />, <see cref="T:yWorks.Graph.IBend" />, or <see cref="T:yWorks.Graph.IPort" />.</para>
      </typeparam>
      <param name="item">
        <para>An item that is part of the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> that is associated with the <see cref="P:yWorks.Graph.IFoldingView.Manager" /> of this instance.</para>
      </param>
      <returns>
        <para>An item in the <see cref="P:yWorks.Graph.IFoldingView.Graph">local graph view</see> that corresponds to the <paramref name="item" /> or <c>null</c>, if the item is not currently being represented in this view.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.IFoldingView.GetMasterItem``1(``0)" />
      <seealso cref="M:yWorks.Graph.IFoldingView.GetMasterEdges(yWorks.Graph.IEdge)" />
    </member>
    <member name="M:yWorks.Graph.IFoldingView.Dispose">
      <summary>
        <para>Disposes of this view explicitly.</para>
      </summary>
      <remarks>
        <para>Normally it is not necessary to do so, because the view will be garbage collected automatically. However if the view still displays contents, this might have unwanted negative side effects (group node sizes being calculated, etc.) A disposed of instance is not synchronized with the <see cref="T:yWorks.Graph.FoldingManager" /> anymore and should not be used anymore.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.IFoldingView.CreateFolderNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">
      <summary>
        <para>Directly creates a collapsed node on this instance with the given parameters.</para>
      </summary>
      <remarks>
        <para>This will implicitly create a new empty group node on the <see cref="P:yWorks.Graph.FoldingManager.MasterGraph" /> with the defaults for such a group node. The <paramref name="parent" /> must be part of the <see cref="P:yWorks.Graph.IFoldingView.Graph">Folded Graph View</see> or <c>null</c> to create a folder at the root of the current hierarchy. It will be converted into a group node if necessary. The returned <see cref="T:yWorks.Graph.INode" /> is also part of the <see cref="P:yWorks.Graph.IFoldingView.Graph">Folded Graph View</see>.</para>
      </remarks>
      <param name="parent">
        <para>The parent node in the <see cref="P:yWorks.Graph.IFoldingView.Graph" />, or <c>null</c></para>
      </param>
      <param name="layout">
        <para>The layout for the collapsed node.</para>
      </param>
      <param name="style">
        <para>The style for the collapsed node</para>
      </param>
      <param name="tag">
        <para>The tag of the node.</para>
      </param>
      <returns>
        <para>A collapsed (folder) node that lives in <see cref="P:yWorks.Graph.IFoldingView.Graph" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.AdjacencyTypes">
      <summary>
        <para>Enumeration type for the different types of adjacency.</para>
      </summary>
      <remarks>
        <para>Directed edges in a graph can be either incoming, outgoing, or both.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)" />
      <seealso cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPortOwner,yWorks.Graph.AdjacencyTypes)" />
    </member>
    <member name="F:yWorks.Graph.AdjacencyTypes.None">
      <summary>
        <para>Neither <see cref="F:yWorks.Graph.AdjacencyTypes.Incoming" /> nor <see cref="F:yWorks.Graph.AdjacencyTypes.Outgoing" /></para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.AdjacencyTypes.Incoming">
      <summary>
        <para>The constant for incoming edges.</para>
      </summary>
      <remarks>
        <para>An edge that is incoming at its owner has the owner as its target.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.AdjacencyTypes.Outgoing">
      <summary>
        <para>The constant for outgoing edges.</para>
      </summary>
      <remarks>
        <para>An edge that is outgoing from its owner has the owner as its source.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.AdjacencyTypes.All">
      <summary>
        <para>Both <see cref="F:yWorks.Graph.AdjacencyTypes.Incoming" /> and <see cref="F:yWorks.Graph.AdjacencyTypes.Outgoing" /></para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.GraphItemTypes">
      <summary>
        <para>An enumeration for use in various properties that can take a bitwise combination of item types that make up an <see cref="T:yWorks.Graph.IGraph" /></para>
      </summary>
      <remarks>
        <para>The enumeration can be used to create <see cref="T:System.FlagsAttribute">bitwise combination</see> of the types.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.GraphItemTypes.Node">
      <summary>
        <para>Constant for nodes.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.INode" />
    </member>
    <member name="F:yWorks.Graph.GraphItemTypes.Edge">
      <summary>
        <para>Constant for edges.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.IEdge" />
    </member>
    <member name="F:yWorks.Graph.GraphItemTypes.NodeLabel">
      <summary>
        <para>Constant for node labels.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.ILabel" />
    </member>
    <member name="F:yWorks.Graph.GraphItemTypes.EdgeLabel">
      <summary>
        <para>Constant for edge labels.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.ILabel" />
    </member>
    <member name="F:yWorks.Graph.GraphItemTypes.Port">
      <summary>
        <para>Constant for ports.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.IPort" />
    </member>
    <member name="F:yWorks.Graph.GraphItemTypes.Label">
      <summary>
        <para>Constant for all kinds of labels.</para>
      </summary>
      <remarks>
        <para>This is a bitwise combination of <see cref="F:yWorks.Graph.GraphItemTypes.NodeLabel" /> and <see cref="F:yWorks.Graph.GraphItemTypes.EdgeLabel" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.ILabel" />
    </member>
    <member name="F:yWorks.Graph.GraphItemTypes.LabelOwner">
      <summary>
        <para>Constant for all kinds of <see cref="T:yWorks.Graph.ILabelOwner" />.</para>
      </summary>
      <remarks>
        <para>This is a bitwise combination of <see cref="F:yWorks.Graph.GraphItemTypes.Node" /> and <see cref="F:yWorks.Graph.GraphItemTypes.Edge" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.ILabelOwner" />
    </member>
    <member name="F:yWorks.Graph.GraphItemTypes.Bend">
      <summary>
        <para>Constant for edge bends.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.IBend" />
    </member>
    <member name="F:yWorks.Graph.GraphItemTypes.All">
      <summary>
        <para>Constant for all item types.</para>
      </summary>
      <remarks>
        <para>This is a bitwise combination of all other types declared in this enum.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.GraphItemTypes.None">
      <summary>
        <para>Constant for no item type.</para>
      </summary>
      <remarks>
        <para>This is a constant where no type bit has been set, i.e. it is <c>0</c>.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.GraphItemTypesSupport">
      <summary>
        <para>Helper class that deals with the <see cref="T:yWorks.Graph.GraphItemTypes" /> enumeration.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.GraphItemTypesSupport.GetItemType(yWorks.Graph.IModelItem)">
      <summary>
        <para>Gets the type of the item.</para>
      </summary>
      <param name="item">
        <para>The item.</para>
      </param>
      <returns>
        <para>The type.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphItemTypesSupport.Is(yWorks.Graph.GraphItemTypes,yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether the <paramref name="item" /> is of the specified <paramref name="type" />.</para>
      </summary>
      <param name="item">
        <para>The item.</para>
      </param>
      <param name="type">
        <para>The type.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the <paramref name="item" /> is of the specified <paramref name="type" />; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphItemTypesSupport.Contains(yWorks.Graph.GraphItemTypes,System.Collections.Generic.IEnumerable{yWorks.Graph.IModelItem})">
      <summary>
        <para>Determines whether the specified items collection contains any of the types described by <paramref name="types" />.</para>
      </summary>
      <param name="items">
        <para>The items.</para>
      </param>
      <param name="types">
        <para>The types.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified items contains any of the types; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphItemTypesSupport.NotContains(yWorks.Graph.GraphItemTypes,System.Collections.Generic.IEnumerable{yWorks.Graph.IModelItem})">
      <summary>
        <para>Determines whether the specified items collection contains none of the types described by <paramref name="types" />.</para>
      </summary>
      <param name="items">
        <para>The items.</para>
      </param>
      <param name="types">
        <para>The types.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified items contains none of the types; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphItemTypesSupport.GetItemTypes(System.Collections.Generic.IEnumerable{yWorks.Graph.IModelItem})">
      <summary>
        <para>Determines the types of the items contained in the collection of items.</para>
      </summary>
      <param name="items">
        <para>The items.</para>
      </param>
      <returns>
        <para>The types of the items.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.IGraph">
      <summary>
        <para>Central interface that models a graph which can be displayed in a <see cref="T:yWorks.Controls.CanvasControl">canvas</see> or <see cref="T:yWorks.Controls.GraphControl" />.</para>
      </summary>
      <remarks>
        <para>This interface can be used to query structural information, it also offers methods that change the structure of the graph and its attributes. A number of events will trigger appropriate events if the structure of the graph changes.</para>
        <para>The graph is made up of collections of <see cref="T:yWorks.Graph.INode">nodes</see> and <see cref="T:yWorks.Graph.IEdge">edges</see>. Each node and edge can be associated with a number of <see cref="T:yWorks.Graph.ILabel">labels</see> and possibly <see cref="T:yWorks.Graph.IPort">ports</see> to which edges connect. An edge connects to two ports and may consist of zero or more <see cref="T:yWorks.Graph.IBend">bends</see>. The graph is treated as a directed graph, i.e. edges have a <see cref="P:yWorks.Graph.IEdge.SourcePort">source port</see> and a <see cref="P:yWorks.Graph.IEdge.TargetPort">target port</see>. It is up to the algorithms and the visualization to possibly treat them as undirected.</para>
        <para>This interface also provides support for hierarchically organized, i.e. grouped graphs. This means that nodes together with their connecting edges can be <see cref="M:yWorks.Graph.IGraph.SetParent(yWorks.Graph.INode,yWorks.Graph.INode)">put into</see> other nodes. The containing node is referred to as a "group node." To create and edit group nodes interactively use the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> as input mode and enable the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations">grouping operations</see>.</para>
        <para>The <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)" /> and <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPortOwner,yWorks.Graph.AdjacencyTypes)" /> methods can be used to query adjacency information from the graph's structure.</para>
        <para>Each element in the graph can be associated with a style that is used for the visualization of the element. Styles can be shared between multiple instances.</para>
        <para>To associate data with the elements in the graph, code can make use of the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> property that all <see cref="T:yWorks.Graph.IModelItem" />s provide. In order to associate more than one data element with the graph items, compound data objects can be used. Alternatively the <see cref="T:yWorks.Graph.IMapperRegistry" /> that can be obtained from the <see cref="P:yWorks.Graph.IGraph.MapperRegistry" /> property can be used to associate arbitrary data sets with the items in this graph.</para>
        <para>This interface contains core methods that may use complicated argument lists. <see cref="T:yWorks.Graph.GraphExtensions" /> is a static utility class that contains <see cref="T:System.Runtime.CompilerServices.ExtensionAttribute">extension methods</see> for this interface that improve the usability of this interface dramatically.</para>
        <para>This interface provides a number of events that can be used to get notified for changes in the graph structure. These events are raised whenever the corresponding state change occurs, e.g. also when loading the graph from a file. If you are only interested in changes that are triggered interactively, you should subscribe to the corresponding events on the <see cref="T:yWorks.Controls.Input.IInputMode" /> implementations that implement the user interaction. Especially, you may not modify the graph structure in handlers for these event, e.g. try to prevent or undo the change that has raised the event.</para>
      </remarks>
      <example />
      <seealso cref="T:yWorks.Graph.DefaultGraph" />
      <seealso cref="T:yWorks.Graph.INode" />
      <seealso cref="T:yWorks.Graph.IEdge" />
      <seealso cref="T:yWorks.Graph.IPort" />
      <seealso cref="T:yWorks.Graph.ILabel" />
      <seealso cref="T:yWorks.Graph.IBend" />
      <seealso cref="T:yWorks.Graph.GraphExtensions" />
      <seealso cref="T:yWorks.Graph.IMapperRegistry" />
    </member>
    <member name="P:yWorks.Graph.IGraph.Nodes">
      <summary>
        <para>Gets a view of the nodes contained in this graph.</para>
      </summary>
      <remarks>
        <para>This is a live view of the nodes that always represents the current state of the graph. The same reference will be returned for each invocation.</para>
        <para>Note that even though nodes can be accessed via index, the underlying graph structure in the default <see cref="T:yWorks.Graph.IGraph" /> implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the nodes in your own list, if possible. This is not necessary for the first or last element or when iterating over the nodes via a <c>foreach</c> loop.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IGraph.Edges">
      <summary>
        <para>Gets a view of the edges contained in this graph.</para>
      </summary>
      <remarks>
        <para>This is a live view of the edges that always represents the current state of the graph. The same reference will be returned for each invocation.</para>
        <para>Note that even though edges can be accessed via index, the underlying graph structure in the default <see cref="T:yWorks.Graph.IGraph" /> implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in your own list, if possible. This is not necessary for the first or last element or when iterating over the edges via a <c>foreach</c> loop.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IGraph.Labels">
      <summary>
        <para>Gets a view of the node and edge labels contained in this graph.</para>
      </summary>
      <remarks>
        <para>This is a live view of the labels that always represents the current state of the graph. The same reference will be returned for each invocation.</para>
        <para>Note that even though labels can be accessed via index, the underlying graph structure in the default <see cref="T:yWorks.Graph.IGraph" /> implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the labels in your own list, if possible. This is not necessary for the first or last element or when iterating over the labels via a <c>foreach</c> loop.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IGraph.Ports">
      <summary>
        <para>Gets a view of the ports contained in this graph.</para>
      </summary>
      <remarks>
        <para>This is a live view of the ports that always represents the current state of the graph. The same reference will be returned for each invocation.</para>
        <para>Note that even though ports can be accessed via index, the underlying graph structure in the default <see cref="T:yWorks.Graph.IGraph" /> implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the ports in your own list, if possible. This is not necessary for the first or last element or when iterating over the ports via a <c>foreach</c> loop.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IGraph.NodeDefaults">
      <summary>
        <para>Gets or sets the defaults for normal nodes.</para>
      </summary>
      <remarks>
        <para>The settings that are obtained from the instance influence newly created elements only. Setting different defaults afterwards does not influence existing elements.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IGraph.EdgeDefaults">
      <summary>
        <para>Gets or sets the defaults for normal edges.</para>
      </summary>
      <remarks>
        <para>The settings that are obtained from the instance influence newly created elements only. Setting different defaults afterwards does not influence existing elements.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IGraph.MapperRegistry">
      <summary>
        <para>Gets the mapper registry that is associated with this graph instance.</para>
      </summary>
      <remarks>
        <para>The registry can be used to store data mappings for the items in this instance.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IMapperRegistry" />
      <seealso cref="T:yWorks.Graph.IModelItem" />
      <seealso cref="P:yWorks.Graph.ITagOwner.Tag" />
    </member>
    <member name="M:yWorks.Graph.IGraph.CreateNode(yWorks.Geometry.RectD,yWorks.Graph.Styles.INodeStyle,System.Object)">
      <summary>
        <para>Creates and returns a node using the specified values for the initial geometry, style, and <see cref="P:yWorks.Graph.ITagOwner.Tag" />.</para>
      </summary>
      <remarks>
        <para>The node will be a part of this graph after the method returns. This will trigger the corresponding events.</para>
      </remarks>
      <param name="layout">
        <para>The layout to use initially. The values will be copied to the node's <see cref="P:yWorks.Graph.INode.Layout">Layout</see> field</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the newly created instance. This is done by reference.</para>
      </param>
      <param name="tag">
        <para>The initial value of the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> that will be assigned to the new node.</para>
      </param>
      <returns>
        <para>A newly created node instance</para>
      </returns>
      <seealso cref="E:yWorks.Graph.IGraph.NodeCreated" />
      <seealso cref="F:yWorks.Graph.Styles.VoidNodeStyle.Instance" />
    </member>
    <member name="M:yWorks.Graph.IGraph.SetEdgePorts(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Sets the ports of the given edge to the new values.</para>
      </summary>
      <remarks>
        <para>This will trigger an <see cref="E:yWorks.Graph.IGraph.EdgePortsChanged" /> event if source or target ports differ from the current ones. Both ports and the edge must belong to the current graph instance.</para>
        <para>An implementation may decide to remove the corresponding ports if no other edge connects to them after the given edge has its source or target ports changed.</para>
      </remarks>
      <param name="edge">
        <para>The edge to change the ports.</para>
      </param>
      <param name="sourcePort">
        <para>The new source port instance.</para>
      </param>
      <param name="targetPort">
        <para>The new target port instance.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>Either <paramref name="edge" />, <paramref name="sourcePort" />, or <paramref name="targetPort" /> are not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)">
      <summary>
        <para>Returns an <see cref="T:System.Collections.Generic.IEnumerable`1" /> for all edges that are adjacent to the given port as a <see cref="P:yWorks.Graph.IEdge.SourcePort" /> or <see cref="P:yWorks.Graph.IEdge.TargetPort" />.</para>
      </summary>
      <remarks>
        <para>Note that even though edges can be accessed via index, the underlying graph structure in the default <see cref="T:yWorks.Graph.IGraph" /> implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in your own list, if possible. This is not necessary for the first or last element or when iterating over the adjacent edges via a <c>foreach</c> loop.</para>
      </remarks>
      <param name="port">
        <para>the port to check</para>
      </param>
      <param name="type">
        <para>The type of adjacency to consider.</para>
      </param>
      <returns>
        <para>An enumeration of all adjacent edges of the given type.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphExtensions.InEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPort)" />
      <seealso cref="M:yWorks.Graph.GraphExtensions.OutEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPort)" />
      <seealso cref="T:yWorks.Graph.AdjacencyTypes" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="port" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPortOwner,yWorks.Graph.AdjacencyTypes)">
      <summary>
        <para>Returns an <see cref="T:yWorks.Utils.IListEnumerable`1" /> for all edges that have the given port owner as their <see cref="P:yWorks.Graph.IEdge.TargetPort">target port's</see> or <see cref="P:yWorks.Graph.IEdge.SourcePort">source port's</see> <see cref="P:yWorks.Graph.IPort.Owner" /> depending on the <see cref="T:yWorks.Graph.AdjacencyTypes" /></para>
      </summary>
      <remarks>
        <para>Note that even though edges can be accessed via index, the underlying graph structure in the default <see cref="T:yWorks.Graph.IGraph" /> implementation is a linked list and indexed access can be slow. In those cases it is recommended to store the edges in your own list, if possible. This is not necessary for the first or last element or when iterating over the adjacent edges via a <c>foreach</c> loop.</para>
      </remarks>
      <param name="type">
        <para>The type of adjacency to consider.</para>
      </param>
      <param name="owner">
        <para>the port owner to check</para>
      </param>
      <returns>
        <para>An enumeration of all adjacent edges of the given type.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphExtensions.InEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)" />
      <seealso cref="M:yWorks.Graph.GraphExtensions.OutEdgesAt(yWorks.Graph.IGraph,yWorks.Graph.IPortOwner)" />
      <seealso cref="T:yWorks.Graph.AdjacencyTypes" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.CreateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort,yWorks.Graph.Styles.IEdgeStyle,System.Object)">
      <summary>
        <para>Creates and returns an edge that connects to the given port instances.</para>
      </summary>
      <remarks>
        <para>The ports must be part of this graph at the time of the invocation. The edge will be a part of this graph after the method returns. This will trigger the corresponding events.</para>
      </remarks>
      <param name="sourcePort">
        <para>The source port the created edge will connect to.</para>
      </param>
      <param name="targetPort">
        <para>The target port the created edge will connect to.</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the newly created instance. This is done by reference.</para>
      </param>
      <param name="tag">
        <para>The initial value of the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> that will be assigned to the new edge.</para>
      </param>
      <returns>
        <para>the newly created edge instance</para>
      </returns>
      <seealso cref="E:yWorks.Graph.IGraph.EdgeCreated" />
      <seealso cref="F:yWorks.Graph.Styles.VoidEdgeStyle.Instance" />
    </member>
    <member name="M:yWorks.Graph.IGraph.CreateEdge(yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Graph.Styles.IEdgeStyle,System.Object)">
      <summary>
        <para>Convenience method that creates and returns an edge that connects to the given node instances using the given style instance.</para>
      </summary>
      <remarks>
        <para>The nodes must be part of this graph at the time of the invocation, and an implementation can choose the <see cref="T:yWorks.Graph.IPort" /> instances to which the edge will be connected. The edge will be a part of this graph after the method returns. This will trigger the corresponding events.</para>
      </remarks>
      <param name="source">
        <para>The source node the created edge will connect to. It is up to the implementation to decide which port to use at the given node. An implementation may create a new port of the edge.</para>
      </param>
      <param name="target">
        <para>The target node the created edge will connect to. It is up to the implementation to decide which port to use at the given node. An implementation may create a new port of the edge.</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the newly created instance. This is done by reference.</para>
      </param>
      <param name="tag">
        <para>The initial value of the <see cref="P:yWorks.Graph.ITagOwner.Tag" /> that will be assigned to the new edge.</para>
      </param>
      <returns>
        <para>the newly created edge instance</para>
      </returns>
      <seealso cref="E:yWorks.Graph.IGraph.EdgeCreated" />
      <seealso cref="F:yWorks.Graph.Styles.VoidEdgeStyle.Instance" />
    </member>
    <member name="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)">
      <summary>
        <para>Removes the given <see cref="T:yWorks.Graph.IModelItem">item</see> from this graph.</para>
      </summary>
      <remarks>
        <para>The item must be a part of this graph.</para>
        <para>If the item is a <see cref="T:yWorks.Graph.INode">node</see> the <see cref="E:yWorks.Graph.IGraph.NodeRemoved" /> event will be triggered. This will remove all adjacent edges and their corresponding ports in proper order before the node will be removed. Also this will trigger the removal of all labels owned by this instance.</para>
        <para>If the item is an <see cref="T:yWorks.Graph.IEdge">edge</see> the <see cref="E:yWorks.Graph.IGraph.EdgeRemoved" /> event will be triggered. An implementation may decide to remove the corresponding ports from the node if no other edge connects to them after the given edge has been removed. Also this will trigger the removal of all labels and bends owned by this instance.</para>
        <para>If the item is a <see cref="T:yWorks.Graph.IBend">bend</see> the <see cref="E:yWorks.Graph.IGraph.BendRemoved" /> event will be triggered.</para>
        <para>If the item is a <see cref="T:yWorks.Graph.IPort">port</see> the <see cref="E:yWorks.Graph.IGraph.PortRemoved" /> event will be triggered. This will also remove all edges that are currently connected to the port.</para>
        <para>If the item is a <see cref="T:yWorks.Graph.ILabel">label</see> the <see cref="E:yWorks.Graph.IGraph.LabelRemoved" /> event will be triggered.</para>
      </remarks>
      <param name="item">
        <para>the live item to be removed from this graph instance</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="item" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="E:yWorks.Graph.IGraph.GraphTagChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Graph.ITagOwner.Tag">tag</see> of the graph has been replaced.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.ITagOwner.Tag" />
    </member>
    <member name="E:yWorks.Graph.IGraph.NodeCreated">
      <summary>
        <para>Occurs when a node has been created.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. Please use the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.NodeCreated" /> event if you are interested only in node creation events that result from user interaction. <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the node creation that has triggered this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.CreateNode(yWorks.Geometry.RectD,yWorks.Graph.Styles.INodeStyle,System.Object)" />
      <seealso cref="M:yWorks.Graph.IGraph.CreateNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)" />
      <seealso cref="M:yWorks.Graph.IGraph.CreateGroupNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.NodeCreated" />
    </member>
    <member name="E:yWorks.Graph.IGraph.DisplaysInvalidated">
      <summary>
        <para>Occurs when the graph has changed visually and the display should be updated to reflect the changes.</para>
      </summary>
      <remarks>
        <para>This event is invoked with <see cref="F:System.EventArgs.Empty" /> per default.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.IGraph.InvalidateDisplays">
      <summary>
        <para>Causes the <see cref="E:yWorks.Graph.IGraph.DisplaysInvalidated" /> event to be triggered.</para>
      </summary>
      <remarks>
        <para>This method may be called by client code to invalidate all views of the graph that have registered with the <see cref="E:yWorks.Graph.IGraph.DisplaysInvalidated" /> event. Views that need to be informed if non-structural changes have been made to the graph should register with the corresponding event.</para>
      </remarks>
    </member>
    <member name="E:yWorks.Graph.IGraph.NodeRemoved">
      <summary>
        <para>Occurs when a node has been removed.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. Please use the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" /> event if you are interested only in node removal events that result from user interaction. <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the node removal that has triggered this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" />
    </member>
    <member name="E:yWorks.Graph.IGraph.NodeStyleChanged">
      <summary>
        <para>Occurs when a node style has been replaced.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.NodeLayoutChanged">
      <summary>
        <para>Occurs when a node layout has been changed.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetNodeLayout(yWorks.Graph.INode,yWorks.Geometry.RectD)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.NodeTagChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Graph.ITagOwner.Tag">tag</see> of a node has been replaced.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.ITagOwner.Tag" />
    </member>
    <member name="E:yWorks.Graph.IGraph.EdgeCreated">
      <summary>
        <para>Occurs when an edge has been created.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. Please use the <see cref="E:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreated" /> event if you are interested only in edge creation events that result from user interaction. <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the edge creation that has triggered this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.CreateEdge(yWorks.Graph.IPort,yWorks.Graph.IPort,yWorks.Graph.Styles.IEdgeStyle,System.Object)" />
      <seealso cref="E:yWorks.Controls.Input.CreateEdgeInputMode.EdgeCreated" />
    </member>
    <member name="E:yWorks.Graph.IGraph.EdgeRemoved">
      <summary>
        <para>Occurs when an edge has been removed.</para>
      </summary>
      <remarks>
        <para>This event will be triggered, too, prior to a node removal.</para>
        <para>This event is intended to provide notification of low level changes in the graph structure. Please use the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" /> event if you are interested only in edge removal events that result from user interaction. <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the edge removal that has triggered this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" />
    </member>
    <member name="E:yWorks.Graph.IGraph.EdgeStyleChanged">
      <summary>
        <para>Occurs when an edge style has been replaced.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.EdgePortsChanged">
      <summary>
        <para>Occurs when an edge had its <see cref="P:yWorks.Graph.IEdge.SourcePort" /> or <see cref="P:yWorks.Graph.IEdge.TargetPort" /> <see cref="M:yWorks.Graph.IGraph.SetEdgePorts(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">changed</see>.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetEdgePorts(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.EdgeTagChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Graph.ITagOwner.Tag">tag</see> of an edge has been replaced.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.ITagOwner.Tag" />
    </member>
    <member name="E:yWorks.Graph.IGraph.BendAdded">
      <summary>
        <para>Occurs when a bend has been added to an edge in this graph.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. Please use the <see cref="E:yWorks.Controls.Input.CreateBendInputMode.BendCreated" /> event if you are interested only in bend creation events that result from user interaction. <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the bend creation that has triggered this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.AddBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD,System.Int32)" />
      <seealso cref="E:yWorks.Controls.Input.CreateBendInputMode.BendCreated" />
    </member>
    <member name="E:yWorks.Graph.IGraph.BendRemoved">
      <summary>
        <para>Occurs when a bend has been removed from an edge in this graph.</para>
      </summary>
      <remarks>
        <para>This event will be triggered, too, if an edge has been removed from the graph, for each of the bends that belonged to the edge.</para>
        <para>This event is intended to provide notification of low level changes in the graph structure. Please use the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" /> event if you are interested only in bend removal events that result from user interaction. <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the bend removal that has triggered this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" />
    </member>
    <member name="E:yWorks.Graph.IGraph.BendLocationChanged">
      <summary>
        <para>Occurs when the location of a bend has been changed.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetBendLocation(yWorks.Graph.IBend,yWorks.Geometry.PointD)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.BendTagChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Graph.ITagOwner.Tag">tag</see> of a bend has been replaced.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.ITagOwner.Tag" />
    </member>
    <member name="E:yWorks.Graph.IGraph.LabelAdded">
      <summary>
        <para>Occurs when a label has been added to this graph instance.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. Please use the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdded" /> event if you are interested only in label creation events that result from user interaction. <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the label creation that has triggered this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.AddLabel(yWorks.Graph.ILabelOwner,System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,System.Nullable{yWorks.Geometry.SizeD},System.Object)" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelAdded" />
    </member>
    <member name="E:yWorks.Graph.IGraph.LabelRemoved">
      <summary>
        <para>Occurs when a label has been removed from this graph instance.</para>
      </summary>
      <remarks>
        <para>This event will also be triggered, prior to the removal of the <see cref="P:yWorks.Graph.ILabel.Owner">owner</see> of the label.</para>
        <para>This event is intended to provide notification of low level changes in the graph structure. Please use the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" /> event if you are interested only in label removal events that result from user interaction. <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the label removal that has triggered this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.LabelTextChanged" />
    </member>
    <member name="E:yWorks.Graph.IGraph.LabelStyleChanged">
      <summary>
        <para>Occurs when a label style has been replaced.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.LabelPreferredSizeChanged">
      <summary>
        <para>Occurs when the preferred size of a label has been changed.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetLabelPreferredSize(yWorks.Graph.ILabel,yWorks.Geometry.SizeD)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.LabelTextChanged">
      <summary>
        <para>Occurs when the text of a label has been changed.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetLabelText(yWorks.Graph.ILabel,System.String)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.LabelLayoutParameterChanged">
      <summary>
        <para>Occurs when the model parameter of a label has been changed.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetLabelLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.LabelTagChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Graph.ITagOwner.Tag">tag</see> of a label has been replaced.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.ITagOwner.Tag" />
    </member>
    <member name="E:yWorks.Graph.IGraph.PortAdded">
      <summary>
        <para>Occurs when a port has been added to this graph instance.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the port creation that has triggered this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.AddPort(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)" />
      <seealso cref="M:yWorks.Graph.IGraph.CreateEdge(yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Graph.Styles.IEdgeStyle,System.Object)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.PortRemoved">
      <summary>
        <para>Occurs when a port has been removed from its <see cref="P:yWorks.Graph.IPort.Owner">owner</see>.</para>
      </summary>
      <remarks>
        <para>This event will also be triggered prior to the removal of the corresponding owner of the port.</para>
        <para>This event is intended to provide notification of low level changes in the graph structure. Please use the <see cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" /> event if you are interested only in port removal events that result from user interaction. <b>Note:</b>You may not modify the graph in the event handler for this event. Especially you may not prevent/undo the port removal that has triggered this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)" />
      <seealso cref="E:yWorks.Controls.Input.GraphEditorInputMode.DeletedItem" />
    </member>
    <member name="E:yWorks.Graph.IGraph.PortStyleChanged">
      <summary>
        <para>Occurs when a port style has been replaced.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.PortLocationParameterChanged">
      <summary>
        <para>Occurs when the location model parameter of a port has been changed.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetPortLocationParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" />
    </member>
    <member name="E:yWorks.Graph.IGraph.PortTagChanged">
      <summary>
        <para>Occurs when the <see cref="P:yWorks.Graph.ITagOwner.Tag">tag</see> of a port has been replaced.</para>
      </summary>
      <remarks>
        <para>This event is intended to provide notification of low level changes in the graph structure. <b>Note:</b>You may not modify the graph in the event handler for this event.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.ITagOwner.Tag" />
    </member>
    <member name="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Assigns the given style instance by reference to the node.</para>
      </summary>
      <remarks>
        <para>Style instances can be shared.</para>
      </remarks>
      <param name="node">
        <para>The node that will be assigned the new style</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the node.</para>
      </param>
      <seealso cref="P:yWorks.Graph.INode.Style" />
      <seealso cref="E:yWorks.Graph.IGraph.NodeStyleChanged" />
      <seealso cref="F:yWorks.Graph.Styles.VoidNodeStyle.Instance" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="node" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Assigns the given style instance by reference to the label.</para>
      </summary>
      <remarks>
        <para>Style instances can be shared.</para>
      </remarks>
      <param name="label">
        <para>The label that will be assigned the new style</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the label.</para>
      </param>
      <seealso cref="P:yWorks.Graph.ILabel.Style" />
      <seealso cref="E:yWorks.Graph.IGraph.LabelStyleChanged" />
      <seealso cref="F:yWorks.Graph.Styles.VoidLabelStyle.Instance" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="label" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Assigns the given style instance by reference to the edge.</para>
      </summary>
      <remarks>
        <para>Style instances can be shared.</para>
      </remarks>
      <param name="edge">
        <para>The edge that will be assigned the new style</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the edge.</para>
      </param>
      <seealso cref="P:yWorks.Graph.IEdge.Style" />
      <seealso cref="E:yWorks.Graph.IGraph.EdgeStyleChanged" />
      <seealso cref="F:yWorks.Graph.Styles.VoidEdgeStyle.Instance" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="edge" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Assigns the given style instance by reference to the port.</para>
      </summary>
      <remarks>
        <para>Style instances can be shared.</para>
      </remarks>
      <param name="port">
        <para>The port that will be assigned the new style</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the port.</para>
      </param>
      <seealso cref="P:yWorks.Graph.IPort.Style" />
      <seealso cref="E:yWorks.Graph.IGraph.PortStyleChanged" />
      <seealso cref="F:yWorks.Graph.Styles.VoidPortStyle.Instance" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="port" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.Contains(yWorks.Graph.IModelItem)">
      <summary>
        <para>Determines whether this graph contains the specified item.</para>
      </summary>
      <param name="item">
        <para>The item.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this graph contains the specified item; otherwise, <c>false</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IGraph.AddBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD,System.Int32)">
      <summary>
        <para>Adds a bend at the given index to the given edge using the coordinates provided.</para>
      </summary>
      <remarks>
        <para>The added instance will be returned.</para>
      </remarks>
      <param name="edge">
        <para>The edge to which the bend will be added.</para>
      </param>
      <param name="location">
        <para>the coordinates to use for the newly created bend</para>
      </param>
      <param name="index">
        <para>The index for the newly added bend; a negative value (which is the default) indicates that the bend should be appended to the end of the list of bends.</para>
      </param>
      <returns>
        <para>a newly created live bend</para>
      </returns>
      <seealso cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)" />
      <seealso cref="M:yWorks.Graph.IGraph.SetBendLocation(yWorks.Graph.IBend,yWorks.Geometry.PointD)" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="edge" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.SetBendLocation(yWorks.Graph.IBend,yWorks.Geometry.PointD)">
      <summary>
        <para>Modifies the location of the given bend.</para>
      </summary>
      <param name="bend">
        <para>the bend whose location is to be modified</para>
      </param>
      <param name="location">
        <para>the new location of the bend</para>
      </param>
      <seealso cref="M:yWorks.Graph.IGraph.AddBend(yWorks.Graph.IEdge,yWorks.Geometry.PointD,System.Int32)" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="bend" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.AddPort(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)">
      <summary>
        <para>Add a port to the given port owner using the location model parameter, style and tag.</para>
      </summary>
      <remarks>
        <para>The <paramref name="locationParameter" /> determines the location of the port.</para>
        <para>An implementation may throw an <see cref="T:System.NotSupportedException" /> if the type of the <paramref name="owner" /> instance does not support adding of ports.</para>
      </remarks>
      <param name="owner">
        <para>the owner to add the port instance to.</para>
      </param>
      <param name="locationParameter">
        <para>the parameter to use for the port to determine its location.</para>
      </param>
      <param name="style">
        <para>the style to initially assign to the <see cref="P:yWorks.Graph.IPort.Style" /> property, e.g. <see cref="F:yWorks.Graph.Styles.VoidPortStyle.Instance" />.</para>
      </param>
      <param name="tag">
        <para>the initial <see cref="P:yWorks.Graph.ITagOwner.Tag" /> to assign.</para>
      </param>
      <returns>
        <para>the newly created port</para>
      </returns>
      <seealso cref="E:yWorks.Graph.IGraph.PortAdded" />
      <seealso cref="F:yWorks.Graph.Styles.VoidPortStyle.Instance" />
      <exception cref="T:System.NotSupportedException">
        <para>If this instance cannot add a port to <paramref name="owner" />.</para>
      </exception>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.AddLabel(yWorks.Graph.ILabelOwner,System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,System.Nullable{yWorks.Geometry.SizeD},System.Object)">
      <summary>
        <para>Add a label to the given node or edge using the text as the initial label text and label model parameter, style and tag.</para>
      </summary>
      <param name="owner">
        <para>The node or edge to add the label to.</para>
      </param>
      <param name="text">
        <para>The initial text of the label</para>
      </param>
      <param name="layoutParameter">
        <para>The label model parameter instance to use.</para>
      </param>
      <param name="style">
        <para>The style to use for the label</para>
      </param>
      <param name="preferredSize">
        <para>The initial values to use for the <see cref="P:yWorks.Graph.ILabel.PreferredSize" />.</para>
      </param>
      <param name="tag">
        <para>The initial <see cref="P:yWorks.Graph.ITagOwner.Tag" /> to assign.</para>
      </param>
      <returns>
        <para>the newly created label</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="owner" /> is not in this graph.</para>
      </exception>
      <seealso cref="E:yWorks.Graph.IGraph.LabelAdded" />
      <seealso cref="M:yWorks.Graph.IGraph.SetLabelText(yWorks.Graph.ILabel,System.String)" />
      <seealso cref="M:yWorks.Graph.IGraph.SetLabelLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)" />
      <seealso cref="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />
      <seealso cref="F:yWorks.Graph.Styles.VoidLabelStyle.Instance" />
    </member>
    <member name="M:yWorks.Graph.IGraph.SetLabelText(yWorks.Graph.ILabel,System.String)">
      <summary>
        <para>Sets the label text of the given label.</para>
      </summary>
      <param name="label">
        <para>the label to modify</para>
      </param>
      <param name="text">
        <para>the new text of the label</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="label" /> is not in this graph.</para>
      </exception>
      <seealso cref="P:yWorks.Graph.ILabel.Text" />
    </member>
    <member name="M:yWorks.Graph.IGraph.SetLabelPreferredSize(yWorks.Graph.ILabel,yWorks.Geometry.SizeD)">
      <summary>
        <para>Sets the preferred size of the label.</para>
      </summary>
      <param name="label">
        <para>The label.</para>
      </param>
      <param name="preferredSize">
        <para>The new preferred size.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="label" /> is not in this graph.</para>
      </exception>
      <seealso cref="P:yWorks.Graph.ILabel.PreferredSize" />
    </member>
    <member name="M:yWorks.Graph.IGraph.SetLabelLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Sets the label model parameter for the given label.</para>
      </summary>
      <param name="label">
        <para>The label.</para>
      </param>
      <param name="layoutParameter">
        <para>The new parameter.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="label" /> is not in this graph, or <paramref name="layoutParameter" /> cannot be used for <paramref name="label" />.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.SetPortLocationParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <summary>
        <para>Sets a new <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> for the given port.</para>
      </summary>
      <param name="port">
        <para>The port to modify</para>
      </param>
      <param name="locationParameter">
        <para>the new parameter that determines the coordinates of the port</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="port" /> is not in this graph, or <paramref name="locationParameter" /> cannot be used for <paramref name="port" />.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.SetNodeLayout(yWorks.Graph.INode,yWorks.Geometry.RectD)">
      <summary>
        <para>Sets the layout of the given node to the new value.</para>
      </summary>
      <param name="node">
        <para>a live node that belongs to this graph</para>
      </param>
      <param name="layout">
        <para>The new layout of the node to assign to its <see cref="P:yWorks.Graph.INode.Layout" />.</para>
      </param>
      <seealso cref="P:yWorks.Graph.INode.Layout" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="node" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.CreateGroupNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">
      <summary>
        <para>Creates a new group node using the provided style and layout as a child of <paramref name="parent" />.</para>
      </summary>
      <remarks>
        <para>The group node will be a direct descendant of <paramref name="parent" />.</para>
        <para>To create group nodes interactively use the <see cref="T:yWorks.Controls.Input.GraphEditorInputMode" /> as input mode and enable the <see cref="P:yWorks.Controls.Input.GraphEditorInputMode.AllowGroupingOperations">grouping operations</see>.</para>
      </remarks>
      <returns>
        <para>The newly created group node.</para>
      </returns>
      <param name="parent">
        <para>The node to use as the parent in the grouping hierarchy or <c>null</c> if the new node should become a top-level node.</para>
      </param>
      <param name="layout">
        <para>The initial layout to use for the new node.</para>
      </param>
      <param name="style">
        <para>The style to use for the new node.</para>
      </param>
      <param name="tag">
        <para>The <see cref="P:yWorks.Graph.ITagOwner.Tag" /> to assign to the <see cref="T:yWorks.Graph.INode" />.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.IGraph.GroupNodeDefaults">
      <summary>
        <para>Gets or sets the defaults for group nodes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.IGraph.SetParent(yWorks.Graph.INode,yWorks.Graph.INode)">
      <summary>
        <para>Sets the parent node for a given node.</para>
      </summary>
      <remarks>
        <para>Use <c>null</c> as <paramref name="parent" /> to make <paramref name="node" /> a top-level node for this graph.</para>
      </remarks>
      <example />
      <param name="node">
        <para>The node to assign a new parent.</para>
      </param>
      <param name="parent">
        <para>The parent group node to assign to <paramref name="node" /> or <c>null</c> to make <paramref name="node" /> a top-level node.</para>
      </param>
      <seealso cref="M:yWorks.Graph.IGraph.GetParent(yWorks.Graph.INode)" />
      <exception cref="T:System.ArgumentException">
        <para>Either <paramref name="node" /> or <paramref name="parent" /> are not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.CreateNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)">
      <summary>
        <para>Creates a new ordinary node as a direct descendant of <paramref name="parent" /> using the given layout and style.</para>
      </summary>
      <remarks />
      <param name="parent">
        <para>The node to use as the parent in the grouping hierarchy or <c>null</c> if the new node should become a top-level node.</para>
      </param>
      <returns>
        <para>The newly created node.</para>
      </returns>
      <param name="layout">
        <para>The layout to use initially. The values will be copied to the node's <see cref="P:yWorks.Graph.INode.Layout">Layout</see> field.</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the newly created instance. This is done by reference.</para>
      </param>
      <param name="tag">
        <para>The <see cref="P:yWorks.Graph.ITagOwner.Tag" /> to assign to the <see cref="T:yWorks.Graph.INode" />.</para>
      </param>
      <seealso cref="M:yWorks.Graph.IGraph.SetParent(yWorks.Graph.INode,yWorks.Graph.INode)" />
      <seealso cref="M:yWorks.Graph.IGraph.CreateNode(yWorks.Geometry.RectD,yWorks.Graph.Styles.INodeStyle,System.Object)" />
      <seealso cref="M:yWorks.Graph.IGraph.CreateGroupNode(yWorks.Graph.INode,System.Nullable{yWorks.Geometry.RectD},yWorks.Graph.Styles.INodeStyle,System.Object)" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="parent" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)">
      <summary>
        <para>Returns an enumerable over the children of the provided node.</para>
      </summary>
      <example />
      <param name="node">
        <para>The node for which to return the children or <c>null</c> if the top-level nodes should be returned.</para>
      </param>
      <returns>
        <para>All nodes that have <paramref name="node" /> as their <see cref="M:yWorks.Graph.IGraph.GetParent(yWorks.Graph.INode)">parent</see>.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="node" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.GetParent(yWorks.Graph.INode)">
      <summary>
        <para>Returns the parent node of the node or <c>null</c> if <paramref name="node" /> is a top-level node.</para>
      </summary>
      <example />
      <param name="node">
        <para>The node to retrieve the parent node for.</para>
      </param>
      <returns>
        <para>The parent node in this hierarchy or <c>null</c> if <paramref name="node" /> is a top-level node.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="node" /> is not in this graph.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)">
      <summary>
        <para>Returns whether the given node is considered a group node.</para>
      </summary>
      <remarks>
        <para>Group nodes may have <see cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)">children</see> but do not necessarily have to.</para>
      </remarks>
      <example />
      <param name="node">
        <para>The node to check.</para>
      </param>
      <returns>
        <para>Whether the node is considered a group node.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="node" /> is not in this graph.</para>
      </exception>
      <seealso cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)" />
      <seealso cref="M:yWorks.Graph.IGraph.SetIsGroupNode(yWorks.Graph.INode,System.Boolean)" />
    </member>
    <member name="M:yWorks.Graph.IGraph.SetIsGroupNode(yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Determines whether the given node should be considered a group node.</para>
      </summary>
      <remarks>
        <para>Group nodes may have <see cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)">children</see> but do not necessarily need to have one. Attempting to set a node to the non-group-node-status while it has children at the same time will result in an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
      <example />
      <param name="node">
        <para>The node to set the group node status for.</para>
      </param>
      <param name="isGroupNode">
        <para>Whether to make the node a group node.</para>
      </param>
      <seealso cref="M:yWorks.Graph.IGraph.GetChildren(yWorks.Graph.INode)" />
      <seealso cref="M:yWorks.Graph.IGraph.IsGroupNode(yWorks.Graph.INode)" />
      <exception cref="T:System.ArgumentException">
        <para>
          <paramref name="node" /> is not in this graph.</para>
      </exception>
      <exception cref="T:System.InvalidOperationException">
        <para>
          <paramref name="node" /> is <c>null</c> or currently has children and <paramref name="isGroupNode" /> is <c>false</c>.</para>
      </exception>
    </member>
    <member name="E:yWorks.Graph.IGraph.ParentChanged">
      <summary>
        <para>Occurs if a node has been reparented in the model.</para>
      </summary>
    </member>
    <member name="E:yWorks.Graph.IGraph.IsGroupNodeChanged">
      <summary>
        <para>Occurs if the group node status of a node has changed.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.NodeEventArgs">
      <summary>
        <para>A specialized subclass of the <see cref="T:yWorks.Utils.ItemEventArgs`1" /> class that is bound to the <see cref="T:yWorks.Graph.INode" /> type and carries additional information about the parent node and the group node status.</para>
      </summary>
      <remarks>
        <para>Since for some events (<see cref="E:yWorks.Graph.IGraph.NodeRemoved" />, <see cref="E:yWorks.Graph.IGraph.IsGroupNodeChanged" />, <see cref="E:yWorks.Graph.IGraph.ParentChanged" />) it is unclear which <see cref="P:yWorks.Graph.NodeEventArgs.Parent" /> or <see cref="P:yWorks.Graph.NodeEventArgs.IsGroupNode" /> the node had before the event this event can be used to carry exactly that information.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.NodeEventArgs.#ctor(yWorks.Graph.INode,yWorks.Graph.INode,System.Boolean)">
      <summary>
        <para>Creates a new instance.</para>
      </summary>
      <param name="item">
        <para>The node that has changed.</para>
      </param>
      <param name="oldParent">
        <para>The parent the node had before this event.</para>
      </param>
      <param name="oldIsGroupNode">
        <para>Whether the node was a group node before this event.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.NodeEventArgs.Parent">
      <summary>
        <para>Gets the parent of the <see cref="P:yWorks.Utils.ItemEventArgs`1.Item">node</see> before this event.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.NodeEventArgs.IsGroupNode">
      <summary>
        <para>Gets whether the <see cref="P:yWorks.Utils.ItemEventArgs`1.Item">node</see> was a group node before this event.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.EdgeEventArgs">
      <summary>
        <para>A specialized subclass of the <see cref="T:yWorks.Utils.ItemEventArgs`1" /> class that is bound to the <see cref="T:yWorks.Graph.IEdge" /> type and carries additional source and target port information.</para>
      </summary>
      <remarks>
        <para>Since for some events (<see cref="E:yWorks.Graph.IGraph.EdgePortsChanged" /> and <see cref="E:yWorks.Graph.IGraph.EdgeRemoved" />) it is unclear what <see cref="P:yWorks.Graph.IEdge.SourcePort" /> and <see cref="P:yWorks.Graph.IEdge.TargetPort" /> the edge had been connected to before the event, this event can be used to carry exactly that information.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.EdgeEventArgs.#ctor(yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort,yWorks.Graph.IPortOwner,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.EdgeEventArgs" /> class.</para>
      </summary>
      <param name="edge">
        <para>The edge to assign to the <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" /> property.</para>
      </param>
      <param name="source">
        <para>The source port the edge was connected to before the event happened.</para>
      </param>
      <param name="target">
        <para>The target port the edge was connected to before the event happened.</para>
      </param>
      <param name="sourceOwner">
        <para>The owner of the source port the edge was connected to before the event happened.</para>
      </param>
      <param name="targetOwner">
        <para>The owner of the target port the edge was connected to before the event happened.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.EdgeEventArgs.SourcePort">
      <summary>
        <para>Gets the source port the edge was connected to before the event happened.</para>
      </summary>
      <value>
        <para>The old source port.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeEventArgs.TargetPort">
      <summary>
        <para>Gets the target port the edge was connected to before the event happened.</para>
      </summary>
      <value>
        <para>The old target port.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeEventArgs.SourcePortOwner">
      <summary>
        <para>Gets the owner of the source port the edge was connected to before the event happened.</para>
      </summary>
      <value>
        <para>The owner of the old source port.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.EdgeEventArgs.TargetPortOwner">
      <summary>
        <para>Gets the owner of the target port the edge was connected to before the event happened.</para>
      </summary>
      <value>
        <para>The owner of the old target port.</para>
      </value>
    </member>
    <member name="T:yWorks.Graph.PortEventArgs">
      <summary>
        <para>A specialized subclass of the <see cref="T:yWorks.Utils.ItemEventArgs`1" /> class that is bound to the <see cref="T:yWorks.Graph.IPort" /> type and carries additional <see cref="T:yWorks.Graph.IPortOwner" /> information.</para>
      </summary>
      <remarks>
        <para>Since for some events (<see cref="E:yWorks.Graph.IGraph.PortRemoved" />) it is unclear what <see cref="P:yWorks.Graph.IPort.Owner" /> the port had been attached to before the event, this event can be used to carry exactly that information.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.PortEventArgs.#ctor(yWorks.Graph.IPort,yWorks.Graph.IPortOwner)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.PortEventArgs" /> class.</para>
      </summary>
      <param name="port">
        <para>The port to assign to the <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" /> property.</para>
      </param>
      <param name="owner">
        <para>The owner of the port the port was attached to.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.PortEventArgs.Owner">
      <summary>
        <para>Gets the owner the port the was connected to before the event happened.</para>
      </summary>
      <value>
        <para>The old owner.</para>
      </value>
    </member>
    <member name="T:yWorks.Graph.LabelEventArgs">
      <summary>
        <para>A specialized subclass of the <see cref="T:yWorks.Utils.ItemEventArgs`1" /> class that is bound to the <see cref="T:yWorks.Graph.ILabel" /> type and carries additional <see cref="T:yWorks.Graph.ILabelOwner">owner</see> information.</para>
      </summary>
      <remarks>
        <para>Since for some events (<see cref="E:yWorks.Graph.IGraph.LabelRemoved" />) it is unclear what <see cref="P:yWorks.Graph.ILabel.Owner" /> the label was owned by before the event, this event can be used to carry exactly that information.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelEventArgs.#ctor(yWorks.Graph.ILabel,yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LabelEventArgs" /> class.</para>
      </summary>
      <param name="label">
        <para>The label to assign to the <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" /> property.</para>
      </param>
      <param name="owner">
        <para>The previous owner of the label.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.LabelEventArgs.Owner">
      <summary>
        <para>Gets the owner of the label that owned the label before the event happened.</para>
      </summary>
      <value>
        <para>The old owner.</para>
      </value>
    </member>
    <member name="T:yWorks.Graph.BendEventArgs">
      <summary>
        <para>A specialized subclass of the <see cref="T:yWorks.Utils.ItemEventArgs`1" /> class that is bound to the <see cref="T:yWorks.Graph.IBend" /> type and carries additional <see cref="T:yWorks.Graph.IEdge">owner</see> and index information.</para>
      </summary>
      <remarks>
        <para>Since for some events (<see cref="E:yWorks.Graph.IGraph.BendRemoved" />) it is unclear what <see cref="P:yWorks.Graph.IBend.Owner" /> the bend was owned by before the event, this event can be used to carry exactly that information.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.BendEventArgs.#ctor(yWorks.Graph.IBend,yWorks.Graph.IEdge,System.Int32)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.BendEventArgs" /> class.</para>
      </summary>
      <param name="bend">
        <para>The bend to assign to the <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" /> property.</para>
      </param>
      <param name="owner">
        <para>The previous owner of the bend.</para>
      </param>
      <param name="index">
        <para>The previous index of the bend in the <see cref="P:yWorks.Graph.IEdge.Bends" /> list.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.BendEventArgs.Owner">
      <summary>
        <para>Gets the owner of the bend that owned the bend before the event happened.</para>
      </summary>
      <value>
        <para>The old owner.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.BendEventArgs.Index">
      <summary>
        <para>Gets the former index of the bend in the <see cref="P:yWorks.Graph.IEdge.Bends" /> list.</para>
      </summary>
      <value>
        <para>The index of the bend before the event happened.</para>
      </value>
    </member>
    <member name="T:yWorks.Graph.ItemChangedEventArgs`2">
      <summary>
        <para>Event argument class used by <see cref="T:yWorks.Graph.IGraph" /> if a model item's property has been changed.</para>
      </summary>
      <typeparam name="TItem">
        <para>The type of the item contained in the event.</para>
      </typeparam>
      <typeparam name="TValue">
        <para>The type of the item's property that has been changed.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Graph.ItemChangedEventArgs`2.#ctor(`0,`1)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.ItemChangedEventArgs`2" /> class.</para>
      </summary>
      <param name="item">
        <para>The item whose property has been changed.</para>
      </param>
      <param name="oldValue">
        <para>The value of the property before the change.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.ItemChangedEventArgs`2.OldValue">
      <summary>
        <para>Gets the value of the property before the change.</para>
      </summary>
      <value>
        <para>The value of the property before the change.</para>
      </value>
    </member>
    <member name="T:yWorks.Graph.NodeLayoutChangedHandler">
      <summary>
        <para>Event delegate method that is used in <see cref="T:yWorks.Graph.IGraph" />'s <see cref="E:yWorks.Graph.IGraph.NodeLayoutChanged">NodeLayoutChanged</see> event.</para>
      </summary>
      <param name="source">
        <para>The source of the event.</para>
      </param>
      <param name="node">
        <para>The node whose layout has changed.</para>
      </param>
      <param name="oldLayout">
        <para>The node layout before the change.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.BendLocationChangedHandler">
      <summary>
        <para>Event delegate method that is used in <see cref="T:yWorks.Graph.IGraph" />'s <see cref="E:yWorks.Graph.IGraph.BendLocationChanged">BendLocationChanged</see> event.</para>
      </summary>
      <param name="source">
        <para>The source of the event.</para>
      </param>
      <param name="bend">
        <para>The bend whose location has changed.</para>
      </param>
      <param name="oldLocation">
        <para>The bend location before the change.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.IGraphSelection">
      <summary>
        <para>Manages the selection state of items in an <see cref="T:yWorks.Graph.IGraph" /> instance.</para>
      </summary>
      <remarks>
        <para>This interface provides access to the <see cref="T:yWorks.Controls.ISelectionModel`1" /> instances that manage the selection of nodes, edges, labels, ports, and bends. The generic methods that use <see cref="T:yWorks.Graph.IModelItem" /> parameters delegate to the corresponding domain-specific selection models.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.ISelectionModel`1" />
    </member>
    <member name="P:yWorks.Controls.IGraphSelection.SelectedNodes">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.ISelectionModel`1" /> of the selected nodes.</para>
      </summary>
      <remarks>
        <para>This is the node part of the selection that this instance is a composite of.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.IGraphSelection.SelectedLabels">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.ISelectionModel`1" /> of the selected labels.</para>
      </summary>
      <remarks>
        <para>This is the label part of the selection that this instance is a composite of.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.IGraphSelection.SelectedEdges">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.ISelectionModel`1" /> of the selected edges.</para>
      </summary>
      <remarks>
        <para>This is the edge part of the selection that this instance is a composite of.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.IGraphSelection.SelectedPorts">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.ISelectionModel`1" /> of the selected ports.</para>
      </summary>
      <remarks>
        <para>This is the ports part of the selection that this instance is a composite of.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.IGraphSelection.SelectedBends">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.ISelectionModel`1" /> of the selected bends.</para>
      </summary>
      <remarks>
        <para>This is the bend part of the selection that this instance is a composite of.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.ILabel">
      <summary>
        <para>The interface used in an <see cref="T:yWorks.Graph.IGraph" /> implementation for labels.</para>
      </summary>
      <remarks>
        <para>This interface provides read-only access to the properties of a label. In order to modify the state of an instance use the various methods provided by the <see cref="T:yWorks.Graph.IGraph" /> this instance belongs to. Labels are stored in <see cref="T:yWorks.Utils.IListEnumerable`1">IListEnumerable&lt;ILabel&gt;</see>s, that can be obtained from <see cref="T:yWorks.Graph.ILabelOwner" /> implementations' <see cref="P:yWorks.Graph.ILabelOwner.Labels" /> property. Typical owners of a label are <see cref="T:yWorks.Graph.INode" /> and <see cref="T:yWorks.Graph.IEdge" /> instances. Like all items in an <c>IGraph</c>, this item supports the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method that can be used to query additional aspects of the item.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.ILabel.Style">
      <summary>
        <para>Gets the style that is responsible for the visual representation of this node in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>In order to set the style on an instance, use the <see cref="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" /> method. Note that the style instance associated with a label instance may be shared between multiple label instances and that the modification of this style will result in a change of the appearance of all labels that are associated with the same style instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.ILabel.PreferredSize">
      <summary>
        <para>Gets the preferred size of the label with respect to its current contents and the implementation of the visualization.</para>
      </summary>
      <remarks>
        <para>Often times the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout's</see> size will be the same as the preferred size, but it's up to the implementation of the <see cref="T:yWorks.Graph.LabelModels.ILabelModel" /> to interpret it differently. In order to set a different preferred size for this label instance use <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.IGraph.SetLabelPreferredSize(yWorks.Graph.ILabel,yWorks.Geometry.SizeD)" /> method.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.ILabel.Owner">
      <summary>
        <para>Gets the owner of this label.</para>
      </summary>
      <remarks>
        <para>Typically this will yield an instance of <see cref="T:yWorks.Graph.INode" /> or <see cref="T:yWorks.Graph.IEdge" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.ILabel.Text">
      <summary>
        <para>Gets the text string associated with this label.</para>
      </summary>
      <remarks>
        <para>It is up to the visualization engine to interpret this property for the visualization of the label. Normally, it will render the text into the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see> of this instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.ILabel.LayoutParameter">
      <summary>
        <para>Gets the label model's parameter that determines the positioning of this label.</para>
      </summary>
      <remarks>
        <para>In order to set a different parameter for this label, use <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.IGraph.SetLabelLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)" /> method. Note that the label model parameter instance associated with a label instance may be shared between multiple label instances and that the modification of this instance or its <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> will result in a change of the positioning of all labels that are associated with the same parameter or model instance.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.ILabelDefaults">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.IGraph" /> and the like to declare and obtain the defaults for labels.</para>
      </summary>
      <remarks>
        <para>Note that changing these defaults does <i>not</i> change properties of already created model items. Rather, only items created after the change are affected.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.INodeDefaults.Labels" />
      <seealso cref="P:yWorks.Graph.IEdgeDefaults.Labels" />
      <seealso cref="P:yWorks.Graph.IGraph.NodeDefaults" />
      <seealso cref="P:yWorks.Graph.IGraph.EdgeDefaults" />
      <seealso cref="P:yWorks.Graph.IGraph.GroupNodeDefaults" />
    </member>
    <member name="P:yWorks.Graph.ILabelDefaults.Style">
      <summary>
        <para>Gets or sets the style to use for labels.</para>
      </summary>
      <remarks>
        <para>Depending on the setting of <see cref="P:yWorks.Graph.ILabelDefaults.ShareStyleInstance" />, the <see cref="M:yWorks.Graph.ILabelDefaults.GetStyleInstance(yWorks.Graph.ILabelOwner)" /> method should return a <see cref="M:System.ICloneable.Clone">clone</see> of this instance or the very same instance.</para>
      </remarks>
      <value>
        <para>The style to use as a template.</para>
      </value>
      <seealso cref="P:yWorks.Graph.ILabelDefaults.ShareStyleInstance" />
    </member>
    <member name="P:yWorks.Graph.ILabelDefaults.AutoAdjustPreferredSize">
      <summary>
        <para>Gets or sets a property that determines whether to automatically adjust the preferred size of a label.</para>
      </summary>
      <remarks>
        <para>On a call to <see cref="M:yWorks.Graph.IGraph.SetLabelText(yWorks.Graph.ILabel,System.String)" /> or <see cref="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />, the preferred size of the label will automatically be adjusted to the preferred size that is suggested by the label's style renderer, if this property is set to true.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.Styles.ILabelStyleRenderer.GetPreferredSize(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />
    </member>
    <member name="P:yWorks.Graph.ILabelDefaults.ShareLayoutParameterInstance">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.ILabelDefaults.LayoutParameter" /> instance should be shared referentially or <see cref="M:System.ICloneable.Clone">cloned</see> upon a call to <see cref="M:yWorks.Graph.ILabelDefaults.GetLayoutParameterInstance(yWorks.Graph.ILabelOwner)" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the reference should be shared; <c>false</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Graph.ILabelDefaults.GetLayoutParameterInstance(yWorks.Graph.ILabelOwner)" />
      <seealso cref="P:yWorks.Graph.ILabelDefaults.LayoutParameter" />
    </member>
    <member name="P:yWorks.Graph.ILabelDefaults.ShareStyleInstance">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.ILabelDefaults.Style" /> instance should be shared referentially or <see cref="M:System.ICloneable.Clone">cloned</see> upon a call to <see cref="M:yWorks.Graph.ILabelDefaults.GetStyleInstance(yWorks.Graph.ILabelOwner)" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the reference should be shared; <c>false</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Graph.ILabelDefaults.GetStyleInstance(yWorks.Graph.ILabelOwner)" />
      <seealso cref="P:yWorks.Graph.ILabelDefaults.Style" />
    </member>
    <member name="M:yWorks.Graph.ILabelDefaults.GetStyleInstance(yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Factory method that returns a style instance for use with newly created labels.</para>
      </summary>
      <remarks>
        <para>Most implementations will yield either, a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.ILabelDefaults.Style" /> property, if <see cref="P:yWorks.Graph.ILabelDefaults.ShareStyleInstance" /> is enabled, but they might use more complicated logic, too.</para>
      </remarks>
      <param name="owner">
        <para>The owner of the label that will be created.</para>
      </param>
      <returns>
        <para>The style to use, which for most implementations is either a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.ILabelDefaults.Style" /> property, if <see cref="P:yWorks.Graph.ILabelDefaults.ShareStyleInstance" /> is enabled.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.ILabelDefaults.LayoutParameter">
      <summary>
        <para>Gets or sets the label model parameter to use for labels.</para>
      </summary>
      <remarks>
        <para>Depending on the setting of <see cref="P:yWorks.Graph.ILabelDefaults.ShareLayoutParameterInstance" />, the <see cref="M:yWorks.Graph.ILabelDefaults.GetLayoutParameterInstance(yWorks.Graph.ILabelOwner)" /> method should return a <see cref="M:System.ICloneable.Clone">clone</see> of this instance or the very same instance.</para>
      </remarks>
      <value>
        <para>The parameter to use as a template.</para>
      </value>
      <seealso cref="P:yWorks.Graph.ILabelDefaults.ShareLayoutParameterInstance" />
      <seealso cref="M:yWorks.Graph.ILabelDefaults.GetLayoutParameterInstance(yWorks.Graph.ILabelOwner)" />
    </member>
    <member name="M:yWorks.Graph.ILabelDefaults.GetLayoutParameterInstance(yWorks.Graph.ILabelOwner)">
      <summary>
        <para>Factory method that returns a label model parameter instance for use with newly created labels.</para>
      </summary>
      <remarks>
        <para>Most implementations will yield either, a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.ILabelDefaults.LayoutParameter" /> property, if <see cref="P:yWorks.Graph.ILabelDefaults.ShareLayoutParameterInstance" /> is enabled, but they might use more complicated logic, too.</para>
      </remarks>
      <param name="owner">
        <para>The owner of the label that will be created.</para>
      </param>
      <returns>
        <para>The parameter to use, which for most implementations is either a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.ILabelDefaults.LayoutParameter" /> property, if <see cref="P:yWorks.Graph.ILabelDefaults.ShareLayoutParameterInstance" /> is enabled.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.LabelModels.ILabelModel">
      <summary>
        <para>Defines the geometry of <see cref="T:yWorks.Graph.ILabel" /> instances with respect to specific <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" />s.</para>
      </summary>
      <remarks>
        <para>In addition to defining the geometry of a label with respect to a specific <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" />, a label model is typically the factory of the label model parameters that are compatible with it, too.</para>
        <para>Typically, the label model defines a, possibly infinite, compilation of valid geometries for labels, and a specific label model parameter specifies an exact geometry for a label.</para>
        <para>By design, the same instance of a label model can be shared by multiple label model parameters. Similarly, the same instance of a label model parameter can be shared by multiple labels.</para>
        <para>This interface supports the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method that can be used to query additional aspects of the implementation.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" />
      <seealso cref="T:yWorks.Graph.ILabel" />
      <seealso cref="T:yWorks.Graph.IGraph" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.ILabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Calculates the <see cref="T:yWorks.Geometry.IOrientedRectangle">geometry</see> of the given label using the given model parameter.</para>
      </summary>
      <param name="label">
        <para>The label to calculate the geometry for.</para>
      </param>
      <param name="layoutParameter">
        <para>A parameter that is compatible with this model. Typically, this is a parameter that has been created by this model, and its property <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> returns this instance.</para>
      </param>
      <returns>
        <para>An <see cref="T:yWorks.Geometry.IOrientedRectangle" /> that describes the geometry of the label. This is typically designed as a flyweight, therefore clients should not cache the instance but store the values if they need a snapshot for later use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.ILabelModel.CreateDefaultParameter">
      <summary>
        <para>Creates a default parameter that can be used for this model.</para>
      </summary>
      <returns>
        <para>a parameter for this model instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.ILabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Provides a <see cref="T:yWorks.Graph.ILookup">lookup context</see> for the given combination of label and parameter.</para>
      </summary>
      <param name="label">
        <para>The label to use in the context.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter to use for the label in the context.</para>
      </param>
      <returns>
        <para>An implementation of the <see cref="T:yWorks.Graph.ILookup" /> interface that can be used to query additional aspects of the label/parameter combination.</para>
      </returns>
      <seealso cref="F:yWorks.Graph.Lookups.Empty" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptor">
      <summary>
        <para>Interface that provides more information about a potential label geometry (a candidate) to an automatic labeling algorithm.</para>
      </summary>
      <remarks>
        <para>Typically, instances of this interface are created by an implementation of <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptorProvider" /> for a pair of an <see cref="T:yWorks.Graph.ILabel" /> and a <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> that describes a potential placement of that label (a 'candidate').</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptorProvider" />
    </member>
    <member name="P:yWorks.Graph.LabelModels.ILabelCandidateDescriptor.ExternalCandidate">
      <summary>
        <para>Gets a value indicating whether this candidate is deemed an external candidate.</para>
      </summary>
      <remarks>
        <para>This is mainly for <see cref="T:yWorks.Graph.INode" /> labels that are a visual part of the node's internals. It could be used for edge labels, too, if the edge occupies significant amounts of visual space.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this describes an external candidate; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelModels.ILabelCandidateDescriptor.EdgeOverlapPenalty">
      <summary>
        <para>Gets a penalty value that is used by labeling algorithms to judge the severity if this candidate overlaps with an edge path.</para>
      </summary>
      <remarks>
        <para>This value must be between 0 and 1 (inclusive). A value of 0 means that an overlap is considered not important, while a value of 1 means that an overlap is considered severe.</para>
      </remarks>
      <value>
        <para>The edge overlap penalty.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelModels.ILabelCandidateDescriptor.NodeOverlapPenalty">
      <summary>
        <para>Gets a penalty value that is used by labeling algorithms to judge the severity if this label candidate overlaps with a node's bounds.</para>
      </summary>
      <remarks>
        <para>This value must be between 0 and 1 (inclusive). A value of 0 means that an overlap is considered not important, while a value of 1 means that an overlap is considered severe.</para>
      </remarks>
      <value>
        <para>The node overlap penalty.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelModels.ILabelCandidateDescriptor.Profit">
      <summary>
        <para>Gets a profit value that is used by labeling algorithms to judge how good this label candidate is.</para>
      </summary>
      <remarks>
        <para>This value must be between 0 and 1 (inclusive). Higher profit means better candidates. Hence, there is a higher probability that the candidate is chosen by a labeling algorithm.</para>
      </remarks>
      <value>
        <para>The profit to be used by labeling algorithms.</para>
      </value>
    </member>
    <member name="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptorProvider">
      <summary>
        <para>An interface that can be used to retrieve <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptor" /> instances for a given pair of a <see cref="T:yWorks.Graph.ILabel" /> and a <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter">candidate parameter</see>.</para>
      </summary>
      <remarks>
        <para>This interface can be used by automatic labeling algorithms to help decide which labels candidate positions should be used.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptor" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.ILabelCandidateDescriptorProvider.GetDescriptor(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Gets the descriptor for a given pair of a label and a <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" />.</para>
      </summary>
      <param name="label">
        <para>The label to possibly assign the <paramref name="layoutParameter" />.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter to provide a descriptor for if applied to the given <paramref name="label" />.</para>
      </param>
      <returns>
        <para>A descriptor or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.LabelModels.ConstantLabelCandidateDescriptorProvider">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptorProvider" /> interface that always yields a constant <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptor" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ConstantLabelCandidateDescriptorProvider.ExternalDescriptorProvider">
      <summary>
        <para>A sharable implementation of the <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptorProvider" /> interface that always yields <see cref="F:yWorks.Graph.LabelModels.LabelCandidateDescriptor.ExternalDescriptor" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.ConstantLabelCandidateDescriptorProvider.InternalDescriptorProvider">
      <summary>
        <para>A sharable implementation of the <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptorProvider" /> interface that always yields <see cref="F:yWorks.Graph.LabelModels.LabelCandidateDescriptor.InternalDescriptor" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.ConstantLabelCandidateDescriptorProvider.#ctor(yWorks.Graph.LabelModels.ILabelCandidateDescriptor)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LabelModels.ConstantLabelCandidateDescriptorProvider" /> class that always yields <paramref name="descriptor" /> in <see cref="M:yWorks.Graph.LabelModels.ConstantLabelCandidateDescriptorProvider.GetDescriptor(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)" />.</para>
      </summary>
      <param name="descriptor">
        <para>The descriptor to yield in <see cref="M:yWorks.Graph.LabelModels.ConstantLabelCandidateDescriptorProvider.GetDescriptor(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.LabelModels.ConstantLabelCandidateDescriptorProvider.GetDescriptor(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Always yields the parameter that has been passed to the constructor.</para>
      </summary>
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.LabelCandidateDescriptor">
      <summary>
        <para>A simple mutable default implementation of the <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptor" /> interface.</para>
      </summary>
      <remarks>
        <para>All properties are read/write in this implementation.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.LabelCandidateDescriptor.ExternalDescriptor">
      <summary>
        <para>A sharable immutable implementation of the <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptor" /> interface that has penalties of <c>1.0d</c> and a profit of <c>1.0d</c> and yields <c>true</c> for the <see cref="P:yWorks.Graph.LabelModels.ILabelCandidateDescriptor.ExternalCandidate" /> property.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.LabelCandidateDescriptor.InternalDescriptor">
      <summary>
        <para>A sharable immutable implementation of the <see cref="T:yWorks.Graph.LabelModels.ILabelCandidateDescriptor" /> interface that has penalties of <c>1.0d</c> and a profit of <c>1.0d</c> and yields <c>false</c> for the <see cref="P:yWorks.Graph.LabelModels.ILabelCandidateDescriptor.ExternalCandidate" /> property.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.LabelModels.ILabelModelParameter">
      <summary>
        <para>Defines a state that can be used to <see cref="M:yWorks.Graph.LabelModels.ILabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">determine the geometry of a label</see> with a <see cref="T:yWorks.Graph.LabelModels.ILabelModel" />.</para>
      </summary>
      <remarks>
        <para>Typically, implementations of this interface are created by factory methods of the corresponding <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" />.</para>
        <para>This interface extends the <see cref="T:System.ICloneable" /> interface. This allows clients to obtain a persistent copy of the current state of this parameter. Immutable parameter implementations may return themselves.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.LabelModels.ILabelModel" />
      <seealso cref="T:yWorks.Graph.ILabel" />
    </member>
    <member name="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model">
      <summary>
        <para>Gets the model that can be used to determine the geometry of a label given this parameter and a label instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.ILabelModelParameter.Supports(yWorks.Graph.ILabel)">
      <summary>
        <para>Determines whether this parameter can be used for a given label instance.</para>
      </summary>
      <remarks>
        <para>A parameter must not necessarily support all types of labels. This method returns whether it supports the given <paramref name="label" />. For example, a parameter might only support labels that are owned by an <see cref="T:yWorks.Graph.INode" />.</para>
      </remarks>
      <param name="label">
        <para>The label to test.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this instance can be used for the given label, <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder">
      <summary>
        <para>Utility interface used by <see cref="T:yWorks.Graph.LabelModels.ILabelModel" /> implementations to find the best <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> to approximate a given layout.</para>
      </summary>
      <remarks>
        <para>Implementations of this class may be retrieved from <see cref="T:yWorks.Graph.LabelModels.ILabelModel" /> implementations using their <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method. Note that implementations are not required to return an instance if queried for this interface.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.ILabelModelParameterFinder.FindBestParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel,yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Tries to find a parameter that best matches the given layout for the provided label instance.</para>
      </summary>
      <remarks>
        <para>This method may not necessarily find a parameter that matches the provided layout exactly. Implementations may choose to simply return the model's <see cref="M:yWorks.Graph.LabelModels.ILabelModel.CreateDefaultParameter">default parameter</see> but may never return <c>null</c>.</para>
      </remarks>
      <param name="label">
        <para>The label to find a parameter for.</para>
      </param>
      <param name="model">
        <para>The model instance to use. This should be the instance this instance has been obtained from.</para>
      </param>
      <param name="layout">
        <para>The anticipated layout for the label.</para>
      </param>
      <returns>
        <para>A non-<c>null</c> parameter that can be used for the label to approximate the provided layout.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder">
      <summary>
        <para>A simple default implementation of the <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterFinder" /> interface that uses the <see cref="T:yWorks.Graph.LabelModels.ILabelModel" />'s own <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterProvider" /> instance to find the closest match.</para>
      </summary>
      <remarks>
        <para>This implementation uses a metric to find the closest of the provided parameter candidates to the layout provided in <see cref="M:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder.FindBestParameter(yWorks.Graph.ILabel,yWorks.Geometry.IOrientedRectangle,System.Collections.Generic.IEnumerable{yWorks.Graph.LabelModels.ILabelModelParameter})" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder.Instance">
      <summary>
        <para>A singleton instance of this class.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder.FindBestParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel,yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Tries to find a parameter that best matches the given layout for the provided label instance.</para>
      </summary>
      <param name="label">
        <para>The label to find a parameter for.</para>
      </param>
      <param name="model">
        <para>The model instance to use. This should be the instance this instance has been obtained from.</para>
      </param>
      <param name="layout">
        <para>The anticipated layout for the label.</para>
      </param>
      <returns>
        <para>A non-<c>null</c> parameter that can be used for the label to approximate the provided layout.</para>
      </returns>
      <remarks>
        <para>This method may not necessarily find a parameter that matches the provided layout exactly. It will first query the <see cref="M:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder.GetCandidateParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)" /> parameter for an enumeration of candidates and will then find the best matching candidate using a metric calculated by <see cref="M:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder.CalculateMetric(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Geometry.IOrientedRectangle)" />. If no parameter can be found this method returns the <see cref="M:yWorks.Graph.LabelModels.ILabelModel.CreateDefaultParameter">default parameter</see> for the model.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder.FindBestParameter(yWorks.Graph.ILabel,yWorks.Geometry.IOrientedRectangle,System.Collections.Generic.IEnumerable{yWorks.Graph.LabelModels.ILabelModelParameter})">
      <summary>
        <para>Tries to find a parameter that best matches the given layout for the provided label instance among the set of given parameters.</para>
      </summary>
      <param name="label">
        <para>The label to find a parameter for.</para>
      </param>
      <param name="layout">
        <para>The anticipated layout for the label.</para>
      </param>
      <param name="layoutParameters">
        <para>A set of parameters to choose from.</para>
      </param>
      <returns>
        <para>A parameter that can be used for the label to approximate the provided layout.</para>
      </returns>
      <remarks>
        <para>Null may be returned if an empty enumerable is passed.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder.GetCandidateParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <summary>
        <para>Retrieves an enumerator over all candidates for a given label and model.</para>
      </summary>
      <param name="label">
        <para>The label.</para>
      </param>
      <param name="model">
        <para>The model of the label.</para>
      </param>
      <returns>
        <para>An enumerator over the candidates. The enumerator may be empty.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder.CalculateMetric(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Calculates a metric for the given label/parameter pair and the target label layout.</para>
      </summary>
      <remarks>
        <para>This implementation gets the geometry from the parameter's model's <see cref="M:yWorks.Graph.LabelModels.ILabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)" /> method and returns the result of a call to <see cref="M:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder.Distance(yWorks.Geometry.IOrientedRectangle,yWorks.Geometry.IOrientedRectangle)" />.</para>
      </remarks>
      <param name="label">
        <para>The label to apply the parameter to.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter candidate.</para>
      </param>
      <param name="layout">
        <para>The targeted layout rectangle.</para>
      </param>
      <returns>
        <para>A metric that indicates the distance between the candidate's layout and the target layout.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.DefaultLabelModelParameterFinder.Distance(yWorks.Geometry.IOrientedRectangle,yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Returns the distance between two <see cref="T:yWorks.Geometry.IOrientedRectangle" /> instances.</para>
      </summary>
      <remarks>
        <para>The distance is calculated using the Euclidean distance between the two centers and the angular deviation between the two up vectors.</para>
      </remarks>
      <param name="rectangle1">
        <para>The first geometry.</para>
      </param>
      <param name="rectangle2">
        <para>The geometry to compare the first one with.</para>
      </param>
      <returns>
        <para>A value indicating the distance between the two instances.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.LabelModels.ILabelModelParameterProvider">
      <summary>
        <para>Helper interface used by <see cref="T:yWorks.Graph.LabelModels.ILabelModel" /> implementations to provide possible candidate <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" />s for a given label and model.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface can be retrieved from the <see cref="T:yWorks.Graph.LabelModels.ILabelModel" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method. Note that not all models necessarily need to or can provide implementations of this interface.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.ILabelModelParameterProvider.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <summary>
        <para>Returns an enumerator over a set of possible <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> instances that can be used for the given label and model.</para>
      </summary>
      <param name="label">
        <para>The label instance to use.</para>
      </param>
      <param name="model">
        <para>The model to provide parameters for.</para>
      </param>
      <returns>
        <para>A possibly empty enumerator over a set of label model parameters.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.ILabelOwner">
      <summary>
        <para>Common interface for items in an <see cref="T:yWorks.Graph.IGraph" /> implementation that may own <see cref="T:yWorks.Graph.ILabel">labels</see>.</para>
      </summary>
      <remarks>
        <para>Like all items in an <c>IGraph</c>, this item supports the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method that can be used to query additional aspects of the item.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.INode" />
      <seealso cref="T:yWorks.Graph.IEdge" />
    </member>
    <member name="P:yWorks.Graph.ILabelOwner.Labels">
      <summary>
        <para>Gets a collection of <see cref="T:yWorks.Graph.ILabel">labels</see> that are owned by this instance.</para>
      </summary>
      <remarks>
        <para>This gives access to a read-only live view of the labels, i.e. the collection can change over time, as well as the labels contained in it. If a snapshot of the current state is needed, one needs to copy the collection and its contents.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.IMapperRegistry">
      <summary>
        <para>A registry that can be used to store <see cref="T:yWorks.Graph.IMapper`2" /> implementations by tag.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface can be found in the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the default <see cref="T:yWorks.Graph.IGraph" /> implementations in the framework.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.MapperRegistry" />
    </member>
    <member name="M:yWorks.Graph.IMapperRegistry.GetMapper``2(System.Object)">
      <summary>
        <para>Returns a mapper that has previously been registered with this instance for the given tag.</para>
      </summary>
      <typeparam name="K">
        <para>The key type for the mapper.</para>
      </typeparam>
      <typeparam name="V">
        <para>The value type for the mapper.</para>
      </typeparam>
      <param name="tag">
        <para>The tag to use to look up the mapper.</para>
      </param>
      <returns>
        <para>The previously registered instance or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IMapperRegistry.AddMapper``2(System.Object,yWorks.Graph.IMapper{``0,``1})">
      <summary>
        <para>Registers a mapper for the given tag.</para>
      </summary>
      <remarks>
        <para>If there already was a mapper for <paramref name="tag" />, it will be replaced.</para>
      </remarks>
      <typeparam name="K">
        <para>The key type for the mapper.</para>
      </typeparam>
      <typeparam name="V">
        <para>The value type for the mapper.</para>
      </typeparam>
      <param name="tag">
        <para>The tag to use.</para>
      </param>
      <param name="mapper">
        <para>The mapper to register.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.IMapperRegistry.RemoveMapper(System.Object)">
      <summary>
        <para>Removes a previously registered mapper for the given tag.</para>
      </summary>
      <param name="tag">
        <para>The tag that has been used for registering the mapper.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.IMapperRegistry.RegisteredTags">
      <summary>
        <para>Gets an enumerable over all tags that have been used to register mapper implementations with this interface.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.IMapperRegistry.GetMapperMetadata(System.Object)">
      <summary>
        <para>Gets the mapper <see cref="T:yWorks.Graph.MapperMetadata">meta data</see> for the mapper that is registered using the <paramref name="tag" />.</para>
      </summary>
      <param name="tag">
        <para>The tag.</para>
      </param>
      <returns>
        <para>The meta data or <c>null</c> if there is no such mapper registered for the given tag.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IMapperRegistry.SetMapperMetadata(System.Object,yWorks.Graph.MapperMetadata)">
      <summary>
        <para>Sets the mapper meta data for the mapper that has been <see cref="M:yWorks.Graph.IMapperRegistry.AddMapper``2(System.Object,yWorks.Graph.IMapper{``0,``1})">registered</see> using the provided <paramref name="tag" />.</para>
      </summary>
      <param name="tag">
        <para>The tag.</para>
      </param>
      <param name="metadata">
        <para>The meta data to store with the mapper.</para>
      </param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <para>If the <see cref="P:yWorks.Graph.MapperMetadata.KeyType" /> or <see cref="P:yWorks.Graph.MapperMetadata.ValueType" /> mismatch the mapper instance in the registry.</para>
      </exception>
    </member>
    <member name="T:yWorks.Graph.MapperRegistryExtensions">
      <summary>
        <para>Provides static convenience extension methods for the <see cref="T:yWorks.Graph.IMapperRegistry" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.MapperRegistryExtensions.CreateWeakMapper``2(yWorks.Graph.IMapperRegistry,System.Object)">
      <summary>
        <para>Creates and <see cref="M:yWorks.Graph.IMapperRegistry.AddMapper``2(System.Object,yWorks.Graph.IMapper{``0,``1})">adds</see> a new <see cref="T:yWorks.Graph.WeakDictionaryMapper`2" /> to the <paramref name="registry" /> using the provided <paramref name="tag" />.</para>
      </summary>
      <remarks>
        <para>If there already was a mapper for <paramref name="tag" />, it will be replaced.</para>
      </remarks>
      <typeparam name="K">
        <para>The type of the keys of the mapper.</para>
      </typeparam>
      <typeparam name="V">
        <para>The type of the values of the mapper.</para>
      </typeparam>
      <param name="registry">
        <para>The registry.</para>
      </param>
      <param name="tag">
        <para>The tag.</para>
      </param>
      <returns>
        <para>The newly created mapper instance.</para>
      </returns>
      <seealso cref="T:yWorks.Graph.WeakDictionaryMapper`2" />
    </member>
    <member name="M:yWorks.Graph.MapperRegistryExtensions.CreateMapper``2(yWorks.Graph.IMapperRegistry,System.Object)">
      <summary>
        <para>Creates and <see cref="M:yWorks.Graph.IMapperRegistry.AddMapper``2(System.Object,yWorks.Graph.IMapper{``0,``1})">adds</see> a new <see cref="T:yWorks.Graph.DictionaryMapper`2" /> to the <paramref name="registry" /> using the provided <paramref name="tag" />.</para>
      </summary>
      <remarks>
        <para>If there already was a mapper for <paramref name="tag" />, it will be replaced.</para>
      </remarks>
      <typeparam name="K">
        <para>The type of the keys of the mapper.</para>
      </typeparam>
      <typeparam name="V">
        <para>The type of the values of the mapper.</para>
      </typeparam>
      <param name="registry">
        <para>The registry.</para>
      </param>
      <param name="tag">
        <para>The tag.</para>
      </param>
      <returns>
        <para>The newly created mapper instance.</para>
      </returns>
      <seealso cref="T:yWorks.Graph.DictionaryMapper`2" />
    </member>
    <member name="M:yWorks.Graph.MapperRegistryExtensions.CreateDelegateMapper``2(yWorks.Graph.IMapperRegistry,System.Object,yWorks.Graph.MapperDelegate{``0,``1})">
      <summary>
        <para>Creates a delegate-based read-only <see cref="T:yWorks.Graph.IMapper`2" /> implementation and <see cref="M:yWorks.Graph.IMapperRegistry.AddMapper``2(System.Object,yWorks.Graph.IMapper{``0,``1})">adds</see> it to the <paramref name="registry" /> using the provided <paramref name="tag" />.</para>
      </summary>
      <remarks>
        <para>If there already was a mapper for <paramref name="tag" />, it will be replaced.</para>
      </remarks>
      <typeparam name="K">
        <para>The type of the keys of the mapper.</para>
      </typeparam>
      <typeparam name="V">
        <para>The type of the values of the mapper.</para>
      </typeparam>
      <param name="registry">
        <para>The registry.</para>
      </param>
      <param name="tag">
        <para>The tag.</para>
      </param>
      <param name="getter">
        <para>The getter delegate to which <see cref="T:yWorks.Graph.IMapper`2" /> reads will be delegated.</para>
      </param>
      <returns>
        <para>The newly created mapper instance.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Mappers.FromDelegate``2(yWorks.Graph.MapperDelegate{``0,``1})" />
    </member>
    <member name="M:yWorks.Graph.MapperRegistryExtensions.CreateConstantMapper``2(yWorks.Graph.IMapperRegistry,System.Object,``1)">
      <summary>
        <para>Creates a simple read-only <see cref="T:yWorks.Graph.IMapper`2" /> implementation and <see cref="M:yWorks.Graph.IMapperRegistry.AddMapper``2(System.Object,yWorks.Graph.IMapper{``0,``1})">adds</see> it to the <paramref name="registry" /> using the provided <paramref name="tag" />.</para>
      </summary>
      <remarks>
        <para>If there already was a mapper for <paramref name="tag" />, it will be replaced.</para>
      </remarks>
      <typeparam name="K">
        <para>The type of the keys of the mapper.</para>
      </typeparam>
      <typeparam name="V">
        <para>The type of the values of the mapper.</para>
      </typeparam>
      <param name="registry">
        <para>The registry.</para>
      </param>
      <param name="tag">
        <para>The tag.</para>
      </param>
      <param name="constant">
        <para>The value to yield during <see cref="T:yWorks.Graph.IMapper`2" /> reads.</para>
      </param>
      <returns>
        <para>The newly created mapper instance.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Mappers.FromConstant``2(``1)" />
    </member>
    <member name="M:yWorks.Graph.MapperRegistryExtensions.GetObjectObjectMapper(yWorks.Graph.IMapperRegistry,System.Object)">
      <summary>
        <para>Returns a mapper instance for which there has previously been registered an instance for the given tag, however using a different type parameter set.</para>
      </summary>
      <param name="registry">
        <para>The registry to retrieve and wrap the mapper from.</para>
      </param>
      <param name="tag">
        <para>The tag to use to look up the mapper.</para>
      </param>
      <returns>
        <para>An instance that delegates to the original mapper or <c>null</c> if no mapper has been found for the provided tag.</para>
      </returns>
      <remarks>
        <para>If the original mapper instance matches the type parameters, it will be returned, otherwise a dynamic wrapping implementation will be returned. This method can be used by generic code that does not know about the exact type parameters.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.INode">
      <summary>
        <para>The interface for node entities in an <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <remarks>
        <para>This interface provides read-only access to the properties of a node. In order to modify the state of an instance use the various methods provided by the <see cref="T:yWorks.Graph.IGraph" /> this instance belongs to. Nodes and <see cref="T:yWorks.Graph.IEdge">edges</see> are the main entities that make up an <see cref="T:yWorks.Graph.IGraph" />. Nodes have zero or more <see cref="P:yWorks.Graph.IPortOwner.Ports" /> to which zero or more edges can connect. <see cref="T:yWorks.Graph.IGraph" /> provides the <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPortOwner,yWorks.Graph.AdjacencyTypes)" /> method for querying the edges that connect to nodes. Also it is possible to query the <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)">adjacent edges for each port</see> that is owned by nodes. This interface combines the functionality of <see cref="T:yWorks.Graph.IPortOwner" /> to get access to the ports, <see cref="T:yWorks.Graph.ILabelOwner" /> to get access to the labels, and, like all items in an <c>IGraph</c>, nodes support the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method inherited from the <see cref="T:yWorks.Graph.IModelItem" /> interface can be used to query additional aspects of each instance.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IGraph" />
      <seealso cref="T:yWorks.Graph.IEdge" />
    </member>
    <member name="P:yWorks.Graph.INode.Layout">
      <summary>
        <para>Gets a live view of the layout of the node.</para>
      </summary>
      <remarks>
        <para>The layout of a node is a rectangle in the world coordinate system that describes the bounding box of the representation of a node. Since this method will yield a live view, it is up to the client to copy the values of the instance if a snapshot of the state is needed. In order to modify the layout of a node, use the <see cref="M:yWorks.Graph.IGraph.SetNodeLayout(yWorks.Graph.INode,yWorks.Geometry.RectD)">various methods</see> in <see cref="T:yWorks.Graph.IGraph" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.INode.Style">
      <summary>
        <para>Gets the style that is responsible for the visual representation of this node in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>In order to set the style on an instance, use the <see cref="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> method. Note that the style instance associated with a node instance may be shared between multiple node instances and that the modification of this style will result in a change of the appearance of all nodes that are associated with the same style instance.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.INodeDefaults">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.IGraph" /> and the like to declare and obtain the defaults for nodes and their labels or ports.</para>
      </summary>
      <remarks>
        <para>Note that changing these defaults does <i>not</i> change properties of already created model items. Rather, only items created after the change are affected.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.IGraph.NodeDefaults" />
      <seealso cref="P:yWorks.Graph.IGraph.GroupNodeDefaults" />
    </member>
    <member name="P:yWorks.Graph.INodeDefaults.Style">
      <summary>
        <para>Gets or sets the style to use for nodes.</para>
      </summary>
      <remarks>
        <para>Depending on the setting of <see cref="P:yWorks.Graph.INodeDefaults.ShareStyleInstance" />, the <see cref="M:yWorks.Graph.INodeDefaults.GetStyleInstance" /> method should return a <see cref="M:System.ICloneable.Clone">clone</see> of this instance or the very same instance.</para>
      </remarks>
      <value>
        <para>The style to use as a template.</para>
      </value>
      <seealso cref="P:yWorks.Graph.INodeDefaults.ShareStyleInstance" />
    </member>
    <member name="M:yWorks.Graph.INodeDefaults.GetStyleInstance">
      <summary>
        <para>Factory method that returns a style instance for use with newly created nodes.</para>
      </summary>
      <remarks>
        <para>Most implementations will yield either, a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.INodeDefaults.Style" /> property, if <see cref="P:yWorks.Graph.INodeDefaults.ShareStyleInstance" /> is enabled, but they might use more complicated logic, too.</para>
      </remarks>
      <returns>
        <para>The style to use, which for most implementations is either a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.INodeDefaults.Style" /> property, if <see cref="P:yWorks.Graph.INodeDefaults.ShareStyleInstance" /> is enabled.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.INodeDefaults.ShareStyleInstance">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.INodeDefaults.Style" /> instance should be shared referentially or <see cref="M:System.ICloneable.Clone">cloned</see> upon a call to <see cref="M:yWorks.Graph.INodeDefaults.GetStyleInstance" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the reference should be shared; <c>false</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Graph.INodeDefaults.GetStyleInstance" />
      <seealso cref="P:yWorks.Graph.INodeDefaults.Style" />
    </member>
    <member name="P:yWorks.Graph.INodeDefaults.Ports">
      <summary>
        <para>Gets or sets the defaults for ports at nodes.</para>
      </summary>
      <value>
        <para>The port defaults.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.INodeDefaults.Labels">
      <summary>
        <para>Gets or sets the defaults for labels at nodes.</para>
      </summary>
      <value>
        <para>The label defaults.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.INodeDefaults.Size">
      <summary>
        <para>Gets or sets the default node size.</para>
      </summary>
      <remarks>
        <para>The values of this size will be used by the <see cref="M:yWorks.Graph.GraphExtensions.CreateNode(yWorks.Graph.IGraph,yWorks.Geometry.PointD,yWorks.Graph.Styles.INodeStyle,System.Object)" /> and <see cref="M:yWorks.Graph.GraphExtensions.CreateNode(yWorks.Graph.IGraph,yWorks.Geometry.PointD,yWorks.Graph.Styles.INodeStyle,System.Object)" /> methods.</para>
      </remarks>
      <value>
        <para>The default size of newly created nodes.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.Input.INodeSnapResultProvider">
      <summary>
        <para>Interface that is used by the <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> for <see cref="T:yWorks.Graph.INode">nodes</see> to collect a number of <see cref="T:yWorks.Controls.Input.SnapResult" />s during the move/edit operation.</para>
      </summary>
      <remarks>
        <para>This interface is queried from the <see cref="T:yWorks.Graph.ILookup" /> of the <see cref="T:yWorks.Graph.INode" />s that are being moved during the edit.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.GraphSnapContext" />
      <seealso cref="P:yWorks.Graph.NodeDecorator.NodeSnapResultProviderDecorator" />
    </member>
    <member name="M:yWorks.Controls.Input.INodeSnapResultProvider.CollectSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.RectD,yWorks.Graph.INode)">
      <summary>
        <para>Called when a node is <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">dragged</see> to add <see cref="T:yWorks.Controls.Input.SnapResult" />s for <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s to which this node can potentially snap.</para>
      </summary>
      <param name="context">
        <para>The snap context which manages the snap lines and the settings.</para>
      </param>
      <param name="args">
        <para>The event argument to obtain the necessary information from and <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">add results to</see>.</para>
      </param>
      <param name="suggestedLayout">
        <para>The <see cref="P:yWorks.Graph.INode.Layout">layout</see> of the node if the node would not snap.</para>
      </param>
      <param name="node">
        <para>The node that is being moved.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.IEdgeSnapResultProvider">
      <summary>
        <para>Interface for classes that help during snapping of parts of edges.</para>
      </summary>
      <remarks>
        <para>An implementation of this class is obtained from the lookup of the <see cref="T:yWorks.Graph.IEdge" />s which are being edited during an operation where <see cref="T:yWorks.Controls.Input.GraphSnapContext">graph snapping</see> is involved.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.EdgeDecorator.EdgeSnapResultProviderDecorator" />
    </member>
    <member name="M:yWorks.Controls.Input.IEdgeSnapResultProvider.CollectSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Utils.IListEnumerable{yWorks.Controls.Input.MovementInfo},yWorks.Graph.IEdge)">
      <summary>
        <para>Called to during the snapping operation whenever <see cref="E:yWorks.Controls.Input.SnapContext.CollectSnapResults">snap results are collected</see>.</para>
      </summary>
      <remarks>
        <para>This method will be called for each collection of the results.</para>
      </remarks>
      <param name="context">
        <para>The context that is using this instance.</para>
      </param>
      <param name="args">
        <para>The event argument to obtain the necessary information from and <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">add results to</see>.</para>
      </param>
      <param name="movementInfos">
        <para>The movement infos that describe the <paramref name="edge" />.</para>
      </param>
      <param name="edge">
        <para>The edge for which the <see cref="T:yWorks.Controls.Input.SnapResult" />s should be <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">collected</see>.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.IBendSnapResultProvider">
      <summary>
        <para>Interface that is used by the <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> for <see cref="T:yWorks.Graph.IBend">bends</see> to collect a number of <see cref="T:yWorks.Controls.Input.SnapResult" />s during the move/edit operation.</para>
      </summary>
      <remarks>
        <para>This interface is queried from the <see cref="T:yWorks.Graph.ILookup" /> of the <see cref="T:yWorks.Graph.IBend" />s that are being moved during the edit.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.GraphSnapContext" />
      <seealso cref="P:yWorks.Graph.BendDecorator.BendSnapResultProviderDecorator" />
    </member>
    <member name="M:yWorks.Controls.Input.IBendSnapResultProvider.CollectSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.PointD,yWorks.Graph.IBend)">
      <summary>
        <para>Called when a node is <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">dragged</see> to add <see cref="T:yWorks.Controls.Input.SnapResult" />s for <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s to which this bend can potentially snap.</para>
      </summary>
      <param name="context">
        <para>The snap context which manages the snap lines and the settings.</para>
      </param>
      <param name="args">
        <para>The event argument to obtain the necessary information from and <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">add results to</see>.</para>
      </param>
      <param name="suggestedLocation">
        <para>The <see cref="P:yWorks.Graph.IBend.Location">location</see> of the bend if the bend would not snap.</para>
      </param>
      <param name="bend">
        <para>The bend that is being moved.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.IPortSnapResultProvider">
      <summary>
        <para>Interface that is used by the <see cref="T:yWorks.Controls.Input.GraphSnapContext" /> for <see cref="T:yWorks.Graph.IPort">port</see> to collect a number of <see cref="T:yWorks.Controls.Input.SnapResult" />s during the move/edit operation.</para>
      </summary>
      <remarks>
        <para>This interface is queried from the <see cref="T:yWorks.Graph.ILookup" /> of the <see cref="T:yWorks.Graph.IPort" />s that are being moved during the edit.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.GraphSnapContext" />
      <seealso cref="P:yWorks.Graph.PortDecorator.PortSnapResultProviderDecorator" />
    </member>
    <member name="M:yWorks.Controls.Input.IPortSnapResultProvider.CollectSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Geometry.PointD,yWorks.Graph.IPort)">
      <summary>
        <para>Called when a node is <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">dragged</see> to add <see cref="T:yWorks.Controls.Input.SnapResult" />s for <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s to which this bend can potentially snap.</para>
      </summary>
      <param name="context">
        <para>The snap context which manages the snap lines and the settings.</para>
      </param>
      <param name="args">
        <para>The event argument to obtain the necessary information from and <see cref="M:yWorks.Controls.Input.CollectSnapResultsEventArgs.AddSnapResult(yWorks.Controls.Input.SnapResult)">add results to</see>.</para>
      </param>
      <param name="suggestedLocation">
        <para>The <see cref="P:yWorks.Graph.IBend.Location">location</see> of the bend if the bend would not snap.</para>
      </param>
      <param name="port">
        <para>The port that is being moved</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.INodeReshapeSnapResultProvider">
      <summary>
        <para>Interface for an implementation which evaluates a list of given <see cref="T:yWorks.Controls.Input.SnapLine" />s for a node which is resized and adds a set of <see cref="T:yWorks.Controls.Input.SnapResult" />s for sizes to which this node can potentially snap.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.INodeReshapeSnapResultProvider.CollectSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext)">
      <summary>
        <para>Called when a node's handle is <see cref="M:yWorks.Controls.Input.IDragHandler.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">dragged</see> to add <see cref="T:yWorks.Controls.Input.SnapResult" />s for <see cref="T:yWorks.Controls.Input.OrthogonalSnapLine" />s or sizes to which this node can potentially snap during resizing.</para>
      </summary>
      <param name="context">
        <para>The snap context which manages the snap lines and the settings.</para>
      </param>
      <param name="args">
        <para>The event argument to obtain the context from and add the results to.</para>
      </param>
      <param name="node">
        <para>The node that is being reshaped.</para>
      </param>
      <param name="reshapeContext">
        <para>Carries information about the reshape operation.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.Input.ReshapeRectangleContext">
      <summary>
        <para>Helper class that carries information about a reshape operation.</para>
      </summary>
      <remarks>
        <para>This class is mainly intended for use by <see cref="M:yWorks.Controls.Input.INodeReshapeSnapResultProvider.CollectSnapResults(yWorks.Controls.Input.GraphSnapContext,yWorks.Controls.Input.CollectSnapResultsEventArgs,yWorks.Graph.INode,yWorks.Controls.Input.ReshapeRectangleContext)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.ReshapeRectangleContext.#ctor(yWorks.Geometry.RectD,yWorks.Geometry.ISize,yWorks.Geometry.ISize,yWorks.Geometry.IRectangle,yWorks.Controls.Input.HandlePositions,yWorks.Geometry.PointD,yWorks.Geometry.PointD,yWorks.Geometry.SizeD)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.ReshapeRectangleContext" /> class.</para>
      </summary>
      <param name="initialBounds">
        <para>The initial bounds of the node.</para>
      </param>
      <param name="minimumSize">
        <para>The minimum size of the node.</para>
      </param>
      <param name="maximumSize">
        <para>The maximum size of the node.</para>
      </param>
      <param name="minimumEnclosedArea">
        <para>The minimum area the node's layout needs to encompass.</para>
      </param>
      <param name="reshapePosition">
        <para>The position of the reshape handle.</para>
      </param>
      <param name="topLeftChangeFactor">
        <para>The factor by which the top left corner of the node layout changes when the handle is dragged.</para>
      </param>
      <param name="bottomRightChangeFactor">
        <para>The factor by which the bottom right corner of the node layout changes when the handle is dragged.</para>
      </param>
      <param name="sizeChangeFactor">
        <para>The factor by which the size of the node layout changes when the handle is dragged.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeRectangleContext.InitialBounds">
      <summary>
        <para>Gets the initial bounds of the node.</para>
      </summary>
      <value>
        <para>The initial bounds of the node.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeRectangleContext.MinimumSize">
      <summary>
        <para>Gets the minimum size of the node.</para>
      </summary>
      <value>
        <para>The minimum size.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeRectangleContext.MaximumSize">
      <summary>
        <para>Gets or sets the maximum size of the node.</para>
      </summary>
      <value>
        <para>The maximum size.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeRectangleContext.MinimumEnclosedArea">
      <summary>
        <para>Gets minimum area the node's layout needs to encompass</para>
      </summary>
      <value>
        <para>The minimum enclosed area. If the area is <see cref="M:yWorks.Geometry.RectangleExtensions.IsEmpty(yWorks.Geometry.IRectangle)">empty</see> the value can be ignored.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeRectangleContext.ReshapePosition">
      <summary>
        <para>Gets the position of the reshape handle.</para>
      </summary>
      <value>
        <para>The reshape position.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeRectangleContext.TopLeftChangeFactor">
      <summary>
        <para>Gets the factor by which the top left corner of the node layout changes when the handle is dragged.</para>
      </summary>
      <value>
        <para>The top left change factor.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeRectangleContext.BottomRightChangeFactor">
      <summary>
        <para>Gets the factor by which the bottom right corner of the node layout changes when the handle is dragged.</para>
      </summary>
      <value>
        <para>The bottom right change factor.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.ReshapeRectangleContext.SizeChangeFactor">
      <summary>
        <para>Gets the factor by which the size of the node layout changes when the handle is dragged.</para>
      </summary>
      <value>
        <para>The size change factor.</para>
      </value>
    </member>
    <member name="T:yWorks.Graph.IPort">
      <summary>
        <para>The interface used in an <see cref="T:yWorks.Graph.IGraph" /> implementation for <see cref="T:yWorks.Graph.IEdge" />s to connect to.</para>
      </summary>
      <remarks>
        <para>This interface provides read-only access to the properties of a port. In order to modify the state of an instance use the various methods provided by the <see cref="T:yWorks.Graph.IGraph" /> this instance belongs to. Ports are owned by <see cref="T:yWorks.Graph.IPortOwner">IPortOwners</see>, normally an <see cref="T:yWorks.Graph.INode" />, but this can also be an <see cref="T:yWorks.Graph.IEdge" /> in special graph implementations. To obtain the <see cref="T:yWorks.Graph.IEdge" /> instances that are connected to a certain port instance, applications need to use the <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)" /> method provided by <see cref="T:yWorks.Graph.IGraph" /> or the corresponding convenience extension methods in <see cref="T:yWorks.Graph.GraphExtensions" />. Zero or more edges may be connected to a port, depending on the implementation of the graph. Like all items in an <c>IGraph</c>, this item supports the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method that can be used to query additional aspects of the item.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IPort.Owner">
      <summary>
        <para>Gets the owner of this port.</para>
      </summary>
      <remarks>
        <para>In traditional <see cref="T:yWorks.Graph.IGraph" /> implementations, this will be an <see cref="T:yWorks.Graph.INode" /> and can safely be cast to one. In order to get to the <see cref="T:yWorks.Graph.IEdge" />s that connect to this instance, use <see cref="T:yWorks.Graph.IGraph" />'s <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)" /> method.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IPort.Style">
      <summary>
        <para>Gets the style that is responsible for the visual representation of this port in a <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </summary>
      <remarks>
        <para>In order to set the style on an instance, use the <see cref="M:yWorks.Graph.IGraph.SetStyle(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)" /> method. Note that the style instance associated with a port instance may be shared between multiple port instances and that the modification of this style will result in a change of the appearance of all ports that are associated with the same style instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IPort.LocationParameter">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" /> that is used to determine the location of this port.</para>
      </summary>
      <remarks>
        <para>The port location can be calculated using the <see cref="P:yWorks.Graph.PortLocationModels.IPortLocationModelParameter.Model" />'s <see cref="M:yWorks.Graph.PortLocationModels.IPortLocationModel.GetLocation(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" /> method or the convenience methods <see cref="M:yWorks.Graph.GraphExtensions.GetLocation(yWorks.Graph.IPort)" /> and <see cref="M:yWorks.Graph.GraphExtensions.GetDynamicLocation(yWorks.Graph.IPort)" />.</para>
        <para>Note that parameters may be shared across port instances.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.IGraph.SetPortLocationParameter(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)" />
      <seealso cref="M:yWorks.Graph.GraphExtensions.GetLocation(yWorks.Graph.IPort)" />
      <seealso cref="M:yWorks.Graph.GraphExtensions.GetDynamicLocation(yWorks.Graph.IPort)" />
    </member>
    <member name="T:yWorks.Graph.IPortOwner">
      <summary>
        <para>The common interface for items in an <see cref="T:yWorks.Graph.IGraph" /> that may own <see cref="T:yWorks.Graph.IPort">ports</see>.</para>
      </summary>
      <remarks>
        <para>Typically this interface is actively implemented by <see cref="T:yWorks.Graph.INode" />'s in an <see cref="T:yWorks.Graph.IGraph" />. To get to the edge instances that connect to the ports, the <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPortOwner,yWorks.Graph.AdjacencyTypes)" /> method can be used. Alternatively for each <see cref="T:yWorks.Graph.IPort" /> in <see cref="P:yWorks.Graph.IPortOwner.Ports" />, one can use the <see cref="M:yWorks.Graph.IGraph.EdgesAt(yWorks.Graph.IPort,yWorks.Graph.AdjacencyTypes)" /> method provided by <see cref="T:yWorks.Graph.IGraph" />. Like all items in an <c>IGraph</c>, this item supports the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method that can be used to query additional aspects of the item.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.INode" />
      <seealso cref="T:yWorks.Graph.IEdge" />
    </member>
    <member name="P:yWorks.Graph.IPortOwner.Ports">
      <summary>
        <para>Gets a collection of <see cref="T:yWorks.Graph.IPort">ports</see> that are owned by this instance.</para>
      </summary>
      <remarks>
        <para>This gives access to a read-only live view of the ports, i.e. the collection can change over time, as well as the ports contained in it. If a snapshot of the current state is needed, one needs to copy the collection.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.IPortCandidate">
      <summary>
        <para>An interface for possible <see cref="T:yWorks.Graph.IPort" /> candidates used by <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> and the like.</para>
      </summary>
      <remarks>
        <para>Note that if an instance's <see cref="P:yWorks.Controls.Input.IPortCandidate.Validity" /> property is <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" /> this instance <see cref="M:yWorks.Controls.Input.IPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> method serves as a factory for the actual candidates.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" />
      <seealso cref="T:yWorks.Controls.Input.IPortCandidateProvider" />
      <seealso cref="T:yWorks.Controls.Input.DefaultPortCandidate" />
    </member>
    <member name="P:yWorks.Controls.Input.IPortCandidate.CandidateTag">
      <summary>
        <para>Gets a user defined tag for this candidate.</para>
      </summary>
      <remarks>
        <para>The interpretation of this value is implementation dependent and may be used for visual feedback or interactive behavior.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.IPortCandidate.Validity">
      <summary>
        <para>Gets whether this instance is a valid port candidate.</para>
      </summary>
      <remarks>
        <para>Implementations of <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> may return sets of port candidates where some of them are marked as invalid e.g. in order to provide visual feedback. If the value is <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" />, method <see cref="M:yWorks.Controls.Input.IPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> needs to be used to determine a concrete candidate instance.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.IPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Controls.Input.IPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Returns a candidate that is derived from this instance that best fits the provided <paramref name="location" />.</para>
      </summary>
      <param name="context">
        <para>The input mode context for which a concrete candidate is queried.</para>
      </param>
      <param name="location">
        <para>The location for which a candidate should be returned.</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Controls.Input.IPortCandidate" /> implementation whose <see cref="P:yWorks.Controls.Input.IPortCandidate.Validity" /> is guaranteed to be non-<see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" />.</para>
      </returns>
      <remarks>
        <para>This method needs to be called by clients if the <see cref="P:yWorks.Controls.Input.IPortCandidate.Validity" /> of this instance is <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" />. In that case calling this method must return an instance whose validity is not <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.IPortCandidate.Validity" />
    </member>
    <member name="P:yWorks.Controls.Input.IPortCandidate.LocationParameter">
      <summary>
        <para>Gets the model parameter that will be used for the <see cref="P:yWorks.Graph.IPort.LocationParameter" /> if this candidate is chosen.</para>
      </summary>
      <remarks>
        <para>Note that the value of this property is undefined if this instance's <see cref="P:yWorks.Controls.Input.IPortCandidate.Validity" /> is <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" />. In this case, the parameter needs to be obtained via the <see cref="M:yWorks.Controls.Input.IPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> instance.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.IPortCandidate.Owner">
      <summary>
        <para>Gets the possible owner of the port to be created for this candidate.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.IPortCandidate.Port">
      <summary>
        <para>Gets the port instance that is already live in the graph if this candidate wraps an existing port or <c>null</c> otherwise.</para>
      </summary>
      <value>
        <para>The instance to use or <c>null</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.IPortCandidate.CreatePort(yWorks.Controls.Input.IInputModeContext)" />
    </member>
    <member name="M:yWorks.Controls.Input.IPortCandidate.CreatePort(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>If the client decides to use this port candidate, this method will serve as a factory to create the instance.</para>
      </summary>
      <param name="context">
        <para>The input mode context for which the port will be created. Implementations can depend on it providing an <see cref="T:yWorks.Graph.IGraph" /> instance in the lookup of the instance.</para>
      </param>
      <remarks>
        <para>If this candidate wraps an existing port, it may return that <see cref="P:yWorks.Controls.Input.IPortCandidate.Port">instance</see>. If this instance's <see cref="P:yWorks.Controls.Input.IPortCandidate.Validity" /> is <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" /> this method may throw an <see cref="T:System.NotSupportedException" />.</para>
      </remarks>
      <returns>
        <para>The port instance to use if this candidate has been chosen. This method may not return <c>null</c>.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphExtensions.GetGraph(yWorks.Controls.Input.IInputModeContext)" />
      <seealso cref="P:yWorks.Controls.Input.IPortCandidate.Port" />
      <seealso cref="M:yWorks.Controls.Input.IPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
      <exception cref="T:System.NotSupportedException">
        <para>If the <see cref="P:yWorks.Controls.Input.IPortCandidate.Validity" /> is <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" />.</para>
      </exception>
    </member>
    <member name="T:yWorks.Controls.Input.PortCandidateValidity">
      <summary>
        <para>Enumeration for the different possible <see cref="P:yWorks.Controls.Input.IPortCandidate.Validity" /> states.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.PortCandidateValidity.Valid">
      <summary>
        <para>The candidate is valid and can be used to connect an edge to.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.PortCandidateValidity.Invalid">
      <summary>
        <para>The candidate should not be used to connect an edge to.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic">
      <summary>
        <para>The candidate cannot be used to create a port, instead <see cref="M:yWorks.Controls.Input.IPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> needs to be called to obtain a <see cref="T:yWorks.Controls.Input.IPortCandidate" /> that is either <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Valid" /> or <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Invalid" />.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.IPortCandidateProvider">
      <summary>
        <para>This interface is used to provide <see cref="T:yWorks.Controls.Input.IPortCandidate" />s for a specific <see cref="T:yWorks.Graph.IPortOwner" />.</para>
      </summary>
      <remarks>
        <para>It is used in the context of the items that will later become the owner (<see cref="T:yWorks.Graph.IPortOwner" />) of the ports obtained from the candidates. They are mainly used during edge creation where there is no real edge yet (only the dummy edge) and thus they need to use the opposite <see cref="T:yWorks.Controls.Input.IPortCandidate" /> to understand the context.</para>
        <para>Implementations of this interface may be queried using the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method of <see cref="T:yWorks.Graph.IPortOwner" /> implementations like <see cref="T:yWorks.Graph.INode" />.</para>
        <para>Note that this interface is similar to the interface <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> in the sense that they will both provide <see cref="T:yWorks.Controls.Input.IPortCandidate" /> instances in a certain query context. They are used in different query contexts, though. The two interfaces can come together in concrete implementations of <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" />: an edge could potentially be connected to ports at any given <see cref="T:yWorks.Graph.IPortOwner" /> and thus the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> interface can be queried from the respective <see cref="T:yWorks.Graph.IPortOwner" /> that the edge will be reconnected to.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.NodeDecorator.PortCandidateProviderDecorator" />
    </member>
    <member name="M:yWorks.Controls.Input.IPortCandidateProvider.GetSourcePortCandidates(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.IPortCandidate)">
      <summary>
        <para>Returns all port candidates that apply for the provided opposite port candidate.</para>
      </summary>
      <remarks>
        <para>The enumerable may both contain <see cref="T:yWorks.Controls.Input.PortCandidateValidity">valid, invalid, and dynamic</see> port candidates.</para>
      </remarks>
      <param name="target">
        <para>The opposite port candidate.</para>
      </param>
      <param name="context">
        <para>The context for which the candidates should be provided.</para>
      </param>
      <returns>
        <para>An enumerable over all port candidates that are associated with the given opposite port.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IPortCandidateProvider.GetTargetPortCandidates(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.IPortCandidate)">
      <summary>
        <para>Returns all port candidates that apply for the provided opposite port candidate.</para>
      </summary>
      <remarks>
        <para>The enumerable may both contain <see cref="T:yWorks.Controls.Input.PortCandidateValidity">valid, invalid, and dynamic</see> port candidates.</para>
      </remarks>
      <param name="context">
        <para>The context for which the candidates should be provided.</para>
      </param>
      <param name="source">
        <para>The opposite port candidate.</para>
      </param>
      <returns>
        <para>An enumerable over all port candidates that are associated with the given opposite port.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IPortCandidateProvider.GetSourcePortCandidates(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Returns all source port candidates that belong to the context of this provider.</para>
      </summary>
      <remarks>
        <para>The enumerable may both contain <see cref="T:yWorks.Controls.Input.PortCandidateValidity">valid, invalid, and dynamic</see> port candidates.</para>
      </remarks>
      <param name="context">
        <para>The context for which the candidates should be provided.</para>
      </param>
      <returns>
        <para>An enumerable over all source port candidates that are associated with the current context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IPortCandidateProvider.GetTargetPortCandidates(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Returns all target port candidates that belong to the context of this provider.</para>
      </summary>
      <remarks>
        <para>The enumerable may both contain <see cref="T:yWorks.Controls.Input.PortCandidateValidity">valid, invalid, and dynamic</see> port candidates.</para>
      </remarks>
      <param name="context">
        <para>The context for which the candidates should be provided.</para>
      </param>
      <returns>
        <para>An enumerable over all target port candidates that are associated with the current context.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider">
      <summary>
        <para>This interface can be used to query <see cref="T:yWorks.Controls.Input.IPortCandidate" />s for a specific existing <see cref="T:yWorks.Graph.IEdge" /></para>
      </summary>
      <remarks>
        <para>As the name implies this is only used in the context of reconnecting existing edges. It is queried for existing edges to find out about possible alternative port candidates that given edge could connect to. It is used during gestures where an edge is reconnected to another port(candidate), i.e. when the source or target port handle of an edge is moved and the source or target port properties of the edge get set to the new <see cref="T:yWorks.Controls.Input.IPortCandidate" />s.</para>
        <para>Implementations of this interface can be queried using the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method of an <see cref="T:yWorks.Graph.IEdge" /> implementation. This interface provides alternative candidates for the <see cref="P:yWorks.Graph.IEdge.SourcePort" /> or <see cref="P:yWorks.Graph.IEdge.TargetPort" /> of an edge.</para>
        <para>Note that this interface is similar to the interface <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> in the sense that they will both provide <see cref="T:yWorks.Controls.Input.IPortCandidate" /> instances in a certain query context. They are used in different query contexts, though. The two interfaces can come together in concrete implementations of <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" />: an edge could potentially be connected to ports at any given <see cref="T:yWorks.Graph.IPortOwner" /> and thus the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> interface can be queried from the respective <see cref="T:yWorks.Graph.IPortOwner" /> that the edge will be reconnected to.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider.GetSourcePortCandidates(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Returns all source port candidates that may be used for the edge.</para>
      </summary>
      <remarks>
        <para>The enumerable may both contain <see cref="T:yWorks.Controls.Input.PortCandidateValidity">valid, invalid, and dynamic</see> port candidates.</para>
      </remarks>
      <param name="context">
        <para>The context for which the candidates should be provided.</para>
      </param>
      <returns>
        <para>An enumerable over all source port candidates that are associated with the current context edge.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider.GetTargetPortCandidates(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Returns all source port candidates that may be used for the edge.</para>
      </summary>
      <remarks>
        <para>The enumerable may both contain <see cref="T:yWorks.Controls.Input.PortCandidateValidity">valid, invalid, and dynamic</see> port candidates.</para>
      </remarks>
      <param name="context">
        <para>The context for which the candidates should be provided.</para>
      </param>
      <returns>
        <para>An enumerable over all target port candidates that are associated with the current context edge.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.IPortDefaults">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.IGraph" /> to declare and obtain the defaults for ports at nodes and edges.</para>
      </summary>
      <remarks>
        <para>Note that changing these defaults does <i>not</i> change properties of already created model items. Rather, only items created after the change are affected.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IPort" />
      <seealso cref="P:yWorks.Graph.INodeDefaults.Ports" />
      <seealso cref="P:yWorks.Graph.IEdgeDefaults.Ports" />
      <seealso cref="P:yWorks.Graph.IGraph.NodeDefaults" />
      <seealso cref="P:yWorks.Graph.IGraph.EdgeDefaults" />
    </member>
    <member name="P:yWorks.Graph.IPortDefaults.Style">
      <summary>
        <para>Gets or sets the style to use for ports.</para>
      </summary>
      <remarks>
        <para>Depending on the setting of <see cref="P:yWorks.Graph.IPortDefaults.ShareStyleInstance" />, the <see cref="M:yWorks.Graph.IPortDefaults.GetStyleInstance(yWorks.Graph.IPortOwner)" /> method should return a <see cref="M:System.ICloneable.Clone">clone</see> of this instance or the very same instance.</para>
      </remarks>
      <value>
        <para>The style to use as a template.</para>
      </value>
      <seealso cref="P:yWorks.Graph.IPortDefaults.ShareStyleInstance" />
    </member>
    <member name="P:yWorks.Graph.IPortDefaults.AutoCleanup">
      <summary>
        <para>Gets or sets whether unused ports should automatically be removed from their owners as soon as no further edge is connected to them.</para>
      </summary>
      <seealso cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)" />
    </member>
    <member name="P:yWorks.Graph.IPortDefaults.ShareStyleInstance">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.IPortDefaults.Style" /> instance should be shared referentially or <see cref="M:System.ICloneable.Clone">cloned</see> upon a call to <see cref="M:yWorks.Graph.IPortDefaults.GetStyleInstance(yWorks.Graph.IPortOwner)" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the reference should be shared; <c>false</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Graph.IPortDefaults.GetStyleInstance(yWorks.Graph.IPortOwner)" />
      <seealso cref="P:yWorks.Graph.IPortDefaults.Style" />
    </member>
    <member name="M:yWorks.Graph.IPortDefaults.GetStyleInstance(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Factory method that returns a style instance for use with newly created ports.</para>
      </summary>
      <remarks>
        <para>Most implementations will yield either, a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.IPortDefaults.Style" /> property, if <see cref="P:yWorks.Graph.IPortDefaults.ShareStyleInstance" /> is enabled, but they might use more complicated logic, too.</para>
      </remarks>
      <param name="owner">
        <para>The owner of the port that will be created.</para>
      </param>
      <returns>
        <para>The style to use, which for most implementations is either a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.IPortDefaults.Style" /> property, if <see cref="P:yWorks.Graph.IPortDefaults.ShareStyleInstance" /> is enabled.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.IPortDefaults.LocationParameter">
      <summary>
        <para>Gets or sets the location model parameter to use for ports.</para>
      </summary>
      <remarks>
        <para>Depending on the setting of <see cref="P:yWorks.Graph.IPortDefaults.ShareLocationParameterInstance" />, the <see cref="M:yWorks.Graph.IPortDefaults.GetLocationParameterInstance(yWorks.Graph.IPortOwner)" /> method should return a <see cref="M:System.ICloneable.Clone">clone</see> of this instance or the very same instance.</para>
      </remarks>
      <value>
        <para>The parameter to use as a template.</para>
      </value>
      <seealso cref="P:yWorks.Graph.IPortDefaults.ShareLocationParameterInstance" />
      <seealso cref="M:yWorks.Graph.IPortDefaults.GetLocationParameterInstance(yWorks.Graph.IPortOwner)" />
    </member>
    <member name="P:yWorks.Graph.IPortDefaults.ShareLocationParameterInstance">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.IPortDefaults.LocationParameter" /> instance should be shared referentially or <see cref="M:System.ICloneable.Clone">cloned</see> upon a call to <see cref="M:yWorks.Graph.IPortDefaults.GetLocationParameterInstance(yWorks.Graph.IPortOwner)" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the reference should be shared; <c>false</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Graph.IPortDefaults.GetLocationParameterInstance(yWorks.Graph.IPortOwner)" />
      <seealso cref="P:yWorks.Graph.IPortDefaults.LocationParameter" />
    </member>
    <member name="M:yWorks.Graph.IPortDefaults.GetLocationParameterInstance(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Factory method that returns a location model parameter instance for use with newly created ports.</para>
      </summary>
      <remarks>
        <para>Most implementations will yield either, a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.IPortDefaults.LocationParameter" /> property, if <see cref="P:yWorks.Graph.IPortDefaults.ShareLocationParameterInstance" /> is enabled, but they might use more complicated logic, too.</para>
      </remarks>
      <param name="owner">
        <para>The owner of the port that will be created.</para>
      </param>
      <returns>
        <para>The parameter to use, which for most implementations is either a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.IPortDefaults.LocationParameter" /> property, if <see cref="P:yWorks.Graph.IPortDefaults.ShareLocationParameterInstance" /> is enabled.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.PortLocationModels.IPortLocationModel">
      <summary>
        <para>Defines the geometry of <see cref="T:yWorks.Graph.IPort" /> instances with respect to specific <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" />s.</para>
      </summary>
      <remarks>
        <para>In addition to defining the location of a port with respect to a specific <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" />, a port location model is typically the factory of the model parameters that are compatible with it, too.</para>
        <para>Typically, the port location model defines a compilation of valid locations for ports, and a specific model parameter specifies an exact geometry for a port.</para>
        <para>By design, the same instance of a port location model can be shared by multiple port location model parameters. Similarly, the same instance of a port location model parameter can be shared by multiple ports.</para>
        <para>This interface supports the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method that can be used to query additional aspects of the implementation.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter" />
      <seealso cref="T:yWorks.Graph.IPort" />
      <seealso cref="T:yWorks.Graph.IGraph" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.IPortLocationModel.GetLocation(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <summary>
        <para>Determines the location of the port for the given parameter.</para>
      </summary>
      <param name="port">
        <para>The port to determine the location for.</para>
      </param>
      <param name="locationParameter">
        <para>The parameter to use. The parameter can be expected to be created by this instance having the <see cref="P:yWorks.Graph.PortLocationModels.IPortLocationModelParameter.Model" /> property set to this instance..</para>
      </param>
      <returns>
        <para>The calculated location of the port.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.IPortLocationModel.CreateParameter(yWorks.Graph.IPortOwner,yWorks.Geometry.PointD)">
      <summary>
        <para>Factory method that creates a parameter for the given port that tries to match the provided location in absolute world coordinates.</para>
      </summary>
      <param name="owner">
        <para>The port owner that will own the port for which the parameter shall be created.</para>
      </param>
      <param name="location">
        <para>The location in the world coordinate system that should be matched as best as possible.</para>
      </param>
      <returns>
        <para>A new instance that can be used to describe the location of an <see cref="T:yWorks.Graph.IPort" /> at the given <paramref name="owner" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.IPortLocationModel.GetContext(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <summary>
        <para>Provides a <see cref="T:yWorks.Graph.ILookup">lookup context</see> for the given combination of port and parameter.</para>
      </summary>
      <param name="port">
        <para>The port to use in the context.</para>
      </param>
      <param name="locationParameter">
        <para>The parameter to use for the port in the context.</para>
      </param>
      <returns>
        <para>An implementation of the <see cref="T:yWorks.Graph.ILookup" /> interface that can be used to query additional aspects of the port/parameter combination.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.PortLocationModels.IPortLocationModelParameter">
      <summary>
        <para>Defines a state that can be used to <see cref="M:yWorks.Graph.PortLocationModels.IPortLocationModel.GetLocation(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">determine the location of a port</see> with a <see cref="T:yWorks.Graph.PortLocationModels.IPortLocationModel" />.</para>
      </summary>
      <remarks>
        <para>Typically, implementations of this interface are created by factory methods of the corresponding <see cref="P:yWorks.Graph.PortLocationModels.IPortLocationModelParameter.Model" />.</para>
        <para>This interface extends the <see cref="T:System.ICloneable" /> interface. This allows clients to obtain a persistent copy of the current state of this parameter. Immutable parameter implementations may return themselves.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.PortLocationModels.IPortLocationModel" />
      <seealso cref="T:yWorks.Graph.IPort" />
    </member>
    <member name="P:yWorks.Graph.PortLocationModels.IPortLocationModelParameter.Model">
      <summary>
        <para>Gets the model that created this parameter.</para>
      </summary>
      <value>
        <para>The model that created this parameter.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.IPortLocationModelParameter.Supports(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Determines whether this parameter can be used for ports at the given <paramref name="owner" />.</para>
      </summary>
      <remarks>
        <para>A parameter must not necessarily support all types of ports. This method returns whether it supports ports at the given <paramref name="owner" />.</para>
      </remarks>
      <param name="owner">
        <para>The port owner to test.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this instance can be used for ports of the given port owner, <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.IPortSelectionTester">
      <summary>
        <para>Interface that can be used to find ports at specific locations in the canvas.</para>
      </summary>
      <remarks>
        <para>This interface is mostly provided through the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of <see cref="T:yWorks.Graph.IPortOwner" /> implementations such as <see cref="T:yWorks.Graph.INode" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IPortSelectionTester.GetHitPort(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Returns the port at the given world coordinate position or <c>null</c> if there is no such port.</para>
      </summary>
      <param name="context">
        <para>The input mode context to use for querying the position.</para>
      </param>
      <param name="location">
        <para>The coordinates of the position in the world coordinate system.</para>
      </param>
      <returns>
        <para>The port at the position or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.IPortSelectionTester.GetPortsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Returns the ports for the given marquee rectangle.</para>
      </summary>
      <param name="context">
        <para>The input mode context to use for querying the position.</para>
      </param>
      <param name="rectangle">
        <para>The marquee selection box in the world coordinate system.</para>
      </param>
      <returns>
        <para>An enumerable over the ports inside the marquee selection box.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.IStripe">
      <summary>
        <para>This interface defines a child element of a table or a table element container</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.IStripe.Insets">
      <summary>
        <para>Gets the insets for this stripe.</para>
      </summary>
      <remarks>
        <para>These insets are applied in addition to any implicit insets provided by the child stripes. To find out the actual insets that are currently in effect, use <see cref="M:yWorks.Graph.StripeExtensions.GetActualInsets(yWorks.Graph.IStripe)" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IStripe.Layout">
      <summary>
        <para>Gets a live view of the relative layout of the stripe.</para>
      </summary>
      <remarks>
        <para>The layout of a stripe is a rectangle in the coordinate system that is relative to the upper left corner of the parent. Since this method will yield a live view, it is up to the client to copy the values of the instance if a snapshot of the state is needed.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IStripe.Style">
      <summary>
        <para>Gets the style for this stripe.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.IStripe.Size">
      <summary>
        <para>Gets the current changeable dimension of the stripe.</para>
      </summary>
      <remarks>
        <para>This is always the stripe size which is not implicitly determined by other stripes, i.e. the height for <see cref="T:yWorks.Graph.IRow" /> instances and the width for <see cref="T:yWorks.Graph.IColumn" /> instances.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IStripe.MinimumSize">
      <summary>
        <para>Gets the minimal permissible value for <see cref="P:yWorks.Graph.IStripe.Size" />.</para>
      </summary>
      <remarks>
        <para>This value determines how much the stripe may be shrunk by interactive manipulation.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IStripe.Table">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.ITable" /> instance where this stripe is installed.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.IStripeHitTestHelper">
      <summary>
        <para>Helper interface that allows to bundle <see cref="T:yWorks.Controls.Input.IHitTestable" /> implementations for the main regions of a <see cref="T:yWorks.Graph.IStripe" /> instance.</para>
      </summary>
      <remarks>
        <para>The default <see cref="T:yWorks.Graph.IRow" /> and <see cref="T:yWorks.Graph.IColumn" /> implementations provide default implementations of this interface.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IStripeHitTestHelper.GetLeadingHeaderHitTestable">
      <summary>
        <para>Return a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that should report hits on the leading header region of the stripe.</para>
      </summary>
      <remarks>
        <para>The leading header is the region that is used by default for click selection and as start location for a stripe drag. Typically, this is the area occupied by the left insets for an <see cref="T:yWorks.Graph.IRow" /> instance and by the top insets for an <see cref="T:yWorks.Graph.IColumn" /> instance.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that should report hits on the header region of the stripe.</para>
      </returns>
      <seealso cref="T:yWorks.Controls.Input.StripeSubregion" />
      <seealso cref="F:yWorks.Controls.Input.StripeSubregionTypes.Header" />
    </member>
    <member name="M:yWorks.Controls.Input.IStripeHitTestHelper.GetTrailingHeaderHitTestable">
      <summary>
        <para>Return a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that should report hits on the trailing header region of the stripe.</para>
      </summary>
      <remarks>
        <para>The trailing header is the region that is used by default for click selection and as start location for a stripe drag. Typically, this is the area occupied by the right insets for an <see cref="T:yWorks.Graph.IRow" /> instance and by the bottom insets for an <see cref="T:yWorks.Graph.IColumn" /> instance.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that should report hits on the header region of the stripe.</para>
      </returns>
      <seealso cref="T:yWorks.Controls.Input.StripeSubregion" />
      <seealso cref="F:yWorks.Controls.Input.StripeSubregionTypes.Header" />
    </member>
    <member name="M:yWorks.Controls.Input.IStripeHitTestHelper.GetStripeHitTestable">
      <summary>
        <para>Return a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that should report hits on the whole stripe.</para>
      </summary>
      <returns>
        <para>a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that should report hits on the whole stripe.</para>
      </returns>
      <seealso cref="T:yWorks.Controls.Input.StripeSubregion" />
      <seealso cref="F:yWorks.Controls.Input.StripeSubregionTypes.Stripe" />
    </member>
    <member name="M:yWorks.Controls.Input.IStripeHitTestHelper.GetNearBorderHitTestable">
      <summary>
        <para>Return a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that should report hits on the near border region of the stripe.</para>
      </summary>
      <remarks>
        <para>The near border is the region that is used for the resize gesture in <see cref="T:yWorks.Controls.Input.ResizeStripeInputMode" /> to expand the stripe to the top or the left. This is typically the upper border for an <see cref="T:yWorks.Graph.IRow" /> instance and the left border for an <see cref="T:yWorks.Graph.IColumn" />.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that should report hits on the near border region of the stripe.</para>
      </returns>
      <seealso cref="T:yWorks.Controls.Input.StripeSubregion" />
      <seealso cref="F:yWorks.Controls.Input.StripeSubregionTypes.NearBorder" />
    </member>
    <member name="M:yWorks.Controls.Input.IStripeHitTestHelper.GetFarBorderHitTestable">
      <summary>
        <para>Return a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that should report hits on the far border region of the stripe.</para>
      </summary>
      <remarks>
        <para>The far border is the region that is used for the resize gesture in <see cref="T:yWorks.Controls.Input.ResizeStripeInputMode" /> to expand the stripe to the bottom or the right. This is typically the bottom border for an <see cref="T:yWorks.Graph.IRow" /> instance and the right border for an <see cref="T:yWorks.Graph.IColumn" />.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Controls.Input.IHitTestable" /> that should report hits on the far border region of the stripe.</para>
      </returns>
      <seealso cref="T:yWorks.Controls.Input.StripeSubregion" />
      <seealso cref="F:yWorks.Controls.Input.StripeSubregionTypes.FarBorder" />
    </member>
    <member name="T:yWorks.Controls.Input.StripeSubregionTypes">
      <summary>
        <para>Enumeration that specifies the various hot spot regions of an <see cref="T:yWorks.Graph.IStripe" /> instance.</para>
      </summary>
      <remarks>
        <para>Members of this enumeration can be combined to specify composite regions.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.StripeSubregion" />
    </member>
    <member name="F:yWorks.Controls.Input.StripeSubregionTypes.None">
      <summary>
        <para>No active hotspot region.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.StripeSubregionTypes.Stripe">
      <summary>
        <para>The hot spot region includes the stripe itself.</para>
      </summary>
      <seealso cref="M:yWorks.Controls.Input.IStripeHitTestHelper.GetStripeHitTestable" />
    </member>
    <member name="F:yWorks.Controls.Input.StripeSubregionTypes.LeadingHeader">
      <summary>
        <para>The hot spot region includes the leading stripe header.</para>
      </summary>
      <remarks>
        <para>The leading header is the region that is used by default for click selection and as start location for a stripe drag. Typically, this is the area occupied by the left insets for an <see cref="T:yWorks.Graph.IRow" /> instance and by the top insets for an <see cref="T:yWorks.Graph.IColumn" /> instance.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.IStripeHitTestHelper.GetLeadingHeaderHitTestable" />
    </member>
    <member name="F:yWorks.Controls.Input.StripeSubregionTypes.TrailingHeader">
      <summary>
        <para>The hot spot region includes the trailing stripe header.</para>
      </summary>
      <remarks>
        <para>The trailing header is the region that is used by default for click selection and as start location for a stripe drag. Typically, this is the area occupied by the right insets for an <see cref="T:yWorks.Graph.IRow" /> instance and by the bottom insets for an <see cref="T:yWorks.Graph.IColumn" /> instance.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.IStripeHitTestHelper.GetTrailingHeaderHitTestable" />
    </member>
    <member name="F:yWorks.Controls.Input.StripeSubregionTypes.Header">
      <summary>
        <para>The hot spot region includes both stripe headers.</para>
      </summary>
      <remarks>
        <para>This is a bitwise combination of <see cref="F:yWorks.Controls.Input.StripeSubregionTypes.LeadingHeader" /> and <see cref="F:yWorks.Controls.Input.StripeSubregionTypes.TrailingHeader" /></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.IStripeHitTestHelper.GetTrailingHeaderHitTestable" />
    </member>
    <member name="F:yWorks.Controls.Input.StripeSubregionTypes.NearBorder">
      <summary>
        <para>The hot spot region includes the near-border region of the stripe.</para>
      </summary>
      <remarks>
        <para>The near border is the region that is used for the resize gesture in <see cref="T:yWorks.Controls.Input.ResizeStripeInputMode" /> to expand the stripe to the top or the left. This is typically the upper border for an <see cref="T:yWorks.Graph.IRow" /> instance and the left border for an <see cref="T:yWorks.Graph.IColumn" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.IStripeHitTestHelper.GetNearBorderHitTestable" />
    </member>
    <member name="F:yWorks.Controls.Input.StripeSubregionTypes.FarBorder">
      <summary>
        <para>The hot spot region includes the stripe far-border region.</para>
      </summary>
      <remarks>
        <para>The far border is the region that is used for the resize gesture in <see cref="T:yWorks.Controls.Input.ResizeStripeInputMode" /> to expand the stripe to the bottom or the right. This is typically the bottom border for an <see cref="T:yWorks.Graph.IRow" /> instance and the right border for an <see cref="T:yWorks.Graph.IColumn" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.IStripeHitTestHelper.GetFarBorderHitTestable" />
    </member>
    <member name="F:yWorks.Controls.Input.StripeSubregionTypes.All">
      <summary>
        <para>Flag for any stripe region.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.StripeSubregion">
      <summary>
        <para>Helper class that further describes the result of a hit test on a stripe or table.</para>
      </summary>
      <remarks>
        <para>Instances of this class are returned by the default <see cref="T:yWorks.Controls.Input.StripeHitTester" /> implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.StripeSubregion.#ctor(yWorks.Controls.Input.StripeSubregionTypes,yWorks.Graph.IStripe)">
      <summary>
        <para>Create a new instance that describes the specific subregion.</para>
      </summary>
      <param name="subregionType">
        <para>The specific subregion</para>
      </param>
      <param name="stripe">
        <para>The stripe</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.StripeSubregion.SubregionType">
      <summary>
        <para>Gets the specific subregion type that this instance describes.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.StripeSubregion.Stripe">
      <summary>
        <para>Gets the stripe that this instance describes.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.StripeSubregion.TargetTableNode">
      <summary>
        <para>Gets or sets the node the region is associated to.</para>
      </summary>
      <remarks>
        <para>This property is not <c>null</c> only is this instance was returned by <see cref="M:yWorks.Controls.Input.ReparentStripePositionHandler.GetTargetSubregion(yWorks.Geometry.PointD)" />. Otherwise, especially if this instance was returned by <see cref="M:yWorks.Graph.TableExtensions.FindStripe(yWorks.Geometry.PointD,yWorks.Graph.StripeTypes,yWorks.Controls.Input.StripeSubregionTypes,yWorks.Controls.CanvasControl,System.Predicate{yWorks.Controls.Input.StripeSubregion})" />, it is <c>null</c>. In this case, you can get the table from the <see cref="P:yWorks.Controls.Input.StripeSubregion.Stripe" /> of this instance.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper">
      <summary>
        <para>Default implementation of <see cref="T:yWorks.Controls.Input.IStripeInputVisualizationHelper" /> that uses <see cref="T:yWorks.Controls.TemplateVisual" />s for the actual visualization.</para>
      </summary>
      <remarks>
        <para>If you want to change the global behavior, you can just provide a different <see cref="T:yWorks.Controls.TemplateVisual" /> for the various predefined template keys in the application resources. If you want to override the visualization for a specific stripe only, assign a different <see cref="T:yWorks.Controls.TemplateVisual" /> to the instance that is already present in the stripe's lookup.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.#ctor(yWorks.Graph.IStripe)">
      <summary>
        <para>Default constructor</para>
      </summary>
      <param name="stripe">
        <para>The stripe for which the visualizations are intended</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)">
      <summary>
        <para>Return an <see cref="T:yWorks.Controls.IVisualCreator" /> that is used to visualize the input operation specified by <paramref name="type" />.</para>
      </summary>
      <remarks>
        <para>This implementation uses <see cref="T:yWorks.Controls.TemplateVisual" />s for the actual visualization.</para>
      </remarks>
      <param name="context">
        <para>The input mode context which provides further information.</para>
      </param>
      <param name="tableNode">
        <para>The node where the stripe's owner is currently bound to.</para>
      </param>
      <param name="type">
        <para>The actual visualization type</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Controls.IVisualCreator" /> instance that renders a representation for the current operation.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.ResizeStripeTemplate" />
    </member>
    <member name="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.FindTemplate(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.StripeVisualizationType)">
      <summary>
        <para>Provide a <see cref="T:yWorks.Controls.TemplateVisual" /> that is used to visualize <paramref name="type" />.</para>
      </summary>
      <param name="context">
        <para>The input mode context. Allows you to access the <see cref="T:yWorks.Controls.CanvasControl" /> to retrieve the resources.</para>
      </param>
      <param name="type">
        <para>The visualization type</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Controls.TemplateVisual" /> that is used to visualize <paramref name="type" />.</para>
      </returns>
    </member>
    <member name="F:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.ResizeStripeTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used to store a <see cref="T:yWorks.Controls.TemplateVisual" /> that can be used to create the visual that will be used to draw the highlight for the stripe that is resized.</para>
      </summary>
      <remarks>
        <para>This template is used for <see cref="F:yWorks.Controls.Input.StripeVisualizationType.Resize" /></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)" />
    </member>
    <member name="P:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.ResizeStripeTemplate">
      <summary>
        <para>Gets or sets the data template that is used to visualize the current stripe resize operation.</para>
      </summary>
      <remarks>
        <para>This template is used for <see cref="F:yWorks.Controls.Input.StripeVisualizationType.Resize" /></para>
      </remarks>
      <value>
        <para>The template for the stripe resize visualization or <c>null</c> in which case the default template that is stored under <see cref="F:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.ResizeStripeTemplateKey" /> is used.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)" />
    </member>
    <member name="F:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.SelectedStripeTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used to store a <see cref="T:yWorks.Controls.TemplateVisual" /> that can be used to create the visual that will be used to draw the highlight for the stripe that is selected.</para>
      </summary>
      <remarks>
        <para>This template is used for <see cref="F:yWorks.Controls.Input.StripeVisualizationType.Selection" /></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)" />
    </member>
    <member name="P:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.SelectedStripeTemplate">
      <summary>
        <para>Gets or sets the data template that is used to visualize the current stripe selection operation.</para>
      </summary>
      <remarks>
        <para>This template is used for <see cref="F:yWorks.Controls.Input.StripeVisualizationType.Selection" /></para>
      </remarks>
      <value>
        <para>The template for the stripe selection visualization or <c>null</c> in which case the default template that is stored under <see cref="F:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.SelectedStripeTemplateKey" /> is used.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)" />
    </member>
    <member name="F:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.DragSourceStripeTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used to store a <see cref="T:yWorks.Controls.TemplateVisual" /> that can be used to create the visual that will be used to draw the highlight for the current source of a stripe reparent operation.</para>
      </summary>
      <remarks>
        <para>This template is used for <see cref="F:yWorks.Controls.Input.StripeVisualizationType.DragSource" /></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)" />
    </member>
    <member name="P:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.DragSourceStripeTemplate">
      <summary>
        <para>Gets or sets the data template that is used to visualize the current source of a stripe reparent operation.</para>
      </summary>
      <remarks>
        <para>This template is used for <see cref="F:yWorks.Controls.Input.StripeVisualizationType.DragSource" /></para>
      </remarks>
      <value>
        <para>The template for the visualizaton of the current source of a stripe reparent operation or <c>null</c> in which case the default template that is stored under <see cref="F:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.DragSourceStripeTemplateKey" /> is used.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)" />
    </member>
    <member name="F:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.DropTargetStripeTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that can be used to store a <see cref="T:yWorks.Controls.TemplateVisual" /> that can be used to create the visual that will be used to draw the highlight for the current target of a stripe reparent operation.</para>
      </summary>
      <remarks>
        <para>This template is used for <see cref="F:yWorks.Controls.Input.StripeVisualizationType.DropTarget" /></para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)" />
    </member>
    <member name="P:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.DropTargetStripeTemplate">
      <summary>
        <para>Gets or sets the data template that is used to visualize the current target of a stripe reparent operation.</para>
      </summary>
      <remarks>
        <para>This template is used for <see cref="F:yWorks.Controls.Input.StripeVisualizationType.DropTarget" /></para>
      </remarks>
      <value>
        <para>The template for the visulization of the current target of a stripe reparent operation or <c>null</c> in which case the default template that is stored under <see cref="F:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.DropTargetStripeTemplateKey" /> is used.</para>
      </value>
      <seealso cref="M:yWorks.Controls.Input.DefaultStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)" />
    </member>
    <member name="T:yWorks.Controls.Input.StripeVisualizationType">
      <summary>
        <para>Enumeration constants for the various visualization types used in conjunction with <see cref="T:yWorks.Controls.Input.IStripeInputVisualizationHelper" /></para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.StripeVisualizationType.Selection">
      <summary>
        <para>Visualization for a selected stripe.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.StripeVisualizationType.DragSource">
      <summary>
        <para>Visualization for the source stripe of a reparent operation.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ReparentStripeInputMode" />
    </member>
    <member name="F:yWorks.Controls.Input.StripeVisualizationType.DropTarget">
      <summary>
        <para>Visualization for the target stripe of a reparent or drag and drop operation.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.Input.ReparentStripeInputMode" />
      <seealso cref="T:yWorks.Controls.Input.StripeDropInputMode" />
    </member>
    <member name="F:yWorks.Controls.Input.StripeVisualizationType.Resize">
      <summary>
        <para>Visualization for resize operations that are triggered for example by <see cref="T:yWorks.Controls.Input.ResizeStripeInputMode" /></para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.IStripeInputVisualizationHelper">
      <summary>
        <para>This interface allows to change the visualization for different input gestures.</para>
      </summary>
      <remarks>
        <para>A stripe should provide an implementation of this interface in its lookup which is queried by the various table related input modes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.IStripeInputVisualizationHelper.GetVisualCreator(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.INode,yWorks.Controls.Input.StripeVisualizationType)">
      <summary>
        <para>Return an <see cref="T:yWorks.Controls.IVisualCreator" /> that is used to visualize the input operation specified by <paramref name="type" />.</para>
      </summary>
      <param name="context">
        <para>The input mode context which provides further information.</para>
      </param>
      <param name="tableNode">
        <para>The node where the stripe's owner is currently bound to.</para>
      </param>
      <param name="type">
        <para>The actual visualization type</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Controls.IVisualCreator" /> instance that renders a representation for the current operation.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.ITable">
      <summary>
        <para>Central interface which provides support for tabular data presentation.</para>
      </summary>
      <remarks>
        <para>This interface supports a presentation of data where the nodes of a diagram are organized in a tabular way, i.e., where each node is associated to a specific row and column in the grid-like structure of a table. The <see cref="T:yWorks.Graph.ITable" /> together with its associated interfaces <see cref="T:yWorks.Graph.IColumn" /> and <see cref="T:yWorks.Graph.IRow" /> represents the model for the tabular presentation (or table, for short). It also provides means for altering the model, in particular creation (<see cref="M:yWorks.Graph.ITable.CreateColumn(yWorks.Graph.IColumn,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})" /> and <see cref="M:yWorks.Graph.ITable.CreateRow(yWorks.Graph.IRow,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})" />) and <see cref="M:yWorks.Graph.ITable.Remove(yWorks.Graph.IStripe)">removal</see> of columns and rows but also changing their size or appearance.</para>
        <para>The table structure is backed by a group node. As a consequence, the nodes which should be presented in a tabular fashion need to be set up as children of this group node. Using a group node to hold the content nodes has several advantages: For example, when the group node is moved, the child nodes move accordingly, thus maintaining the visual clue that they are contained in the table group node.</para>
        <para>Note that the table structure and its content nodes are only loosely coupled: the node's center coordinates determine the row and column that it belongs to.</para>
        <para>Associating an <see cref="T:yWorks.Graph.ITable" /> instance with its backing group node can most conveniently be done by setting a <see cref="T:yWorks.Graph.Styles.TableNodeStyle" /> instance as style of the associated group node. This style manages the visualization of the individual rows and columns. It also associates its <see cref="P:yWorks.Graph.Styles.TableNodeStyle.Table" /> with the group node by decorating its <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> to return the table instance.</para>
        <para>User interaction is supported by the <see cref="T:yWorks.Controls.Input.TableEditorInputMode" /> which provides support for intractively resizing rows and columns, re-parenting them, or editing their labels.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IStripe" />
      <seealso cref="T:yWorks.Graph.IColumn" />
      <seealso cref="T:yWorks.Graph.IRow" />
      <seealso cref="T:yWorks.Graph.Table" />
      <seealso cref="T:yWorks.Controls.Input.TableEditorInputMode" />
    </member>
    <member name="P:yWorks.Graph.ITable.Insets">
      <summary>
        <para>Gets or sets the insets for this table.</para>
      </summary>
      <remarks>
        <para>These insets are applied in addition to any implicit insets provided by the child stripes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.ITable.RelativeLocation">
      <summary>
        <para>Gets or sets the relative location of the upper left corner of the table.</para>
      </summary>
      <remarks>
        <para>The actual interpretation of this value depends on the context. If the table is bound to a node, this location is usually interpreted relative to the upper left corner of the node layout.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.ITable.Layout" />
    </member>
    <member name="P:yWorks.Graph.ITable.Layout">
      <summary>
        <para>Gets the relative layout of the table.</para>
      </summary>
      <remarks>
        <para>The upper left corner of the layout always coincides with <see cref="P:yWorks.Graph.ITable.RelativeLocation" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.ITable.RelativeLocation" />
    </member>
    <member name="P:yWorks.Graph.ITable.RowDefaults">
      <summary>
        <para>Gets or sets the defaults for rows.</para>
      </summary>
      <remarks>
        <para>The settings that are obtained from the instance influence newly created elements only. Setting different defaults later does not influence existing elements.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.ITable.ColumnDefaults">
      <summary>
        <para>Gets or sets the defaults for Columns.</para>
      </summary>
      <remarks>
        <para>The settings that are obtained from the instance influence newly created elements only. Setting different defaults later does not influence existing elements.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.ITable.RootRow">
      <summary>
        <para>Gets the virtual root of the row hierarchy</para>
      </summary>
      <remarks>
        <para>This row should not be queried except for the <see cref="P:yWorks.Graph.IRow.ParentRow" /> and the associated <see cref="P:yWorks.Graph.IStripe.Table" /></para>
      </remarks>
      <seealso cref="M:yWorks.Graph.ITable.SetParent(yWorks.Graph.IRow,yWorks.Graph.IRow,System.Nullable{System.Int32})" />
      <seealso cref="M:yWorks.Graph.ITable.CreateRow(yWorks.Graph.IRow,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})" />
    </member>
    <member name="P:yWorks.Graph.ITable.RootColumn">
      <summary>
        <para>Gets the virtual root of the column hierarchy</para>
      </summary>
      <remarks>
        <para>This column should not be queried except for the <see cref="P:yWorks.Graph.IColumn.ParentColumn" /> and the associated <see cref="P:yWorks.Graph.IStripe.Table" /></para>
      </remarks>
      <seealso cref="M:yWorks.Graph.ITable.SetParent(yWorks.Graph.IColumn,yWorks.Graph.IColumn,System.Nullable{System.Int32})" />
      <seealso cref="M:yWorks.Graph.ITable.CreateColumn(yWorks.Graph.IColumn,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})" />
    </member>
    <member name="M:yWorks.Graph.ITable.AddLabel(yWorks.Graph.IStripe,System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,System.Nullable{yWorks.Geometry.SizeD},System.Object)">
      <summary>
        <para>Add a label to the given owner using the text as the initial label text and label model parameter and style.</para>
      </summary>
      <param name="owner">
        <para>the owner to add the label to.</para>
      </param>
      <param name="text">
        <para>the initial text of the label</para>
      </param>
      <param name="layoutParameter">
        <para>The label model parameter instance to use.</para>
      </param>
      <param name="style">
        <para>The style to use for the label</para>
      </param>
      <param name="preferredSize">
        <para>The initial values to use for the <see cref="P:yWorks.Graph.ILabel.PreferredSize" />.</para>
      </param>
      <param name="tag">
        <para>the initial <see cref="P:yWorks.Graph.ITagOwner.Tag" /> to assign.</para>
      </param>
      <returns>
        <para>the newly created label</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ITable.SetLabelText(yWorks.Graph.ILabel,System.String)" />
      <seealso cref="M:yWorks.Graph.ITable.SetLabelLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)" />
      <seealso cref="M:yWorks.Graph.ITable.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />
    </member>
    <member name="M:yWorks.Graph.ITable.SetLabelText(yWorks.Graph.ILabel,System.String)">
      <summary>
        <para>Sets the label text of the given label.</para>
      </summary>
      <param name="label">
        <para>the label to modify</para>
      </param>
      <param name="text">
        <para>the new text of the label</para>
      </param>
      <seealso cref="P:yWorks.Graph.ILabel.Text" />
    </member>
    <member name="M:yWorks.Graph.ITable.Remove(yWorks.Graph.ILabel)">
      <summary>
        <para>Removes the given label from its owner.</para>
      </summary>
      <remarks>
        <para>This will trigger the corresponding event.</para>
      </remarks>
      <param name="label">
        <para>the label to remove</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.ITable.SetLabelPreferredSize(yWorks.Graph.ILabel,yWorks.Geometry.SizeD)">
      <summary>
        <para>Sets the preferred size of the label.</para>
      </summary>
      <param name="label">
        <para>The label.</para>
      </param>
      <param name="preferredSize">
        <para>The new preferred size.</para>
      </param>
      <seealso cref="P:yWorks.Graph.ILabel.PreferredSize" />
    </member>
    <member name="M:yWorks.Graph.ITable.SetLabelLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Sets the label model parameter for the given label.</para>
      </summary>
      <param name="label">
        <para>The label.</para>
      </param>
      <param name="layoutParameter">
        <para>The new parameter.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>If the parameter cannot be used for this label.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.ITable.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Assigns the given style instance by reference to the label.</para>
      </summary>
      <remarks>
        <para>Style instances can be shared.</para>
      </remarks>
      <param name="label">
        <para>The label that will be assigned the new style</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the label.</para>
      </param>
      <seealso cref="P:yWorks.Graph.ILabel.Style" />
    </member>
    <member name="E:yWorks.Graph.ITable.LabelAdded">
      <summary>
        <para>Occurs when a label has been added to this graph instance.</para>
      </summary>
      <seealso cref="M:yWorks.Graph.ITable.AddLabel(yWorks.Graph.IStripe,System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,System.Nullable{yWorks.Geometry.SizeD},System.Object)" />
    </member>
    <member name="E:yWorks.Graph.ITable.LabelRemoved">
      <summary>
        <para>Occurs when a label has been removed from this graph instance.</para>
      </summary>
      <remarks>
        <para>This event will also be triggered, prior to the removal of the <see cref="P:yWorks.Graph.ILabel.Owner">owner</see> of the label.</para>
        <para>Implementations may choose to use the <see cref="T:yWorks.Graph.LabelEventArgs" /> to carry additional label owner information. The <see cref="P:yWorks.Graph.LabelEventArgs.Owner" /> property will be set to the the owner of the label that owned it before the removal.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.ITable.Remove(yWorks.Graph.ILabel)" />
    </member>
    <member name="E:yWorks.Graph.ITable.LabelChanged">
      <summary>
        <para>Occurs when a label has been changed, for instance, if its style has been replaced.</para>
      </summary>
      <seealso cref="M:yWorks.Graph.ITable.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />
    </member>
    <member name="M:yWorks.Graph.ITable.CreateRow(yWorks.Graph.IRow,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})">
      <summary>
        <para>Create a new row as the <paramref name="index" />th child of <paramref name="owner" /> with the given parameters.</para>
      </summary>
      <param name="owner">
        <para>The owner of the new row.</para>
      </param>
      <param name="index">
        <para>The position in the child list.</para>
      </param>
      <param name="height">
        <para>The actual height of the row.</para>
      </param>
      <param name="minHeight">
        <para>The minimal height of the row.</para>
      </param>
      <param name="insets">
        <para>The insets of the row.</para>
      </param>
      <param name="style">
        <para>The style of the row.</para>
      </param>
      <param name="tag">
        <para>The tag of the row</para>
      </param>
      <returns>
        <para>A new row instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.ITable.CreateColumn(yWorks.Graph.IColumn,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})">
      <summary>
        <para>Create a new column as the <paramref name="index" />th child of <paramref name="owner" /> with the given parameters.</para>
      </summary>
      <param name="owner">
        <para>The owner of the new column.</para>
      </param>
      <param name="index">
        <para>The position in the child list.</para>
      </param>
      <param name="width">
        <para>The actual width of the column.</para>
      </param>
      <param name="minWidth">
        <para>The minimal width of the column.</para>
      </param>
      <param name="insets">
        <para>The insets of the column.</para>
      </param>
      <param name="style">
        <para>The style of the column.</para>
      </param>
      <param name="tag">
        <para>The tag of the column</para>
      </param>
      <returns>
        <para>A new column instance</para>
      </returns>
    </member>
    <member name="E:yWorks.Graph.ITable.StripeCreated">
      <summary>
        <para>Occurs when a stripe has been added.</para>
      </summary>
      <seealso cref="M:yWorks.Graph.ITable.CreateRow(yWorks.Graph.IRow,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})" />
      <seealso cref="M:yWorks.Graph.ITable.CreateColumn(yWorks.Graph.IColumn,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})" />
    </member>
    <member name="E:yWorks.Graph.ITable.StripeRemoved">
      <summary>
        <para>Occurs when a stripe has been removed from its parent.</para>
      </summary>
      <seealso cref="M:yWorks.Graph.ITable.Remove(yWorks.Graph.IStripe)" />
    </member>
    <member name="M:yWorks.Graph.ITable.SetSize(yWorks.Graph.IStripe,System.Double)">
      <summary>
        <para>Sets the actual size of <paramref name="stripe" />.</para>
      </summary>
      <remarks>
        <para>This method sets the <see cref="P:yWorks.Graph.IStripe.Size" /> of <paramref name="stripe" />.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe to change</para>
      </param>
      <param name="size">
        <para>The new size of the stripe</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.ITable.SetMinimumSize(yWorks.Graph.IStripe,System.Double)">
      <summary>
        <para>Sets the minimum size of <paramref name="stripe" />.</para>
      </summary>
      <remarks>
        <para>This method sets the <see cref="P:yWorks.Graph.IStripe.MinimumSize" /> of <paramref name="stripe" />.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe to change</para>
      </param>
      <param name="minimumSize">
        <para>The new minimum size of the stripe</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.ITable.SetStripeInsets(yWorks.Graph.IStripe,yWorks.Geometry.InsetsD)">
      <summary>
        <para>Sets the insets of <paramref name="stripe" />.</para>
      </summary>
      <param name="stripe">
        <para>The stripe to change</para>
      </param>
      <param name="insets">
        <para>The new insets of the stripe</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.ITable.SetStyle(yWorks.Graph.IStripe,yWorks.Graph.Styles.IStripeStyle)">
      <summary>
        <para>Sets the style of <paramref name="stripe" />.</para>
      </summary>
      <param name="stripe">
        <para>The stripe to change</para>
      </param>
      <param name="style">
        <para>The new style of the stripe</para>
      </param>
    </member>
    <member name="E:yWorks.Graph.ITable.StripeChanged">
      <summary>
        <para>Occurs when a stripe has been changed, for instance, if its style has been replaced.</para>
      </summary>
      <seealso cref="M:yWorks.Graph.ITable.SetStyle(yWorks.Graph.IStripe,yWorks.Graph.Styles.IStripeStyle)" />
      <seealso cref="M:yWorks.Graph.ITable.SetStripeInsets(yWorks.Graph.IStripe,yWorks.Geometry.InsetsD)" />
      <seealso cref="M:yWorks.Graph.ITable.SetSize(yWorks.Graph.IStripe,System.Double)" />
      <seealso cref="M:yWorks.Graph.ITable.SetMinimumSize(yWorks.Graph.IStripe,System.Double)" />
    </member>
    <member name="M:yWorks.Graph.ITable.SetParent(yWorks.Graph.IRow,yWorks.Graph.IRow,System.Nullable{System.Int32})">
      <summary>
        <para>Sets <paramref name="owner" /> as new parent of <paramref name="row" />, inserting <paramref name="row" /> at the given <paramref name="index" />.</para>
      </summary>
      <remarks>
        <para>The row will be inserted at position <paramref name="index" /> in the child list of the new parent.</para>
      </remarks>
      <param name="owner" />
      <param name="row" />
      <param name="index" />
    </member>
    <member name="M:yWorks.Graph.ITable.SetParent(yWorks.Graph.IColumn,yWorks.Graph.IColumn,System.Nullable{System.Int32})">
      <summary>
        <para>Sets <paramref name="owner" /> as new parent of <paramref name="column" />, inserting <paramref name="column" /> at the given <paramref name="index" />.</para>
      </summary>
      <remarks>
        <para>The column will be inserted at position <paramref name="index" /> in the child list of the new parent.</para>
      </remarks>
      <param name="owner" />
      <param name="column" />
      <param name="index" />
    </member>
    <member name="M:yWorks.Graph.ITable.Remove(yWorks.Graph.IStripe)">
      <summary>
        <para>Removes <paramref name="stripe" /> from its parent container.</para>
      </summary>
      <remarks>
        <para>This method reparents all children of <paramref name="stripe" /> to the parent of the stripe.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe to remove</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.IRow">
      <summary>
        <para>Interface that describes a row in a <see cref="T:yWorks.Graph.ITable" /> instance.</para>
      </summary>
      <remarks>
        <para>Default implementations of this interface are created by the factory methods in the <see cref="T:yWorks.Graph.ITable" /> interface and its implementations, therefore, it usually shouldn't be necessary to implement this interface yourself.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.ITable.CreateRow(yWorks.Graph.IRow,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})" />
    </member>
    <member name="P:yWorks.Graph.IRow.ParentRow">
      <summary>
        <para>Gets the parent of this row.</para>
      </summary>
      <remarks>
        <para>In a table, each row has a parent, except for the <see cref="P:yWorks.Graph.ITable.RootRow" /> hierarchy root.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IRow.ChildRows">
      <summary>
        <para>Gets the child rows.</para>
      </summary>
      <remarks>
        <para>This collection may be empty. Each entry in this collection has this instance as <see cref="P:yWorks.Graph.IRow.ParentRow" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.IColumn">
      <summary>
        <para>Interface that describes a column in a <see cref="T:yWorks.Graph.ITable" /> instance.</para>
      </summary>
      <remarks>
        <para>Default implementations of this interface are created by the factory methods in the <see cref="T:yWorks.Graph.ITable" /> interface and its implementations, therefore, it usually shouldn't be necessary to implement this interface yourself.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.ITable.CreateColumn(yWorks.Graph.IColumn,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})" />
    </member>
    <member name="P:yWorks.Graph.IColumn.ParentColumn">
      <summary>
        <para>Gets the parent of this column.</para>
      </summary>
      <remarks>
        <para>In a table, each column has a parent, except for the <see cref="P:yWorks.Graph.ITable.RootColumn" /> hierarchy root.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IColumn.ChildColumns">
      <summary>
        <para>Gets the child columns.</para>
      </summary>
      <remarks>
        <para>This collection may be empty. Each entry in this collection has this instance as <see cref="P:yWorks.Graph.IColumn.ParentColumn" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Markup.Common.InteriorStretchLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.InteriorStretchLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.InteriorStretchLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.InteriorStretchLabelModel.Position)">
      <param name="position" />
    </member>
    <member name="M:yWorks.Markup.Common.InteriorStretchLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.InteriorStretchLabelModel.Position,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="position" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.InteriorStretchLabelModelParameterExtension.Position" />
    <member name="P:yWorks.Markup.Common.InteriorStretchLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.InteriorStretchLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.InteriorStretchLabelModel">
      <summary>
        <para>A label model for node labels that lie inside of the node's <see cref="P:yWorks.Graph.INode.Layout" /> bounds and have been stretched to fit the node's size.</para>
      </summary>
      <remarks>
        <para>This label model supports 5 positions inside of the layout's bounds.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorStretchLabelModel.North">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorStretchLabelModel" />, trying to change that instance's <see cref="P:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorStretchLabelModel.East">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorStretchLabelModel" />, trying to change that instance's <see cref="P:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorStretchLabelModel.South">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorStretchLabelModel" />, trying to change that instance's <see cref="P:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorStretchLabelModel.West">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorStretchLabelModel" />, trying to change that instance's <see cref="P:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Center">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorStretchLabelModel" />, trying to change that instance's <see cref="P:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Position">
      <summary>
        <para>Enumeration of the possible positions of the <see cref="T:yWorks.Graph.LabelModels.InteriorStretchLabelModel" />.</para>
      </summary>
      <remarks>
        <para>This field can be used as an argument for the <see cref="M:yWorks.Graph.LabelModels.InteriorStretchLabelModel.CreateParameter(yWorks.Graph.LabelModels.InteriorStretchLabelModel.Position)" /> factory method.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Position.North">
      <summary>
        <para>Encodes a position at the top side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Position.East">
      <summary>
        <para>Encodes a position at the right side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Position.South">
      <summary>
        <para>Encodes a position at the bottom side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Position.West">
      <summary>
        <para>Encodes a position at the left side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Position.Center">
      <summary>
        <para>Encodes a position at the center of the node interior</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorStretchLabelModel.#ctor">
      <summary>
        <para>Creates a new instance of this model with empty insets.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Insets">
      <summary>
        <para>Gets or sets the insets to use within the node's <see cref="P:yWorks.Graph.INode.Layout" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorStretchLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorStretchLabelModel.CreateDefaultParameter" />
    <member name="M:yWorks.Graph.LabelModels.InteriorStretchLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorStretchLabelModel.CreateParameter(yWorks.Graph.LabelModels.InteriorStretchLabelModel.Position)">
      <summary>
        <para>Creates the parameter for the given position.</para>
      </summary>
      <param name="position">
        <para>The position.</para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorStretchLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorStretchLabelModel.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="label" />
      <param name="model" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorStretchLabelModel.GetNodeInsets(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Returns the insets this model would require for the node owner of the label if the the given label was used with the provided parameter.</para>
      </summary>
      <param name="label">
        <para>The label to use.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter to use.</para>
      </param>
      <returns>
        <para>The insets rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorStretchLabelModel.GetMinimumNodeSize(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Returns the minimum size this model would require for the node owner of the label if the the given label was used with the provided parameter.</para>
      </summary>
      <param name="label">
        <para>The label to use.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter to use.</para>
      </param>
      <returns>
        <para>The minimum size requirements for this label.</para>
      </returns>
    </member>
    <member name="T:yWorks.Markup.Common.InteriorLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.InteriorLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.InteriorLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.InteriorLabelModel.Position)">
      <param name="position" />
    </member>
    <member name="M:yWorks.Markup.Common.InteriorLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.InteriorLabelModel.Position,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="position" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.InteriorLabelModelParameterExtension.Position" />
    <member name="P:yWorks.Markup.Common.InteriorLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.InteriorLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.InteriorLabelModel">
      <summary>
        <para>A label model for node labels that lie inside of the node's <see cref="P:yWorks.Graph.INode.Layout" /> bounds.</para>
      </summary>
      <remarks>
        <para>This label model supports nine positions inside of the layout's bounds.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.North">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.InteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.East">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.InteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.South">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.InteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.SouthEast">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.InteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.SouthWest">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.InteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.West">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.InteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.NorthEast">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.InteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.NorthWest">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.InteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.Center">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.InteriorLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.LabelModels.InteriorLabelModel.Position">
      <summary>
        <para>Enumeration of the possible positions of the <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />.</para>
      </summary>
      <remarks>
        <para>This field can be used as an argument for the <see cref="M:yWorks.Graph.LabelModels.InteriorLabelModel.CreateParameter(yWorks.Graph.LabelModels.InteriorLabelModel.Position)" /> factory method.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.Position.North">
      <summary>
        <para>Encodes a position at the top side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.Position.East">
      <summary>
        <para>Encodes a position at the right side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.Position.South">
      <summary>
        <para>Encodes a position at the bottom side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.Position.West">
      <summary>
        <para>Encodes a position at the left side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.Position.NorthEast">
      <summary>
        <para>Encodes a position at the upper right corner of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.Position.SouthEast">
      <summary>
        <para>Encodes a position at the lower right corner of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.Position.NorthWest">
      <summary>
        <para>Encodes a position at the upper left corner of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.Position.SouthWest">
      <summary>
        <para>Encodes a position at the lower left corner of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.InteriorLabelModel.Position.Center">
      <summary>
        <para>Encodes a position at the center of the node interior</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorLabelModel.#ctor">
      <summary>
        <para>Creates a new instance of this model with empty insets.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.LabelModels.InteriorLabelModel.Insets">
      <summary>
        <para>Gets or sets the insets to use within the node's <see cref="P:yWorks.Graph.INode.Layout" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorLabelModel.CreateDefaultParameter" />
    <member name="M:yWorks.Graph.LabelModels.InteriorLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorLabelModel.CreateParameter(yWorks.Graph.LabelModels.InteriorLabelModel.Position)">
      <summary>
        <para>Creates the parameter for the given position.</para>
      </summary>
      <param name="position">
        <para>The position.</para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorLabelModel.GetNodeInsets(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Returns the insets this model would require for the node owner of the label if the the given label was used with the provided parameter.</para>
      </summary>
      <param name="label">
        <para>The label to use.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter to use.</para>
      </param>
      <returns>
        <para>The insets rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorLabelModel.GetMinimumNodeSize(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Returns the minimum size this model would require for the node owner of the label if the the given label was used with the provided parameter.</para>
      </summary>
      <param name="label">
        <para>The label to use.</para>
      </param>
      <param name="layoutParameter">
        <para>The parameter to use.</para>
      </param>
      <returns>
        <para>The minimum size requirements for this label.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.InteriorLabelModel.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="label" />
      <param name="model" />
    </member>
    <member name="T:yWorks.Graph.MapperMetadata">
      <summary>
        <para>The meta data that is associated with <see cref="T:yWorks.Graph.IMapper`2" />s in a <see cref="T:yWorks.Graph.IMapperRegistry" />.</para>
      </summary>
      <seealso cref="M:yWorks.Graph.IMapperRegistry.GetMapperMetadata(System.Object)" />
      <seealso cref="M:yWorks.Graph.IMapperRegistry.SetMapperMetadata(System.Object,yWorks.Graph.MapperMetadata)" />
    </member>
    <member name="M:yWorks.Graph.MapperMetadata.Create``2(yWorks.Graph.IMapper{``0,``1})">
      <summary>
        <para>Creates an instance for the specified mapper.</para>
      </summary>
      <typeparam name="TKey">
        <para>The type of the keys.</para>
      </typeparam>
      <typeparam name="TValue">
        <para>The type of the values.</para>
      </typeparam>
      <param name="mapper">
        <para>The mapper instance to create the metadata for.</para>
      </param>
      <returns>
        <para>An instance that uses the <see cref="P:yWorks.Graph.MapperMetadata.KeyType" /> and <see cref="P:yWorks.Graph.MapperMetadata.ValueType" /> of the mapper.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.MapperMetadata.#ctor(yWorks.Graph.MapperMetadata)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.MapperMetadata" /> from the given instance class.</para>
      </summary>
      <param name="metadata">
        <para>The metadata to copy key and value type from.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.MapperMetadata.#ctor(System.Type,System.Type)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.MapperMetadata" /> class.</para>
      </summary>
      <param name="keyType">
        <para>Type of the keys.</para>
      </param>
      <param name="valueType">
        <para>Type of the values.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.MapperRegistry">
      <summary>
        <para>A simple <see cref="T:System.Collections.Generic.Dictionary`2" />-based implementation of the <see cref="T:yWorks.Graph.IMapperRegistry" /> interface.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.MapperRegistry.GetMapper``2(System.Object)">
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.MapperRegistry.AddMapper``2(System.Object,yWorks.Graph.IMapper{``0,``1})">
      <param name="tag" />
      <param name="mapper" />
    </member>
    <member name="M:yWorks.Graph.MapperRegistry.RemoveMapper(System.Object)">
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.MapperRegistry.GetMapperMetadata(System.Object)">
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.MapperRegistry.SetMapperMetadata(System.Object,yWorks.Graph.MapperMetadata)">
      <param name="tag" />
      <param name="metadata" />
    </member>
    <member name="T:yWorks.Markup.Common.NinePositionsEdgeLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.NinePositionsEdgeLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.NinePositionsEdgeLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position)">
      <param name="position" />
    </member>
    <member name="M:yWorks.Markup.Common.NinePositionsEdgeLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="position" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.NinePositionsEdgeLabelModelParameterExtension.Position" />
    <member name="P:yWorks.Markup.Common.NinePositionsEdgeLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.NinePositionsEdgeLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel">
      <summary>
        <para>An edge label model that knows nine different label positions.</para>
      </summary>
      <remarks>
        <para>The possible positions are near the source port, at the center of the edge, or near the target port, each above, below, or centered on the edge. The distance to the edge and the absolute angular orientation of the label can be specified.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position">
      <summary>
        <para>Determines the position of a label in the <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" /></para>
      </summary>
      <remarks>
        <para>This enumeration can be used for the factory method <see cref="M:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.CreateParameter(yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position)" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position.SourceAbove">
      <summary>
        <para>Encodes a label position at the source above the edge</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position.CenterAbove">
      <summary>
        <para>Encodes a label position at the center above the edge</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position.TargetAbove">
      <summary>
        <para>Encodes a label position at the target above the edge</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position.SourceCentered">
      <summary>
        <para>Encodes a label position at the source of the edge that lies on the edge</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position.CenterCentered">
      <summary>
        <para>Encodes a label position at the center of the edge that lies on the edge</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position.TargetCentered">
      <summary>
        <para>Encodes a label position at the source of the edge that lies on the edge</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position.SourceBelow">
      <summary>
        <para>Encodes a label position at the source below the edge</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position.CenterBelow">
      <summary>
        <para>Encodes a label position at the center below the edge</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position.TargetBelow">
      <summary>
        <para>Encodes a label position at the target below the edge</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.SourceAbove">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle" /> or <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance" /> properties will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.CenterAbove">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle" /> or <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance" /> properties will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.TargetAbove">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle" /> or <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance" /> properties will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.SourceCentered">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle" /> or <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance" /> properties will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.CenterCentered">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle" /> or <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance" /> properties will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.TargetCentered">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle" /> or <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance" /> properties will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.SourceBelow">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle" /> or <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance" /> properties will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.CenterBelow">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle" /> or <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance" /> properties will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.TargetBelow">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle" /> or <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance" /> properties will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" /> class with a <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance" /> of 10 and an <see cref="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle" /> of 0.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.#ctor(System.Double,System.Double)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel" /> class.</para>
      </summary>
      <param name="distance">
        <para>The distance.</para>
      </param>
      <param name="angle">
        <para>The angle.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Angle">
      <summary>
        <para>Gets or sets the angle for the rotation of the labels.</para>
      </summary>
      <remarks>
        <para>A value of <c>0</c> makes the label appear horizontally aligned.</para>
      </remarks>
      <value>
        <para>The angle in radians.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Distance">
      <summary>
        <para>Gets or sets the distance of the labels above or below the edge.</para>
      </summary>
      <value>
        <para>The distance to the edge.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.CreateDefaultParameter" />
    <member name="M:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.CreateParameter(yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Position)">
      <summary>
        <para>Create a model parameter for the specified <paramref name="position" /></para>
      </summary>
      <param name="position">
        <para>The position for this parameter</para>
      </param>
      <returns>
        <para>a model parameter for the specified <paramref name="position" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.NinePositionsEdgeLabelModel.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="label" />
      <param name="model" />
    </member>
    <member name="T:yWorks.Controls.Input.PortCandidateProviderBase">
      <summary>
        <para>An abstract convenience implementation of the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> interface.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.PortCandidateProviderBase.Style">
      <summary>
        <para>Gets or sets the style to use for the creation of the port in <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.CreateInstance(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.DefaultPortCandidate)" />.</para>
      </summary>
      <remarks>
        <para>A value of <c>null</c> will make the implementation use the corresponding current default port style.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviderBase.AddExistingPorts(yWorks.Graph.IPortOwner,System.Collections.Generic.IList{yWorks.Controls.Input.IPortCandidate})">
      <summary>
        <para>Convenience method for subclasses that adds all existing <see cref="P:yWorks.Graph.IPortOwner.Ports" /> of the <paramref name="owner" /> to the provided list.</para>
      </summary>
      <param name="owner">
        <para>The port owner whose ports should be added.</para>
      </param>
      <param name="list">
        <para>The list to add candidates for existing ports to.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviderBase.CreateCandidate(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,System.Boolean)">
      <summary>
        <para>Factory method that creates a simple candidate that will use the <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.CreateInstance(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.DefaultPortCandidate)" /> method of this instance to delegate <see cref="M:yWorks.Controls.Input.IPortCandidate.CreatePort(yWorks.Controls.Input.IInputModeContext)" /> queries to.</para>
      </summary>
      <param name="locationParameter">
        <para>The location of the candidate. This instance is assigned by reference to the candidate.</para>
      </param>
      <param name="owner">
        <para>The owner to use for the candidate.</para>
      </param>
      <param name="valid">
        <para>Whether the port should be <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Valid" />.</para>
      </param>
      <returns>
        <para>A candidate whose <see cref="M:yWorks.Controls.Input.IPortCandidate.CreatePort(yWorks.Controls.Input.IInputModeContext)" /> method delegates to this instance's <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.CreateInstance(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.DefaultPortCandidate)" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviderBase.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.DefaultPortCandidate,yWorks.Geometry.PointD)">
      <summary>
        <para>Callback method used by the ports created using the factory methods <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.CreateCandidate(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,System.Boolean)" />.</para>
      </summary>
      <remarks>
        <para>This method can be overridden by subclasses to perform more sophisticated candidate creation logic.</para>
      </remarks>
      <param name="context">
        <para>The context in which the instance is created.</para>
      </param>
      <param name="candidate">
        <para>The candidate to create a port for.</para>
      </param>
      <param name="suggestedLocation">
        <para>The location to get a candidate for.</para>
      </param>
      <returns>
        <para>The new candidate whose <see cref="P:yWorks.Controls.Input.IPortCandidate.Validity" /> may not be <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviderBase.CreateInstance(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.DefaultPortCandidate)">
      <summary>
        <para>Callback method used by the ports created using the factory methods <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.CreateCandidate(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,System.Boolean)" />.</para>
      </summary>
      <remarks>
        <para>This method can be overridden by subclasses to perform more sophisticated port creation logic.</para>
      </remarks>
      <param name="context">
        <para>The context in which the instance is created.</para>
      </param>
      <param name="candidate">
        <para>The candidate to create a port for.</para>
      </param>
      <returns>
        <para>The new port.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.PortCandidateProviderBase.Tag">
      <summary>
        <para>Gets or sets the tag to assign to the port in <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.CreateInstance(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.DefaultPortCandidate)" /></para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviderBase.GetSourcePortCandidates(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.IPortCandidate)">
      <summary>
        <para>Convenience implementation that simply delegates to <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.GetPortCandidates(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </summary>
      <param name="context" />
      <param name="target" />
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviderBase.GetTargetPortCandidates(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.IPortCandidate)">
      <summary>
        <para>Convenience implementation that simply delegates to <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.GetPortCandidates(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </summary>
      <param name="context" />
      <param name="source" />
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviderBase.GetSourcePortCandidates(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Convenience implementation that simply delegates to <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.GetPortCandidates(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </summary>
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviderBase.GetTargetPortCandidates(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Convenience implementation that simply delegates to <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.GetPortCandidates(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </summary>
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviderBase.GetPortCandidates(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Creates an enumeration of possibly port candidates.</para>
      </summary>
      <remarks>
        <para>This method is used as a callback by most of the getter methods in this class. Subclasses should override this method to provide the same candidates for all use-cases.</para>
      </remarks>
      <param name="context">
        <para>The context for which the candidates should be provided.</para>
      </param>
      <returns>
        <para>An enumerable collection of port candidates.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.PortCandidateProviders">
      <summary>
        <para>Provides access to various factory methods to create <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> instances for various purposes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.PortCandidateProviders.NoCandidates">
      <summary>
        <para>A generic implementation of the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> interface that provides no candidates.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviders.FromExistingPorts(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Creates an implementation of the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> interface that returns the ports that exist in the given <see cref="P:yWorks.Graph.IPortOwner.Ports" />'s <see cref="T:yWorks.Graph.IPortOwner" /> collection.</para>
      </summary>
      <param name="owner">
        <para>The owner of the port collection.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviders.FromShapeGeometry(yWorks.Graph.IPortOwner,System.Double[])">
      <summary>
        <para>Creates an implementation of <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> that works for <see cref="T:yWorks.Graph.IPortOwner" /> implementations that have <see cref="T:yWorks.Graph.Styles.IShapeGeometry" /> instances in their lookup.</para>
      </summary>
      <param name="owner">
        <para>The owner to receive the shape geometry from</para>
      </param>
      <param name="ratios">
        <para>A number of double values that are interpreted as ratio values between 0.0 and 1.0. If none are given, the provider inserts a port candidate at the center of each straight line segment.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviders.FromShapeGeometry(yWorks.Graph.IPortOwner,System.Boolean,System.Double,System.Double[])">
      <summary>
        <para>Creates an implementation of <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> that works for <see cref="T:yWorks.Graph.IPortOwner" /> implementations that have <see cref="T:yWorks.Graph.Styles.IShapeGeometry" /> instances in their lookup.</para>
      </summary>
      <param name="owner">
        <para>The owner to receive the shape geometry from</para>
      </param>
      <param name="minimumSegmentLength">
        <para>the minimum length a segment needs to have in order to be used to add port candidates.</para>
      </param>
      <param name="ratios">
        <para>A number of double values that are interpreted as ratio values between 0.0 and 1.0. If none are given, the provider inserts a port candidate at the center of each straight line segment.</para>
      </param>
      <param name="addExistingPortsEnabled">
        <para>determines whether <see cref="M:yWorks.Controls.Input.PortCandidateProviderBase.AddExistingPorts(yWorks.Graph.IPortOwner,System.Collections.Generic.IList{yWorks.Controls.Input.IPortCandidate})">existing ports should be added to the list of ports</see>.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviders.Combine(System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidateProvider})">
      <summary>
        <para>Creates a generic composite implementation for the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> interface.</para>
      </summary>
      <param name="providers">
        <para>The providers to create the composite from.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviders.Combine(yWorks.Controls.Input.IPortCandidateProvider[])">
      <summary>
        <para>Creates a generic composite implementation for the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> interface.</para>
      </summary>
      <param name="providers">
        <para>The providers to create the composite from.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviders.FromUnoccupiedPorts(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Creates a simple implementation of an <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> that returns unoccupied ports at a given entity.</para>
      </summary>
      <param name="owner">
        <para>The owner to query the ports from.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviders.FromPortDefaults(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Creates a simple implementation of an <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> that always returns a candidate that uses the default <see cref="P:yWorks.Graph.IPortDefaults.LocationParameter" /> for the corresponding <see cref="T:yWorks.Graph.IPortDefaults" />.</para>
      </summary>
      <param name="owner" />
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviders.FromNodeCenter(yWorks.Graph.INode)">
      <summary>
        <para>Creates a trivial implementation of an <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> that always returns exactly one candidate that is centered at the node's <see cref="P:yWorks.Graph.INode.Layout" />.</para>
      </summary>
      <param name="node">
        <para>The node to get the layout's center from.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviders.FromCandidates(yWorks.Controls.Input.IPortCandidate[])">
      <summary>
        <para>Creates an implementation of an <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> that provides only the given port candidates.</para>
      </summary>
      <param name="candidates">
        <para>The port candidates the provider should provide.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.PortCandidateProviders.FromCandidates(System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate})">
      <summary>
        <para>Creates an implementation of an <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> that provides only the given port candidates.</para>
      </summary>
      <param name="candidates">
        <para>The port candidates the provider should provide.</para>
      </param>
      <returns>
        <para>A new <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.PortRelocationHandle">
      <summary>
        <para>A sophisticated implementation of the <see cref="T:yWorks.Controls.Input.IHandle" /> interface that lets the user change an edge's <see cref="P:yWorks.Graph.IEdge.SourcePort">source</see> and <see cref="P:yWorks.Graph.IEdge.TargetPort">target port</see>.</para>
      </summary>
      <remarks>
        <para>This handle will move one of the edge's end points visually to another <see cref="T:yWorks.Graph.IPort" /> or <see cref="T:yWorks.Controls.Input.IPortCandidate" /> and upon finalization of the gesture will <see cref="M:yWorks.Controls.Input.PortRelocationHandle.SetPorts(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">set the new ports</see> for the edge. This class heavily relies on the implementation of the <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> that is queried from the <see cref="T:yWorks.Graph.IEdge" /> this handle is acting on.</para>
      </remarks>
      <seealso cref="M:yWorks.Controls.Input.PortRelocationHandle.GetPortCandidates(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean)" />
      <seealso cref="P:yWorks.Graph.EdgeDecorator.EdgeReconnectionPortCandidateProviderDecorator" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.#ctor(yWorks.Graph.IGraph,yWorks.Graph.IEdge,System.Boolean)">
      <summary>
        <para>Creates a new instance of the <see cref="T:yWorks.Controls.Input.PortRelocationHandle" /> class.</para>
      </summary>
      <param name="graph">
        <para>The graph or <c>null</c>. If the graph instance is not specified, the handle will try to receive the graph from the <see cref="T:yWorks.Controls.Input.IInputModeContext" /> it is passed in during <see cref="M:yWorks.Controls.Input.PortRelocationHandle.InitializeDrag(yWorks.Controls.Input.IInputModeContext)" />.</para>
      </param>
      <param name="edge">
        <para>The edge.</para>
      </param>
      <param name="sourceEnd">
        <para>if set to <c>true</c> the source end will be subject to relocation, otherwise it will be the target port.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.ShowHitPortOwnerCandidatesOnly">
      <summary>
        <para>Gets or sets a value indicating whether to show the candidates of hit <see cref="T:yWorks.Graph.IPortOwner" />s only.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if only candidates of hit nodes and edges are shown; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.CreatePortCandidateDescriptor">
      <summary>
        <para>Factory method that creates the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> that will be used to paint the <see cref="T:yWorks.Controls.Input.IPortCandidate" />s.</para>
      </summary>
      <returns>
        <para>The descriptor to use for the rendering in the <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.CreateCurrentPortCandidateDescriptor">
      <summary>
        <para>Factory method that creates the <see cref="T:yWorks.Controls.ICanvasObjectDescriptor" /> that will be used to paint the "current" <see cref="T:yWorks.Controls.Input.IPortCandidate" />.</para>
      </summary>
      <returns>
        <para>The descriptor to use for the rendering in the <see cref="T:yWorks.Controls.CanvasControl" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.MaximumSnapDistance">
      <summary>
        <para>Gets or sets the maximum distance the pointer may be away of a candidate in order to be snapped to the candidate.</para>
      </summary>
      <remarks>
        <para>The distance is measured in view coordinates. The default value is <c>50.0</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.CreateDummyEdge(yWorks.Graph.IEdge)">
      <summary>
        <para>Factory method that creates the dummy edge that will be shown during the drag operation.</para>
      </summary>
      <param name="edge">
        <para>The edge to be represented by the dummy edge.</para>
      </param>
      <returns>
        <para>The dummy edge instance to use.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.PortRelocationHandle.ShowDummyEdge" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.SetToPortCandidate(yWorks.Graph.SimpleEdge,System.Boolean,yWorks.Controls.Input.IPortCandidate)">
      <summary>
        <para>Updates the dummy edge's visual appearance to reflect the new port candidate.</para>
      </summary>
      <param name="dummy">
        <para>The dummy edge.</para>
      </param>
      <param name="source">
        <para>Whether to update the source or target port.</para>
      </param>
      <param name="portCandidate">
        <para>The new candidate to indicate.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.AllowEdgeToEdgeConnections">
      <summary>
        <para>Gets or sets whether or not edges are allowed to connect to other edges.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.AllowCyclicPortDependencies">
      <summary>
        <para>Gets or sets whether or not cyclic port dependencies are allowed.</para>
      </summary>
      <remarks>
        <para>If <see cref="P:yWorks.Controls.Input.PortRelocationHandle.AllowEdgeToEdgeConnections">edge to edge connections</see> are allowed by this instance, this property determines whether <see cref="M:yWorks.Controls.Input.PortRelocationHandle.GetClosestCandidate(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate})" />s are will yield candidates that would result in the edge being modified would create a cyclic dependency. The default is <c>false</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.AddExistingPort">
      <summary>
        <para>Gets or sets a property that determines whether the existing port should be available as a possible port candidate, too.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>. If this property is set to <c>false</c>, <see cref="M:yWorks.Controls.Input.PortRelocationHandle.GetPortCandidates(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean)" /> will return only the ports provided by the <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> in the node's lookup.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.InitializeDrag(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.GetPortCandidates(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean)">
      <summary>
        <para>Gets the possible candidates for the given edge.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> from the edge's <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> to retrieve the candidate sets. If <see cref="P:yWorks.Controls.Input.PortRelocationHandle.AddExistingPort" /> is enabled, the existing port will be part of the candidates.</para>
      </remarks>
      <param name="context">
        <para>The context that is used to retrieve the candidates for.</para>
      </param>
      <param name="edge">
        <para>The edge.</para>
      </param>
      <param name="sourcePort">
        <para>Whether to look for source port candidates.</para>
      </param>
      <returns>
        <para>A non-<c>null</c> enumerable over the candidates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.CreateExistingPortCandidate(yWorks.Graph.IPort)">
      <summary>
        <para>Factory method that creates the candidate for the existing port.</para>
      </summary>
      <param name="port">
        <para>The port to create a candidate for.</para>
      </param>
      <returns>
        <para>The candidate or <c>null</c>.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.PortRelocationHandle.GetPortCandidates(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean)" />
      <seealso cref="P:yWorks.Controls.Input.PortRelocationHandle.AddExistingPort" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.HandleMove(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.SetClosestCandidate(yWorks.Controls.Input.IPortCandidate)">
      <summary>
        <para>Updates the closest candidate for visual feedback.</para>
      </summary>
      <param name="portCandidate" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.CancelDrag(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="originalLocation" />
      <param name="newLocation" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.SetPort(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,System.Boolean,yWorks.Controls.Input.IPortCandidate,System.Nullable{yWorks.Geometry.PointD})">
      <summary>
        <para>Callback that is triggered by <see cref="M:yWorks.Controls.Input.PortRelocationHandle.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> to actually change the port.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="edge">
        <para>The edge to change ports.</para>
      </param>
      <param name="setSourcePort">
        <para>Whether to set the source port. <c>false</c> for target ports.</para>
      </param>
      <param name="portCandidate">
        <para>The candidate that has been chosen.</para>
      </param>
      <param name="suggestedLocation">
        <para>The suggested location for the port.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.GetPort(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.IPortCandidate,System.Nullable{yWorks.Geometry.PointD})">
      <summary>
        <para>Callback used during <see cref="M:yWorks.Controls.Input.PortRelocationHandle.DragFinished(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> to actually get the new port from the chosen candidate.</para>
      </summary>
      <remarks>
        <para>This implementation returns the result of <see cref="M:yWorks.Controls.Input.IPortCandidate.CreatePort(yWorks.Controls.Input.IInputModeContext)" /> or calls <see cref="M:yWorks.Graph.IGraph.AddPort(yWorks.Graph.IPortOwner,yWorks.Graph.PortLocationModels.IPortLocationModelParameter,yWorks.Graph.Styles.IPortStyle,System.Object)" /> if the result was <c>null</c>.</para>
      </remarks>
      <param name="context" />
      <param name="portCandidate">
        <para>The candidate to get a port instance from.</para>
      </param>
      <param name="suggestedLocation">
        <para>The suggested location for the port.</para>
      </param>
      <returns>
        <para>A non-<c>null</c> port instance.</para>
      </returns>
      <seealso cref="M:yWorks.Controls.Input.PortRelocationHandle.SetPorts(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.SetPorts(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge,yWorks.Graph.IPort,yWorks.Graph.IPort)">
      <summary>
        <para>Finally sets the ports for the edge to the new values.</para>
      </summary>
      <param name="context">
        <para>The context in which the ports are set.</para>
      </param>
      <param name="edge">
        <para>The edge to set the ports for.</para>
      </param>
      <param name="sourcePort">
        <para>The (possibly) new source port.</para>
      </param>
      <param name="targetPort">
        <para>The (possibly) new target port.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.GetClosestCandidate(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,System.Collections.Generic.IEnumerable{yWorks.Controls.Input.IPortCandidate})">
      <summary>
        <para>Finds the closest candidate from the given set of candidates.</para>
      </summary>
      <param name="context">
        <para>The context in for which the closest handle candidate is sought.</para>
      </param>
      <param name="location">
        <para>The location for which to find a candidate.</para>
      </param>
      <param name="candidates">
        <para>The list of possible candidates.</para>
      </param>
      <returns>
        <para>The closes candidate or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.ResolveCandidate(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.IPortCandidate,yWorks.Geometry.PointD)">
      <summary>
        <para>Tries to <see cref="M:yWorks.Controls.Input.IPortCandidate.GetPortCandidateAt(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">resolve</see> a dynamic port candidate for the given location.</para>
      </summary>
      <param name="context">
        <para>The context in which the candidate is resolved.</para>
      </param>
      <param name="portCandidate">
        <para>The candidate.</para>
      </param>
      <param name="location">
        <para>The current location.</para>
      </param>
      <returns>
        <para>A candidate.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.ResolvePortCandidates">
      <summary>
        <para>Gets or sets a value indicating whether a <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic">dynamic port candidate</see> should be resolved for the current mouse location.</para>
      </summary>
      <remarks>
        <para>By default this feature is enabled and the <see cref="P:yWorks.Controls.Input.PortRelocationHandle.PortCandidateResolutionRecognizer" /> is configured so that the resolution mechanism is used if the user <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.ShiftPressed">holds the shift modifier</see> during the gesture.</para>
      </remarks>
      <seealso cref="P:yWorks.Controls.Input.PortRelocationHandle.PortCandidateResolutionRecognizer" />
      <seealso cref="M:yWorks.Controls.Input.PortRelocationHandle.ResolveCandidate(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.IPortCandidate,yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.PortCandidateResolutionRecognizer">
      <summary>
        <para>Gets or sets the event recognizer that determines whether a <see cref="F:yWorks.Controls.Input.PortCandidateValidity.Dynamic">dynamic port candidate</see> should be resolved.</para>
      </summary>
      <remarks>
        <para>Note that this property has no effect if <see cref="P:yWorks.Controls.Input.PortRelocationHandle.ResolvePortCandidates" /> is set to <c>false</c>.</para>
        <para>By default this is set to <see cref="F:yWorks.Controls.Input.KeyEventRecognizers.ShiftPressed" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.SourceEnd">
      <summary>
        <para>Gets a value indicating whether the source end of the edge is handled by this instance.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the source end is handled; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.Edge">
      <summary>
        <para>Gets the edge this instance acts upon.</para>
      </summary>
      <value>
        <para>The edge.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.DummyEdge">
      <summary>
        <para>Gets the dummy edge this instance uses during the edit.</para>
      </summary>
      <value>
        <para>The dummy edge.</para>
      </value>
      <seealso cref="P:yWorks.Controls.Input.PortRelocationHandle.ShowDummyEdge" />
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.ShowDummyEdge">
      <summary>
        <para>Gets or sets a value indicating whether to show a dummy edge during the drag operation.</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.InputModeContext">
      <summary>
        <para>Gets or sets the context to operate on.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.PortRelocationHandle.Location">
      <summary>
        <para>Gets a view of the location of the item.</para>
      </summary>
      <remarks>
        <para>This implementation returns <c>this</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.IsPortCandidateResolutionEnabled(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Determines whether <see cref="M:yWorks.Controls.Input.PortRelocationHandle.ResolveCandidate(yWorks.Controls.Input.IInputModeContext,yWorks.Controls.Input.IPortCandidate,yWorks.Geometry.PointD)">port candidate resolution</see> is enabled for the current gesture.</para>
      </summary>
      <remarks>
        <para>This implementation checks whether the the parent input mode is an instance of <see cref="T:yWorks.Controls.Input.HandleInputMode" />, the <see cref="P:yWorks.Controls.Input.PortRelocationHandle.PortCandidateResolutionRecognizer" /> recognizes its <see cref="T:yWorks.Controls.Mouse2DEventArgs" />, and the <see cref="P:yWorks.Controls.Input.HandleInputMode.CurrentHandle" />'s location is equal to this <see cref="P:yWorks.Controls.Input.PortRelocationHandle.Location" />.</para>
      </remarks>
      <param name="context">
        <para>The context to inspect.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if port candidates may be resolved; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.CreateDummyEdgeVisualCreator(yWorks.Graph.SimpleEdge)">
      <summary>
        <para>Factory method that creates a dummy paintable for the dummy edge during the drag operation.</para>
      </summary>
      <param name="dummy">
        <para>The dummy to create a paintable for.</para>
      </param>
      <returns>
        <para>A paintable that shows the dummy.</para>
      </returns>
      <seealso cref="P:yWorks.Controls.Input.PortRelocationHandle.ShowDummyEdge" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.HideOriginalEdge(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge)">
      <summary>
        <para>Hides the original edge that during the drag operation.</para>
      </summary>
      <param name="edge">
        <para>The edge to hide.</para>
      </param>
      <param name="context">
        <para>The context to get the canvas the edge should be hidden from.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.PortRelocationHandle.UnhideOriginalEdge(yWorks.Graph.IEdge,yWorks.Controls.CanvasControl)" />
      <seealso cref="P:yWorks.Controls.Input.PortRelocationHandle.ShowDummyEdge" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.UnhideOriginalEdge(yWorks.Graph.IEdge,yWorks.Controls.CanvasControl)">
      <summary>
        <para>Unhides the original edge that was hidden during the drag operation.</para>
      </summary>
      <param name="edge">
        <para>The edge to unhide.</para>
      </param>
      <param name="canvas">
        <para>The canvas the edge was hidden from.</para>
      </param>
      <seealso cref="M:yWorks.Controls.Input.PortRelocationHandle.HideOriginalEdge(yWorks.Controls.Input.IInputModeContext,yWorks.Graph.IEdge)" />
      <seealso cref="P:yWorks.Controls.Input.PortRelocationHandle.ShowDummyEdge" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.SetPosition(yWorks.Geometry.PointD)">
      <summary>
        <para>Updates the position of the handle.</para>
      </summary>
      <param name="location">
        <para>The new location of the handle.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandle.GetGraph(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Gets the graph to use from the context.</para>
      </summary>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <returns>
        <para>A graph instance or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.PortRelocationHandleProvider">
      <summary>
        <para>Simple implementation of a <see cref="T:yWorks.Controls.Input.IHandleProvider" /> that can be used for <see cref="T:yWorks.Graph.IEdge" />s.</para>
      </summary>
      <remarks>
        <para>It will return the <see cref="T:yWorks.Controls.Input.IHandle" />s for the <see cref="P:yWorks.Graph.IEdge.SourcePort">source</see> and <see cref="P:yWorks.Graph.IEdge.TargetPort">target</see> ports using <see cref="T:yWorks.Controls.Input.PortRelocationHandle" />s.</para>
        <para>Note that this implementation also explicitly implements the <see cref="T:yWorks.Controls.Input.IEdgePortHandleProvider" /> and that it is recommended to decorate the <see cref="T:yWorks.Controls.Input.IEdgePortHandleProvider" /> interface with edges in order to influence the handles of the source and target port of the edge instead of directly decorating and implementing the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> interface. The default implementation of the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> interface in the lookup of the <see cref="T:yWorks.Graph.IEdge" />s (see <see cref="P:yWorks.Graph.DefaultGraph.DefaultEdgeLookup" />) will use the <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> interface to collect the source and target port handles.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.PortRelocationHandleProvider.graph">
      <summary>
        <para>The graph this provider is working on.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.PortRelocationHandleProvider.edge">
      <summary>
        <para>The edge this provider is working on.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandleProvider.#ctor(yWorks.Graph.IGraph,yWorks.Graph.IEdge)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.Input.PortRelocationHandleProvider" /> class using the given graph and edge.</para>
      </summary>
      <param name="graph">
        <para>The graph or null. If the graph is null, the handles will try to receive the graph from the <see cref="T:yWorks.Controls.Input.IInputModeContext" /> it is used in.</para>
      </param>
      <param name="edge">
        <para>The edge.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandleProvider.GetHandles(yWorks.Controls.Input.IInputModeContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.PortRelocationHandleProvider.CreatePortRelocationHandle(yWorks.Graph.IGraph,yWorks.Graph.IEdge,System.Boolean)">
      <summary>
        <para>Factory method that creates the handle for this provider.</para>
      </summary>
      <param name="graph">
        <para>The graph that contains the edge.</para>
      </param>
      <param name="edge">
        <para>The edge.</para>
      </param>
      <param name="sourcePort">
        <para>if set to <c>true</c> the handle for the source port is sought.</para>
      </param>
      <returns>
        <para>A handle or <c>null</c>.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.PortsHandleProvider">
      <summary>
        <para>A simple implementation of an <see cref="T:yWorks.Controls.Input.IHandleProvider" /> that returns all handles in the lookup of the ports owned by the given owner.</para>
      </summary>
      <remarks>
        <para>Using this class to display port handles will result in exceptions if the underlying port instances are removed from the graph while the handles are displayed. This can happen, for example, through <c>Undo</c> or if ports are removed programmatically with <see cref="M:yWorks.Graph.IGraph.Remove(yWorks.Graph.IModelItem)" />. In that case, you need to query the handles again before interacting with the graph, for example by temporarily unselecting and reselecting the port-owning nodes.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.PortsHandleProvider.portOwner">
      <summary>
        <para>The owner of the ports.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.PortsHandleProvider.#ctor(yWorks.Graph.IPortOwner)">
      <summary>
        <para>Creates an instance using the given owner as the provider for the ports.</para>
      </summary>
      <param name="owner" />
    </member>
    <member name="M:yWorks.Controls.Input.PortsHandleProvider.GetHandles(yWorks.Controls.Input.IInputModeContext)">
      <summary>
        <para>Returns a collection of zero or more <see cref="T:yWorks.Controls.Input.IHandle" /> implementations that are associated with the ports of this context.</para>
      </summary>
      <returns>
        <para>A collection of handles.</para>
      </returns>
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.Input.PortsHandleProvider.GetHandle(yWorks.Graph.IPort)">
      <summary>
        <para>Retrieves the handle implementation from the port's lookup.</para>
      </summary>
      <param name="port" />
    </member>
    <member name="T:yWorks.Markup.Common.RowExtension" />
    <member name="M:yWorks.Markup.Common.RowExtension.#ctor" />
    <member name="P:yWorks.Markup.Common.RowExtension.Rows" />
    <member name="P:yWorks.Markup.Common.RowExtension.MinimumSize" />
    <member name="P:yWorks.Markup.Common.RowExtension.Size" />
    <member name="P:yWorks.Markup.Common.RowExtension.Insets" />
    <member name="P:yWorks.Markup.Common.RowExtension.Labels" />
    <member name="P:yWorks.Markup.Common.RowExtension.Style" />
    <member name="P:yWorks.Markup.Common.RowExtension.Tag" />
    <member name="M:yWorks.Markup.Common.RowExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Common.SandwichParameterExtension" />
    <member name="M:yWorks.Markup.Common.SandwichParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.SandwichParameterExtension.#ctor(yWorks.Graph.LabelModels.ExteriorLabelModel.Position)">
      <param name="position" />
    </member>
    <member name="M:yWorks.Markup.Common.SandwichParameterExtension.#ctor(yWorks.Graph.LabelModels.ExteriorLabelModel.Position,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="position" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.SandwichParameterExtension.Position" />
    <member name="P:yWorks.Markup.Common.SandwichParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.SandwichParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.SandwichLabelModel">
      <summary>
        <para>A node label model that knows only two possible positions.</para>
      </summary>
      <remarks>
        <para>The label will be placed centered on top or below the node's <see cref="P:yWorks.Graph.INode.Layout" /> using a specifiable <see cref="P:yWorks.Graph.LabelModels.SandwichLabelModel.YOffset" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.SandwichLabelModel.North">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.SandwichLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.SandwichLabelModel.YOffset" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.SandwichLabelModel.South">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.SandwichLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.SandwichLabelModel.YOffset" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.SandwichLabelModel.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LabelModels.SandwichLabelModel" /> class with zero offset.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.LabelModels.SandwichLabelModel.YOffset">
      <summary>
        <para>Gets or sets the distance between the node's <see cref="P:yWorks.Graph.INode.Layout" /> and the label's <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.SandwichLabelModel.CreateNorthParameter">
      <summary>
        <para>Creates a parameter for the north side of the node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.SandwichLabelModel.CreateSouthParameter">
      <summary>
        <para>Creates a parameter for the south side of the node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.SandwichLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.SandwichLabelModel.CreateDefaultParameter" />
    <member name="M:yWorks.Graph.LabelModels.SandwichLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.SandwichLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.SandwichLabelModel.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="label" />
      <param name="model" />
    </member>
    <member name="T:yWorks.Markup.Common.SegmentRatioParameterExtension" />
    <member name="P:yWorks.Markup.Common.SegmentRatioParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.SegmentRatioParameterExtension.#ctor" />
    <member name="P:yWorks.Markup.Common.SegmentRatioParameterExtension.Index" />
    <member name="P:yWorks.Markup.Common.SegmentRatioParameterExtension.Ratio" />
    <member name="M:yWorks.Markup.Common.SegmentRatioParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.PortLocationModels.SegmentRatioPortLocationModel">
      <summary>
        <para>A port location model that places the port on a certain edge segment at a specified ratio.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.PortLocationModels.SegmentRatioPortLocationModel.Instance">
      <summary>
        <para>A static immutable global instance of this class.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.SegmentRatioPortLocationModel.GetLocation(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="port" />
      <param name="locationParameter" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.SegmentRatioPortLocationModel.CreateParameter(yWorks.Graph.IPortOwner,yWorks.Geometry.PointD)">
      <param name="owner" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.SegmentRatioPortLocationModel.CreateFromSource(System.Double,System.Int32)">
      <summary>
        <para>Creates the a new parameter for the specified segment index and ratio.</para>
      </summary>
      <param name="ratio">
        <para>The ratio for the segment, with <c>0</c> being at the start of the segment and <c>1</c> at the end.</para>
      </param>
      <param name="segmentIndex">
        <para>The index of the segment.</para>
      </param>
      <returns>
        <para>A parameter for the given ratio and segment.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.SegmentRatioPortLocationModel.CreateFromTarget(System.Double,System.Int32)">
      <summary>
        <para>Creates the a new parameter for the specified segment index counted from the target end of the edge and the provided ratio.</para>
      </summary>
      <param name="ratio">
        <para>The ratio for the segment, with <c>0</c> being at the start of the segment and <c>1</c> at the end.</para>
      </param>
      <param name="segmentIndex">
        <para>The index of the segment counted from the target end.</para>
      </param>
      <returns>
        <para>A parameter for the given ratio and segment.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.SegmentRatioPortLocationModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.PortLocationModels.SegmentRatioPortLocationModel.GetContext(yWorks.Graph.IPort,yWorks.Graph.PortLocationModels.IPortLocationModelParameter)">
      <param name="port" />
      <param name="locationParameter" />
    </member>
    <member name="T:yWorks.Controls.Input.EdgeReconnectionPortCandidateProviders">
      <summary>
        <para>Provides default implementations of the <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> interface.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.EdgeReconnectionPortCandidateProviders.FromSourceAndTarget(yWorks.Graph.IEdge)">
      <summary>
        <para>Creates an implementation of the <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> interface that returns the candidates provided by the source and target port's owner's <see cref="T:yWorks.Controls.Input.IPortCandidateProvider" /> implementations or the existing edge's port, if no such provider is registered.</para>
      </summary>
      <remarks>
        <para>This instance uses the lookup mechanism of the nodes to query the providers.</para>
      </remarks>
      <param name="edge" />
    </member>
    <member name="F:yWorks.Controls.Input.EdgeReconnectionPortCandidateProviders.AllNodeCandidates">
      <summary>
        <para>Creates an implementation of the <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> interface that returns a union of all <see cref="M:yWorks.Controls.Input.IPortCandidateProvider.GetSourcePortCandidates(yWorks.Controls.Input.IInputModeContext)">source port candidates</see> or <see cref="M:yWorks.Controls.Input.IPortCandidateProvider.GetTargetPortCandidates(yWorks.Controls.Input.IInputModeContext)">target port candidates</see>, respectively, of nodes in the graph.</para>
      </summary>
      <remarks>
        <para>This implementation can be used to allow for <see cref="T:yWorks.Controls.Input.PortRelocationHandle">relocating an edge's port</see> to any available source or target port in the graph.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.EdgeReconnectionPortCandidateProviders.AllNodeAndEdgeCandidates">
      <summary>
        <para>Creates an implementation of the <see cref="T:yWorks.Controls.Input.IEdgeReconnectionPortCandidateProvider" /> interface that returns a union of all <see cref="M:yWorks.Controls.Input.IPortCandidateProvider.GetSourcePortCandidates(yWorks.Controls.Input.IInputModeContext)">source port candidates</see> or <see cref="M:yWorks.Controls.Input.IPortCandidateProvider.GetTargetPortCandidates(yWorks.Controls.Input.IInputModeContext)">target port candidates</see>, respectively, of nodse and edges in the graph.</para>
      </summary>
      <remarks>
        <para>This implementation can be used to allow for <see cref="T:yWorks.Controls.Input.PortRelocationHandle">relocating an edge's port</see> to any available source or target port in the graph.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.LabelModels.SmartEdgeLabelModel">
      <summary>
        <para>An edge label model that allows the placement at any position.</para>
      </summary>
      <remarks>
        <para>Similar to <see cref="T:yWorks.Graph.LabelModels.EdgeSegmentLabelModel" />, a position is specified by an edge segment and a ratio on that segment, amongst others. During changes of the edge path, the label keeps its relative location with respect to the bends of the reference segment in a similar way.</para>
        <para>In contrast to <see cref="T:yWorks.Graph.LabelModels.EdgeSegmentLabelModel" />, the distance from the edge path is not a property of the model but of the particular parameter. In addition, this class does not implement <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameterProvider" /> and therefore, labels with this model can be moved freely and are not restricted to a fixed set of candidates at a given distance from the edge.</para>
        <para>If <see cref="P:yWorks.Graph.LabelModels.SmartEdgeLabelModel.AutoRotation" /> is enabled, labels are automatically rotated according to the angle of the corresponding reference edge segment.</para>
        <para>During movements, labels with this model snap to noteable positions if the <see cref="T:yWorks.Controls.Input.MoveLabelInputMode" /> provides a <see cref="T:yWorks.Controls.Input.LabelSnapContext" /> that is enabled and has a suitable configuration.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.SmartEdgeLabelModel.#ctor">
      <summary>
        <para>Initializes a new instance of this class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.LabelModels.SmartEdgeLabelModel.AutoRotation">
      <summary>
        <para>Gets or sets whether or not edge labels are automatically rotated according to the angle of the corresponding reference edge segment.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels are automatically rotated; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>By default, this feature is enabled.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.LabelModels.SmartEdgeLabelModel.Angle">
      <summary>
        <para>Gets or sets the rotation angle of all labels with this model.</para>
      </summary>
      <value>
        <para>The rotation angle of all labels with this model.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.LabelModels.SmartEdgeLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.SmartEdgeLabelModel.CreateParameterFromSource(System.Int32,System.Double,System.Double)">
      <summary>
        <para>Creates a parameter that measures the provided segment index from the source side of the edge path.</para>
      </summary>
      <param name="segmentIndex">
        <para>The zero-based index of the segment beginning from the source side.</para>
      </param>
      <param name="distance">
        <para>The distance between the label's box and the edge's path.</para>
      </param>
      <param name="segmentRatio">
        <para>The ratio at which to place the label at the segment. A ratio of <c>0.0</c> will place the label at the source side of the segment, a ratio of <c>1.0</c> at the target side. Ratios lesser than <c>0.0</c> or greater than <c>1.0</c> will be interpreted as absolute values in world coordinates.</para>
      </param>
      <returns>
        <para>A label parameter that describes the provided parameters for this model instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.SmartEdgeLabelModel.CreateParameterFromTarget(System.Int32,System.Double,System.Double)">
      <summary>
        <para>Creates a parameter that measures the provided segment index from the target side of the edge path.</para>
      </summary>
      <param name="segmentIndex">
        <para>The zero-based index of the segment beginning from the target side.</para>
      </param>
      <param name="distance">
        <para>The distance between the label's box and the edge's path.</para>
      </param>
      <param name="segmentRatio">
        <para>The ratio at which to place the label at the segment. A ratio of <c>0.0</c> will place the label at the target side of the segment, a ratio of <c>1.0</c> at the source side. Ratios lesser than <c>0.0</c> or greater than <c>1.0</c> will be interpreted as absolute values in world coordinates.</para>
      </param>
      <returns>
        <para>A label parameter that describes the provided parameters for this model instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.SmartEdgeLabelModel.CreateDefaultParameter" />
    <member name="M:yWorks.Graph.LabelModels.SmartEdgeLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.SmartEdgeLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.SmartEdgeLabelModel.FindBestParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel,yWorks.Geometry.IOrientedRectangle)">
      <param name="label" />
      <param name="model" />
      <param name="layout" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.SmartEdgeLabelModel.GetDistance(yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Gets the distance from the edge path described by the specified parameter.</para>
      </summary>
      <param name="layoutParameter">
        <para>The parameter to get the edge path distance for.</para>
      </param>
      <returns>
        <para>The distance from the edge path</para>
      </returns>
    </member>
    <member name="T:yWorks.Markup.Common.SmartEdgeLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.SmartEdgeLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.SmartEdgeLabelModelParameterExtension.#ctor(yWorks.Markup.Common.SliderParameterLocation,System.Int32,System.Double,System.Double)">
      <param name="location" />
      <param name="segmentIndex" />
      <param name="distance" />
      <param name="segmentRatio" />
    </member>
    <member name="M:yWorks.Markup.Common.SmartEdgeLabelModelParameterExtension.#ctor(yWorks.Markup.Common.SliderParameterLocation,System.Int32,System.Double,System.Double,yWorks.Graph.LabelModels.SmartEdgeLabelModel)">
      <param name="location" />
      <param name="segmentIndex" />
      <param name="distance" />
      <param name="segmentRatio" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.SmartEdgeLabelModelParameterExtension.Model" />
    <member name="P:yWorks.Markup.Common.SmartEdgeLabelModelParameterExtension.Location" />
    <member name="P:yWorks.Markup.Common.SmartEdgeLabelModelParameterExtension.SegmentIndex" />
    <member name="P:yWorks.Markup.Common.SmartEdgeLabelModelParameterExtension.SegmentRatio" />
    <member name="P:yWorks.Markup.Common.SmartEdgeLabelModelParameterExtension.Distance" />
    <member name="M:yWorks.Markup.Common.SmartEdgeLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Common.SliderParameterLocation">
      <summary>
        <para>Flaggable enumeration that is used by <see cref="T:yWorks.Graph.LabelModels.SmartEdgeLabelModel" /> to indicate the position.</para>
      </summary>
      <remarks>
        <para>This enumeration is mainly used by the XAML serialization mechanisms.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Markup.Common.SliderParameterLocation.Left">
      <summary>
        <para>Left of the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Markup.Common.SliderParameterLocation.Right">
      <summary>
        <para>Right of the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Markup.Common.SliderParameterLocation.FromSource">
      <summary>
        <para>Measured from the source end.</para>
      </summary>
    </member>
    <member name="F:yWorks.Markup.Common.SliderParameterLocation.FromTarget">
      <summary>
        <para>Measured from the target end.</para>
      </summary>
    </member>
    <member name="F:yWorks.Markup.Common.SliderParameterLocation.Center">
      <summary>
        <para>"Center" segment.</para>
      </summary>
    </member>
    <member name="T:yWorks.Markup.Common.StretchStripeLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.StretchStripeLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.StretchStripeLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.StretchStripeLabelModel.Position)">
      <param name="position" />
    </member>
    <member name="M:yWorks.Markup.Common.StretchStripeLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.StretchStripeLabelModel.Position,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="position" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.StretchStripeLabelModelParameterExtension.Position" />
    <member name="P:yWorks.Markup.Common.StretchStripeLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.StretchStripeLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.StretchStripeLabelModel">
      <summary>
        <para>A label model for labels that is especially tailored to be used as a model for the four default positions where the label of a stripe may lie.</para>
      </summary>
      <remarks>
        <para>This label model supports four positions inside of the stripe bounds. The east and west positions are rotated automatically. The <see cref="P:yWorks.Graph.ILabel.Owner" /> is expected to be an <see cref="T:yWorks.Graph.IStripe" /> instance, i.e. the parameter supports only <see cref="T:yWorks.Graph.IStripe" /> instances.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StretchStripeLabelModel.North">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.StripeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.StretchStripeLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StretchStripeLabelModel.South">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.StripeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.StretchStripeLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StretchStripeLabelModel.East">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.StripeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.StretchStripeLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StretchStripeLabelModel.West">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.StripeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.StretchStripeLabelModel.Insets" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.LabelModels.StretchStripeLabelModel.Insets">
      <summary>
        <para>Gets or sets the insets to use within the stripe's <see cref="P:yWorks.Graph.IStripe.Layout" />.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.LabelModels.StretchStripeLabelModel.Position">
      <summary>
        <para>Enumeration of the possible positions of the <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />.</para>
      </summary>
      <remarks>
        <para>This field can be used as an argument for the <see cref="M:yWorks.Graph.LabelModels.InteriorLabelModel.CreateParameter(yWorks.Graph.LabelModels.InteriorLabelModel.Position)" /> factory method.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StretchStripeLabelModel.Position.North">
      <summary>
        <para>Encodes a position at the top side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StretchStripeLabelModel.Position.East">
      <summary>
        <para>Encodes a position at the right side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StretchStripeLabelModel.Position.South">
      <summary>
        <para>Encodes a position at the bottom side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StretchStripeLabelModel.Position.West">
      <summary>
        <para>Encodes a position at the left side of the node interior</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.StretchStripeLabelModel.#ctor">
      <summary>
        <para>Creates a new instance of this model with empty insets.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.LabelModels.StretchStripeLabelModel.UseActualInsets">
      <summary>
        <para>Gets or sets whether or not to use the <see cref="M:yWorks.Graph.StripeExtensions.GetActualInsets(yWorks.Graph.IStripe)">actual insets</see> or the normal <see cref="P:yWorks.Graph.IStripe.Insets" /> of a stripe for centering the label inside the stripe header area.</para>
      </summary>
      <remarks>
        <para>If <c>true</c> the header insets are used. Default is <c>false</c></para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.StretchStripeLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Calculates the geometry in form of an <see cref="T:yWorks.Geometry.IOrientedRectangle" /> for a given label using the given model parameter.</para>
      </summary>
      <remarks>
        <para>The geometry is calculated in table coordinates, i.e. relative to <see cref="P:yWorks.Graph.ITable.RelativeLocation" />.</para>
      </remarks>
      <param name="label">
        <para>the label to calculate the geometry for</para>
      </param>
      <param name="layoutParameter">
        <para>A parameter that has been created by this model. This is typically the parameter that yielded this instance through its <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> property.</para>
      </param>
      <returns>
        <para>An instance that describes the geometry. This is typically an instance designed as a flyweight, so clients should not cache the instance but store the values if they need a snapshot for later use</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.StretchStripeLabelModel.CreateDefaultParameter" />
    <member name="M:yWorks.Graph.LabelModels.StretchStripeLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.StretchStripeLabelModel.CreateParameter(yWorks.Graph.LabelModels.StretchStripeLabelModel.Position)">
      <summary>
        <para>Creates the parameter for the given position.</para>
      </summary>
      <param name="position">
        <para>The position.</para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.Graph.LabelModels.StretchStripeLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.StretchStripeLabelModel.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="label" />
      <param name="model" />
    </member>
    <member name="T:yWorks.Graph.StripeExtensions">
      <summary>
        <para>Extension helper methods to work with <see cref="T:yWorks.Graph.IStripe" /> instances.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.IsRoot(yWorks.Graph.IStripe)">
      <summary>
        <para>Checks whether <paramref name="stripe" /> is the root item of a stripe hierarchy.</para>
      </summary>
      <param name="stripe">
        <para>the item to query. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff <paramref name="stripe" /> is a root stripe.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.StripeExtensions.GetRoot(yWorks.Graph.IStripe)" />
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.GetIndex(yWorks.Graph.IStripe)">
      <summary>
        <para>Gets the index of <paramref name="stripe" /> in its <see cref="M:yWorks.Graph.StripeExtensions.GetParentStripe(yWorks.Graph.IStripe)" /> collection of <see cref="M:yWorks.Graph.StripeExtensions.GetChildStripes(yWorks.Graph.IStripe)" />.</para>
      </summary>
      <remarks>
        <para>The <paramref name="stripe" /> is the <b>GetIndex</b>th child of its parent.</para>
      </remarks>
      <param name="stripe">
        <para>the item to query. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <returns>
        <para>the children of <paramref name="stripe" /></para>
      </returns>
      <seealso cref="P:yWorks.Graph.IColumn.ChildColumns" />
      <seealso cref="P:yWorks.Graph.IRow.ChildRows" />
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.GetActualMinSize(yWorks.Graph.IStripe)">
      <summary>
        <para>Returns the actual minimum size a stripe can acquire.</para>
      </summary>
      <remarks>
        <para>This is the maximum of <see cref="P:yWorks.Graph.IStripe.MinimumSize" /> and the horizontal or vertical <see cref="P:yWorks.Graph.IStripe.Insets" />.</para>
      </remarks>
      <param name="stripe" />
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.GetChildStripes(yWorks.Graph.IStripe)">
      <summary>
        <para>Gets the direct children of <paramref name="stripe" /> in a table hierarchy.</para>
      </summary>
      <remarks>
        <para>For <see cref="T:yWorks.Graph.IColumn" /> instances, this returns <see cref="P:yWorks.Graph.IColumn.ChildColumns" />, for <see cref="T:yWorks.Graph.IRow" /> instances, this returns <see cref="P:yWorks.Graph.IRow.ChildRows" /></para>
      </remarks>
      <param name="stripe">
        <para>the item to query. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <returns>
        <para>the children of <paramref name="stripe" /></para>
      </returns>
      <seealso cref="P:yWorks.Graph.IColumn.ChildColumns" />
      <seealso cref="P:yWorks.Graph.IRow.ChildRows" />
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.GetParentStripe(yWorks.Graph.IStripe)">
      <summary>
        <para>Gets the parent of <paramref name="stripe" /> in a table hierarchy.</para>
      </summary>
      <remarks>
        <para>For <see cref="T:yWorks.Graph.IColumn" /> instances, this returns <see cref="P:yWorks.Graph.IColumn.ParentColumn" />, for <see cref="T:yWorks.Graph.IRow" /> instances, this returns <see cref="P:yWorks.Graph.IRow.ParentRow" /></para>
      </remarks>
      <param name="stripe">
        <para>the item to query. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <returns>
        <para>the parent of <paramref name="stripe" /></para>
      </returns>
      <seealso cref="P:yWorks.Graph.IColumn.ParentColumn" />
      <seealso cref="P:yWorks.Graph.IRow.ParentRow" />
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.GetRoot(yWorks.Graph.IStripe)">
      <summary>
        <para>Gets the root of the stripe hierarchy of <paramref name="stripe" /> in a table hierarchy.</para>
      </summary>
      <remarks>
        <para>If the stripe is part of an <see cref="T:yWorks.Graph.ITable" /> instance, this returns <see cref="P:yWorks.Graph.ITable.RootColumn" /> for <see cref="T:yWorks.Graph.IColumn" /> instances and <see cref="P:yWorks.Graph.IRow.ParentRow" /> for <see cref="P:yWorks.Graph.ITable.RootRow" /> instances. Otherwise <c>null</c> is returned.</para>
      </remarks>
      <param name="stripe">
        <para>the item to query. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <returns>
        <para>the root of <paramref name="stripe" /></para>
      </returns>
      <seealso cref="P:yWorks.Graph.ITable.RootColumn" />
      <seealso cref="P:yWorks.Graph.ITable.RootRow" />
      <seealso cref="M:yWorks.Graph.StripeExtensions.IsRoot(yWorks.Graph.IStripe)" />
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.GetLeaves(yWorks.Graph.IStripe)">
      <summary>
        <para>Returns a collection of all descendants of <paramref name="stripe" /> that are leaves and therefore don't have any child stripes.</para>
      </summary>
      <param name="stripe">
        <para>The stripe to query. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <returns>
        <para>A collection of all leaf descendants of <paramref name="stripe" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.GetDescendants(yWorks.Graph.IStripe)">
      <summary>
        <para>Returns a collection of all descendants of <paramref name="stripe" />.</para>
      </summary>
      <remarks>
        <para>The descendants are returned in top to bottom order.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe to query. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <returns>
        <para>A collection of all descendants of <paramref name="stripe" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.GetAbsoluteBounds(yWorks.Graph.IStripe,yWorks.Graph.INode)">
      <summary>
        <para>Returns the layout of <paramref name="stripe" /> in absolute coordinates.</para>
      </summary>
      <remarks>
        <para>Since <see cref="P:yWorks.Graph.IStripe.Layout" /> is relative to the owning node's left corner, you need to provide an <paramref name="node" /> node to calculate the absolute layout.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe to calculate the layout for. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="node">
        <para>The node relative to which the stripe layout is calculated. This should be the same node where <see cref="P:yWorks.Graph.IStripe.Table" /> for <paramref name="stripe" /> is associated to.</para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.GetActualInsets(yWorks.Graph.IStripe)">
      <summary>
        <para>Gets the insets that are currently in effect for this stripe.</para>
      </summary>
      <remarks>
        <para>This value is determined by the accumulated insets of all ancestor, sibling and descendant insets. These insets may be larger than <see cref="P:yWorks.Graph.IStripe.Insets" />.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe to calculate the actual insets for. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <returns>
        <para>The actual insets of the stripe.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.StripeExtensions.GetActualSize(yWorks.Graph.IStripe)">
      <summary>
        <para>The current actual dimension of the stripe.</para>
      </summary>
      <remarks>
        <para>This is always the stripe size which is actually used for the stripe. For leaf stripes, this is the same as <see cref="P:yWorks.Graph.IStripe.Size" />, otherwise, it is the accumulated size of all descendants with taking nested insets into account.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe to calculate the actual size for. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <returns>
        <para>The actual size of the stripe.</para>
      </returns>
    </member>
    <member name="T:yWorks.Markup.Common.StripeLabelModelParameterExtension" />
    <member name="M:yWorks.Markup.Common.StripeLabelModelParameterExtension.#ctor" />
    <member name="M:yWorks.Markup.Common.StripeLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.StripeLabelModel.Position)">
      <param name="position" />
    </member>
    <member name="M:yWorks.Markup.Common.StripeLabelModelParameterExtension.#ctor(yWorks.Graph.LabelModels.StripeLabelModel.Position,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="position" />
      <param name="model" />
    </member>
    <member name="P:yWorks.Markup.Common.StripeLabelModelParameterExtension.Position" />
    <member name="P:yWorks.Markup.Common.StripeLabelModelParameterExtension.Model" />
    <member name="M:yWorks.Markup.Common.StripeLabelModelParameterExtension.ProvideValue(System.IServiceProvider)">
      <param name="provider" />
    </member>
    <member name="T:yWorks.Graph.LabelModels.StripeLabelModel">
      <summary>
        <para>A label model for labels that is especially tailored to be used as a model for the four default positions where the label of a stripe may lie.</para>
      </summary>
      <remarks>
        <para>This label model supports four positions inside of the stripe bounds. The east and west positions are rotated automatically. The <see cref="P:yWorks.Graph.ILabel.Owner" /> is expected to be an <see cref="T:yWorks.Graph.IStripe" /> instance, i.e. the parameter supports only <see cref="T:yWorks.Graph.IStripe" /> instances.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StripeLabelModel.North">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.StripeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.StripeLabelModel.Ratio" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StripeLabelModel.South">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.StripeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.StripeLabelModel.Ratio" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StripeLabelModel.East">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.StripeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.StripeLabelModel.Ratio" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StripeLabelModel.West">
      <summary>
        <para>A convenience parameter instance that can be shared between label instances.</para>
      </summary>
      <remarks>
        <para>Although the <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> can be cast to a <see cref="T:yWorks.Graph.LabelModels.StripeLabelModel" />, trying to change that instances' <see cref="P:yWorks.Graph.LabelModels.StripeLabelModel.Ratio" /> will raise an <see cref="T:System.InvalidOperationException" />.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.LabelModels.StripeLabelModel.Position">
      <summary>
        <para>Enumeration of the possible positions of the <see cref="T:yWorks.Graph.LabelModels.InteriorLabelModel" />.</para>
      </summary>
      <remarks>
        <para>This field can be used as an argument for the <see cref="M:yWorks.Graph.LabelModels.InteriorLabelModel.CreateParameter(yWorks.Graph.LabelModels.InteriorLabelModel.Position)" /> factory method.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StripeLabelModel.Position.North">
      <summary>
        <para>Encodes a position at the top side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StripeLabelModel.Position.East">
      <summary>
        <para>Encodes a position at the right side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StripeLabelModel.Position.South">
      <summary>
        <para>Encodes a position at the bottom side of the node interior</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.LabelModels.StripeLabelModel.Position.West">
      <summary>
        <para>Encodes a position at the left side of the node interior</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelModels.StripeLabelModel.#ctor">
      <summary>
        <para>Creates a new instance of this model with empty insets.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.LabelModels.StripeLabelModel.UseActualInsets">
      <summary>
        <para>Gets or sets a value indicating whether to use the <see cref="M:yWorks.Graph.StripeExtensions.GetActualInsets(yWorks.Graph.IStripe)">actual insets</see> or the normal <see cref="P:yWorks.Graph.IStripe.Insets" /> of a stripe for centering the label inside the stripe header area.</para>
      </summary>
      <remarks>
        <para>If <c>true</c> the header insets are used. Default is <c>false</c></para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.LabelModels.StripeLabelModel.Ratio">
      <summary>
        <para>Gets or sets the ratio how far the label should be positioned from the border in the header area.</para>
      </summary>
      <remarks>
        <para>0 means the label is positioned on the outer border, 1 means it is positioned at the inner border of the header or inset area. Default value is 0.5</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.LabelModels.StripeLabelModel.GetGeometry(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Calculates the geometry in form of an <see cref="T:yWorks.Geometry.IOrientedRectangle" /> for a given label using the given model parameter.</para>
      </summary>
      <remarks>
        <para>The geometry is calculated in table coordinates, i.e. relative to <see cref="P:yWorks.Graph.ITable.RelativeLocation" />.</para>
      </remarks>
      <param name="label">
        <para>the label to calculate the geometry for</para>
      </param>
      <param name="layoutParameter">
        <para>A parameter that has been created by this model. This is typically the parameter that yielded this instance through its <see cref="P:yWorks.Graph.LabelModels.ILabelModelParameter.Model" /> property.</para>
      </param>
      <returns>
        <para>An instance that describes the geometry. This is typically an instance designed as a flyweight, so clients should not cache the instance but store the values if they need a snapshot for later use</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LabelModels.StripeLabelModel.CreateDefaultParameter" />
    <member name="M:yWorks.Graph.LabelModels.StripeLabelModel.GetContext(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <param name="label" />
      <param name="layoutParameter" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.StripeLabelModel.CreateParameter(yWorks.Graph.LabelModels.StripeLabelModel.Position)">
      <summary>
        <para>Creates the parameter for the given position.</para>
      </summary>
      <param name="position">
        <para>The position.</para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.Graph.LabelModels.StripeLabelModel.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.LabelModels.StripeLabelModel.GetParameters(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModel)">
      <param name="label" />
      <param name="model" />
    </member>
    <member name="T:yWorks.Controls.IStripeSelection">
      <summary>
        <para>Manages the selection state of items in an <see cref="T:yWorks.Graph.ITable" /> instance.</para>
      </summary>
      <remarks>
        <para>This interface provides access to the <see cref="T:yWorks.Controls.ISelectionModel`1" /> instances that manage the selection of rows and columns. The generic methods that use <see cref="T:yWorks.Graph.IModelItem" /> parameters delegate to the corresponding domain-specific selection models.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.ISelectionModel`1" />
    </member>
    <member name="P:yWorks.Controls.IStripeSelection.SelectedRows">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.ISelectionModel`1" /> of the selected rows.</para>
      </summary>
      <remarks>
        <para>This is the row part of the selection that this instance is a composite of.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.IStripeSelection.SelectedColumns">
      <summary>
        <para>Gets an <see cref="T:yWorks.Controls.ISelectionModel`1" /> of the selected columns.</para>
      </summary>
      <remarks>
        <para>This is the column part of the selection that this instance is a composite of.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.IStripeSelection.AllowMixedSelection">
      <summary>
        <para>Gets or sets whether to allow mixed row/column selections</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.IStripeSelection.AllowCrossTableSelection">
      <summary>
        <para>Gets or sets whether to allow the selection to span multiple table instances</para>
      </summary>
      <remarks>
        <para>The default is <c>false</c></para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.StripeSelection">
      <summary>
        <para>Default implementation of the <see cref="T:yWorks.Controls.IStripeSelection" /> interface.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.StripeSelection.AllowMixedSelection">
      <summary>
        <para>Gets or sets whether to allow mixed row/column selections</para>
      </summary>
      <remarks>
        <para>The default is <c>false</c></para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.StripeSelection.AllowCrossTableSelection">
      <summary>
        <para>Gets or sets whether to allow the selection to span multiple table instances</para>
      </summary>
      <remarks>
        <para>The default is <c>true</c></para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.StripeSelection.#ctor">
      <summary>
        <para>Default constructor that creates empty selection models.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.StripeSelection.OnItemSelectionChanged(yWorks.Controls.ItemSelectionChangedEventArgs{yWorks.Graph.IStripe})">
      <summary>
        <para>Raises the <see cref="E:yWorks.Controls.StripeSelection.ItemSelectionChanged" /> event</para>
      </summary>
      <param name="args">
        <para>The parameters for the event</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.StripeSelection.GetEnumerator" />
    <member name="M:yWorks.Controls.StripeSelection.IsSelected(yWorks.Graph.IStripe)">
      <summary>
        <para>Return whether <paramref name="stripe" /> is currently selected</para>
      </summary>
      <param name="stripe">
        <para>The stripe to test</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff <paramref name="stripe" /> is currently selected</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.StripeSelection.SetSelected(yWorks.Graph.IStripe,System.Boolean)">
      <param name="item" />
      <param name="selected" />
    </member>
    <member name="M:yWorks.Controls.StripeSelection.Clear" />
    <member name="T:yWorks.Graph.PortDefaults">
      <summary>
        <para>A canonic implementation of the <see cref="T:yWorks.Graph.IPortDefaults" /> interface.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.PortDefaults.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.PortDefaults" /> class using a trivial location model parameter.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.PortDefaults.GetStyleInstance(yWorks.Graph.IPortOwner)">
      <param name="owner" />
    </member>
    <member name="M:yWorks.Graph.PortDefaults.GetLocationParameterInstance(yWorks.Graph.IPortOwner)">
      <param name="owner" />
    </member>
    <member name="M:yWorks.Graph.PortDefaults.GetStyleInstance">
      <summary>
        <para>Factory method that returns a style instance for use with newly created ports.</para>
      </summary>
      <remarks>
        <para>Most implementations will yield either, a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.PortDefaults.Style" /> property, if <see cref="P:yWorks.Graph.PortDefaults.ShareStyleInstance" /> is enabled, but they might use more complicated logic, too.</para>
      </remarks>
      <returns>
        <para>The style to use, which for most implementations is either a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.PortDefaults.Style" /> property, if <see cref="P:yWorks.Graph.PortDefaults.ShareStyleInstance" /> is enabled.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.NodeDefaults">
      <summary>
        <para>A canonic implementation of the <see cref="T:yWorks.Graph.INodeDefaults" /> interface.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.NodeDefaults.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.NodeDefaults" /> class using default properties.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.NodeDefaults.GetStyleInstance" />
    <member name="T:yWorks.Graph.EdgeDefaults">
      <summary>
        <para>A canonic implementation of the <see cref="T:yWorks.Graph.IEdgeDefaults" /> interface</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.EdgeDefaults.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.EdgeDefaults" /> class with default edge style and label and port defaults.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.EdgeDefaults.GetStyleInstance" />
    <member name="T:yWorks.Graph.LabelDefaults">
      <summary>
        <para>A canonic implementation of the <see cref="T:yWorks.Graph.ILabelDefaults" /> interface</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelDefaults.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.LabelDefaults" /> class using a trivial parameter.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LabelDefaults.GetStyleInstance(yWorks.Graph.ILabelOwner)">
      <param name="owner" />
    </member>
    <member name="M:yWorks.Graph.LabelDefaults.GetLayoutParameterInstance(yWorks.Graph.ILabelOwner)">
      <param name="owner" />
    </member>
    <member name="T:yWorks.Graph.Table">
      <summary>
        <para>Default implementation of the <see cref="T:yWorks.Graph.ITable" /> interface.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Table.DefaultStripeLookup">
      <summary>
        <para>Gets an <see cref="T:yWorks.Graph.IContextLookup" /> that provides the default implementations returned by an <see cref="T:yWorks.Graph.IStripe" />'s lookup.</para>
      </summary>
      <remarks>
        <para>The provided default implementations can for example be used as fallback when the stripe lookup is wrapped.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Table.DefaultColumnLookup">
      <summary>
        <para>Gets an <see cref="T:yWorks.Graph.IContextLookup" /> that provides the default implementations returned by an <see cref="T:yWorks.Graph.IColumn" />'s lookup.</para>
      </summary>
      <remarks>
        <para>The provided default implementations can for example be used as fallback when the column lookup is wrapped.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Table.DefaultRowLookup">
      <summary>
        <para>Gets an <see cref="T:yWorks.Graph.IContextLookup" /> that provides the default implementations returned by an <see cref="T:yWorks.Graph.IRow" />'s lookup.</para>
      </summary>
      <remarks>
        <para>The provided default implementations can for example be used as fallback when the row lookup is wrapped.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Table.#ctor">
      <summary>
        <para>Default constructor that creates an empty table</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Table.Rows">
      <summary>
        <para>Gets the toplevel <see cref="T:yWorks.Graph.IRow" />s in this table.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Table.Columns">
      <summary>
        <para>Gets the toplevel <see cref="T:yWorks.Graph.IColumn" />s in this table.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Table.Layout">
      <summary>
        <para>Gets the relative layout of the table.</para>
      </summary>
      <remarks>
        <para>The upper left corner of the layout always coincides with <see cref="P:yWorks.Graph.Table.RelativeLocation" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.Table.RelativeLocation" />
    </member>
    <member name="M:yWorks.Graph.Table.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.Table.CreateRow(yWorks.Graph.IRow,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})">
      <param name="owner" />
      <param name="height" />
      <param name="minHeight" />
      <param name="insets" />
      <param name="style" />
      <param name="tag" />
      <param name="index" />
    </member>
    <member name="M:yWorks.Graph.Table.CreateColumn(yWorks.Graph.IColumn,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})">
      <param name="owner" />
      <param name="width" />
      <param name="minWidth" />
      <param name="insets" />
      <param name="style" />
      <param name="tag" />
      <param name="index" />
    </member>
    <member name="M:yWorks.Graph.Table.OnStripeCreated(yWorks.Graph.IStripe)">
      <summary>
        <para>Called after a stripe has been created and added to a table.</para>
      </summary>
      <remarks>
        <para>This method raises the <see cref="E:yWorks.Graph.Table.StripeCreated" /> event.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe that has just been created.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Table.Remove(yWorks.Graph.IStripe)">
      <param name="stripe" />
    </member>
    <member name="M:yWorks.Graph.Table.OnStripeRemoved(yWorks.Graph.IStripe,yWorks.Graph.IStripe)">
      <summary>
        <para>Called after a stripe has been removed from its owner.</para>
      </summary>
      <remarks>
        <para>This method raises the <see cref="E:yWorks.Graph.Table.StripeRemoved" /> event.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe that has just been removed.</para>
      </param>
      <param name="owner">
        <para>The old owner of the stripe.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Table.InstallStaticUndoSupport(yWorks.Graph.IGraph)">
      <summary>
        <para>Installs the undo support for use with all tables that are bound to nodes in <paramref name="graph" />.</para>
      </summary>
      <remarks>
        <para>This methods installs the undo support which manages the <paramref name="graph" /> at the time this method is called. In contrast to <see cref="M:yWorks.Graph.Table.InstallDynamicUndoSupport(yWorks.Graph.IGraph)" /> the installed undo support will not change when the <paramref name="graph" />'s undo support changes.</para>
        <para>This method adds undo support both for existing nodes in <paramref name="graph" /> as well as for newly created or changed nodes.</para>
      </remarks>
      <param name="graph">
        <para>The graph where the nodes exist or will be created/changed.</para>
      </param>
      <seealso cref="M:yWorks.Graph.Table.UninstallStaticUndoSupport(yWorks.Graph.IGraph)" />
      <seealso cref="M:yWorks.Graph.Table.InstallDynamicUndoSupport(yWorks.Graph.IGraph)" />
    </member>
    <member name="M:yWorks.Graph.Table.InstallDynamicUndoSupport(yWorks.Graph.IGraph)">
      <summary>
        <para>Installs the undo support for use with all tables that are bound to nodes in <paramref name="graph" />.</para>
      </summary>
      <remarks>
        <para>This method queries the <paramref name="graph" /> for its undo support dynamically whenever undo support is queried in the table. In contrast to <see cref="M:yWorks.Graph.Table.InstallStaticUndoSupport(yWorks.Graph.IGraph)" /> the undo support installed with this method will thus always be the one which is the currently available support for the <paramref name="graph" />.</para>
      </remarks>
      <param name="graph">
        <para>The graph where the nodes exist or will be created/changed and where the undo support should come from.</para>
      </param>
      <seealso cref="M:yWorks.Graph.Table.UninstallDynamicUndoSupport(yWorks.Graph.IGraph)" />
      <seealso cref="M:yWorks.Graph.Table.InstallStaticUndoSupport(yWorks.Graph.IGraph)" />
    </member>
    <member name="M:yWorks.Graph.Table.UninstallStaticUndoSupport(yWorks.Graph.IGraph)">
      <summary>
        <para>Uninstalls the undo support that has previously been installed with <see cref="M:yWorks.Graph.Table.InstallStaticUndoSupport(yWorks.Graph.IGraph)" /></para>
      </summary>
      <param name="graph">
        <para>The graph where the tables are installed for which the undo support should be cleared.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Table.UninstallDynamicUndoSupport(yWorks.Graph.IGraph)">
      <summary>
        <para>Uninstalls the undo support that has previously been installed with <see cref="M:yWorks.Graph.Table.InstallDynamicUndoSupport(yWorks.Graph.IGraph)" /></para>
      </summary>
      <param name="graph">
        <para>The graph where the tables are installed for which the undo support should be cleared.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Table.SetSize(yWorks.Graph.IStripe,System.Double)">
      <param name="stripe" />
      <param name="size" />
    </member>
    <member name="M:yWorks.Graph.Table.SetMinimumSize(yWorks.Graph.IStripe,System.Double)">
      <param name="stripe" />
      <param name="minimumSize" />
    </member>
    <member name="M:yWorks.Graph.Table.SetStripeInsets(yWorks.Graph.IStripe,yWorks.Geometry.InsetsD)">
      <param name="stripe" />
      <param name="insets" />
    </member>
    <member name="M:yWorks.Graph.Table.SetStyle(yWorks.Graph.IStripe,yWorks.Graph.Styles.IStripeStyle)">
      <param name="stripe" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Table.OnStripeChanged(yWorks.Graph.IStripe,yWorks.Graph.IStripe,yWorks.Graph.ITable)">
      <summary>
        <para>Callback that is invoked after a stripe has changed.</para>
      </summary>
      <remarks>
        <para>This will trigger the <see cref="E:yWorks.Graph.Table.StripeChanged" /> event.</para>
      </remarks>
      <param name="owner">
        <para>The original owner</para>
      </param>
      <param name="stripe">
        <para>The stripe that has changed.</para>
      </param>
      <param name="oldTable">
        <para>The original table owner, in case the stripe has been moved between different table instances</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Table.SetParent(yWorks.Graph.IRow,yWorks.Graph.IRow,System.Nullable{System.Int32})">
      <param name="owner" />
      <param name="row" />
      <param name="index" />
    </member>
    <member name="M:yWorks.Graph.Table.SetParent(yWorks.Graph.IColumn,yWorks.Graph.IColumn,System.Nullable{System.Int32})">
      <param name="owner" />
      <param name="column" />
      <param name="index" />
    </member>
    <member name="M:yWorks.Graph.Table.AddLabel(yWorks.Graph.IStripe,System.String,yWorks.Graph.LabelModels.ILabelModelParameter,yWorks.Graph.Styles.ILabelStyle,System.Nullable{yWorks.Geometry.SizeD},System.Object)">
      <param name="owner" />
      <param name="text" />
      <param name="layoutParameter" />
      <param name="style" />
      <param name="preferredSize" />
      <param name="tag" />
    </member>
    <member name="M:yWorks.Graph.Table.SetLabelText(yWorks.Graph.ILabel,System.String)">
      <summary>
        <para>Sets the label text of the given label.</para>
      </summary>
      <param name="label">
        <para>the label to modify</para>
      </param>
      <param name="text">
        <para>the new text of the label</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>If the label is not associated with this table instance.</para>
      </exception>
      <seealso cref="P:yWorks.Graph.ILabel.Text" />
    </member>
    <member name="M:yWorks.Graph.Table.Remove(yWorks.Graph.ILabel)">
      <summary>
        <para>Removes the given label from its owner.</para>
      </summary>
      <remarks>
        <para>This will trigger the corresponding event.</para>
      </remarks>
      <param name="label">
        <para>the label to remove</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>If the label is not associated with this table instance.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.Table.SetLabelPreferredSize(yWorks.Graph.ILabel,yWorks.Geometry.SizeD)">
      <summary>
        <para>Sets the preferred size of the label.</para>
      </summary>
      <param name="label">
        <para>The label.</para>
      </param>
      <param name="preferredSize">
        <para>The new preferred size.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>If the label is not associated with this table instance.</para>
      </exception>
      <seealso cref="P:yWorks.Graph.ILabel.PreferredSize" />
    </member>
    <member name="M:yWorks.Graph.Table.SetLabelLayoutParameter(yWorks.Graph.ILabel,yWorks.Graph.LabelModels.ILabelModelParameter)">
      <summary>
        <para>Sets the label model parameter for the given label.</para>
      </summary>
      <param name="label">
        <para>The label.</para>
      </param>
      <param name="layoutParameter">
        <para>The new parameter.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>If the parameter cannot be used for this label or if the label is not associated with this table instance.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.Table.SetStyle(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Assigns the given style instance by reference to the label.</para>
      </summary>
      <remarks>
        <para>Style instances can be shared.</para>
      </remarks>
      <param name="label">
        <para>The label that will be assigned the new style</para>
      </param>
      <param name="style">
        <para>The style instance that will be assigned to the label.</para>
      </param>
      <seealso cref="P:yWorks.Graph.ILabel.Style" />
    </member>
    <member name="M:yWorks.Graph.Table.OnLabelAdded(yWorks.Graph.ILabel)">
      <summary>
        <para>Called after a label has been added to a stripe.</para>
      </summary>
      <remarks>
        <para>This method raises the <see cref="E:yWorks.Graph.Table.LabelAdded" /> event.</para>
      </remarks>
      <param name="label">
        <para>The label that has just been added.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Table.OnLabelChanged(yWorks.Graph.ILabel)">
      <summary>
        <para>Callback that is invoked after a label has changed.</para>
      </summary>
      <remarks>
        <para>This method raises the <see cref="E:yWorks.Graph.Table.LabelChanged" /> event.</para>
      </remarks>
      <param name="label">
        <para>The label that has changed.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Table.OnLabelRemoved(yWorks.Graph.ILabelOwner,yWorks.Graph.ILabel)">
      <summary>
        <para>Called after a label has been removed from its stripe.</para>
      </summary>
      <remarks>
        <para>This method raises the <see cref="E:yWorks.Graph.Table.LabelRemoved" /> event.</para>
      </remarks>
      <param name="label">
        <para>The label that has just been removed.</para>
      </param>
      <param name="owner">
        <para>The old owner of the label.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Table.RowDefaults">
      <summary>
        <para>Gets or sets the defaults for rows.</para>
      </summary>
      <remarks>
        <para>The settings that are obtained from the instance influence newly created elements only. Setting different defaults later does not influence existing elements.</para>
        <para>If no value is set explicitly a default will be created using <see cref="M:yWorks.Graph.Table.CreateRowDefaults" /> upon first read access.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Table.CreateRowDefaults">
      <summary>
        <para>Callback method that creates the row defaults.</para>
      </summary>
      <returns>
        <para>A new instance of the <see cref="T:yWorks.Graph.StripeDefaults" /> class that is used for <see cref="M:yWorks.Graph.Table.CreateRow(yWorks.Graph.IRow,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})">newly created rows</see>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.Table.ColumnDefaults">
      <summary>
        <para>Gets or sets the defaults for Columns.</para>
      </summary>
      <remarks>
        <para>The settings that are obtained from the instance influence newly created elements only. Setting different defaults later does not influence existing elements.</para>
        <para>If no value is set explicitly a default will be created using <see cref="M:yWorks.Graph.Table.CreateColumnDefaults" /> upon first read access.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Table.CreateColumnDefaults">
      <summary>
        <para>Callback method that creates the Column defaults.</para>
      </summary>
      <returns>
        <para>A new instance of the <see cref="T:yWorks.Graph.StripeDefaults" /> class which is used for <see cref="M:yWorks.Graph.Table.CreateColumn(yWorks.Graph.IColumn,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})">newly created columns</see>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Table.Clone" />
    <member name="M:yWorks.Graph.Table.CopyDefaults(yWorks.Graph.IStripeDefaults)">
      <summary>
        <para>Called during <see cref="M:yWorks.Graph.Table.Clone" /> to create a copy of <paramref name="originalDefaults" /></para>
      </summary>
      <remarks>
        <para>This implementation returns an unchanged reference to <paramref name="originalDefaults" />. If you need to create a deep clone of <paramref name="originalDefaults" />, you'll have to perform the cloning yourself.</para>
      </remarks>
      <param name="originalDefaults">
        <para>The default settings that should be copied during a clone operation.</para>
      </param>
      <returns>
        <para>The original reference to <paramref name="originalDefaults" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Table.CopyRow(yWorks.Graph.IRow)">
      <summary>
        <para>Called during <see cref="M:yWorks.Graph.Table.Clone" /> to create a copy of <paramref name="row" /></para>
      </summary>
      <remarks>
        <para>If <paramref name="row" /> implements the <see cref="T:System.ICloneable" /> interface, the <paramref name="row" /> instance is <see cref="M:System.ICloneable.Clone" />d, otherwise, the original instance is returned unchanged.</para>
      </remarks>
      <param name="row">
        <para>The row that should be copied during a clone operation.</para>
      </param>
      <returns>
        <para>A clone of <paramref name="row" /> if possible, otherwise the original reference to <paramref name="row" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Table.CopyColumn(yWorks.Graph.IColumn)">
      <summary>
        <para>Called during <see cref="M:yWorks.Graph.Table.Clone" /> to create a copy of <paramref name="column" /></para>
      </summary>
      <remarks>
        <para>If <paramref name="column" /> implements the <see cref="T:System.ICloneable" /> interface, the <paramref name="column" /> instance is <see cref="M:System.ICloneable.Clone" />d, otherwise, the original instance is returned unchanged.</para>
      </remarks>
      <param name="column">
        <para>The column that should be copied during a clone operation.</para>
      </param>
      <returns>
        <para>A clone of <paramref name="column" /> if possible, otherwise the original reference to <paramref name="column" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Table.GetCellBounds(yWorks.Graph.INode,yWorks.Graph.IColumn,yWorks.Graph.IRow)">
      <summary>
        <para>Calculates the absolute bounds of a table cell that is determined by <paramref name="column" /> and <paramref name="row" /></para>
      </summary>
      <remarks>
        <para>Both <paramref name="column" /> and <paramref name="row" /> must live in the same <see cref="T:yWorks.Graph.ITable" /> instance that is also present in the <paramref name="tableNode" />s <see cref="T:yWorks.Graph.ILookup" />. Otherwise, an <see cref="T:System.ArgumentException" /> is thrown.</para>
      </remarks>
      <param name="tableNode">
        <para>The node where a table is bound to via the node's lookup</para>
      </param>
      <param name="column">
        <para>The column that determines the cell</para>
      </param>
      <param name="row">
        <para>The row that determines the cell</para>
      </param>
      <returns>
        <para>The absolute bounds of a the cell determined by <paramref name="column" /> and <paramref name="row" /></para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>If no table is present in the <see cref="T:yWorks.Graph.ILookup" /> of <paramref name="tableNode" />, or if <paramref name="column" /> and <paramref name="row" /> are part of a different table instance.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.Table.PlaceNodeInCell(yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.INode,yWorks.Graph.IColumn,yWorks.Graph.IRow,System.Boolean,System.Boolean)">
      <summary>
        <para>Places <paramref name="node" /> in the center of the table cell determined by <paramref name="column" /> and <paramref name="row" />.</para>
      </summary>
      <remarks>
        <para>Both <paramref name="column" /> and <paramref name="row" /> must live in the same <see cref="T:yWorks.Graph.ITable" /> instance that is also present in the <paramref name="tableNode" />s <see cref="T:yWorks.Graph.ILookup" />. Otherwise, an <see cref="T:System.ArgumentException" /> is thrown. The cell bounds are determined by <see cref="M:yWorks.Graph.Table.GetCellBounds(yWorks.Graph.INode,yWorks.Graph.IColumn,yWorks.Graph.IRow)" />.</para>
        <para>If <paramref name="reparent" /> is <c>true</c>, the node is made a child node of <paramref name="tableNode" /> if it is no descendant of the table node hierarchy yet. Otherwise, the grouping hierarchy is not changed.</para>
        <para>If <paramref name="alwaysMove" /> is <c>true</c>, the node is moved even if its center is already contained in the cell, otherwise only when the node layout center is currently outside of the cell bounds.</para>
        <para>This method does not change the size of the target stripes if they would be too small to contain the whole node layout. Callers must increase the stripe size before or after calling this method, if necessary.</para>
      </remarks>
      <param name="graph">
        <para>The graph instance where the move should be performed</para>
      </param>
      <param name="node">
        <para>The node that should be moved into the given cell.</para>
      </param>
      <param name="tableNode">
        <para>The node where a table is bound to via the node's lookup</para>
      </param>
      <param name="column">
        <para>The column that determines the cell</para>
      </param>
      <param name="row">
        <para>The row that determines the cell</para>
      </param>
      <param name="reparent">
        <para>Whether <paramref name="node" /> should also be made part of <paramref name="tableNode" />'s grouping hierarchy if it is not yet contained in it.</para>
      </param>
      <param name="alwaysMove">
        <para>Whether <paramref name="node" /> should be moved even if it is already placed in the cell.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>If no table is present in the <see cref="T:yWorks.Graph.ILookup" /> of <paramref name="tableNode" />, or if <paramref name="column" /> and <paramref name="row" /> are part of a different table instance.</para>
      </exception>
    </member>
    <member name="T:yWorks.Graph.StripeEventArgs">
      <summary>
        <para>A specialized subclass of the <see cref="T:yWorks.Utils.ItemEventArgs`1" /> class that is bound to the <see cref="T:yWorks.Graph.IStripe" /> type and carries additional <see cref="T:yWorks.Graph.IStripe">owner</see> information.</para>
      </summary>
      <remarks>
        <para>Since for some events (<see cref="E:yWorks.Graph.ITable.StripeRemoved" />) it is unclear what <see cref="M:yWorks.Graph.StripeExtensions.GetParentStripe(yWorks.Graph.IStripe)">parent</see> the stripe was owned by before the event, this event can be used to carry exactly that information.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.StripeEventArgs.#ctor(yWorks.Graph.IStripe,yWorks.Graph.IStripe,yWorks.Graph.ITable)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.StripeEventArgs" /> class.</para>
      </summary>
      <param name="stripe">
        <para>The stripe to assign to the <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" /> property.</para>
      </param>
      <param name="parentStripe">
        <para>The previous parent of the stripe.</para>
      </param>
      <param name="table">
        <para>The table the stripe belonged to previously.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.StripeEventArgs.ParentStripe">
      <summary>
        <para>Gets the parent of the stripe that owned the stripe before the event happened.</para>
      </summary>
      <value>
        <para>The old owner.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.StripeEventArgs.Table">
      <summary>
        <para>Gets the table that owned the stripe before the event happened.</para>
      </summary>
      <value>
        <para>The old table.</para>
      </value>
    </member>
    <member name="T:yWorks.Graph.StripeTypes">
      <summary>
        <para>An enumeration for use in various properties that can take a bitwise combination of stripe types</para>
      </summary>
      <remarks>
        <para>The enumeration can be used to create <see cref="T:System.FlagsAttribute">bitwise combination</see> of the types.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.StripeTypes.Row">
      <summary>
        <para>Constant for rows.</para>
      </summary>
      <seealso cref="F:yWorks.Graph.StripeTypes.Row" />
    </member>
    <member name="F:yWorks.Graph.StripeTypes.Column">
      <summary>
        <para>Constant for columns.</para>
      </summary>
      <seealso cref="F:yWorks.Graph.StripeTypes.Column" />
    </member>
    <member name="F:yWorks.Graph.StripeTypes.All">
      <summary>
        <para>Constant for all item types.</para>
      </summary>
      <remarks>
        <para>This is a bitwise combination of all other types declared in this enum.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.StripeTypes.None">
      <summary>
        <para>Constant for no item type.</para>
      </summary>
      <remarks>
        <para>This is a constant where no type bit has been set, i.e. it is <c>0</c>.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Markup.Common.TableExtension" />
    <member name="P:yWorks.Markup.Common.TableExtension.Rows" />
    <member name="P:yWorks.Markup.Common.TableExtension.Columns" />
    <member name="P:yWorks.Markup.Common.TableExtension.Insets" />
    <member name="P:yWorks.Markup.Common.TableExtension.RelativeLocation" />
    <member name="P:yWorks.Markup.Common.TableExtension.RowDefaults" />
    <member name="P:yWorks.Markup.Common.TableExtension.ColumnDefaults" />
    <member name="M:yWorks.Markup.Common.TableExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.IStripeDefaults">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.ITable" /> and the like to declare and obtain the defaults for stripes and their labels.</para>
      </summary>
      <seealso cref="P:yWorks.Graph.ITable.RowDefaults" />
      <seealso cref="P:yWorks.Graph.ITable.ColumnDefaults" />
    </member>
    <member name="P:yWorks.Graph.IStripeDefaults.Insets">
      <summary>
        <para>Gets or sets the default insets for a stripe.</para>
      </summary>
      <value>
        <para>The default insets.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.IStripeDefaults.Size">
      <summary>
        <para>Gets or sets the default stripe size.</para>
      </summary>
      <value>
        <para>The default size of newly created stripe.</para>
      </value>
      <seealso cref="P:yWorks.Graph.IStripe.Size" />
    </member>
    <member name="P:yWorks.Graph.IStripeDefaults.MinimumSize">
      <summary>
        <para>Gets or sets the default minimum stripe size.</para>
      </summary>
      <value>
        <para>The default minimum size of newly created stripes.</para>
      </value>
      <seealso cref="P:yWorks.Graph.IStripe.MinimumSize" />
    </member>
    <member name="P:yWorks.Graph.IStripeDefaults.Labels">
      <summary>
        <para>Gets or sets the defaults for labels at stripes.</para>
      </summary>
      <value>
        <para>The label defaults.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.IStripeDefaults.Style">
      <summary>
        <para>Gets or sets the style to use for stripes.</para>
      </summary>
      <remarks>
        <para>Depending on the setting of <see cref="P:yWorks.Graph.IStripeDefaults.ShareStyleInstance" />, the <see cref="M:yWorks.Graph.IStripeDefaults.GetStyleInstance" /> method should return a <see cref="M:System.ICloneable.Clone">clone</see> of this instance or the very same instance.</para>
      </remarks>
      <value>
        <para>The style to use as a template.</para>
      </value>
      <seealso cref="P:yWorks.Graph.IStripeDefaults.ShareStyleInstance" />
    </member>
    <member name="P:yWorks.Graph.IStripeDefaults.ShareStyleInstance">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="P:yWorks.Graph.IStripeDefaults.Style" /> instance should be shared referentially or <see cref="M:System.ICloneable.Clone">cloned</see> upon a call to <see cref="M:yWorks.Graph.IStripeDefaults.GetStyleInstance" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the reference should be shared; <c>false</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Graph.IStripeDefaults.GetStyleInstance" />
      <seealso cref="P:yWorks.Graph.IStripeDefaults.Style" />
    </member>
    <member name="M:yWorks.Graph.IStripeDefaults.GetStyleInstance">
      <summary>
        <para>Factory method that returns a style instance for use with newly created stripes.</para>
      </summary>
      <remarks>
        <para>Most implementations will yield either, a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.IStripeDefaults.Style" /> property, if <see cref="P:yWorks.Graph.IStripeDefaults.ShareStyleInstance" /> is enabled, but they might use more complicated logic, too.</para>
      </remarks>
      <returns>
        <para>The style to use, which for most implementations is either a <see cref="M:System.ICloneable.Clone">clone</see> of or the <see cref="P:yWorks.Graph.IStripeDefaults.Style" /> property, if <see cref="P:yWorks.Graph.IStripeDefaults.ShareStyleInstance" /> is enabled.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.StripeDefaults">
      <summary>
        <para>A canonic implementation of the <see cref="T:yWorks.Graph.IStripeDefaults" /> interface.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.StripeDefaults.Insets">
      <summary>
        <para>Gets or sets the default insets for a stripe.</para>
      </summary>
      <value>
        <para>The default insets.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.StripeDefaults.#ctor">
      <summary>
        <para>Default constructor</para>
      </summary>
      <remarks>
        <para>This constructor sets the style to <see cref="F:yWorks.Graph.Styles.VoidNodeStyle.Instance" /> and the insets to <see cref="F:yWorks.Geometry.InsetsD.Empty" /></para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.StripeDefaults.Size">
      <summary>
        <para>Gets or sets the default stripe size.</para>
      </summary>
      <value>
        <para>The default size of newly created stripe. Default value is 100</para>
      </value>
      <seealso cref="P:yWorks.Graph.IStripe.Size" />
    </member>
    <member name="P:yWorks.Graph.StripeDefaults.MinimumSize">
      <summary>
        <para>Gets or sets the default minimum stripe size.</para>
      </summary>
      <value>
        <para>The default minimum size of newly created stripes. Default value is 10</para>
      </value>
      <seealso cref="P:yWorks.Graph.IStripe.MinimumSize" />
    </member>
    <member name="M:yWorks.Graph.StripeDefaults.GetStyleInstance" />
    <member name="T:yWorks.Graph.TableExtensions">
      <summary>
        <para>Extension method holder class that extends the <see cref="T:yWorks.Graph.ITable" /> type with utility methods.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.ITable" />
    </member>
    <member name="M:yWorks.Graph.TableExtensions.CreateLabelStyle(yWorks.Graph.ITable,yWorks.Graph.IStripe)">
      <summary>
        <para>Convenience method that delegates to the <see cref="M:yWorks.Graph.ILabelDefaults.GetStyleInstance(yWorks.Graph.ILabelOwner)" /> method for the given <see cref="T:yWorks.Graph.IStripe">stripe</see>.</para>
      </summary>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="stripe">
        <para>The item the newly created label will belong to.</para>
      </param>
      <returns>
        <para>The style instance to use for newly created stripes.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.CreateLabelLayoutParameter(yWorks.Graph.ITable,yWorks.Graph.IStripe)">
      <summary>
        <para>Creates the label model parameter for a given <see cref="T:yWorks.Graph.ILabelOwner" />.</para>
      </summary>
      <remarks>
        <para>This implementation uses the label defaults for the <paramref name="table" /> to <see cref="M:yWorks.Graph.ILabelDefaults.GetLayoutParameterInstance(yWorks.Graph.ILabelOwner)">obtain the parameter instance</see>.</para>
      </remarks>
      <param name="table">
        <para>The table to retrieve the <see cref="T:yWorks.Graph.ILabelDefaults" /> from. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="stripe">
        <para>The item that is the <see cref="P:yWorks.Graph.ILabel.Owner" /> of the label in question.</para>
      </param>
      <returns>
        <para>The default label model parameter to use for newly created labels at the item.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILabelDefaults.GetLayoutParameterInstance(yWorks.Graph.ILabelOwner)" />
    </member>
    <member name="M:yWorks.Graph.TableExtensions.CalculateLabelPreferredSize(yWorks.Graph.ITable,yWorks.Graph.IStripe,yWorks.Graph.Styles.ILabelStyle,yWorks.Graph.LabelModels.ILabelModelParameter,System.String,System.Object)">
      <summary>
        <para>Calculates the preferred size of a label with the given properties.</para>
      </summary>
      <param name="table">
        <para>The graph to which the label will be added.</para>
      </param>
      <param name="stripe">
        <para>The item that will own the label.</para>
      </param>
      <param name="style">
        <para>The label style.</para>
      </param>
      <param name="layoutParameter">
        <para>The label model parameter.</para>
      </param>
      <param name="text">
        <para>The text.</para>
      </param>
      <param name="tag">
        <para>The tag for the label.</para>
      </param>
      <returns>
        <para>The size as calculated by the <see cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.CreateRow(yWorks.Graph.ITable,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})">
      <summary>
        <para>Creates and returns a row as last child of <paramref name="table" />.</para>
      </summary>
      <remarks>
        <para>The row will be a part of this table after the method returns. This will trigger the corresponding events.</para>
      </remarks>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="height">
        <para>The actual height of the row.</para>
      </param>
      <param name="minHeight">
        <para>The minimal height of the row.</para>
      </param>
      <param name="insets">
        <para>The insets of the row.</para>
      </param>
      <param name="style">
        <para>The style of the row.</para>
      </param>
      <param name="tag">
        <para>The tag of the row</para>
      </param>
      <param name="index">
        <para>The position in the child list.</para>
      </param>
      <returns>
        <para>A newly created row instance</para>
      </returns>
      <seealso cref="E:yWorks.Graph.ITable.StripeCreated" />
    </member>
    <member name="M:yWorks.Graph.TableExtensions.CreateColumn(yWorks.Graph.ITable,System.Nullable{System.Double},System.Nullable{System.Double},System.Nullable{yWorks.Geometry.InsetsD},yWorks.Graph.Styles.IStripeStyle,System.Object,System.Nullable{System.Int32})">
      <summary>
        <para>Creates and returns a column as last child of <paramref name="table" />.</para>
      </summary>
      <remarks>
        <para>The column will be a part of this table after the method returns. This will trigger the corresponding events.</para>
      </remarks>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="width">
        <para>The actual width of the column.</para>
      </param>
      <param name="minWidth">
        <para>The minimal width of the column.</para>
      </param>
      <param name="insets">
        <para>The insets of the column.</para>
      </param>
      <param name="style">
        <para>The style of the column.</para>
      </param>
      <param name="tag">
        <para>The tag of the column</para>
      </param>
      <param name="index">
        <para>The position in the child list.</para>
      </param>
      <returns>
        <para>A newly created column instance</para>
      </returns>
      <seealso cref="E:yWorks.Graph.ITable.StripeCreated" />
    </member>
    <member name="M:yWorks.Graph.TableExtensions.RemoveWithResize(yWorks.Graph.ITable,yWorks.Graph.IStripe)">
      <summary>
        <para>
          <see cref="M:yWorks.Graph.ITable.Remove(yWorks.Graph.IStripe)" />s <paramref name="stripe" /> from <paramref name="table" /> and resizes all affected stripes so that the table size does not change if possible.</para>
      </summary>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="stripe">
        <para>The stripe to remove</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.RemoveRecursively(yWorks.Graph.ITable,yWorks.Graph.IStripe)">
      <summary>
        <para>
          <see cref="M:yWorks.Graph.ITable.Remove(yWorks.Graph.IStripe)" />s <paramref name="stripe" /> and all of its descendants from <paramref name="table" />.</para>
      </summary>
      <remarks>
        <para>This method does not resize any stripes, use <see cref="M:yWorks.Graph.TableExtensions.RemoveRecursivelyWithResize(yWorks.Graph.ITable,yWorks.Graph.IStripe)" /> instead.</para>
      </remarks>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="stripe">
        <para>The stripe to remove</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.RemoveRecursivelyWithResize(yWorks.Graph.ITable,yWorks.Graph.IStripe)">
      <summary>
        <para>
          <see cref="M:yWorks.Graph.TableExtensions.RemoveWithResize(yWorks.Graph.ITable,yWorks.Graph.IStripe)">Removes</see> the given <paramref name="stripe" /> and all of its descendants from <paramref name="table" /> and resizes all affected stripes so that the table size does not change if possible.</para>
      </summary>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="stripe">
        <para>The stripe to remove</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.FindStripe(yWorks.Geometry.PointD,yWorks.Graph.StripeTypes,yWorks.Controls.Input.StripeSubregionTypes,yWorks.Controls.CanvasControl,System.Predicate{yWorks.Controls.Input.StripeSubregion})">
      <summary>
        <para>Convenience method to find a stripe underneath a certain point.</para>
      </summary>
      <param name="location">
        <para>The location to test.</para>
      </param>
      <param name="stripeTypes">
        <para>An enumeration value of <see cref="T:yWorks.Graph.StripeTypes" /> to specify the stripe type.</para>
      </param>
      <param name="subregionTypes">
        <para>An enumeration value of <see cref="T:yWorks.Controls.Input.StripeSubregionTypes" /> to further restrict the stripe region.</para>
      </param>
      <param name="canvasControl">
        <para>The canvas that provides necessary context for hit determination, such as <see cref="P:yWorks.Controls.ICanvasContext.HitTestRadius" />.</para>
      </param>
      <param name="filter">
        <para>Additional predicate to further restrict the hit test results.</para>
      </param>
      <returns>
        <para>The stripe subregions that have been found for the location or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.FindStripes(yWorks.Graph.ITable,yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Graph.StripeTypes,System.Predicate{yWorks.Graph.IStripe})">
      <summary>
        <para>Convenience method to find all stripes underneath a certain point.</para>
      </summary>
      <remarks>
        <para>The stripes are always returned in bottom up, rows first order. Note that this method does not take any <see cref="P:yWorks.Controls.ICanvasContext.HitTestRadius" /> into account.</para>
      </remarks>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="node">
        <para>The node this table is currently bound to</para>
      </param>
      <param name="location">
        <para>The location to test.</para>
      </param>
      <param name="stripeTypes">
        <para>An enumeration value of <see cref="T:yWorks.Graph.StripeTypes" /> to specify the stripe type.</para>
      </param>
      <param name="filter">
        <para>Additional predicate to further restrict the hit test results.</para>
      </param>
      <returns>
        <para>The stripes that have been found for the location or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.FindRow(yWorks.Graph.ITable,yWorks.Graph.INode,yWorks.Geometry.PointD,System.Predicate{yWorks.Graph.IStripe})">
      <summary>
        <para>Convenience method to find a row underneath a certain point.</para>
      </summary>
      <remarks>
        <para>The rows are tested in bottom up order.</para>
      </remarks>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="node">
        <para>The node this table is currently bound to</para>
      </param>
      <param name="location">
        <para>The location to test.</para>
      </param>
      <param name="filter">
        <para>Additional predicate to further restrict the results.</para>
      </param>
      <returns>
        <para>The topmost row that has been found for the location or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.FindColumn(yWorks.Graph.ITable,yWorks.Graph.INode,yWorks.Geometry.PointD,System.Predicate{yWorks.Graph.IStripe})">
      <summary>
        <para>Convenience method to find a column underneath a certain point.</para>
      </summary>
      <remarks>
        <para>The column are tested in bottom up order.</para>
      </remarks>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="node">
        <para>The node this table is currently bound to</para>
      </param>
      <param name="location">
        <para>The location to test.</para>
      </param>
      <param name="filter">
        <para>Additional predicate to further restrict the results.</para>
      </param>
      <returns>
        <para>The topmost column that has been found for the location or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.FindStripes(yWorks.Geometry.PointD,yWorks.Graph.StripeTypes,yWorks.Controls.Input.StripeSubregionTypes,yWorks.Controls.CanvasControl,System.Predicate{yWorks.Controls.Input.StripeSubregion})">
      <summary>
        <para>Used as a callback to find the items underneath a certain point.</para>
      </summary>
      <param name="location">
        <para>The location to test.</para>
      </param>
      <param name="stripeTypes">
        <para>An enumeration value of <see cref="T:yWorks.Graph.StripeTypes" /> to specify the stripe type.</para>
      </param>
      <param name="subregionTypes">
        <para>An enumeration value of <see cref="T:yWorks.Controls.Input.StripeSubregionTypes" /> to further restrict the stripe region.</para>
      </param>
      <param name="canvas">
        <para>The canvas that provides necessary context for hit determination, such as <see cref="P:yWorks.Controls.ICanvasContext.HitTestRadius" />.</para>
      </param>
      <param name="filter">
        <para>Additional predicate to further restrict the hit test results.</para>
      </param>
      <returns>
        <para>The stripe subregions that have been found for the location.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.CreateGrid(yWorks.Graph.ITable,System.Int32,System.Int32)">
      <summary>
        <para>Convenience method that creates a <paramref name="columns" /> x <paramref name="rows" />.</para>
      </summary>
      <remarks>
        <para>All existing rows and columns are cleared from <paramref name="table" /></para>
      </remarks>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <param name="columns">
        <para>The number of columns to test.</para>
      </param>
      <param name="rows">
        <para>The number of rows to test.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.Clear(yWorks.Graph.ITable)">
      <summary>
        <para>Convenience method that clears all stripes from a table.</para>
      </summary>
      <remarks>
        <para>All existing rows and columns are cleared from <paramref name="table" /></para>
      </remarks>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.AdjustLabelPreferredSize(yWorks.Graph.ITable,yWorks.Graph.ILabel)">
      <summary>
        <para>Adjusts the <see cref="P:yWorks.Graph.ILabel.PreferredSize" /> property of a label to fit the suggested size of its <see cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" />.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Graph.ILabel.Style">style's</see> renderer for the label to determine the preferred rendering size. This is useful after the label's content or style have been changed.</para>
      </remarks>
      <param name="table">
        <para>The table to use. This is a <c>this</c> parameter, so that the method can be used as an extension method.</para>
      </param>
      <seealso cref="P:yWorks.Graph.ILabelDefaults.AutoAdjustPreferredSize" />
      <param name="label">
        <para>The label to adjust the size for.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.GetCellBounds(yWorks.Graph.ITable,yWorks.Graph.IColumn,yWorks.Graph.IRow)">
      <summary>
        <para>Calculates the relative bounds of a table cell that is determined by <paramref name="column" /> and <paramref name="row" /></para>
      </summary>
      <remarks>
        <para>Both <paramref name="column" /> and <paramref name="row" /> must live in the provided <paramref name="table" /> instance. Otherwise, an <see cref="T:System.ArgumentException" /> is thrown.</para>
      </remarks>
      <param name="table">
        <para>The table containing the <paramref name="column" /> and <paramref name="row" /></para>
      </param>
      <param name="column">
        <para>The column that determines the cell</para>
      </param>
      <param name="row">
        <para>The row that determines the cell</para>
      </param>
      <returns>
        <para>The relative bounds of a the cell determined by <paramref name="column" /> and <paramref name="row" /></para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>If <paramref name="column" /> and <paramref name="row" /> are part of a different table instance.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.TableExtensions.GetAccumulatedInsets(yWorks.Graph.ITable)">
      <summary>
        <para>Return the accumulated insets for the table.</para>
      </summary>
      <param name="table" />
    </member>
    <member name="T:yWorks.Graph.Styles.ArcEdgeStyleRenderer">
      <summary>
        <para>Default renderer implementation for <see cref="T:yWorks.Graph.Styles.ArcEdgeStyle" /></para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.Configure" />
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.GetHeight">
      <summary>
        <para>Retrieves the <see cref="P:yWorks.Graph.Styles.ArcEdgeStyle.Height" /> of the style.</para>
      </summary>
      <returns>
        <para>the height.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Overridden for performance reasons.</para>
      </summary>
      <param name="context" />
      <param name="rectangle" />
      <returns />
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.IsFixedHeight">
      <summary>
        <para>Gets a value indicating whether this <see cref="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.GetHeight" /> should be interpreted as an absolute or relative value.</para>
      </summary>
      <returns>
        <para>
          <c>true</c> if the height value should be interpreted as a fixed value, otherwise, <c>false</c>.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.GetHeight" />
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.GetPen" />
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.GetTangent(System.Double)">
      <param name="ratio" />
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.GetTangent(System.Int32,System.Double)">
      <param name="segmentIndex" />
      <param name="ratio" />
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.CropPath(yWorks.Geometry.GeneralPath)">
      <param name="path" />
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.GetSegmentCount" />
    <member name="P:yWorks.Graph.Styles.ArcEdgeStyleRenderer.AddBridges">
      <summary>
        <para>Gets whether bridges are added to the edge path.</para>
      </summary>
      <remarks>
        <para>Overridden to return <c>false</c> since the flattening interferes with its own obstacles.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.CreatePath" />
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.GetTargetArrow">
      <summary>
        <para>Gets the target arrow from the style via <see cref="P:yWorks.Graph.Styles.IArrowOwner.TargetArrow" />.</para>
      </summary>
      <returns>
        <para>The arrow to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyleRenderer.GetSourceArrow">
      <summary>
        <para>Gets the source arrow from the style via <see cref="P:yWorks.Graph.Styles.IArrowOwner.SourceArrow" />.</para>
      </summary>
      <returns>
        <para>The arrow to use.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.ArcEdgeStyle">
      <summary>
        <para>Provides an arc representation for an edge.</para>
      </summary>
      <remarks>
        <para>The rendering does not take into account bends of an edge, instead the arc's height is determined as a fixed ratio or fixed height.</para>
        <para>This style uses an <see cref="T:yWorks.Graph.Styles.ArcEdgeStyleRenderer" /> for its visualization.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyle.#ctor">
      <summary>
        <para>Creates a new instance using <see cref="T:yWorks.Graph.Styles.ArcEdgeStyleRenderer" /> as renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyle.#ctor(yWorks.Graph.Styles.ArcEdgeStyleRenderer)">
      <summary>
        <para>Creates a new instance using the provided renderer.</para>
      </summary>
      <param name="renderer">
        <para>The custom renderer for this style instance.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.ArcEdgeStyle.Pen">
      <summary>
        <para>Gets or sets the <see cref="T:System.Drawing.Pen" /> that is used to draw the arc</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="P:System.Drawing.Pens.Black" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ArcEdgeStyle.Height">
      <summary>
        <para>Gets or sets the "height" of the arc.</para>
      </summary>
      <remarks>
        <para>Depending on the setting of <see cref="P:yWorks.Graph.Styles.ArcEdgeStyle.FixedHeight" />, this value is interpreted differently: If <see cref="P:yWorks.Graph.Styles.ArcEdgeStyle.FixedHeight" /> is disabled, the height of the arc will depend on it's width. The width will be multiplied by this value to obtain the height. If the <see cref="P:yWorks.Graph.Styles.ArcEdgeStyle.FixedHeight" /> feature is enabled, this value will be interpreted as the absolute height.</para>
        <para>The default value is <c>0</c>.</para>
      </remarks>
      <value>
        <para>The height of the arc, either relative or absolute.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.ArcEdgeStyle.FixedHeight">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Graph.Styles.ArcEdgeStyle" /> interprets the <see cref="P:yWorks.Graph.Styles.ArcEdgeStyle.Height" /> value as an absolute or relative value.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the height value should be interpreted as a fixed value, otherwise, <c>false</c>.</para>
      </value>
      <seealso cref="P:yWorks.Graph.Styles.ArcEdgeStyle.Height" />
    </member>
    <member name="P:yWorks.Graph.Styles.ArcEdgeStyle.ProvideHeightHandle">
      <summary>
        <para>Gets or sets a value indicating whether the <see cref="T:yWorks.Graph.Styles.ArcEdgeStyleRenderer" /> should provide an <see cref="T:yWorks.Controls.Input.IHandle" /> if queried for the <see cref="T:yWorks.Controls.Input.IHandleProvider" /> implementation that allows for adjusting the <see cref="P:yWorks.Graph.Styles.ArcEdgeStyle.Height" /> of this instance.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c>(which is the default) if a handle should be provided; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.ArcEdgeStyle.TargetArrow">
      <summary>
        <para>Gets or sets the visual arrow at the target end of edges that use this style.</para>
      </summary>
      <remarks>
        <para>Arrow instances may be shared between multiple style instances.</para>
        <para>The default value is <see cref="F:yWorks.Graph.Styles.Arrows.None" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ArcEdgeStyle.SourceArrow">
      <summary>
        <para>Gets or sets the visual arrow at the source end of edges that use this style.</para>
      </summary>
      <remarks>
        <para>Arrow instances may be shared between multiple style instances.</para>
        <para>The default value is <see cref="F:yWorks.Graph.Styles.Arrows.None" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ArcEdgeStyle.Renderer">
      <summary>
        <para>Gets the renderer implementation that has been supplied to this instance in the constructor.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ArcEdgeStyle.Clone">
      <summary>
        <para>Performs a <see cref="M:System.Object.MemberwiseClone" /></para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.ArrowType">
      <summary>
        <para>Defines common default arrow types for <see cref="T:yWorks.Graph.Styles.Arrow" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ArrowType.Default">
      <summary>
        <para>Default arrow</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ArrowType.Simple">
      <summary>
        <para>Simple arrow</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ArrowType.Short">
      <summary>
        <para>Short arrow</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ArrowType.Diamond">
      <summary>
        <para>Diamond shaped arrow</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ArrowType.None">
      <summary>
        <para>No arrow</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ArrowType.Circle">
      <summary>
        <para>Circular shaped arrow</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ArrowType.Cross">
      <summary>
        <para>Cross shaped arrow</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ArrowType.Triangle">
      <summary>
        <para>Triangular shaped arrow</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.BevelNodeStyleRenderer">
      <summary>
        <para>A <see cref="T:yWorks.Graph.Styles.INodeStyle" /> <see cref="T:yWorks.Graph.Styles.INodeStyleRenderer">renderer</see> implementation that draws a rounded rectangle with a bevel border in a 'shiny plate' fashion.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node">
      <summary>
        <para>Gets or sets the currently configured node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the <see cref="T:yWorks.Controls.IVisualCreator" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query hit test with. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="node">
        <para>The node to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="node">
        <para>The node to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Tests the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node">node</see> using the current <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style" /> for an intersection with the given box.</para>
      </summary>
      <param name="context">
        <para>the current input mode context</para>
      </param>
      <param name="rectangle">
        <para>the box describing the marquee's bounds</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the node is considered to be captured by the marquee</para>
      </returns>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Layout" /> to determine whether the node is in the box.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Determines visibility by checking for an intersection with the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Layout" />.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="rectangle">
        <para>The current clip</para>
      </param>
      <returns>
        <para>Whether the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Layout" /> is visible in the clip.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <summary>
        <para>Returns the layout bounds as an upper bound for the painting bound.</para>
      </summary>
      <param name="context">
        <para>the context to calculate the bounds for</para>
      </param>
      <returns>
        <para>the bounds or <c>null</c> to indicate an unbound area</para>
      </returns>
      <remarks>
        <para>This implementation simply sets the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Layout" />'s bounds to the scratch variable and returns.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node" /> properties, calls <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the shape geometry for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Layout">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.INode.Layout" /> of the node this renderer is currently configured for.</para>
      </summary>
      <remarks>
        <para>Returns <c>Node.Layout</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Color">
      <summary>
        <para>Gets the color from the style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Inset">
      <summary>
        <para>Gets the inset from the style.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and node have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Node" /> properties have been populated by the <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, or <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> methods.</para>
        <para>This is an empty implementation. Subclasses might have to override this method.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.Radius">
      <summary>
        <para>Gets the radius to use from the style.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="inner" />
      <param name="outer" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)">
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.GetOutline" />
    <member name="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyleRenderer.ProvideRadiusHandle">
      <summary>
        <para>Gets or sets a property that determines whether this instance should provide an <see cref="T:yWorks.Controls.Input.IHandle" /> for editing the radius of the shape.</para>
      </summary>
      <remarks>
        <para>The default is <c>false</c>. This implementation will add an appropriate <see cref="T:yWorks.Controls.Input.IHandleProvider" /> to the <see cref="M:yWorks.Graph.Styles.BevelNodeStyleRenderer.Lookup(System.Type)" /> of this instance if this feature is enabled.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.Styles.BevelNodeStyle">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.Graph.Styles.INodeStyle" /> that can be used to create rectangular nodes with rounded corners, a bevel border, and a shining background.</para>
      </summary>
      <remarks>
        <para>Optionally, this style renders a drop shadow by itself.</para>
        <para>This style uses the <see cref="T:yWorks.Graph.Styles.BevelNodeStyleRenderer" /> to visualize a node.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.BevelNodeStyleRenderer" />
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyle.#ctor">
      <summary>
        <para>Creates a new instance using <see cref="T:yWorks.Graph.Styles.BevelNodeStyleRenderer" /> as renderer to share.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyle.#ctor(yWorks.Graph.Styles.BevelNodeStyleRenderer)">
      <summary>
        <para>Creates a new instance using the provided renderer to share.</para>
      </summary>
      <param name="renderer" />
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyle.Inset">
      <summary>
        <para>Gets or sets the insets to use for the bevel.</para>
      </summary>
      <remarks>
        <para>The default value is <c>3</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyle.Radius">
      <summary>
        <para>Gets or sets the radius of the corner of the rounded rectangle.</para>
      </summary>
      <remarks>
        <para>The default value is <c>10</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyle.Color">
      <summary>
        <para>Gets or sets the base color to use.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="P:System.Drawing.Color.Black" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.BevelNodeStyle.DrawShadow">
      <summary>
        <para>Gets or sets a value indicating whether to draw a drop shadow.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if node has a drop shadow; <c>false</c> otherwise.</para>
      </value>
      <remarks>
        <para>The default value is <c>false</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.BevelNodeStyle.Clone" />
    <member name="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator">
      <summary>
        <para>Decorates an arbitrary node styles with an additional collapse/expand handle.</para>
      </summary>
      <remarks>
        <para>This style uses the <see cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer" /> to adorn an existing <see cref="T:yWorks.Graph.Styles.INodeStyle" /> with an icon that can then be clicked to trigger the <see cref="F:yWorks.Controls.Input.Commands.ToggleExpansionState" />.</para>
        <para>By default, this handle is rendered as a plus ("+") sign when in collapsed state, and a minus ("-") sign when in expanded state.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer" />
    </member>
    <member name="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.ButtonPlacement">
      <summary>
        <para>Gets or sets an <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> that determines the placement of the button for toggling the expanded state.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Graph.LabelModels.ILabelModelParameter" /> should <see cref="M:yWorks.Graph.LabelModels.ILabelModelParameter.Supports(yWorks.Graph.ILabel)">support</see> labels bound to an <see cref="T:yWorks.Graph.INode" /> because the button will be positioned as if it was an <see cref="T:yWorks.Graph.ILabel" /> owned by the <see cref="T:yWorks.Graph.INode" /> that uses this style.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.Insets">
      <summary>
        <para>Gets or sets the insets to use for the <see cref="T:yWorks.Controls.Input.INodeInsetsProvider" /> that will be reported by the <see cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer" />'s <see cref="T:yWorks.Graph.ILookup" />.</para>
      </summary>
      <remarks>
        <para>This effectively influences the way the bounds of a group node are being calculated. The default <see cref="T:yWorks.Graph.IGroupBoundsCalculator" /> implementation will use these insets to determine the minimum size of a group node given a set of contained nodes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.CollapsedIcon">
      <summary>
        <para>Yields the icon to use for displaying the button on a <see cref="M:yWorks.Graph.IFoldingView.Collapse(yWorks.Graph.INode)">collapsed</see> group node.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.ExpandedIcon">
      <summary>
        <para>Yields the icon to use for displaying the button on an <see cref="M:yWorks.Graph.IFoldingView.Expand(yWorks.Graph.INode)">expanded</see> group node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator" /> class.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.Wrapped" /> property will be initialized with a <see cref="T:yWorks.Graph.Styles.ShapeNodeStyle" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.#ctor(yWorks.Graph.Styles.INodeStyle,yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator" /> class using the provided style for the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.Wrapped" /> property and the provided <see cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer" /> as renderer.</para>
      </summary>
      <param name="wrapped">
        <para>The decorated style.</para>
      </param>
      <param name="renderer">
        <para>An instance of <see cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer" /> to render this style.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.Clone" />
    <member name="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.Wrapped">
      <summary>
        <para>Gets or sets the wrapped node style that will be used to perform the actual rendering of the node.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer">
      <summary>
        <para>
          <see cref="T:yWorks.Graph.Styles.INodeStyleRenderer" /> implementation that can be used in conjunction with <see cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator" /> instances.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Node">
      <summary>
        <para>Gets or sets the currently configured node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and node have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Node" /> properies have been populated by the <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, or <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> methods.</para>
        <para>This is an empty implementation. Subclasses might have to override this method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the <see cref="T:yWorks.Controls.IVisualCreator" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query hit test with. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="node">
        <para>The node to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="node">
        <para>The node to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Node" /> properties, calls <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the shape geometry for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.IsInside(yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Layout">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.INode.Layout" /> of the node this renderer is currently configured for.</para>
      </summary>
      <remarks>
        <para>Returns <c>Node.Layout</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer" /> class.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetIcon(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Callback method that yields the <see cref="T:yWorks.Graph.Styles.IIcon" /> to use.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <returns>
        <para>The icon to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetButtonLocationParameter">
      <summary>
        <para>Yields the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.ButtonPlacement" /> for the current <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /></para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Delegates to the <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetWrappedStyle" /> and checks the button.</para>
      </summary>
      <param name="context" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Delegates to the <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetWrappedStyle" />.</para>
      </summary>
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.IsInside(yWorks.Geometry.PointD)">
      <summary>
        <para>Delegates to the <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetWrappedStyle" />.</para>
      </summary>
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetOutline">
      <summary>
        <para>Delegates to the <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetWrappedStyle" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <summary>
        <para>Delegates to the <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetWrappedStyle" /> and takes the button into account.</para>
      </summary>
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Delegates to the <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetWrappedStyle" />.</para>
      </summary>
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Delegates to the <see cref="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetWrappedStyle" />.</para>
      </summary>
      <param name="inner" />
      <param name="outer" />
    </member>
    <member name="M:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.GetWrappedStyle">
      <summary>
        <para>Yields the <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator.Wrapped" /> property for the current <see cref="P:yWorks.Graph.Styles.CollapsibleNodeStyleDecoratorRenderer.Style" /></para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.StyleDecorationZoomPolicy">
      <summary>
        <para>Specifies how the zoom level affects the rendering of styles that are used as selection, highlight or focus indicator.</para>
      </summary>
      <seealso cref="T:yWorks.Controls.NodeStyleDecorationInstaller" />
      <seealso cref="T:yWorks.Controls.EdgeStyleDecorationInstaller" />
      <seealso cref="T:yWorks.Controls.LabelStyleDecorationInstaller" />
    </member>
    <member name="F:yWorks.Controls.StyleDecorationZoomPolicy.ViewCoordinates">
      <summary>
        <para>The visual is rendered in the view coordinate space and doesn't scale with the zoom level.</para>
      </summary>
      <remarks>
        <para>This is similar to the default node resize handles, for example.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.StyleDecorationZoomPolicy.WorldCoordinates">
      <summary>
        <para>The visual is rendered in the world coordinate space and scales with the zoom level like a regular graph item visualization, for example a node style.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.StyleDecorationZoomPolicy.Mixed">
      <summary>
        <para>Uses WorldCoordinates rendering for zoom level &gt;= 1 and ViewCoordinates rendering for zoom level &lt; 1.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.DefaultLabelStyle">
      <summary>
        <para>A basic label style which renders the label's <see cref="P:yWorks.Graph.ILabel.Text" /> and optionally a <see cref="P:yWorks.Graph.Styles.DefaultLabelStyle.BackgroundBrush">background</see> and <see cref="P:yWorks.Graph.Styles.DefaultLabelStyle.BackgroundPen">border</see>.</para>
      </summary>
      <remarks>
        <para>This style uses a <see cref="T:yWorks.Graph.Styles.DefaultLabelStyleRenderer" /> to create its visualization.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyle.#ctor">
      <summary>
        <para>Creates a new instance using <see cref="T:yWorks.Graph.Styles.DefaultLabelStyleRenderer" /> as renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyle.#ctor(yWorks.Graph.Styles.ILabelStyleRenderer)">
      <summary>
        <para>Creates a new instance using the provided renderer.</para>
      </summary>
      <param name="renderer">
        <para>The custom renderer for this style instance.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyle.BackgroundBrush">
      <summary>
        <para>Gets or sets the brush to use for the background box of the label.</para>
      </summary>
      <remarks>
        <para>The default value is <c>null</c>.</para>
      </remarks>
      <value>
        <para>The background brush or <c>null</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyle.StringFormat">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyle.StringFormat" /> to use for rendering the label.</para>
      </summary>
      <value>
        <para>The string format.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyle.ClipText">
      <summary>
        <para>Gets or sets a value that determines whether text should be clipped.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyle.NormalizeBrushes">
      <summary>
        <para>Gets or sets a property that determines whether brushes, that can be transformed (<see cref="T:System.Drawing.Drawing2D.LinearGradientBrush" />, <see cref="T:System.Drawing.Drawing2D.PathGradientBrush" />, and <see cref="T:System.Drawing.TextureBrush" />) should be transformed so that (0,0) is at the node layout's top left corner and (1,1) is at the bottom right corner.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyle.BackgroundPen">
      <summary>
        <para>Gets or sets the pen to use for the background box of the label.</para>
      </summary>
      <remarks>
        <para>The default value is <c>null</c>.</para>
      </remarks>
      <value>
        <para>The background pen or <c>null</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyle.Font">
      <summary>
        <para>Gets or sets the font to use for the label.</para>
      </summary>
      <value>
        <para>The typeface.</para>
      </value>
      <remarks>
        <para>The default value is an instance of <see cref="P:yWorks.Graph.Styles.DefaultLabelStyle.Font" /> for <c>Arial</c>".</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>value cannot be null!</para>
      </exception>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyle.AutoFlip">
      <summary>
        <para>Gets or sets a value indicating whether the label should be flipped 180 degrees automatically, if it would be oriented downwards, otherwise.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the label should be flipped automatically otherwise, <c>false</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyle.TextBrush">
      <summary>
        <para>Gets or sets the brush to use for the label's text.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="P:System.Drawing.Brushes.Black" />.</para>
      </remarks>
      <value>
        <para>The font brush or <c>null</c>.</para>
      </value>
      <exception cref="T:System.ArgumentException">
        <para>value cannot be null!</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyle.Clone" />
    <member name="T:yWorks.Graph.Styles.IconLabelStyle">
      <summary>
        <para>A label style that draws an icon in addition to the text.</para>
      </summary>
      <remarks>
        <para>This style draws the icon at the location specified by <see cref="P:yWorks.Graph.Styles.IconLabelStyle.IconPlacement" /> and delegates the drawing of the label's text to the <see cref="P:yWorks.Graph.Styles.IconLabelStyle.Wrapped" /> style.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyle.#ctor">
      <summary>
        <para>Creates a new instance using no icon and <see cref="T:yWorks.Graph.Styles.IconLabelStyleRenderer" /> as renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyle.#ctor(yWorks.Graph.Styles.IIcon,yWorks.Graph.Styles.ILabelStyleRenderer)">
      <summary>
        <para>Creates a new instance using the provided icon and renderer.</para>
      </summary>
      <param name="icon">
        <para>The icon to draw.</para>
      </param>
      <param name="renderer">
        <para>The custom renderer for this style instance.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.IconLabelStyle.Icon">
      <summary>
        <para>Gets or sets the icon to paint for the label.</para>
      </summary>
      <value>
        <para>The icon.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.IconLabelStyle.IconPlacement">
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>value</c> is null.</para>
      </exception>
    </member>
    <member name="P:yWorks.Graph.Styles.IconLabelStyle.Wrapped">
      <summary>
        <para>Gets or sets the style that renders the text of the label.</para>
      </summary>
      <value>
        <para>The style that renders the text of the label.</para>
      </value>
      <remarks>
        <para>This style will be rendered before the icon and is responsible for rendering the <see cref="P:yWorks.Graph.ILabel.Text" />, since <see cref="T:yWorks.Graph.Styles.IconLabelStyleRenderer" /> will only render the <see cref="P:yWorks.Graph.Styles.IconLabelStyle.Icon" />.</para>
        <para>The default value is <see cref="T:yWorks.Graph.Styles.DefaultLabelStyle" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">
        <para>
          <c>value</c> is null.</para>
      </exception>
    </member>
    <member name="P:yWorks.Graph.Styles.IconLabelStyle.WrappedInsets">
      <summary>
        <para>Gets or sets the insets that should be applied for the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see> of the <see cref="P:yWorks.Graph.Styles.IconLabelStyle.Wrapped">wrapped style</see> rendering.</para>
      </summary>
      <value>
        <para>The insets for the wrapped style rendering.</para>
      </value>
      <remarks>
        <para>The <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetPreferredSize(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" /> will take the preferred size of the <see cref="P:yWorks.Graph.Styles.IconLabelStyle.Wrapped" />'s <see cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" /> and add these insets to it. During the <see cref="T:yWorks.Controls.IVisualCreator">rendering</see> these insets will be used to offset the rendering of the wrapped style.</para>
        <para>The default insets are empty.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.IconLabelStyle.AutoFlip">
      <summary>
        <para>Gets a value indicating whether to automatically flip the rendering should the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see>'s <see cref="P:yWorks.Geometry.IOrientedRectangle.UpY">up vector</see> point downwards.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this style should automatically flip the rendering so that it is never rendered upside down; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyle.Clone" />
    <member name="T:yWorks.Graph.Styles.IIcon">
      <summary>
        <para>A simple icon interface for classes that can paint icons.</para>
      </summary>
      <remarks>
        <para>Basically, this is an <see cref="T:yWorks.Controls.IVisual" /> with a <see cref="P:yWorks.Graph.Styles.IIcon.Size" />. It is used in <see cref="T:yWorks.Graph.Styles.IconLabelStyle" /> to decorate an <see cref="T:yWorks.Graph.ILabel" />. It is also used to define the expand/collapse buttons (+/-) in <see cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator" />.</para>
        <para>Icons should always paint themselves in the rectangle defined by the origin (0, 0) and the icon's size.</para>
        <para>
          <see cref="T:yWorks.Graph.Styles.ImageIcon" /> and <see cref="T:yWorks.Graph.Styles.UriImageIcon" /> provide GraphML serializable implementations to use images for these decorations.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.IconLabelStyle" />
      <seealso cref="T:yWorks.Graph.Styles.CollapsibleNodeStyleDecorator" />
      <seealso cref="T:yWorks.Graph.Styles.ImageIcon" />
      <seealso cref="T:yWorks.Graph.Styles.UriImageIcon" />
    </member>
    <member name="P:yWorks.Graph.Styles.IIcon.Size">
      <summary>
        <para>Gets the size of the icon.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.ImageIcon">
      <summary>
        <para>A trivial implementation of the <see cref="T:yWorks.Graph.Styles.IIcon" /> interface that paints an image.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ImageIcon.#ctor" />
    <member name="M:yWorks.Graph.Styles.ImageIcon.#ctor(System.Drawing.Image)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.ImageIcon" /> class using the provided image.</para>
      </summary>
      <param name="image">
        <para>The image.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.ImageIcon.Image">
      <summary>
        <para>The image that should be used for this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ImageIcon.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="graphics" />
    </member>
    <member name="T:yWorks.Graph.Styles.UriImageIcon">
      <summary>
        <para>A trivial implementation of the <see cref="T:yWorks.Graph.Styles.IIcon" /> interface that paints an image that is loaded from a <see cref="P:yWorks.Graph.Styles.UriImageIcon.Uri" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageIcon.#ctor" />
    <member name="M:yWorks.Graph.Styles.UriImageIcon.#ctor(System.Uri)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.UriImageIcon" /> class using the provided uri.</para>
      </summary>
      <param name="uri">
        <para>The uri.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.UriImageIcon.Uri">
      <summary>
        <para>Gets or sets the URI that is used for the image.</para>
      </summary>
      <value>
        <para>The URI.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.UriImageIcon.Image">
      <summary>
        <para>The image that should be used for this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageIcon.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="graphics" />
    </member>
    <member name="T:yWorks.Graph.Styles.DefaultLabelStyleRenderer">
      <summary>
        <para>A simple <see cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" /> implementation that can handle <see cref="T:yWorks.Graph.Styles.DefaultLabelStyle" /> instances.</para>
      </summary>
      <remarks>
        <para>This implementation will just draw the label's <see cref="P:yWorks.Graph.ILabel.Text" /> using the properties provided by <see cref="T:yWorks.Graph.Styles.DefaultLabelStyle" /> into the label's <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see> area.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.#ctor">
      <summary>
        <para>Creates a new default instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Layout">
      <summary>
        <para>Retrieves the current <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see>.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Label">
      <summary>
        <para>Gets or sets the currently configured label.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and label have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Label" /> properties have been populated by the <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetVisualCreator(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />, <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetBoundsProvider(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />, <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetHitTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />, or <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetMarqueeTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" /> methods.</para>
        <para>Stores the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see> into <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Layout" />. Subclasses which to override this method should call the base implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetVisualCreator(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, calls <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="label">
        <para>The label to retrieve the <see cref="T:yWorks.Controls.IVisualCreator" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetBoundsProvider(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, calls <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="label">
        <para>The label to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetHitTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, calls <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="label">
        <para>The label to query hit test with. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetMarqueeTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, calls <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="label">
        <para>The label to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetVisibilityTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="label">
        <para>The label to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetContext(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="label">
        <para>The label to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Lookup(System.Type)">
      <summary>
        <para>Implements the <see cref="T:yWorks.Graph.ILookup" /> interface.</para>
      </summary>
      <remarks>
        <para>This method will be used by default if <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetContext(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" /> has been queried for a lookup implementation. Note that it cannot be assumed that <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" /> has already been invoked. However, normally <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Label" /> and <see cref="P:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Style" /> will be correctly configured if invoked directly after <c>GetContext</c>. Subclass implementations should make sure to configure this instance before they return <c>this</c> as a result of a successful lookup. This implementation will check if <c>type.IsInstanceOfType(this)</c> and will call <see cref="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.Configure" /> on success and return <c>this</c>.</para>
      </remarks>
      <param name="type">
        <para>The type to query for.</para>
      </param>
      <returns>
        <para>An implementation or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Uses the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)" /> to determine whether the clip intersects.</para>
      </summary>
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetPreferredSize(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <param name="label" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.IsTextMirrored(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <summary>
        <para>Determines whether the text should be horizontally mirrored.</para>
      </summary>
      <remarks>
        <para>This can be necessary if the <see cref="T:yWorks.Controls.CanvasControl" />'s <see cref="T:System.Windows.Forms.FlowDirection" /> is set to <see cref="F:System.Windows.Forms.FlowDirection.RightToLeft" /> because this will apply a mirroring transform onto the canvas contents, making text unreadable otherwise. This implementation tests whether the flow direction property on the canvas is set to <see cref="F:System.Windows.Forms.FlowDirection.RightToLeft" />.</para>
      </remarks>
      <param name="context">
        <para>The context for which the rendering is performed.</para>
      </param>
      <param name="g">
        <para>The drawing context that will be used for the rendering.</para>
      </param>
      <returns>
        <para>Whether to apply a mirroring transformation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.IsClippingText">
      <summary>
        <para>Determines whether text should be forced to be clipped inside the rectangle.</para>
      </summary>
      <returns>
        <para>This value as obtained from the style.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.IsAutoFlip">
      <summary>
        <para>Delegates to <see cref="P:yWorks.Graph.Styles.DefaultLabelStyle.AutoFlip" /></para>
      </summary>
      <returns>
        <para>Whether to flip the drawing if it is upside down.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetStringFormat">
      <summary>
        <para>Gets the <see cref="T:System.Drawing.StringFormat" /> to use for rendering the string.</para>
      </summary>
      <returns>
        <para>The stringformat as obtained from the style.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetPreferredSize">
      <summary>
        <para>Calculates the preferred size given the current state of the renderer.</para>
      </summary>
      <returns>
        <para>The size as suggested by this renderer.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.DefaultLabelStyleRenderer.GetTransform">
      <summary>
        <para>Gets the transform for the label.</para>
      </summary>
      <returns>
        <para>The transform.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.IconLabelStyleRenderer">
      <summary>
        <para>An <see cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" /> that can handle <see cref="T:yWorks.Graph.Styles.IconLabelStyle" /> instances.</para>
      </summary>
      <remarks>
        <para>This implementation paints the label's inner style and an icon.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.#ctor">
      <summary>
        <para>Creates a new instance of this renderer.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Label">
      <summary>
        <para>Gets or sets the currently configured label.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetVisualCreator(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, calls <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="label">
        <para>The label to retrieve the <see cref="T:yWorks.Controls.IVisualCreator" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetBoundsProvider(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, calls <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="label">
        <para>The label to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetHitTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, calls <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="label">
        <para>The label to query hit test with. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetMarqueeTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, calls <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="label">
        <para>The label to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetVisibilityTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="label">
        <para>The label to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetContext(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="label" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="label">
        <para>The label to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Label" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the label. The value will be stored in the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Lookup(System.Type)">
      <summary>
        <para>Implements the <see cref="T:yWorks.Graph.ILookup" /> interface.</para>
      </summary>
      <remarks>
        <para>This method will be used by default if <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetContext(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" /> has been queried for a lookup implementation. Note that it cannot be assumed that <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" /> has already been invoked. However, normally <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Label" /> and <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" /> will be correctly configured if invoked directly after <c>GetContext</c>. Subclass implementations should make sure to configure this instance before they return <c>this</c> as a result of a successful lookup. This implementation will check if <c>type.IsInstanceOfType(this)</c> and will call <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure" /> on success and return <c>this</c>.</para>
      </remarks>
      <param name="type">
        <para>The type to query for.</para>
      </param>
      <returns>
        <para>An implementation or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetTransform">
      <summary>
        <para>Gets the transform for the label.</para>
      </summary>
      <returns>
        <para>The transform.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetIconTransform">
      <summary>
        <para>Gets the transform for the icon.</para>
      </summary>
      <remarks>
        <para>This is supposed to be prepended to the <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetTransform">label's transform</see>.</para>
      </remarks>
      <returns>
        <para>The icon's transform.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and item have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Label" /> fields have been populated by the <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetVisualCreator(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />, <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetBoundsProvider(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />, <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetHitTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" />, or <see cref="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetMarqueeTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" /> methods.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetWrappedStyle">
      <summary>
        <para>Retrieves the <see cref="P:yWorks.Graph.Styles.IconLabelStyle.Wrapped" /> from the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" />.</para>
      </summary>
      <returns>
        <para>The style.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetIcon">
      <summary>
        <para>Retrieves the <see cref="P:yWorks.Graph.Styles.IconLabelStyle.Icon" /> from the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" />.</para>
      </summary>
      <returns>
        <para>The icon.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetInnerStyleInsets">
      <summary>
        <para>Retrieves the <see cref="P:yWorks.Graph.Styles.IconLabelStyle.WrappedInsets" /> from the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" />.</para>
      </summary>
      <returns>
        <para>The insets.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.IsAutoFlip">
      <summary>
        <para>Retrieves the <see cref="P:yWorks.Graph.Styles.IconLabelStyle.AutoFlip" /> property from the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" />.</para>
      </summary>
      <returns>
        <para>The autoflip property value.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetIconPlacement">
      <summary>
        <para>Retrieves the <see cref="P:yWorks.Graph.Styles.IconLabelStyle.IconPlacement" /> from the <see cref="P:yWorks.Graph.Styles.IconLabelStyleRenderer.Style" />.</para>
      </summary>
      <returns>
        <para>The placement parameter.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.ShouldHitTestIcon">
      <summary>
        <para>Returns whether the icon bounds should be considered for hit testing.</para>
      </summary>
      <returns>
        <para>true</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetPreferredSize">
      <summary>
        <para>Calculates the preferred size given the current state of the renderer.</para>
      </summary>
      <returns>
        <para>The size as suggested by this renderer.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IconLabelStyleRenderer.GetPreferredSize(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <param name="label" />
      <param name="style" />
    </member>
    <member name="T:yWorks.Controls.EdgeDecorationInstaller">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.Controls.ICanvasObjectInstaller" /> interface that can decorate the visual appearence of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </summary>
      <remarks>
        <para>This will install an <see cref="T:yWorks.Controls.ICanvasObject" /> during <see cref="M:yWorks.Controls.ICanvasObjectInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">installation</see>, that will render the path and the bends of an edge using a <see cref="M:yWorks.Controls.EdgeDecorationInstaller.GetPen(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">pen</see> for the path and a <see cref="M:yWorks.Controls.EdgeDecorationInstaller.GetBendDrawing(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">drawing</see> for the bends.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.EdgeDecorationInstaller.GetPen(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that retrieves the pen for the context.</para>
      </summary>
      <remarks>
        <para>This implementation will use the <see cref="F:yWorks.Controls.EdgeSelectionIndicatorInstaller.PenKey" /> resource to find a <see cref="T:System.Drawing.Pen" /> instance. If <c>null</c> is yielded, a default pen will be used.</para>
      </remarks>
      <param name="edge">
        <para>The edge for which the rendering will be used.</para>
      </param>
      <param name="canvas">
        <para>The canvas for which the pen shall be returned.</para>
      </param>
      <returns>
        <para>The pen instance to use for the rendering of the edge in the given context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.EdgeDecorationInstaller.GetBendDrawing(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that retrieves the drawing of the bend for the context.</para>
      </summary>
      <remarks>
        <para>This implementation will use the <see cref="F:yWorks.Controls.EdgeSelectionIndicatorInstaller.BendTemplateKey" /> resource to find a <see cref="T:yWorks.Controls.TemplateVisual" /> instance. If <c>null</c> is yielded, a default drawing will be used.</para>
      </remarks>
      <param name="canvas">
        <para>The canvas for which the drawing shall be returned.</para>
      </param>
      <param name="edge">
        <para>The edge for which the rendering will be used.</para>
      </param>
      <returns>
        <para>The drawing instance to use for the rendering of the bends in the given context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.EdgeDecorationInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">
      <summary>
        <para>Installs a rendering for the <paramref name="item" /> if it is an <see cref="T:yWorks.Graph.IEdge" /> that will use the <see cref="M:yWorks.Controls.EdgeDecorationInstaller.GetBendDrawing(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)" /> and <see cref="M:yWorks.Controls.EdgeDecorationInstaller.GetPen(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)" /> to render the path and bends.</para>
      </summary>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="group">
        <para>The <see cref="T:yWorks.Controls.ICanvasObjectGroup" /> to add the new canvas object to.</para>
      </param>
      <param name="item">
        <para>The item to install.</para>
      </param>
      <returns>
        <para>The canvas object representing the item.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.EdgeSelectionIndicatorInstaller">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.Controls.ICanvasObjectInstaller" /> interface that can install the selection outline of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </summary>
      <remarks>
        <para>This will <see cref="M:yWorks.Controls.EdgeDecorationInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">install</see> an <see cref="T:yWorks.Controls.ICanvasObject" /> that will render the path and the bends of an edge using a <see cref="M:yWorks.Controls.EdgeSelectionIndicatorInstaller.GetPen(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">pen</see> for the path and a <see cref="M:yWorks.Controls.EdgeSelectionIndicatorInstaller.GetBendDrawing(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">drawing</see> for the bends.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.EdgeSelectionIndicatorInstaller.PenKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:System.Drawing.Pen" /> that will be used to draw the path of the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.EdgeSelectionIndicatorInstaller.BendTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used to draw the bends of the edge.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.EdgeSelectionIndicatorInstaller.GetPen(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that retrieves the pen for the context.</para>
      </summary>
      <remarks>
        <para>This implementation will use the <see cref="F:yWorks.Controls.EdgeSelectionIndicatorInstaller.PenKey" /> resource to find a <see cref="T:System.Drawing.Pen" /> instance. If <c>null</c> is yielded, a default pen will be used.</para>
      </remarks>
      <param name="edge">
        <para>The edge for which the rendering will be used.</para>
      </param>
      <param name="canvas">
        <para>The canvas for which the pen shall be returned.</para>
      </param>
      <returns>
        <para>The pen instance to use for the rendering of the edge in the given context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.EdgeSelectionIndicatorInstaller.GetBendDrawing(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that retrieves the drawing of the bend for the context.</para>
      </summary>
      <remarks>
        <para>This implementation will use the <see cref="F:yWorks.Controls.EdgeSelectionIndicatorInstaller.BendTemplateKey" /> resource to find a <see cref="T:yWorks.Controls.TemplateVisual" /> instance. If <c>null</c> is yielded, a default drawing will be used.</para>
      </remarks>
      <param name="canvas">
        <para>The canvas for which the drawing shall be returned.</para>
      </param>
      <param name="edge">
        <para>The edge for which the rendering will be used.</para>
      </param>
      <returns>
        <para>The drawing instance to use for the rendering of the bends in the given context.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.EdgeFocusIndicatorInstaller">
      <summary>
        <para>An specialized subclass of the <see cref="T:yWorks.Controls.EdgeSelectionIndicatorInstaller" /> that can install the focus indicator of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </summary>
      <remarks>
        <para>This will <see cref="M:yWorks.Controls.EdgeDecorationInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">install</see> an <see cref="T:yWorks.Controls.ICanvasObject" /> that will render the path and the bends of an edge using a <see cref="M:yWorks.Controls.EdgeFocusIndicatorInstaller.GetPen(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">pen</see> for the path and a <see cref="M:yWorks.Controls.EdgeFocusIndicatorInstaller.GetBendDrawing(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">drawing</see> for the bends.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.EdgeFocusIndicatorInstaller.PenKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:System.Drawing.Pen" /> that will be used to draw the path of the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.EdgeFocusIndicatorInstaller.BendTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used to draw the bends of the edge.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.EdgeFocusIndicatorInstaller.GetPen(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that retrieves the pen for the context.</para>
      </summary>
      <remarks>
        <para>This implementation will use the <see cref="F:yWorks.Controls.EdgeFocusIndicatorInstaller.PenKey" /> resource to find a <see cref="T:System.Drawing.Pen" /> instance. If <c>null</c> is yielded, a default pen will be used.</para>
      </remarks>
      <param name="edge">
        <para>The edge for which the rendering will be used.</para>
      </param>
      <param name="canvas">
        <para>The canvas for which the pen shall be returned.</para>
      </param>
      <returns>
        <para>The pen instance to use for the rendering of the edge in the given context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.EdgeFocusIndicatorInstaller.GetBendDrawing(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that retrieves the drawing of the bend for the context.</para>
      </summary>
      <remarks>
        <para>This implementation will use the <see cref="F:yWorks.Controls.EdgeFocusIndicatorInstaller.BendTemplateKey" /> resource to find a <see cref="T:yWorks.Controls.TemplateVisual" /> instance. If <c>null</c> is yielded, a default drawing will be used.</para>
      </remarks>
      <param name="canvas">
        <para>The canvas for which the drawing shall be returned.</para>
      </param>
      <param name="edge">
        <para>The edge for which the rendering will be used.</para>
      </param>
      <returns>
        <para>The drawing instance to use for the rendering of the bends in the given context.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.EdgeHighlightIndicatorInstaller">
      <summary>
        <para>An specialized subclass of the <see cref="T:yWorks.Controls.EdgeSelectionIndicatorInstaller" /> that can install the highlight rendering of an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </summary>
      <remarks>
        <para>This will <see cref="M:yWorks.Controls.EdgeDecorationInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">install</see> an <see cref="T:yWorks.Controls.ICanvasObject" /> that will render the path and the bends of an edge using a <see cref="M:yWorks.Controls.EdgeHighlightIndicatorInstaller.GetPen(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">pen</see> for the path and a <see cref="M:yWorks.Controls.EdgeHighlightIndicatorInstaller.GetBendDrawing(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">drawing</see> for the bends.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.EdgeHighlightIndicatorInstaller.PenKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:System.Drawing.Pen" /> that will be used to draw the path of the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.EdgeHighlightIndicatorInstaller.BendTemplateKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey" /> that will be used to find the <see cref="T:yWorks.Controls.TemplateVisual" /> that will be used to draw the bends of the edge.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.EdgeHighlightIndicatorInstaller.GetPen(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that retrieves the pen for the context.</para>
      </summary>
      <remarks>
        <para>This implementation will use the <see cref="F:yWorks.Controls.EdgeHighlightIndicatorInstaller.PenKey" /> resource to find a <see cref="T:System.Drawing.Pen" /> instance. If <c>null</c> is yielded, a default pen will be used.</para>
      </remarks>
      <param name="edge">
        <para>The edge for which the rendering will be used.</para>
      </param>
      <param name="canvas">
        <para>The canvas for which the pen shall be returned.</para>
      </param>
      <returns>
        <para>The pen instance to use for the rendering of the edge in the given context.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.EdgeHighlightIndicatorInstaller.GetBendDrawing(yWorks.Controls.CanvasControl,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback method that retrieves the drawing of the bend for the context.</para>
      </summary>
      <remarks>
        <para>This implementation will use the <see cref="F:yWorks.Controls.EdgeHighlightIndicatorInstaller.BendTemplateKey" /> resource to find a <see cref="T:yWorks.Controls.TemplateVisual" /> instance. If <c>null</c> is yielded, a default drawing will be used.</para>
      </remarks>
      <param name="canvas">
        <para>The context for which the drawing shall be returned.</para>
      </param>
      <param name="edge">
        <para>The edge for which the rendering will be used.</para>
      </param>
      <returns>
        <para>The drawing instance to use for the rendering of the bends in the given context.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.EdgeStyleBase`1">
      <summary>
        <para>An abstract base class that makes it possible to easily implement a custom <see cref="T:yWorks.Graph.Styles.IEdgeStyle" />.</para>
      </summary>
      <remarks>
        <para>The only method that needs to be implemented by subclasses is <see cref="M:yWorks.Graph.Styles.EdgeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IEdge)" />, however to improve rendering performance it is highly recommended to implement at least <see cref="M:yWorks.Graph.Styles.EdgeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IEdge)" />, too.</para>
        <para>This implementation differs from the straightforward <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> implementation in that there is no visible separation between the style and its <see cref="T:yWorks.Graph.Styles.IEdgeStyleRenderer" />. Instead the renderer used by the base class is fixed and delegates all calls back to the style instance.</para>
      </remarks>
      <typeparam name="TVisual">
        <para>The type of the visual this instance will create. Subclasses will probably declare a fixed type to make the implementation of <see cref="M:yWorks.Graph.Styles.EdgeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IEdge)" /> and <see cref="M:yWorks.Graph.Styles.EdgeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IEdge)" /> more convenient.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.EdgeStyleBase`1" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.EdgeStyleBase`1.Renderer">
      <summary>
        <para>Gets the renderer implementation for this instance.</para>
      </summary>
      <remarks>
        <para>The private implementation will delegate all API calls back to this instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback that creates the visual.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.EdgeStyleBase`1.Renderer" />.</para>
      </remarks>
      <param name="context">
        <para>The render context.</para>
      </param>
      <param name="edge">
        <para>The edge to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual as required by the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> interface.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.EdgeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IEdge)" />
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IEdge)">
      <summary>
        <para>Callback that updates the visual previously created by <see cref="M:yWorks.Graph.Styles.EdgeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IEdge)" />.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.EdgeStyleBase`1.Renderer" />. This implementation simply delegates to <see cref="M:yWorks.Graph.Styles.EdgeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IEdge)" /> so subclasses should override to improve rendering performance.</para>
      </remarks>
      <param name="context">
        <para>The render context.</para>
      </param>
      <param name="oldVisual">
        <para>The visual that has been created in the call to <see cref="M:yWorks.Graph.Styles.EdgeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IEdge)" />.</para>
      </param>
      <param name="edge">
        <para>The edge to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual as required by the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> interface.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.EdgeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IEdge)" />
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.IEdge)">
      <summary>
        <para>Gets the bounds of the visual for the edge in the given context.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IBoundsProvider.GetBounds(yWorks.Controls.ICanvasContext)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.EdgeStyleBase`1.Renderer" />. This implementation simply yields a <see cref="T:yWorks.Geometry.RectD">rectangle</see> containing. the locations of the <see cref="P:yWorks.Graph.IEdge.SourcePort">source port</see> and the <see cref="P:yWorks.Graph.IEdge.TargetPort">target port</see> of the edge and the locations of all its <see cref="P:yWorks.Graph.IEdge.Bends">bends</see>.</para>
      </remarks>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="edge">
        <para>The edge to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual bounds of the visual representation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD,yWorks.Graph.IEdge)">
      <summary>
        <para>Determines whether the visualization for the specified edge is visible in the context.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisibilityTestable.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.EdgeStyleBase`1.Renderer" />. This implementation simply tests whether the <see cref="M:yWorks.Graph.Styles.EdgeStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.IEdge)">bounds</see> intersect the clip.</para>
      </remarks>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="rectangle">
        <para>The clipping rectangle.</para>
      </param>
      <param name="edge">
        <para>The edge to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified edge is visible in the clipping rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Graph.IEdge)">
      <summary>
        <para>Determines whether the visual representation of the edge has been hit at the given location.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.EdgeStyleBase`1.Renderer" />.</para>
        <para>This implementation returns the result of the <see cref="M:yWorks.Geometry.PointD.HitsPolyline(System.Collections.Generic.IEnumerable{yWorks.Geometry.IPoint},System.Double)" /> method of class <see cref="T:yWorks.Geometry.PointD" /> with the polygonal line defined by the source port, the target port and the bends of the edge and the <see cref="P:yWorks.Controls.ICanvasContext.HitTestRadius" /> of the <see cref="T:yWorks.Controls.ICanvasContext">canvas context</see>.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="location">
        <para>The point to test.</para>
      </param>
      <param name="edge">
        <para>The edge to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified edge representation is hit; <c>false</c> otherwise.</para>
      </returns>
      <seealso cref="M:yWorks.Geometry.PointD.HitsPolyline(System.Collections.Generic.IEnumerable{yWorks.Geometry.IPoint},System.Double)" />
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Graph.IEdge)">
      <summary>
        <para>Determines whether the visualization for the specified edge is included in the marquee selection.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.Input.IMarqueeTestable.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.EdgeStyleBase`1.Renderer" />.</para>
        <para>This implementation returns the result of the <see cref="M:yWorks.Geometry.RectD.IntersectsPolyline(System.Collections.Generic.IEnumerable{yWorks.Geometry.IPoint})" /> method of class <see cref="T:yWorks.Geometry.RectD" /> with the polygonal line defined by the source port, the target port and the bends of the edge.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="rectangle">
        <para>The marquee selection box.</para>
      </param>
      <param name="edge">
        <para>The edge to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified edge is visible is selected by the marquee rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.Lookup(yWorks.Graph.IEdge,System.Type)">
      <summary>
        <para>Performs the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> operation for the <see cref="M:yWorks.Graph.Styles.IEdgeStyleRenderer.GetContext(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" /> that has been queried from the <see cref="P:yWorks.Graph.Styles.EdgeStyleBase`1.Renderer" />.</para>
      </summary>
      <remarks>
        <para>This implementation yields <c>null</c> for everything but:</para>
        <list type="bullet">
          <item>
            <see cref="T:yWorks.Controls.Input.IHitTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IVisualCreator" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IBoundsProvider" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IVisibilityTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.Input.IMarqueeTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Graph.ILookup" />
          </item>
          <item>
            <see cref="T:yWorks.Graph.Styles.IPathGeometry" />
          </item>
        </list>
        <para>For these interfaces an implementation will be returned that delegates to the methods in this instance.</para>
      </remarks>
      <param name="edge">
        <para>The edge to use for the context lookup.</para>
      </param>
      <param name="type">
        <para>The type to query.</para>
      </param>
      <returns>
        <para>An implementation of the <paramref name="type" /> or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.Clone">
      <summary>
        <para>Creates a new object that is a copy of the current instance.</para>
      </summary>
      <remarks>
        <para>Immutable subclasses should consider returning <c>this</c>.</para>
      </remarks>
      <returns>
        <para>A new object that is a copy of this instance using <see cref="M:System.Object.MemberwiseClone" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.GetTangent(yWorks.Graph.IEdge,System.Double)">
      <summary>
        <para>Gets the tangent to the edge at the specified ratio and the corresponding touch point.</para>
      </summary>
      <param name="edge">
        <para>The edge.</para>
      </param>
      <param name="ratio">
        <para>A value between 0 and 1 inclusively that indicates a ratio from the beginning to the end of the path of the edge.</para>
      </param>
      <returns>
        <para>The tangent, if any exists.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.GetTangent(yWorks.Graph.IEdge,System.Int32,System.Double)">
      <summary>
        <para>Gets the tangent to the edge at the specified ratio of a segment of the edge and the corresponding touch point.</para>
      </summary>
      <param name="edge">
        <para>The edge.</para>
      </param>
      <param name="segmentIndex">
        <para>Index of the segment of the edge.</para>
      </param>
      <param name="ratio">
        <para>A value between 0 and 1 inclusively that indicates a ratio from the beginning to the end of the segment of the edge.</para>
      </param>
      <returns>
        <para>The tangent, if any exists.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.GetPath(yWorks.Graph.IEdge)">
      <summary>
        <para>Gets the path of the edge.</para>
      </summary>
      <param name="edge">
        <para>The edge.</para>
      </param>
      <returns>
        <para>The path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.GetSegmentCount(yWorks.Graph.IEdge)">
      <summary>
        <para>Gets the number of segments of the edge.</para>
      </summary>
      <param name="edge">
        <para>The edge.</para>
      </param>
      <returns>
        <para>The segment count.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.GetTargetArrowAnchor(yWorks.Geometry.GeneralPath,yWorks.Graph.Styles.IArrow)">
      <summary>
        <para>Convenience method that calculates the target arrow anchor and direction for a a given arrow and path.</para>
      </summary>
      <param name="path">
        <para>The path of the edge.</para>
      </param>
      <param name="arrow">
        <para>The arrow.</para>
      </param>
      <returns>
        <para>The anchor and directional vector of the arrow, if any exist.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.GetSourceArrowAnchor(yWorks.Geometry.GeneralPath,yWorks.Graph.Styles.IArrow)">
      <summary>
        <para>Convenience method that calculates the source arrow anchor and direction for a a given arrow and path.</para>
      </summary>
      <param name="path">
        <para>The path of the edge.</para>
      </param>
      <param name="arrow">
        <para>The arrow.</para>
      </param>
      <returns>
        <para>The anchor and directional vector of the arrow, if any exist.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.CropPath(yWorks.Graph.IEdge,yWorks.Graph.Styles.IArrow,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)">
      <summary>
        <para>Convenience method that crops the edge's path at the nodes.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="T:yWorks.Graph.Styles.IEdgePathCropper" /> instances found in the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the source and target port of the edge to perform the actual cropping.</para>
      </remarks>
      <param name="edge">
        <para>The edge that is being rendered.</para>
      </param>
      <param name="path">
        <para>The path that should be cropped.</para>
      </param>
      <param name="sourceArrow">
        <para>The source arrow instance.</para>
      </param>
      <param name="targetArrow">
        <para>The target arrow instance.</para>
      </param>
      <returns>
        <para>The cropped path. This is can be either the same instance of the given path or a newly created instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.AddArrows(yWorks.Controls.IRenderContext,yWorks.Controls.VisualGroup,yWorks.Graph.IEdge,yWorks.Geometry.GeneralPath,yWorks.Graph.Styles.IArrow,yWorks.Graph.Styles.IArrow)">
      <summary>
        <para>Convenience method that renders the arrows to in a given <see cref="T:System.Drawing.Graphics" /> context.</para>
      </summary>
      <param name="context">
        <para>The context for the rendering.</para>
      </param>
      <param name="group">
        <para>The <see cref="T:yWorks.Controls.VisualGroup" /> to add the arrow <see cref="T:yWorks.Controls.IVisual" />s to.</para>
      </param>
      <param name="edge">
        <para>The edge that is being rendered.</para>
      </param>
      <param name="edgePath">
        <para>The edge path.</para>
      </param>
      <param name="sourceArrow">
        <para>The source arrow.</para>
      </param>
      <param name="targetArrow">
        <para>The target arrow.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Styles.EdgeStyleBase`1.UpdateArrows(yWorks.Controls.IRenderContext,yWorks.Controls.VisualGroup,yWorks.Graph.IEdge,yWorks.Geometry.GeneralPath,yWorks.Graph.Styles.IArrow,yWorks.Graph.Styles.IArrow)">
      <summary>
        <para>Convenience method that updates the arrows in a given container.</para>
      </summary>
      <param name="context">
        <para>The context for the rendering.</para>
      </param>
      <param name="group">
        <para>The container to which the arrows should be added.</para>
      </param>
      <param name="edge">
        <para>The edge that is being rendered.</para>
      </param>
      <param name="edgePath">
        <para>The edge path.</para>
      </param>
      <param name="sourceArrow">
        <para>The source arrow.</para>
      </param>
      <param name="targetArrow">
        <para>The target arrow.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.EdgeStyleDecorationInstaller">
      <summary>
        <para>Allows the use of an <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> to render the selection, highlight or focus indicator of edges.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Controls.EdgeStyleDecorationInstaller.ZoomPolicy" /> property defines how the zoom level affects the rendering of the indicator. It can either scale according to the zoom level similar to regular graph items or have always to same thickness regardless of the zoom, similar to the default yFiles indicators.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.NodeStyleDecorationInstaller" />
      <seealso cref="T:yWorks.Controls.LabelStyleDecorationInstaller" />
    </member>
    <member name="M:yWorks.Controls.EdgeStyleDecorationInstaller.#ctor">
      <summary>
        <para>Create a new instance of this class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.EdgeStyleDecorationInstaller.ZoomPolicy">
      <summary>
        <para>Gets or sets how the style is affected by the current zoom level.</para>
      </summary>
      <remarks>
        <para>Changes of the value of this property are propagated to all styles created by this instance and become immediately visible.</para>
        <para>The default value is <see cref="F:yWorks.Controls.StyleDecorationZoomPolicy.ViewCoordinates" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.EdgeStyleDecorationInstaller.EdgeStyle">
      <summary>
        <para>Gets or sets the style to use for the rendering.</para>
      </summary>
      <remarks>
        <para>Changes of the value of this property are <b>not</b> propagated to already created styles.</para>
        <para>The default value is an instance of <see cref="T:yWorks.Graph.Styles.PolylineEdgeStyle" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.EdgeStyleDecorationInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">
      <summary>
        <para>Installs a rendering for the <paramref name="item" /> if it is an <see cref="T:yWorks.Graph.IEdge" />.</para>
      </summary>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="group">
        <para>The canvas object group to add the newly created <see cref="T:yWorks.Controls.ICanvasObject" /> to.</para>
      </param>
      <param name="item">
        <para>The item to install.</para>
      </param>
      <returns>
        <para>The canvas object representing the item.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.GeneralPathNodeStyle">
      <summary>
        <para>A node style that can display node shapes with a boundary that is defined by a <see cref="T:yWorks.Geometry.GeneralPath" /> instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyle.#ctor">
      <summary>
        <para>Creates a new instance using a simple rectangular path and <see cref="T:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer" /> as renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyle.#ctor(yWorks.Geometry.GeneralPath,yWorks.Graph.Styles.GeneralPathNodeStyleRenderer)">
      <summary>
        <para>Creates a new instance using the specified path and a custom renderer instance.</para>
      </summary>
      <param name="path">
        <para>The path that defines the boundary of this style.</para>
      </param>
      <param name="renderer">
        <para>Custom renderer instance for this style</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.GeneralPathNodeStyle.NormalizeBrushes">
      <summary>
        <para>Gets or sets whether to normalize the brush.</para>
      </summary>
      <remarks>
        <para>Applies a matrix on non-<see cref="T:System.Drawing.SolidBrush" />es to ensure that e.g. gradients are stretched over the entire node.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.GeneralPathNodeStyle.Path">
      <summary>
        <para>Get or sets the path that defines the boundary of the shape.</para>
      </summary>
      <remarks>
        <para>The path must be defined in such a way that &lt;0,0&gt; will be at the top left of a node's <see cref="P:yWorks.Graph.INode.Layout" /> and &lt;1,1&gt; will be at the lower right. The path will be scaled accordingly during the painting.</para>
        <para>The default is a simple rectangular path.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.GeneralPathNodeStyle.Brush">
      <summary>
        <para>Gets or sets the <see cref="T:System.Drawing.Brush" /> that is used to draw the shape.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="P:System.Drawing.Brushes.White" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.GeneralPathNodeStyle.Pen">
      <summary>
        <para>Gets or sets the <see cref="T:System.Drawing.Pen" /> that is used to draw the shape.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="P:System.Drawing.Pens.Black" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyle.Clone" />
    <member name="T:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer">
      <summary>
        <para>An <see cref="T:yWorks.Graph.Styles.INodeStyleRenderer" /> implementation that can handle <see cref="T:yWorks.Graph.Styles.GeneralPathNodeStyle" /> instances.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node">
      <summary>
        <para>Gets or sets the currently configured node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the <see cref="T:yWorks.Controls.IVisualCreator" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query hit test with. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="node">
        <para>The node to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="node">
        <para>The node to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Lookup(System.Type)">
      <summary>
        <para>Implements the <see cref="T:yWorks.Graph.ILookup" /> interface.</para>
      </summary>
      <remarks>
        <para>This method will be used by default if <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> has been queried for a lookup implementation. Note that it cannot be assumed that <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" /> has already been invoked. However, normally <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node" /> and <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style" /> will be correctly configured if invoked directly after <c>GetContext</c>. Subclass implementations should make sure to configure this instance before they return <c>this</c> as a result of a successful lookup. This implementation will check if <c>type.IsInstanceOfType(this)</c> and will call <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" /> on success and return <c>this</c>.</para>
      </remarks>
      <param name="type">
        <para>The type to query for.</para>
      </param>
      <returns>
        <para>An implementation or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Determines visibility by checking for an intersection with the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Layout" />.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="rectangle">
        <para>The current clip</para>
      </param>
      <returns>
        <para>Whether the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Layout" /> is visible in the clip.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node" /> properties, calls <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the shape geometry for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Layout">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.INode.Layout" /> of the node this renderer is currently configured for.</para>
      </summary>
      <remarks>
        <para>Returns <c>Node.Layout</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer" /> class.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and node have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.Node" /> properties have been populated by the <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, or <see cref="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> methods.</para>
        <para>This is an empty implementation. Subclasses might have to override this method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.NormalizeBrushes">
      <summary>
        <para>Determines whether brushes should be normalized.</para>
      </summary>
      <returns>
        <para>
          <see cref="P:yWorks.Graph.Styles.GeneralPathNodeStyle.NormalizeBrushes" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="inner" />
      <param name="outer" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)">
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.GeneralPathNodeStyleRenderer.GetOutline" />
    <member name="T:yWorks.Graph.Styles.IEdgePathCropper">
      <summary>
        <para>Interface used by the framework mainly for calculating the visible path of an edge.</para>
      </summary>
      <remarks>
        <para>This interface is queried through the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of <see cref="T:yWorks.Graph.IPort" /> instances to calculate the visible portion of an edge path.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.IEdgePathCropper.CropEdgePath(yWorks.Graph.IEdge,System.Boolean,yWorks.Graph.Styles.IArrow,yWorks.Geometry.GeneralPath)">
      <summary>
        <para>Crops the provided <paramref name="path" /> at one end of an edge.</para>
      </summary>
      <param name="edge">
        <para>The edge whose path is to be cropped.</para>
      </param>
      <param name="atSource">
        <para>Whether to crop the source or target side of the path.</para>
      </param>
      <param name="arrow">
        <para>The arrow that is used at the end of the edge.</para>
      </param>
      <param name="path">
        <para>The path to crop.</para>
      </param>
      <returns>
        <para>The cropped path. This is can be either the same instance of the given path or a newly created instance.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.IGroupBoundsCalculator">
      <summary>
        <para>Interface for implementations that can calculate the bounds of a group node in a grouped graph.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface will be queried from <see cref="T:yWorks.Graph.INode" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.IGroupBoundsCalculator.CalculateBounds(yWorks.Graph.IGraph,yWorks.Graph.INode)">
      <summary>
        <para>Calculates the bounds of the <see cref="P:yWorks.Graph.INode.Layout" /> for the given <paramref name="groupNode" /> that is a group node in the <paramref name="graph" />.</para>
      </summary>
      <param name="graph">
        <para>The graph which holds the <paramref name="groupNode" />.</para>
      </param>
      <param name="groupNode">
        <para>The node to calculate the bounds for.</para>
      </param>
      <returns>
        <para>The minimum bounds to use for the given group node.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.VoidLabelStyle">
      <summary>
        <para>A void implementation of a label style that does nothing and behaves like an invisible style.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidLabelStyle.Instance" /> of this class instead of <c>null</c> where <c>null</c> is not allowed. For example you cannot assign <c>null</c> to the <see cref="P:yWorks.Graph.ILabel.Style" /> property of an <see cref="T:yWorks.Graph.ILabel" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidLabelStyle.Instance">
      <summary>
        <para>The singleton instance of this style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.VoidLabelStyle.Renderer">
      <summary>
        <para>Gets the <see cref="F:yWorks.Graph.Styles.VoidLabelStyleRenderer.Instance">VoidLabelStyleRenderer instance</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Graph.Styles.ILabelStyle.Renderer">ILabelStyle.Renderer</seealso>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidLabelStyle.Clone">
      <summary>
        <para>Returns <c>this</c>.</para>
      </summary>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.VoidLabelStyleRenderer">
      <summary>
        <para>A void implementation of a label style renderer that does nothing.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidLabelStyleRenderer.Instance" /> of this class instead of <c>null</c> where <c>null</c> is not allowed. For example you cannot assign <c>null</c> to the <see cref="P:yWorks.Graph.Styles.ILabelStyle.Renderer" /> property of an <see cref="T:yWorks.Graph.Styles.ILabelStyle" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidLabelStyleRenderer.Instance">
      <summary>
        <para>The singleton instance of this renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidLabelStyleRenderer.GetPreferredSize(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Yields <see cref="F:yWorks.Geometry.SizeD.Empty" />.</para>
      </summary>
      <param name="label" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidLabelStyleRenderer.GetVisualCreator(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.VoidVisualCreator.Instance" /> that will do nothing.</para>
      </summary>
      <param name="label" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidLabelStyleRenderer.GetBoundsProvider(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.BoundsProviders.Empty" /> that will return empty bounds.</para>
      </summary>
      <param name="label" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidLabelStyleRenderer.GetVisibilityTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.VisibilityTestables.Never" /> that will always claim invisibility.</para>
      </summary>
      <param name="label" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidLabelStyleRenderer.GetHitTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.Input.HitTestables.Never" /> that will always report misses.</para>
      </summary>
      <param name="label" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidLabelStyleRenderer.GetMarqueeTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.Input.MarqueeTestables.Never" /> that will always report misses.</para>
      </summary>
      <param name="label" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidLabelStyleRenderer.GetContext(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Graph.Lookups.Empty" /> that will not yield anything.</para>
      </summary>
      <param name="label" />
      <param name="style" />
    </member>
    <member name="T:yWorks.Graph.Styles.ILabelStyle">
      <summary>
        <para>Style implementation for <see cref="T:yWorks.Graph.ILabel" /> instances in an <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <remarks>
        <para>Implementations are responsible for rendering <see cref="T:yWorks.Graph.ILabel" /> instances in a <see cref="T:yWorks.Controls.CanvasControl" />. It is up to the implementation to interpret the visual appearance of a label. The framework uses the associated, possibly shared <see cref="P:yWorks.Graph.Styles.ILabelStyle.Renderer" /> to perform the actual rendering of this style for a given label. This interface extends the <see cref="T:System.ICloneable" /> interface. This allows clients to obtain a persistent copy of the current state of this style. Immutable style implementations may return themselves.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ILabelStyle.Renderer">
      <summary>
        <para>Gets the renderer implementation that can be queried for implementations that provide details about the visual appearance and visual behavior for a given label and this style instance.</para>
      </summary>
      <remarks>
        <para>The idiom for retrieving, e.g. an <see cref="T:yWorks.Controls.IVisualCreator" /> implementation for a given style is:</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.Styles.ILabelStyleRenderer">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.Styles.ILabelStyle" /> implementations to query the actual <see cref="T:yWorks.Controls.IVisualCreator" />, <see cref="T:yWorks.Controls.IVisibilityTestable" />, <see cref="T:yWorks.Controls.IBoundsProvider" />, <see cref="T:yWorks.Controls.Input.IHitTestable" />, and <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> implementations for a label and an associated style.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface should be designed to be sharable between multiple style instances and should therefore not contain style specific state.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.ILabelStyle" />
      <seealso cref="T:yWorks.Graph.ILabel" />
      <seealso cref="T:yWorks.Graph.Styles.INodeStyleRenderer" />
      <seealso cref="T:yWorks.Graph.Styles.IEdgeStyleRenderer" />
      <seealso cref="T:yWorks.Graph.Styles.IPortStyleRenderer" />
    </member>
    <member name="M:yWorks.Graph.Styles.ILabelStyleRenderer.GetPreferredSize(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Calculates the <see cref="P:yWorks.Graph.ILabel.PreferredSize">preferred size</see> of a given label using the associated style.</para>
      </summary>
      <param name="label">
        <para>The label to determine the preferred size for</para>
      </param>
      <param name="style">
        <para>The style instance that uses this instance as its <see cref="P:yWorks.Graph.Styles.ILabelStyle.Renderer" /></para>
      </param>
      <returns>
        <para>A size that can be used as the <see cref="P:yWorks.Graph.ILabel.PreferredSize" /> if this renderer paints the label using the associated style.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ILabelStyleRenderer.GetVisualCreator(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IVisualCreator" /> interface that can handle the provided label and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation, but never <c>null</c>.</para>
      </remarks>
      <param name="label">
        <para>The label to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the creation of the visual</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently create or update the visual for the label. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations. This method may not return <c>null</c> but should yield a <see cref="F:yWorks.Controls.VoidVisualCreator.Instance">void</see> implementation instead.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ILabelStyleRenderer.GetBoundsProvider(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IBoundsProvider" /> interface that can handle the provided label and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="label">
        <para>The label to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the calculating the painting bounds</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the label's painting bounds. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ILabelStyleRenderer.GetVisibilityTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IVisibilityTestable" /> interface that can handle the provided label and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="label">
        <para>The label to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the testing the visibility</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the label's visibility. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ILabelStyleRenderer.GetHitTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.Input.IHitTestable" /> interface that can handle the provided label and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="label">
        <para>The label to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the querying hit tests</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently perform hit tests. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations. This method may return <c>null</c> to indicate that the label cannot be hit tested.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ILabelStyleRenderer.GetMarqueeTestable(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> interface that can handle the provided label and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="label">
        <para>The label to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the querying marquee intersection test.</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the marquee intersections. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ILabelStyleRenderer.GetContext(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Gets a temporary context instance that can be used to query additional information for the label's style.</para>
      </summary>
      <remarks>
        <para>Implementations may return <see cref="F:yWorks.Graph.Lookups.Empty" /> if they don't support this, but may not return <c>null</c>.</para>
      </remarks>
      <param name="label">
        <para>The label to provide a context instance for.</para>
      </param>
      <param name="style">
        <para>The style to use for the context.</para>
      </param>
      <returns>
        <para>An non-<c>null</c> lookup implementation.</para>
      </returns>
      <seealso cref="F:yWorks.Graph.Lookups.Empty" />
      <seealso cref="T:yWorks.Graph.ILookup" />
    </member>
    <member name="T:yWorks.Controls.Input.INodeInsetsProvider">
      <summary>
        <para>Interface for implementations that yield insets for a given <see cref="T:yWorks.Graph.INode" />.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface will be queried from an <see cref="T:yWorks.Graph.INode" />'s <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method. The default implementation of a graph uses this instance by default to determine the insets of a group node.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.Input.INodeInsetsProvider.GetInsets(yWorks.Graph.INode)">
      <summary>
        <para>Returns the insets for the given <paramref name="node" />.</para>
      </summary>
      <param name="node">
        <para>The node to yield insets for.</para>
      </param>
      <returns>
        <para>The insets for the node.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.VoidShapeGeometry">
      <summary>
        <para>A void implementation of the <see cref="T:yWorks.Graph.Styles.IShapeGeometry" /> interface that does nothing and behaves like an empty geometry.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidShapeGeometry.Instance" /> of this class instead of <c>null</c> were <c>null</c> is not allowed. The <see cref="T:yWorks.Graph.Styles.VoidNodeStyleRenderer" /> does so for example.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidShapeGeometry.Instance">
      <summary>
        <para>The <see cref="T:yWorks.Graph.Styles.VoidShapeGeometry" /> singleton.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidShapeGeometry.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>This implementation always returns <c>null</c> (a <see cref="T:System.Nullable`1" /> with no value).</para>
      </summary>
      <param name="inner">
        <para>The first point of the line that is inside the shape.</para>
      </param>
      <param name="outer">
        <para>The second point of the line that is outside the shape.</para>
      </param>
      <returns>
        <para>A <see cref="T:System.Nullable`1" /> with no value.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IShapeGeometry.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">IShapeGeometry.GetIntersection</seealso>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidShapeGeometry.IsInside(yWorks.Geometry.PointD)">
      <summary>
        <para>This implementation always returns <c>false</c>.</para>
      </summary>
      <param name="location">
        <para>The point to test.</para>
      </param>
      <returns>
        <para>
          <c>false</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IShapeGeometry.IsInside(yWorks.Geometry.PointD)">IShapeGeometry.IsInside</seealso>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidShapeGeometry.GetOutline">
      <summary>
        <para>This implementation returns an empty path.</para>
      </summary>
      <remarks>
        <para>This means that the outline never intersects any line or contains any point.</para>
      </remarks>
      <returns>
        <para>The empty path.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IShapeGeometry.GetOutline">IShapeGeometry.GetOutline</seealso>
    </member>
    <member name="T:yWorks.Graph.Styles.VoidNodeStyle">
      <summary>
        <para>A void implementation of a node style that does nothing and behaves like an invisible style.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidNodeStyle.Instance" /> of this class instead of <c>null</c> where <c>null</c> is not allowed. For example you cannot assign <c>null</c> to the <see cref="P:yWorks.Graph.INode.Style" /> property of an <see cref="T:yWorks.Graph.INode" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidNodeStyle.Instance">
      <summary>
        <para>The <see cref="T:yWorks.Graph.Styles.VoidNodeStyle" /> singleton.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.VoidNodeStyle.Renderer">
      <summary>
        <para>Gets the <see cref="F:yWorks.Graph.Styles.VoidNodeStyleRenderer.Instance">VoidNodeStyleRenderer instance</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Graph.Styles.INodeStyle.Renderer">INodeStyle.Renderer</seealso>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidNodeStyle.Clone">
      <summary>
        <para>Returns <c>this</c>.</para>
      </summary>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.VoidNodeStyleRenderer">
      <summary>
        <para>A void implementation of a node style renderer that does nothing.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidNodeStyleRenderer.Instance" /> of this class instead of <c>null</c> where <c>null</c> is not allowed. For example you cannot assign <c>null</c> to the <see cref="P:yWorks.Graph.Styles.INodeStyle.Renderer" /> property of an <see cref="T:yWorks.Graph.Styles.INodeStyle" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidNodeStyleRenderer.Instance">
      <summary>
        <para>The <see cref="T:yWorks.Graph.Styles.VoidNodeStyleRenderer" /> singleton.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidNodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>This implementation always returns the <see cref="F:yWorks.Graph.Styles.VoidShapeGeometry.Instance">VoidShapeGeometry instance</see>.</para>
      </summary>
      <param name="node">
        <para>The node to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the painting</para>
      </param>
      <returns>
        <para>The <see cref="F:yWorks.Graph.Styles.VoidShapeGeometry.Instance">VoidShapeGeometry instance</see>.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.INodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">INodeStyleRenderer.GetShapeGeometry</seealso>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.VoidVisualCreator.Instance" /> that will do nothing.</para>
      </summary>
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.BoundsProviders.Empty" /> that will return empty bounds.</para>
      </summary>
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidNodeStyleRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.VisibilityTestables.Never" /> that will always claim invisibility.</para>
      </summary>
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.Input.HitTestables.Never" /> that will always report misses.</para>
      </summary>
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.Input.MarqueeTestables.Never" /> that will always report misses.</para>
      </summary>
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Graph.Lookups.Empty" /> that will not yield anything.</para>
      </summary>
      <param name="node" />
      <param name="style" />
    </member>
    <member name="T:yWorks.Graph.Styles.INodeStyle">
      <summary>
        <para>Style implementation for <see cref="T:yWorks.Graph.INode" /> instances in an <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <remarks>
        <para>Implementations are responsible for rendering <see cref="T:yWorks.Graph.INode" /> instances in a <see cref="T:yWorks.Controls.CanvasControl" />. It is up to the implementation to interpret the visual appearance of a node. The framework uses the associated, possibly shared <see cref="P:yWorks.Graph.Styles.INodeStyle.Renderer" /> to perform the actual rendering of this style for a given node. This interface extends the <see cref="T:System.ICloneable" /> interface. This allows clients to obtain a persistent copy of the current state of this style. Immutable style implementations may return themselves.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.INodeStyle.Renderer">
      <summary>
        <para>Gets the renderer implementation that can be queried for implementations that provide details about the visual appearance and visual behavior for a given node and this style instance.</para>
      </summary>
      <remarks>
        <para>The idiom for retrieving, e.g. an <see cref="T:yWorks.Controls.IVisualCreator" /> implementation for a given style is:</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.Styles.INodeStyleRenderer">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.Styles.INodeStyle" /> implementations that can be used to query the actual <see cref="T:yWorks.Controls.IVisualCreator" />, <see cref="T:yWorks.Controls.IBoundsProvider" />, <see cref="T:yWorks.Controls.Input.IHitTestable" />, and <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> implementations for a node and an associated style.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface should be designed to be sharable between multiple style instances and should therefore not contain style specific state.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.INodeStyle" />
      <seealso cref="T:yWorks.Graph.INode" />
      <seealso cref="T:yWorks.Graph.Styles.IEdgeStyleRenderer" />
      <seealso cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" />
      <seealso cref="T:yWorks.Graph.Styles.IPortStyleRenderer" />
    </member>
    <member name="M:yWorks.Graph.Styles.INodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Graph.Styles.IShapeGeometry" /> interface that can handle the provided node and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="node">
        <para>The node to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the painting</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query geometry information from. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.INodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IVisualCreator" /> interface that can handle the provided node and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation, but never <c>null</c>.</para>
      </remarks>
      <param name="node">
        <para>The node to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the creation of the visual</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently create or update the visual for the node. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations. This method may not return <c>null</c> but should yield a <see cref="F:yWorks.Controls.VoidVisualCreator.Instance">void</see> implementation instead.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.INodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IBoundsProvider" /> interface that can handle the provided node and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="node">
        <para>The node to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the calculating the painting bounds</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the node's painting bounds. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.INodeStyleRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IVisibilityTestable" /> interface that can handle the provided node and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="node">
        <para>The node to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the testing the visibility</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the node's visibility. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.INodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.Input.IHitTestable" /> interface that can handle the provided node and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="node">
        <para>The node to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the querying hit tests</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently perform hit tests. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations. This method may return <c>null</c> to indicate that the node cannot be hit tested.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.INodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> interface that can handle the provided node and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="node">
        <para>The node to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the querying marquee intersection test.</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the marquee intersections. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.INodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Gets a temporary context instance that can be used to query additional information for the node's style.</para>
      </summary>
      <remarks>
        <para>Implementations may return <see cref="F:yWorks.Graph.Lookups.Empty" /> if they don't support this, but may not return <c>null</c>.</para>
      </remarks>
      <param name="node">
        <para>The node to provide a context instance for.</para>
      </param>
      <param name="style">
        <para>The style to use for the context.</para>
      </param>
      <returns>
        <para>An non-<c>null</c> lookup implementation.</para>
      </returns>
      <seealso cref="F:yWorks.Graph.Lookups.Empty" />
      <seealso cref="T:yWorks.Graph.ILookup" />
    </member>
    <member name="T:yWorks.Graph.Styles.IPathGeometry">
      <summary>
        <para>Interface that is used mainly by <see cref="T:yWorks.Graph.Styles.IEdgeStyleRenderer" /> implementations to reveal geometric details about the visualization of an edge's path.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.IPathGeometry.GetTangent(System.Double)">
      <summary>
        <para>Calculates the tangent on the edge's path at the given ratio point.</para>
      </summary>
      <param name="ratio">
        <para>a value in [0,1] where 0 is the source's end and 1 is at the target's end of the visible edge path</para>
      </param>
      <returns>
        <para>The tangential line, if any exists.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IPathGeometry.GetTangent(System.Int32,System.Double)">
      <summary>
        <para>Calculates the tangent on the edge's path at the given ratio point for the given segment.</para>
      </summary>
      <param name="segmentIndex">
        <para>the segment to use for the calculation</para>
      </param>
      <param name="ratio">
        <para>a value in [0,1] where 0 is the source's end and 1 is at the target's end of the segment</para>
      </param>
      <returns>
        <para>The tangential line, if any exists.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.IPathGeometry.GetTangent(System.Double)" />
      <seealso cref="M:yWorks.Graph.Styles.IPathGeometry.GetSegmentCount" />
    </member>
    <member name="M:yWorks.Graph.Styles.IPathGeometry.GetSegmentCount">
      <summary>
        <para>Returns the number of "segments" this edge's path consists of.</para>
      </summary>
      <returns>
        <para>the number of segments or <c>-1</c> if there is no such thing as a segment for this edge.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IPathGeometry.GetPath">
      <summary>
        <para>Returns a representation of the visible path of the edge in form of a <see cref="T:yWorks.Geometry.GeneralPath" /></para>
      </summary>
      <returns>
        <para>An instance that describes the visible path or <c>null</c> if this is not applicable for the current geometry.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.VoidPortStyleRenderer">
      <summary>
        <para>A void implementation of a port style renderer that does nothing.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidPortStyleRenderer.Instance" /> of this class instead of <c>null</c> where <c>null</c> is not allowed. For example you cannot assign <c>null</c> to the <see cref="P:yWorks.Graph.Styles.IPortStyle.Renderer" /> property of an <see cref="T:yWorks.Graph.Styles.IPortStyle" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidPortStyleRenderer.Instance">
      <summary>
        <para>The <see cref="T:yWorks.Graph.Styles.VoidPortStyleRenderer" /> singleton.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidPortStyleRenderer.GetVisualCreator(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.VoidVisualCreator.Instance" /> that will do nothing.</para>
      </summary>
      <param name="port" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidPortStyleRenderer.GetBoundsProvider(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.BoundsProviders.Empty" /> that will return empty bounds.</para>
      </summary>
      <param name="port" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidPortStyleRenderer.GetVisibilityTestable(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.VisibilityTestables.Never" /> that will always claim invisibility.</para>
      </summary>
      <param name="port" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidPortStyleRenderer.GetHitTestable(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.Input.HitTestables.Never" /> that will always report misses.</para>
      </summary>
      <param name="port" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidPortStyleRenderer.GetMarqueeTestable(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.Input.MarqueeTestables.Never" /> that will always report misses.</para>
      </summary>
      <param name="port" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidPortStyleRenderer.GetContext(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Graph.Lookups.Empty" /> that will not yield anything.</para>
      </summary>
      <param name="port" />
      <param name="style" />
    </member>
    <member name="T:yWorks.Graph.Styles.VoidPortStyle">
      <summary>
        <para>A void implementation of a port style that does nothing and behaves like an invisible style.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidPortStyle.Instance" /> of this class instead of <c>null</c> where <c>null</c> is not allowed. For example you cannot assign <c>null</c> to the <see cref="P:yWorks.Graph.IPort.Style" /> property of an <see cref="T:yWorks.Graph.IPort" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidPortStyle.Instance">
      <summary>
        <para>The <see cref="T:yWorks.Graph.Styles.VoidPortStyle" /> singleton.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.VoidPortStyle.Renderer">
      <summary>
        <para>Gets the <see cref="F:yWorks.Graph.Styles.VoidPortStyleRenderer.Instance">VoidPortStyleRenderer instance</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Graph.Styles.IPortStyle.Renderer">IPortStyle.Renderer</seealso>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidPortStyle.Clone">
      <summary>
        <para>Returns <c>this</c>.</para>
      </summary>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.IPortStyle">
      <summary>
        <para>Style implementation for <see cref="T:yWorks.Graph.IPort" /> instances in an <see cref="T:yWorks.Graph.IGraph" />.</para>
      </summary>
      <remarks>
        <para>Implementations are responsible for rendering <see cref="T:yWorks.Graph.IPort" /> instances in a <see cref="T:yWorks.Controls.CanvasControl" />. It is up to the implementation to interpret the visual appearance of a port. The framework uses the associated, possibly shared <see cref="P:yWorks.Graph.Styles.IPortStyle.Renderer" /> to perform the actual rendering of this style for a given port. This interface extends the <see cref="T:System.ICloneable" /> interface. This allows clients to obtain a persistent copy of the current state of this style. Immutable style implementations may return themselves.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.IPortStyle.Renderer">
      <summary>
        <para>Gets the renderer implementation that can be queried for implementations that provide details about the visual appearance and visual behavior for a given port and this style instance.</para>
      </summary>
      <remarks>
        <para>The idiom for retrieving, e.g. an <see cref="T:yWorks.Controls.IVisualCreator" /> implementation for a given style is:</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.Styles.IPortStyleRenderer">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.Styles.IPortStyle" /> implementations that can be used to query the actual <see cref="T:yWorks.Controls.IVisualCreator" />, <see cref="T:yWorks.Controls.IBoundsProvider" />, <see cref="T:yWorks.Controls.Input.IHitTestable" />, <see cref="T:yWorks.Controls.IVisibilityTestable" />, and <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> implementations for a port and an associated style.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface should be designed to be sharable between multiple style instances and should therefore not contain style specific state.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.IPortStyle" />
      <seealso cref="T:yWorks.Graph.IPort" />
      <seealso cref="T:yWorks.Graph.Styles.INodeStyleRenderer" />
      <seealso cref="T:yWorks.Graph.Styles.IEdgeStyleRenderer" />
      <seealso cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" />
    </member>
    <member name="M:yWorks.Graph.Styles.IPortStyleRenderer.GetVisualCreator(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IVisualCreator" /> interface that can handle the provided port and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation, but never <c>null</c>.</para>
      </remarks>
      <param name="port">
        <para>The port to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the creation of the visual</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently create or update the visual for the port. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations. This method may not return <c>null</c> but should yield a <see cref="F:yWorks.Controls.VoidVisualCreator.Instance">void</see> implementation instead.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IPortStyleRenderer.GetBoundsProvider(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IBoundsProvider" /> interface that can handle the provided port and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="port">
        <para>The port to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the calculating the painting bounds</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the port's painting bounds. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IPortStyleRenderer.GetVisibilityTestable(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IVisibilityTestable" /> interface that can handle the provided port and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="port">
        <para>The port to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the testing the visibility</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the port's visibility. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IPortStyleRenderer.GetHitTestable(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.Input.IHitTestable" /> interface that can handle the provided port and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="port">
        <para>The port to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the querying hit tests</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently perform hit tests. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations. This method may return <c>null</c> to indicate that the port cannot be hit tested.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IPortStyleRenderer.GetMarqueeTestable(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.Input.IMarqueeTestable" /> interface that can handle the provided port and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation.</para>
      </remarks>
      <param name="port">
        <para>The port to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the querying marquee intersection test.</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently query the marquee intersections. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IPortStyleRenderer.GetContext(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)">
      <summary>
        <para>Gets a temporary context instance that can be used to query additional information for the port's style.</para>
      </summary>
      <remarks>
        <para>Implementations may return <see cref="F:yWorks.Graph.Lookups.Empty" /> if they don't support this, but may not return <c>null</c>.</para>
      </remarks>
      <param name="port">
        <para>The port to provide a context instance for.</para>
      </param>
      <param name="style">
        <para>The style to use for the context.</para>
      </param>
      <returns>
        <para>An non-<c>null</c> lookup implementation.</para>
      </returns>
      <seealso cref="F:yWorks.Graph.Lookups.Empty" />
      <seealso cref="T:yWorks.Graph.ILookup" />
    </member>
    <member name="T:yWorks.Graph.Styles.IShapeGeometry">
      <summary>
        <para>Interface that describes the geometry of a shape which has an interior and an exterior.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.IShapeGeometry.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Returns the intersection for the given line with this shape's geometry.</para>
      </summary>
      <param name="inner">
        <para>The first point of the line that is inside the shape.</para>
      </param>
      <param name="outer">
        <para>The second point of the line that is outside the shape.</para>
      </param>
      <returns>
        <para>The coordinates of the intersection point, if an intersection was found.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IShapeGeometry.IsInside(yWorks.Geometry.PointD)">
      <summary>
        <para>Checks whether the given coordinate is deemed to lie within the shape's geometric bounds.</para>
      </summary>
      <param name="location">
        <para>The point to test.</para>
      </param>
      <returns>
        <para>True if the point lies within the shape.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IShapeGeometry.GetOutline">
      <summary>
        <para>Returns the outline of the shape or <c>null</c>.</para>
      </summary>
      <returns>
        <para>The outline or <c>null</c> if no outline can be provided.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.IStripeStyle">
      <summary>
        <para>Style implementation for <see cref="T:yWorks.Graph.IStripe" /> instances in an <see cref="T:yWorks.Graph.ITable" />.</para>
      </summary>
      <remarks>
        <para>It is up to the implementation to interpret the visual appearance of a stripe. The framework uses the associated, possibly shared <see cref="P:yWorks.Graph.Styles.IStripeStyle.Renderer" /> to perform the actual rendering of this style for a given stripe. This interface extends the <see cref="T:System.ICloneable" /> interface. This allows clients to obtain a persistent copy of the current state of this style. Immutable style implementations may return themselves.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.IStripeStyle.Renderer">
      <summary>
        <para>Gets the renderer implementation that can be queried for implementations that provide details about the visual appearance and visual behavior for a given stripe and this style instance.</para>
      </summary>
      <remarks>
        <para>The idiom for retrieving, e.g. an <see cref="T:yWorks.Controls.IVisualCreator" /> implementation for a given stripe is:</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.Styles.IStripeStyleRenderer">
      <summary>
        <para>Interface used by <see cref="T:yWorks.Graph.Styles.IStripeStyle" /> implementations that can be used to query the actual <see cref="T:yWorks.Controls.IVisualCreator" /> implementation for a stripe and an associated style.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface should be designed to be sharable between multiple style instances and should therefore not contain style specific state.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.IStripeStyle" />
      <seealso cref="T:yWorks.Graph.IStripe" />
    </member>
    <member name="M:yWorks.Graph.Styles.IStripeStyleRenderer.GetVisualCreator(yWorks.Graph.IStripe,yWorks.Graph.Styles.IStripeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Controls.IVisualCreator" /> interface that can handle the provided stripe and its associated style.</para>
      </summary>
      <remarks>
        <para>This method may return a flyweight implementation, but never <c>null</c>.</para>
      </remarks>
      <param name="stripe">
        <para>The nstripeode to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the creation of the visual</para>
      </param>
      <returns>
        <para>An implementation that may be used to subsequently create or update the visual for the stripe. Clients should not cache this instance and must always call this method immediately before using the value returned. This enables the use of the flyweight design pattern for implementations. This method may not return <c>null</c> but should yield a <see cref="F:yWorks.Controls.VoidVisualCreator.Instance">void</see> implementation instead.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.IStripeStyleRenderer.GetContext(yWorks.Graph.IStripe,yWorks.Graph.Styles.IStripeStyle)">
      <summary>
        <para>Gets a temporary context instance that can be used to query additional information for the stripe's style.</para>
      </summary>
      <remarks>
        <para>Implementations may return <see cref="F:yWorks.Graph.Lookups.Empty" /> if they don't support this, but may not return <c>null</c>.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe to provide a context instance for.</para>
      </param>
      <param name="style">
        <para>The style to use for the context.</para>
      </param>
      <returns>
        <para>An non-<c>null</c> lookup implementation.</para>
      </returns>
      <seealso cref="F:yWorks.Graph.Lookups.Empty" />
      <seealso cref="T:yWorks.Graph.ILookup" />
    </member>
    <member name="T:yWorks.Graph.Styles.VoidStripeStyle">
      <summary>
        <para>A void implementation of a stripe style that does nothing and behaves like an invisible style.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidStripeStyle.Instance" /> of this class instead of <c>null</c> where <c>null</c> is not allowed. For example you cannot assign <c>null</c> to the <see cref="P:yWorks.Graph.IStripe.Style" /> property of an <see cref="T:yWorks.Graph.IStripe" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidStripeStyle.Instance">
      <summary>
        <para>The <see cref="T:yWorks.Graph.Styles.VoidStripeStyle" /> singleton.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.VoidStripeStyle.Renderer">
      <summary>
        <para>Gets the <see cref="F:yWorks.Graph.Styles.VoidStripeStyleRenderer.Instance">VoidStripeStyleRenderer instance</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Graph.Styles.IStripeStyle.Renderer">IStripeStyle.Renderer</seealso>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidStripeStyle.Clone">
      <summary>
        <para>Returns <c>this</c>.</para>
      </summary>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.VoidStripeStyleRenderer">
      <summary>
        <para>A void implementation of a stripe style renderer that does nothing.</para>
      </summary>
      <remarks>
        <para>This class implements the singleton pattern. Use the shared static <see cref="F:yWorks.Graph.Styles.VoidStripeStyleRenderer.Instance" /> of this class instead of <c>null</c> where <c>null</c> is not allowed. For example you cannot assign <c>null</c> to the <see cref="P:yWorks.Graph.Styles.IStripeStyle.Renderer" /> property of an <see cref="T:yWorks.Graph.Styles.IStripeStyle" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Graph.Styles.VoidStripeStyleRenderer.Instance">
      <summary>
        <para>The <see cref="T:yWorks.Graph.Styles.VoidStripeStyleRenderer" /> singleton.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.VoidStripeStyleRenderer.GetVisualCreator(yWorks.Graph.IStripe,yWorks.Graph.Styles.IStripeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Controls.VoidVisualCreator.Instance" /> that will do nothing.</para>
      </summary>
      <param name="stripe" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.VoidStripeStyleRenderer.GetContext(yWorks.Graph.IStripe,yWorks.Graph.Styles.IStripeStyle)">
      <summary>
        <para>Yields the <see cref="F:yWorks.Graph.Lookups.Empty" /> that will not yield anything.</para>
      </summary>
      <param name="stripe" />
      <param name="style" />
    </member>
    <member name="T:yWorks.Controls.ImageVisual">
      <summary>
        <para>Draws an image in a specific location and size.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ImageVisual.Image">
      <summary>
        <para>Gets or sets the image to draw.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ImageVisual.Rectangle">
      <summary>
        <para>Gets or sets the bounds into which the image is drawn.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ImageVisual.InterpolationMode">
      <summary>
        <para>Gets or sets the interpolation mode to draw the image.</para>
      </summary>
      <remarks>
        <para>Setting this to <see cref="F:System.Drawing.Drawing2D.InterpolationMode.Invalid" /> will use the current interpolation mode of the <see cref="T:System.Drawing.Graphics" /> when drawing. This is also the default value.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.ImageVisual.#ctor">
      <summary>
        <para>Creates a new visual with no image and <see cref="P:yWorks.Controls.ImageVisual.InterpolationMode" /> set to <see cref="F:System.Drawing.Drawing2D.InterpolationMode.Invalid" /></para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ImageVisual.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <param name="context" />
      <param name="g" />
    </member>
    <member name="T:yWorks.Graph.Styles.LabelStyleBase`1">
      <summary>
        <para>An abstract base class that makes it possible to easily implement a custom <see cref="T:yWorks.Graph.Styles.ILabelStyle" />.</para>
      </summary>
      <remarks>
        <para>Only <see cref="M:yWorks.Graph.Styles.LabelStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.ILabel)" /> and <see cref="M:yWorks.Graph.Styles.LabelStyleBase`1.GetPreferredSize(yWorks.Graph.ILabel)" /> need to be implemented by subclasses, however to improve rendering performance it is highly recommended to implement at least <see cref="M:yWorks.Graph.Styles.LabelStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.ILabel)" />, too.</para>
        <para>This implementation differs from the straightforward <see cref="T:yWorks.Graph.Styles.ILabelStyle" /> implementation in that there is no visible separation between the style and its <see cref="T:yWorks.Graph.Styles.ILabelStyleRenderer" />. Instead the renderer used by the base class is fixed and delegates all calls back to the style instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.LabelStyleBase`1" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.LabelStyleBase`1.Renderer">
      <summary>
        <para>Gets the renderer implementation for this instance.</para>
      </summary>
      <remarks>
        <para>The private implementation will delegate all API calls back to this instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.ILabel)">
      <summary>
        <para>Callback that creates the visual.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.LabelStyleBase`1.Renderer" />.</para>
      </remarks>
      <param name="context">
        <para>The render context.</para>
      </param>
      <param name="label">
        <para>The label to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual as required by the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> interface.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.LabelStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.ILabel)" />
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.ILabel)">
      <summary>
        <para>Callback that updates the visual previously created by <see cref="M:yWorks.Graph.Styles.LabelStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.ILabel)" />.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.LabelStyleBase`1.Renderer" />. This implementation simply delegates to <see cref="M:yWorks.Graph.Styles.LabelStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.ILabel)" /> so subclasses should override to improve rendering performance.</para>
      </remarks>
      <param name="context">
        <para>The render context.</para>
      </param>
      <param name="oldVisual">
        <para>The visual that has been created in the call to <see cref="M:yWorks.Graph.Styles.LabelStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.ILabel)" />.</para>
      </param>
      <param name="label">
        <para>The label to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual as required by the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> interface.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.LabelStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.ILabel)" />
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.ILabel)">
      <summary>
        <para>Gets the bounds of the visual for the label in the given context.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IBoundsProvider.GetBounds(yWorks.Controls.ICanvasContext)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.LabelStyleBase`1.Renderer" />.</para>
        <para>This implementation simply yields the <see cref="M:yWorks.Geometry.OrientedRectangleExtensions.GetBounds(yWorks.Geometry.IOrientedRectangle)">bounds</see> of the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see> of the given label.</para>
      </remarks>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="label">
        <para>The label to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual bounds of the visual representation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD,yWorks.Graph.ILabel)">
      <summary>
        <para>Determines whether the visualization for the specified label is visible in the context.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisibilityTestable.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.LabelStyleBase`1.Renderer" />.</para>
        <para>This implementation simply tests whether the <see cref="M:yWorks.Graph.Styles.LabelStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.ILabel)">bounds</see> intersect the clip.</para>
      </remarks>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="rectangle">
        <para>The clipping rectangle.</para>
      </param>
      <param name="label">
        <para>The label to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified label is visible in the clipping rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Graph.ILabel)">
      <summary>
        <para>Determines whether the visual representation of the label has been hit at the given location.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.LabelStyleBase`1.Renderer" />.</para>
        <para>This implementation returns the result of the <see cref="M:yWorks.Geometry.OrientedRectangleExtensions.Hits(yWorks.Geometry.IOrientedRectangle,yWorks.Geometry.PointD,System.Double)" /> method invoked for the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see> of the label, the given <see cref="T:yWorks.Geometry.PointD">point</see> and the <see cref="P:yWorks.Controls.ICanvasContext.HitTestRadius">hit test radius</see> of the <see cref="T:yWorks.Controls.ICanvasContext">canvas context</see>.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="location">
        <para>The point to test.</para>
      </param>
      <param name="label">
        <para>The label to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified label representation is hit; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Graph.ILabel)">
      <summary>
        <para>Determines whether the visualization for the specified label is included in the marquee selection.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.Input.IMarqueeTestable.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.LabelStyleBase`1.Renderer" />.</para>
        <para>This implementation returns the result of the <see cref="M:yWorks.Geometry.RectD.Intersects(yWorks.Geometry.IOrientedRectangle,System.Double)" /> method invoked on <paramref name="rectangle" /> for the <see cref="M:yWorks.Graph.GraphExtensions.GetLayout(yWorks.Graph.ILabel)">layout</see> of the label and the <paramref name="context" />.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="rectangle">
        <para>The marquee selection box.</para>
      </param>
      <param name="label">
        <para>The label to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified label is visible is selected by the marquee rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.Lookup(yWorks.Graph.ILabel,System.Type)">
      <summary>
        <para>Performs the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> operation for the <see cref="M:yWorks.Graph.Styles.ILabelStyleRenderer.GetContext(yWorks.Graph.ILabel,yWorks.Graph.Styles.ILabelStyle)" /> that has been queried from the <see cref="P:yWorks.Graph.Styles.LabelStyleBase`1.Renderer" />.</para>
      </summary>
      <remarks>
        <para>This implementation yields <c>null</c> for everything but:</para>
        <list type="bullet">
          <item>
            <see cref="T:yWorks.Controls.Input.IHitTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IVisualCreator" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IBoundsProvider" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IVisibilityTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.Input.IMarqueeTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Graph.ILookup" />
          </item>
        </list>
        <para>For these interfaces an implementation will be returned that delegates to the methods in this instance.</para>
      </remarks>
      <param name="label">
        <para>The label to use for the context lookup.</para>
      </param>
      <param name="type">
        <para>The type to query.</para>
      </param>
      <returns>
        <para>An implementation of the <paramref name="type" /> or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.Clone">
      <summary>
        <para>Creates a new object that is a copy of the current instance.</para>
      </summary>
      <remarks>
        <para>Immutable subclasses should consider returning <c>this</c>.</para>
      </remarks>
      <returns>
        <para>A new object that is a copy of this instance using <see cref="M:System.Object.MemberwiseClone" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.GetPreferredSize(yWorks.Graph.ILabel)">
      <summary>
        <para>Callback that returns the preferred <see cref="T:yWorks.Geometry.SizeD">size</see> of the label.</para>
      </summary>
      <param name="label">
        <para>The label to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The preferred size.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.LabelStyleBase`1.GetTransform(yWorks.Geometry.IOrientedRectangle,System.Boolean)">
      <summary>
        <para>Gets a transform that can be used to multiply a <see cref="P:System.Drawing.Graphics.Transform" /> so that painting occurs in the label coordinate system.</para>
      </summary>
      <remarks>
        <para>The coordinate system will then be transformed so that paints to the origin will paint into the corner of the label layout.</para>
      </remarks>
      <param name="layout">
        <para>The layout.</para>
      </param>
      <param name="autoFlip">
        <para>if set to <c>true</c> the orientation will automatically be flipped so that the content is not rendered upside down.</para>
      </param>
      <returns>
        <para>A matrix to multiply to the graphics context.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.LabelStyleDecorationInstaller">
      <summary>
        <para>Allows the use of an <see cref="T:yWorks.Graph.Styles.ILabelStyle" /> to render the selection, highlight or focus indicator of labels.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Controls.LabelStyleDecorationInstaller.ZoomPolicy" /> property defines how the zoom level affects the rendering of the indicator. It can either scale according to the zoom level similar to regular graph items or have always to same thickness regardless of the zoom, similar to the default yFiles indicators.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.EdgeStyleDecorationInstaller" />
      <seealso cref="T:yWorks.Controls.NodeStyleDecorationInstaller" />
    </member>
    <member name="M:yWorks.Controls.LabelStyleDecorationInstaller.#ctor">
      <summary>
        <para>Create a new instance of this class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.LabelStyleDecorationInstaller.ZoomPolicy">
      <summary>
        <para>Gets or sets how the style is affected by the current zoom level.</para>
      </summary>
      <remarks>
        <para>Changes of the value of this property are propagated to all styles created by this instance and become immediately visible.</para>
        <para>The default value is <see cref="F:yWorks.Controls.StyleDecorationZoomPolicy.ViewCoordinates" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.LabelStyleDecorationInstaller.Margins">
      <summary>
        <para>Gets or sets the margins around the label layout.</para>
      </summary>
      <remarks>
        <para>Actually, the bounds rendered by the style is the original label layout enlarged by these margins.</para>
        <para>Changes of the value of this property are propagated to all styles created by this instance and become immediately visible.</para>
        <para>The default margins have a value of <c>5</c> for all four sides.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.LabelStyleDecorationInstaller.LabelStyle">
      <summary>
        <para>Gets or sets the style to use for the rendering.</para>
      </summary>
      <remarks>
        <para>Changes of the value of this property are <b>not</b> propagated to already created styles.</para>
        <para>The default value is an instance of <see cref="T:yWorks.Graph.Styles.DefaultLabelStyle" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.LabelStyleDecorationInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">
      <summary>
        <para>Installs a rendering for the <paramref name="item" /> if it is an <see cref="T:yWorks.Graph.ILabel" />.</para>
      </summary>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="group">
        <para>The canvas object group to add the newly created canvas object to.</para>
      </param>
      <param name="item">
        <para>The item to install.</para>
      </param>
      <returns>
        <para>The canvas object representing the item.</para>
      </returns>
    </member>
    <member name="T:yWorks.Markup.Platform.BitmapExtension" />
    <member name="P:yWorks.Markup.Platform.BitmapExtension.ImageData" />
    <member name="M:yWorks.Markup.Platform.BitmapExtension.#ctor" />
    <member name="M:yWorks.Markup.Platform.BitmapExtension.#ctor(System.Drawing.Bitmap)">
      <param name="image" />
    </member>
    <member name="M:yWorks.Markup.Platform.BitmapExtension.#ctor(System.String)">
      <param name="imageData" />
    </member>
    <member name="M:yWorks.Markup.Platform.BitmapExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Platform.MetafileExtension" />
    <member name="P:yWorks.Markup.Platform.MetafileExtension.ImageData" />
    <member name="M:yWorks.Markup.Platform.MetafileExtension.#ctor" />
    <member name="M:yWorks.Markup.Platform.MetafileExtension.#ctor(System.Drawing.Imaging.Metafile)">
      <param name="meta" />
    </member>
    <member name="M:yWorks.Markup.Platform.MetafileExtension.#ctor(System.String)">
      <param name="imageData" />
    </member>
    <member name="M:yWorks.Markup.Platform.MetafileExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Markup.Platform.UriImageNodeStyleExtension" />
    <member name="P:yWorks.Markup.Platform.UriImageNodeStyleExtension.Uri" />
    <member name="M:yWorks.Markup.Platform.UriImageNodeStyleExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="P:yWorks.Markup.Platform.UriImageNodeStyleExtension.OutlineShape" />
    <member name="T:yWorks.Markup.Platform.UriImageIconExtension" />
    <member name="P:yWorks.Markup.Platform.UriImageIconExtension.Uri" />
    <member name="M:yWorks.Markup.Platform.UriImageIconExtension.ProvideValue(System.IServiceProvider)">
      <param name="serviceProvider" />
    </member>
    <member name="T:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer">
      <summary>
        <para>A style renderer implementation that can be used together with <see cref="T:yWorks.Graph.Styles.MemoryImageNodeStyle" /> instances.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node">
      <summary>
        <para>Gets or sets the currently configured node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and node have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node" /> properties have been populated by the <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, or <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> methods.</para>
        <para>This is an empty implementation. Subclasses might have to override this method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the <see cref="T:yWorks.Controls.IVisual" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query hit test with. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="node">
        <para>The node to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="node">
        <para>The node to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Lookup(System.Type)">
      <summary>
        <para>Implements the <see cref="T:yWorks.Graph.ILookup" /> interface.</para>
      </summary>
      <remarks>
        <para>This method will be used by default if <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> has been queried for a lookup implementation. Note that it cannot be assumed that <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" /> has already been invoked. However, normally <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node" /> and <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style" /> will be correctly configured if invoked directly after <c>GetContext</c>. Subclass implementations should make sure to configure this instance before they return <c>this</c> as a result of a successful lookup. This implementation will check if <c>type.IsInstanceOfType(this)</c> and will call <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" /> on success and return <c>this</c>.</para>
      </remarks>
      <param name="type">
        <para>The type to query for.</para>
      </param>
      <returns>
        <para>An implementation or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Determines visibility by checking for an intersection with the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Layout" />.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="rectangle">
        <para>The current clip</para>
      </param>
      <returns>
        <para>Whether the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Layout" /> is visible in the clip.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <summary>
        <para>Returns the layout bounds as an upper bound for the painting bound.</para>
      </summary>
      <param name="context">
        <para>the context to calculate the bounds for</para>
      </param>
      <returns>
        <para>the bounds or <c>null</c> to indicate an unbound area</para>
      </returns>
      <remarks>
        <para>This implementation simply sets the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Layout" />'s bounds to the scratch variable and returns.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node" /> properties, calls <see cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the shape geometry for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.Layout">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.INode.Layout" /> of the node this renderer is currently configured for.</para>
      </summary>
      <remarks>
        <para>Returns <c>Node.Layout</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetImage">
      <summary>
        <para>Get the image that is currently used to render the style.</para>
      </summary>
      <returns />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.#ctor">
      <summary>
        <para>Create a new instance of this renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Tries to use <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyle.OutlineShape" /> to perform the hit test analysis, otherwise reverts to default (rectangular) behavior.</para>
      </summary>
      <param name="context">
        <para>the context the hit test is performed in</para>
      </param>
      <param name="location">
        <para>the coordinates in world coordinate system</para>
      </param>
      <returns>
        <para>whether something has been hit</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetInterpolationMode">
      <summary>
        <para>Gets the interpolation mode for to set on the graphics context for rendering of the image.</para>
      </summary>
      <remarks>
        <para>A value of <see cref="F:System.Drawing.Drawing2D.InterpolationMode.Invalid" /> is interpreted as follows: use the value currently set on the graphics context.</para>
      </remarks>
      <returns>
        <para>
          <see cref="F:System.Drawing.Drawing2D.InterpolationMode.Invalid" />
        </para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Tries to use the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyle.OutlineShape" /> to perform the marquee intersection analysis, otherwise reverts to default (rectangular) behavior.</para>
      </summary>
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Tries to use the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyle.OutlineShape" /> to perform the intersection calculation, otherwise reverts to default (rectangular) behavior.</para>
      </summary>
      <param name="inner" />
      <param name="outer" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)">
      <summary>
        <para>Tries to use the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyle.OutlineShape" /> to perform the contains test, otherwise reverts to default (rectangular) behavior.</para>
      </summary>
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyleRenderer.GetOutline">
      <summary>
        <para>Tries to use the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyle.OutlineShape" /> to create the outline shape path, otherwise reverts to default (rectangular) behavior.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.MemoryImageNodeStyle">
      <summary>
        <para>An implementation of the <see cref="T:yWorks.Graph.Styles.INodeStyle" /> interface that uses an <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyle.Image" /> as the visual representation of a node.</para>
      </summary>
      <remarks>
        <para>During serialization this instance will serialize the contents of the image.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.UriImageNodeStyle" />
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyle.#ctor">
      <summary>
        <para>Create a new instance of this style.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyle.#ctor(yWorks.Graph.Styles.MemoryImageNodeStyleRenderer)">
      <summary>
        <para>Create a new instance of this style.</para>
      </summary>
      <param name="styleRenderer">
        <para>The custom renderer for this instance</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.MemoryImageNodeStyle.OutlineShape">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Geometry.GeneralPath" /> of the outline of the image that will be displayed.</para>
      </summary>
      <remarks>
        <para>This shape will be used to satisfy requests to <see cref="M:yWorks.Controls.Input.IMarqueeTestable.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /> and <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> and may be left <c>null</c> to indicate default (rectangular) behavior.</para>
        <para>The default value is <c>null</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.MemoryImageNodeStyle.Clone">
      <summary>
        <para>This implementation performs a shallow copy with respect to the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyle.Image" /> property.</para>
      </summary>
      <remarks>
        <para>If clients need to have a deep copy of this instance, they need to manually clone and reassign the <see cref="P:yWorks.Graph.Styles.MemoryImageNodeStyle.Image" /> to the clone.</para>
      </remarks>
      <returns>
        <para>A shallow copy of this instance.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.NodeStyleBase`1">
      <summary>
        <para>An abstract base class that makes it possible to easily implement a custom <see cref="T:yWorks.Graph.Styles.INodeStyle" />.</para>
      </summary>
      <remarks>
        <para>The only method that needs to be implemented by subclasses is <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.INode)" />, however to improve rendering performance it is highly recommended to implement at least <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.INode)" />, too.</para>
        <para>This implementation differs from the straightforward <see cref="T:yWorks.Graph.Styles.INodeStyle" /> implementation in that there is no visible separation between the style and its <see cref="T:yWorks.Graph.Styles.INodeStyleRenderer" />. Instead the renderer used by the base class is fixed and delegates all calls back to the style instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.NodeStyleBase`1" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.NodeStyleBase`1.Renderer">
      <summary>
        <para>Gets the renderer implementation for this instance.</para>
      </summary>
      <remarks>
        <para>The private implementation will delegate all API calls back to this instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.INode)">
      <summary>
        <para>Callback that creates the visual.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.NodeStyleBase`1.Renderer" />.</para>
      </remarks>
      <param name="context">
        <para>The render context.</para>
      </param>
      <param name="node">
        <para>The node to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual as required by the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> interface.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.NodeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.INode)">
      <summary>
        <para>Callback that updates the visual previously created by <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.INode)" />.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.NodeStyleBase`1.Renderer" />. This implementation simply delegates to <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.INode)" /> so subclasses should override to improve rendering performance.</para>
      </remarks>
      <param name="context">
        <para>The render context.</para>
      </param>
      <param name="oldVisual">
        <para>The visual that has been created in the call to <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.INode)" />.</para>
      </param>
      <param name="node">
        <para>The node to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual as required by the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> interface.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.NodeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.INode)" />
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.INode)">
      <summary>
        <para>Gets the bounds of the visual for the node in the given context.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IBoundsProvider.GetBounds(yWorks.Controls.ICanvasContext)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.NodeStyleBase`1.Renderer" />. This implementation simply yields the <see cref="P:yWorks.Graph.INode.Layout" />.</para>
      </remarks>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="node">
        <para>The node to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual bounds of the visual representation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD,yWorks.Graph.INode)">
      <summary>
        <para>Determines whether the visualization for the specified node is visible in the context.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisibilityTestable.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.NodeStyleBase`1.Renderer" />. This implementation simply tests whether the <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.INode)">bounds</see> intersect the clip.</para>
      </remarks>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="rectangle">
        <para>The clipping rectangle.</para>
      </param>
      <param name="node">
        <para>The node to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified node is visible in the clipping rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Graph.INode)">
      <summary>
        <para>Determines whether the visual representation of the node has been hit at the given location.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.NodeStyleBase`1.Renderer" />. This implementation uses the <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.GetOutline(yWorks.Graph.INode)">outline</see> to determine whether the node has been hit.</para>
      </remarks>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="location">
        <para>The point to test.</para>
      </param>
      <param name="node">
        <para>The node to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified node representation is hit; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Graph.INode)">
      <summary>
        <para>Determines whether the visualization for the specified node is included in the marquee selection.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.Input.IMarqueeTestable.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.NodeStyleBase`1.Renderer" />. This implementation simply tests whether the <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.INode)">bounds</see> intersect the marquee box.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="rectangle">
        <para>The marquee selection box.</para>
      </param>
      <param name="node">
        <para>The node to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified node is visible is selected by the marquee rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.Lookup(yWorks.Graph.INode,System.Type)">
      <summary>
        <para>Performs the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> operation for the <see cref="M:yWorks.Graph.Styles.INodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> that has been queried from the <see cref="P:yWorks.Graph.Styles.NodeStyleBase`1.Renderer" />.</para>
      </summary>
      <remarks>
        <para>This implementation yields <c>null</c> for everything but:</para>
        <list type="bullet">
          <item>
            <see cref="T:yWorks.Controls.Input.IHitTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IVisualCreator" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IBoundsProvider" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IVisibilityTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.Input.IMarqueeTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Graph.ILookup" />
          </item>
          <item>
            <see cref="T:yWorks.Graph.Styles.IShapeGeometry" />
          </item>
        </list>
        <para>For these interfaces an implementation will be returned that delegates to the methods in this instance.</para>
      </remarks>
      <param name="node">
        <para>The node to use for the context lookup.</para>
      </param>
      <param name="type">
        <para>The type to query.</para>
      </param>
      <returns>
        <para>An implementation of the <paramref name="type" /> or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.GetIntersection(yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Gets the intersection of a line with the visual representation of the node.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Graph.Styles.IShapeGeometry.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.NodeStyleBase`1.Renderer" />. This implementation simply uses the <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.GetOutline(yWorks.Graph.INode)">outline</see> to determine the intersection or the <see cref="P:yWorks.Graph.INode.Layout" /> if the outline is <c>null</c>. If it is feasible to determine the intersection point for the current shape, this method should be implemented in addition to <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.GetOutline(yWorks.Graph.INode)" /> to improve performance.</para>
      </remarks>
      <param name="node">
        <para>The node to which this style instance is assigned.</para>
      </param>
      <param name="inner">
        <para>The coordinates of a point lying <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.IsInside(yWorks.Graph.INode,yWorks.Geometry.PointD)">inside</see> the shape.</para>
      </param>
      <param name="outer">
        <para>The coordinates of a point lying outside the shape.</para>
      </param>
      <returns>
        <para>The intersection point if one has been found or <c>null</c>, otherwise.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.NodeStyleBase`1.IsInside(yWorks.Graph.INode,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.IsInside(yWorks.Graph.INode,yWorks.Geometry.PointD)">
      <summary>
        <para>Determines whether the provided point is geometrically inside the visual bounds of the node.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Graph.Styles.IShapeGeometry.IsInside(yWorks.Geometry.PointD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.NodeStyleBase`1.Renderer" />. This implementation simply uses the <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.GetOutline(yWorks.Graph.INode)">outline</see> to determine whether the point is contained or the <see cref="P:yWorks.Graph.INode.Layout" /> if the outline is <c>null</c>. If it is feasible to determine whether a given point lies inside the shape, this method should be implemented in addition to <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.GetOutline(yWorks.Graph.INode)" /> to improve performance.</para>
      </remarks>
      <param name="node">
        <para>The node to which this style instance is assigned.</para>
      </param>
      <param name="location">
        <para>The point to test.</para>
      </param>
      <returns>
        <para>Whether the point is considered to lie inside the shape.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.GetOutline(yWorks.Graph.INode)">
      <summary>
        <para>Gets the outline of the visual style.</para>
      </summary>
      <remarks>
        <para>This implementation yields <c>null</c> to indicate that the <see cref="P:yWorks.Graph.INode.Layout" /> depicts the outline. Implementing this method influences the behavior of <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.IsInside(yWorks.Graph.INode,yWorks.Geometry.PointD)" /> and <see cref="M:yWorks.Graph.Styles.NodeStyleBase`1.GetIntersection(yWorks.Graph.INode,yWorks.Geometry.PointD,yWorks.Geometry.PointD)" /> since the default implementations delegate to it.</para>
      </remarks>
      <param name="node">
        <para>The node to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The outline of the visual representation or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleBase`1.Clone">
      <summary>
        <para>Creates a new object that is a copy of the current instance.</para>
      </summary>
      <remarks>
        <para>Immutable subclasses should consider returning <c>this</c>.</para>
      </remarks>
      <returns>
        <para>A new object that is a copy of this instance using <see cref="M:System.Object.MemberwiseClone" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.NodeStyleDecorationInstaller">
      <summary>
        <para>Allows the use of an <see cref="T:yWorks.Graph.Styles.INodeStyle" /> to render the selection, highlight or focus indicator of nodes.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Controls.NodeStyleDecorationInstaller.ZoomPolicy" /> property defines how the zoom level affects the rendering of the indicator. It can either scale according to the zoom level similar to regular graph items or have always to same thickness regardless of the zoom, similar to the default yFiles indicators.</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.EdgeStyleDecorationInstaller" />
      <seealso cref="T:yWorks.Controls.LabelStyleDecorationInstaller" />
    </member>
    <member name="M:yWorks.Controls.NodeStyleDecorationInstaller.#ctor">
      <summary>
        <para>Create a new instance of this class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.NodeStyleDecorationInstaller.ZoomPolicy">
      <summary>
        <para>Gets or sets how the style is affected by the current zoom level.</para>
      </summary>
      <remarks>
        <para>Changes of the value of this property are propagated to all styles created by this instance and become immediately visible.</para>
        <para>The default value is <see cref="F:yWorks.Controls.StyleDecorationZoomPolicy.ViewCoordinates" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.NodeStyleDecorationInstaller.Margins">
      <summary>
        <para>Gets or sets the margins around the node layout.</para>
      </summary>
      <remarks>
        <para>Actually, the bounds rendered by the style is the original node layout enlarged by these margins.</para>
        <para>Changes of the value of this property are propagated to all styles created by this instance and become immediately visible.</para>
        <para>The default margins have a value of <c>5</c> for all four sides.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.NodeStyleDecorationInstaller.NodeStyle">
      <summary>
        <para>Gets or sets the style to use for the rendering.</para>
      </summary>
      <remarks>
        <para>Changes of the value of this property are <b>not</b> propagated to already created styles.</para>
        <para>The default value is an instance of <see cref="T:yWorks.Graph.Styles.ShapeNodeStyle" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.NodeStyleDecorationInstaller.AddCanvasObject(yWorks.Controls.ICanvasContext,yWorks.Controls.ICanvasObjectGroup,System.Object)">
      <summary>
        <para>Installs a rendering for the <paramref name="item" /> if it is an <see cref="T:yWorks.Graph.INode" />.</para>
      </summary>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="group">
        <para>The canvas object group to add the newly created canvas object to.</para>
      </param>
      <param name="item">
        <para>The item to install.</para>
      </param>
      <returns>
        <para>The canvas object representing the item.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter">
      <summary>
        <para>A label style decorator that uses a node style instance to render the background and a label style instance to render the foreground of a label.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter" /> class.</para>
      </summary>
      <remarks>
        <para>This constructor uses a <see cref="T:yWorks.Graph.Styles.ShapeNodeStyle" /> and a <see cref="T:yWorks.Graph.Styles.DefaultLabelStyle" /> for the <see cref="P:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter.NodeStyle" /> and <see cref="P:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter.LabelStyle" /> properties.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter.#ctor(yWorks.Graph.Styles.INodeStyle,yWorks.Graph.Styles.ILabelStyle)">
      <summary>
        <para>Creates a label style that uses the provided node style to render the background and the label style to render the foreground of this style.</para>
      </summary>
      <remarks>
        <para>Note that the styles will be stored by reference, thus modifying the style will directly affect the rendering of this instance.</para>
      </remarks>
      <param name="nodeStyle">
        <para>The style to use for rendering the background of the label.</para>
      </param>
      <param name="labelStyle">
        <para>The style to use for rendering the foreground of the label.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter.NodeStyle">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.Styles.INodeStyle" /> that is used for rendering the background of the label.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter.LabelStyle">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.Styles.ILabelStyle" /> that is used for rendering the foreground of the label.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter.AutoFlip">
      <summary>
        <para>Gets a value indicating whether the label should be flipped 180 degrees automatically, if it would be oriented downwards, otherwise.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the label should be flipped automatically otherwise, <c>false</c>. The default is <c>true</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter.LabelStyleInsets">
      <summary>
        <para>Gets or sets the insets to apply for the <see cref="P:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter.LabelStyle" /> as margins.</para>
      </summary>
      <value>
        <para>The label style insets. The default is (0,0,0,0).</para>
      </value>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleLabelStyleAdapter.Clone" />
    <member name="T:yWorks.Graph.Styles.NodeStylePortStyleAdapter">
      <summary>
        <para>A port style decorator that uses a node style instance to render the port.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStylePortStyleAdapter.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.NodeStylePortStyleAdapter" /> class.</para>
      </summary>
      <remarks>
        <para>This constructor uses an ellipse <see cref="T:yWorks.Graph.Styles.ShapeNodeStyle" /> with a black <see cref="T:System.Drawing.Brush" /> for the <see cref="P:yWorks.Graph.Styles.NodeStylePortStyleAdapter.NodeStyle" /> property.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStylePortStyleAdapter.#ctor(yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Creates a port style that uses the provided node style to render the port.</para>
      </summary>
      <remarks>
        <para>Note that the styles will be stored by reference, thus modifying the style will directly affect the rendering of this instance.</para>
      </remarks>
      <param name="nodeStyle">
        <para>The style to use for rendering the port.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.NodeStylePortStyleAdapter.NodeStyle">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.Styles.INodeStyle" /> that is used for rendering the port.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.NodeStylePortStyleAdapter.RenderSize">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Geometry.MutableSize" /> of the port that will be displayed using <see cref="P:yWorks.Graph.Styles.NodeStylePortStyleAdapter.NodeStyle" />.</para>
      </summary>
      <remarks>
        <para>The default value is (5,5).</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStylePortStyleAdapter.Clone" />
    <member name="T:yWorks.Graph.Styles.NodeStyleStripeStyleAdapter">
      <summary>
        <para>A stripe style decorator that uses a node style instance to render the stripe.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleStripeStyleAdapter.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.NodeStyleStripeStyleAdapter" /> class.</para>
      </summary>
      <remarks>
        <para>This constructor uses an rectangular <see cref="T:yWorks.Graph.Styles.ShapeNodeStyle" /> with a transparent brush and a black pen for the <see cref="P:yWorks.Graph.Styles.NodeStyleStripeStyleAdapter.NodeStyle" /> property.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleStripeStyleAdapter.#ctor(yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Creates a stripe style that uses the provided node style to render the stripe.</para>
      </summary>
      <remarks>
        <para>Note that the styles will be stored by reference, thus modifying the style will directly affect the rendering of this instance.</para>
      </remarks>
      <param name="nodeStyle">
        <para>The node style to use for rendering the stripe.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.NodeStyleStripeStyleAdapter.NodeStyle">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.Styles.INodeStyle" /> that is used for rendering the stripe.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.NodeStyleStripeStyleAdapter.Clone" />
    <member name="T:yWorks.Controls.OverviewGraphVisualCreator">
      <summary>
        <para>An <see cref="T:yWorks.Controls.IVisualCreator" /> for use in a <see cref="T:yWorks.Controls.CanvasControl" /> that renders a <see cref="T:yWorks.Graph.IGraph" /> instance in a sloppy overview style.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.OverviewGraphVisualCreator.#ctor(yWorks.Graph.IGraph)">
      <summary>
        <para>Creates a new instance for the given graph.</para>
      </summary>
      <param name="graph" />
    </member>
    <member name="P:yWorks.Controls.OverviewGraphVisualCreator.NodeStyle">
      <summary>
        <para>Gets or sets the overview node style.</para>
      </summary>
      <value>
        <para>The overview node style.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.OverviewGraphVisualCreator.GroupNodeStyle">
      <summary>
        <para>Gets or sets the overview group node style.</para>
      </summary>
      <value>
        <para>The overview node style.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.OverviewGraphVisualCreator.EdgeStyle">
      <summary>
        <para>Gets or sets the overview edge style.</para>
      </summary>
      <value>
        <para>The overview edge style.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.OverviewGraphVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Controls.OverviewGraphVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Controls.OverviewGraphVisualCreator.Paint(yWorks.Controls.IRenderContext,System.Drawing.Graphics)">
      <summary>
        <para>Paints the overview graph on the given <paramref name="graphics" /> context.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Controls.OverviewGraphVisualCreator.PaintNode(yWorks.Controls.IRenderContext,System.Drawing.Graphics,yWorks.Graph.INode)" />, <see cref="M:yWorks.Controls.OverviewGraphVisualCreator.PaintEdge(yWorks.Controls.IRenderContext,System.Drawing.Graphics,yWorks.Graph.IEdge)" />, and <see cref="M:yWorks.Controls.OverviewGraphVisualCreator.PaintGroupNode(yWorks.Controls.IRenderContext,System.Drawing.Graphics,yWorks.Graph.INode)" /> to render the elements.</para>
      </remarks>
      <param name="context">
        <para>The render context.</para>
      </param>
      <param name="graphics">
        <para>The graphics context.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.OverviewGraphVisualCreator.PaintNode(yWorks.Controls.IRenderContext,System.Drawing.Graphics,yWorks.Graph.INode)">
      <summary>
        <para>Callback method that paints a node.</para>
      </summary>
      <param name="context" />
      <param name="g" />
      <param name="node" />
    </member>
    <member name="M:yWorks.Controls.OverviewGraphVisualCreator.PaintGroupNode(yWorks.Controls.IRenderContext,System.Drawing.Graphics,yWorks.Graph.INode)">
      <summary>
        <para>Callback method that paints a group node.</para>
      </summary>
      <param name="context" />
      <param name="g" />
      <param name="node" />
    </member>
    <member name="M:yWorks.Controls.OverviewGraphVisualCreator.GetNodeStyle(yWorks.Graph.INode)">
      <summary>
        <para>Callback that returns and/or configures a node style for the given node to render.</para>
      </summary>
      <param name="node">
        <para>The node to render.</para>
      </param>
      <returns>
        <para>The style or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.OverviewGraphVisualCreator.GetGroupNodeStyle(yWorks.Graph.INode)">
      <summary>
        <para>Callback that returns and/or configures a group node style for the given node to render.</para>
      </summary>
      <param name="node">
        <para>The group node to render.</para>
      </param>
      <returns>
        <para>The style or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.OverviewGraphVisualCreator.GetEdgeStyle(yWorks.Graph.IEdge)">
      <summary>
        <para>Callback that returns and/or configures a edge style for the given node to render.</para>
      </summary>
      <param name="edge">
        <para>The edge to render.</para>
      </param>
      <returns>
        <para>The style or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.OverviewGraphVisualCreator.PaintEdge(yWorks.Controls.IRenderContext,System.Drawing.Graphics,yWorks.Graph.IEdge)">
      <summary>
        <para>Paints the given edge.</para>
      </summary>
      <param name="context" />
      <param name="g" />
      <param name="edge" />
    </member>
    <member name="T:yWorks.Graph.Styles.PanelNodeStyle">
      <summary>
        <para>An implementation of <see cref="T:yWorks.Graph.Styles.INodeStyle" /> that draws a simple floating panel with a slight gradient, a thin border and optionally a drop shadow.</para>
      </summary>
      <remarks>
        <para>This style can be used to create the visual representation for group nodes, for example. By default, it a drop shadow by itself.</para>
        <para>This style uses the <see cref="T:yWorks.Graph.Styles.PanelNodeStyleRenderer" /> to visualize a node.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.PanelNodeStyleRenderer" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyle.#ctor">
      <summary>
        <para>Creates a new instance using <see cref="T:yWorks.Graph.Styles.PanelNodeStyleRenderer" /> as renderer to share.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyle.#ctor(yWorks.Graph.Styles.PanelNodeStyleRenderer)">
      <summary>
        <para>Creates a new instance using the provided renderer to share.</para>
      </summary>
      <param name="renderer" />
    </member>
    <member name="P:yWorks.Graph.Styles.PanelNodeStyle.Color">
      <summary>
        <para>Gets or sets the base color to use.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="P:System.Drawing.Color.Black" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.PanelNodeStyle.LabelInsetsColor">
      <summary>
        <para>Gets or sets the base color to use for drawing the label insets background.</para>
      </summary>
      <remarks>
        <para>Setting this to <c>null</c> effectively disables label insets background coloring.</para>
        <para>The default value is <see cref="P:System.Drawing.Color.LightGray" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.PanelNodeStyle.Insets">
      <summary>
        <para>Gets or sets the instance to use that provides the insets for this style.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Graph.Styles.PanelNodeStyleRenderer" /> will use these insets and return them via an <see cref="T:yWorks.Controls.Input.INodeInsetsProvider" /> if such an instance is queried through the <see cref="M:yWorks.Graph.Styles.INodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">context lookup</see>.</para>
        <para>The default insets are set to (5,5,5,5).</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.INodeInsetsProvider" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyle.Clone" />
    <member name="T:yWorks.Graph.Styles.PanelNodeStyleRenderer">
      <summary>
        <para>A <see cref="T:yWorks.Graph.Styles.INodeStyle" /> <see cref="T:yWorks.Graph.Styles.INodeStyleRenderer">renderer</see> implementation that draws a simple floating panel with a slight gradient, a thin border and a simple drop shadow.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.Styles.PanelNodeStyle" />
    </member>
    <member name="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node">
      <summary>
        <para>Gets or sets the currently configured node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and node have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node" /> properties have been populated by the <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, or <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> methods.</para>
        <para>This is an empty implementation. Subclasses might have to override this method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the <see cref="T:yWorks.Controls.IVisualCreator" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query hit test with. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="node">
        <para>The node to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="node">
        <para>The node to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Hit tests the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node">node</see> using the current <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" />.</para>
      </summary>
      <param name="context">
        <para>the context the hit test is performed in</para>
      </param>
      <param name="location">
        <para>the coordinates in world coordinate system</para>
      </param>
      <returns>
        <para>whether something has been hit</para>
      </returns>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Layout" /> to determine whether the node has been hit. The check is delegated to <see cref="M:yWorks.Geometry.RectD.Contains(yWorks.Geometry.PointD,System.Double)" /> using <see cref="P:yWorks.Controls.ICanvasContext.HitTestRadius" /> as the last argument.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Tests the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node">node</see> using the current <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" /> for an intersection with the given box.</para>
      </summary>
      <param name="context">
        <para>the current input mode context</para>
      </param>
      <param name="rectangle">
        <para>the box describing the marquee's bounds</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the node is considered to be captured by the marquee</para>
      </returns>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Layout" /> to determine whether the node is in the box.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node" /> properties, calls <see cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the shape geometry for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Finds an intersection for the current <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Node">node</see> using the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Style" />.</para>
      </summary>
      <remarks>
        <para>This implementation returns the intersection for the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Layout" />.</para>
      </remarks>
      <returns>
        <para>True if an intersection was actually found</para>
      </returns>
      <param name="inner" />
      <param name="outer" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)">
      <summary>
        <para>Checks whether the given coordinate lies within the shape's geometric bounds.</para>
      </summary>
      <remarks>
        <para>This implementation checks for containment in the <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Layout" />.</para>
      </remarks>
      <returns>
        <para>True if the point lies within the geometry of the rendering.</para>
      </returns>
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetOutline">
      <summary>
        <para>Returns the outline of the shape using the node's <see cref="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Layout" />.</para>
      </summary>
      <returns>
        <para>The outline of the bounds of the node.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Layout">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.INode.Layout" /> of the node this renderer is currently configured for.</para>
      </summary>
      <remarks>
        <para>Returns <c>Node.Layout</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.#ctor">
      <summary>
        <para>Creates a new instance of this style.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.DrawShadow">
      <summary>
        <para>Determines whether to draw the drop shadow.</para>
      </summary>
      <returns>
        <para>
          <c>true</c>, always.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.Styles.PanelNodeStyleRenderer.Color">
      <summary>
        <para>Gets the color from the style.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.Styles.PanelNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <param name="context" />
    </member>
    <member name="T:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1">
      <summary>
        <para>An abstract base class for <see cref="T:yWorks.Graph.Styles.IEdgeStyleRenderer" /> implementations that are based on the calculation of a <see cref="T:yWorks.Geometry.GeneralPath" />.</para>
      </summary>
      <typeparam name="TStyle">
        <para>The exact type of style to use for this instance.</para>
      </typeparam>
    </member>
    <member name="F:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.path">
      <summary>
        <para>The path instance that this instance is working with.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Edge">
      <summary>
        <para>Gets or sets the currently configured edge.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetVisualCreator(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="edge" /> parameters, calls <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="edge">
        <para>The edge to retrieve the <see cref="T:yWorks.Controls.IVisualCreator" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Edge" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the edge. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetBoundsProvider(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="edge" /> parameters, calls <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="edge">
        <para>The edge to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Edge" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the edge. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetMarqueeTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="edge" /> parameters, calls <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="edge">
        <para>The edge to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Edge" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the edge. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetVisibilityTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="edge" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="edge">
        <para>The edge to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Edge" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the edge. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetContext(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="edge" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="edge">
        <para>The edge to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Edge" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the edge. The value will be stored in the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Calls <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /> and test the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Edge" /> using the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Style" /> for a visible intersection with the clip bounds.</para>
      </summary>
      <remarks>
        <para>This simple implementation uses <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetBounds(yWorks.Controls.ICanvasContext)" /> to determine the visibility. Subclasses may choose to override this behavior for improved performance but need to <b>make sure to call <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /></b> if they depend on a configured instance.</para>
      </remarks>
      <param name="context">
        <para>the current canvas context</para>
      </param>
      <param name="rectangle">
        <para>the clip bounds</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge may be painted within the clip bounds.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetVisibilityTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetPathGeometry(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Gets an implementation of the <see cref="T:yWorks.Graph.Styles.IPathGeometry" /> interface that can handle the provided edge and its associated style.</para>
      </summary>
      <param name="edge">
        <para>The edge to provide an instance for</para>
      </param>
      <param name="style">
        <para>The style to use for the painting</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" />
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetTangent(System.Double)" />
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetTangent(System.Int32,System.Double)" />
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetSegmentCount" />
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetPath" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetTangent(System.Double)">
      <summary>
        <para>Calculates the tangent on the edge's path at the given ratio point.</para>
      </summary>
      <param name="ratio">
        <para>a value in [0,1] where 0 is the source's end and 1 is at the target's end of the visible edge path</para>
      </param>
      <remarks>
        <para>This method is part of the <see cref="T:yWorks.Graph.Styles.IPathGeometry" /> interface, that is implemented by this class. This interface will be returned by <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetPathGeometry(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />.</para>
      </remarks>
      <returns>
        <para>The tangential line, if any exists.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetPathGeometry(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetTangent(System.Int32,System.Double)">
      <summary>
        <para>Calculates the tangent on the edge's path at the given ratio point for the given segment.</para>
      </summary>
      <param name="segmentIndex">
        <para>the segment to use for the calculation</para>
      </param>
      <param name="ratio">
        <para>a value in [0,1] where 0 is the source's end and 1 is at the target's end of the segment</para>
      </param>
      <remarks>
        <para>This method is part of the <see cref="T:yWorks.Graph.Styles.IPathGeometry" /> interface, that is implemented by this class. This interface will be returned by <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetPathGeometry(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />.</para>
      </remarks>
      <returns>
        <para>The tangential line, if any exists.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetTangent(System.Double)" />
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetSegmentCount" />
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetPathGeometry(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetSegmentCount">
      <summary>
        <para>Returns the number of "segments" this edge's path consists of.</para>
      </summary>
      <remarks>
        <para>This method is part of the <see cref="T:yWorks.Graph.Styles.IPathGeometry" /> interface, that is implemented by this class. This interface will be returned by <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetPathGeometry(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />.</para>
      </remarks>
      <returns>
        <para>the number of segments or <c>-1</c> if there is no such thing as a segment for this edge.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetPathGeometry(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetTargetArrow">
      <summary>
        <para>Gets the target arrow from the style.</para>
      </summary>
      <returns>
        <para>The arrow to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetSourceArrow">
      <summary>
        <para>Gets the source arrow from the style.</para>
      </summary>
      <returns>
        <para>The arrow to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetSourceArrowAnchor(yWorks.Graph.Styles.IArrow)">
      <summary>
        <para>Calculate and update the anchor and the source arrow's direction vector.</para>
      </summary>
      <param name="arrow">
        <para>The arrow to calculate the anchor for.</para>
      </param>
      <returns>
        <para>The anchor and directional vector of the arrow, if any exist.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetTargetArrowAnchor(yWorks.Graph.Styles.IArrow)">
      <summary>
        <para>Calculate and update the anchor and the target arrow's direction vector.</para>
      </summary>
      <param name="arrow">
        <para>The arrow to calculate the anchor for.</para>
      </param>
      <returns>
        <para>The anchor and directional vector of the arrow, if any exist.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CropPath(yWorks.Geometry.GeneralPath)">
      <summary>
        <para>Crops the edge's path at the nodes.</para>
      </summary>
      <remarks>
        <para>This implementation uses the <see cref="T:yWorks.Graph.Styles.IEdgePathCropper" /> instances found in the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> of the source and target port of the edge to perform the actual cropping.</para>
      </remarks>
      <param name="path">
        <para>The path that should be cropped.</para>
      </param>
      <returns>
        <para>The cropped path. This is can be either the same instance of the given path or a newly created instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreatePath">
      <summary>
        <para>This method should create the basic uncropped path given the control points.</para>
      </summary>
      <returns>
        <para>A path that has to be cropped, yet.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and edge have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Style" /> and <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Edge" /> properties have been populated by the <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetVisualCreator(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />, <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetBoundsProvider(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />, <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetHitTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />, or <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetMarqueeTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" /> methods.</para>
        <para>Subclasses which override this method have to call the base implementation, first.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetBridgeCreator">
      <summary>
        <para>Yields the <see cref="T:yWorks.Controls.IBridgeCreator" /> to use for <see cref="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.AddBridges">adding bridges</see> to the <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreatePath">created path</see>.</para>
      </summary>
      <remarks>
        <para>The return value of this method (which may be <c>null</c>) will be passed to the <see cref="T:yWorks.Controls.BridgeManager" />'s <see cref="M:yWorks.Controls.BridgeManager.AddBridges(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Controls.IBridgeCreator)" /> method.</para>
      </remarks>
      <returns>
        <para>This implementation returns <c>null</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.AddBridges">
      <summary>
        <para>Gets whether the rendered path should use the <see cref="T:yWorks.Controls.BridgeManager" /> to <see cref="M:yWorks.Controls.BridgeManager.AddBridges(yWorks.Controls.IRenderContext,yWorks.Geometry.GeneralPath,yWorks.Controls.IBridgeCreator)">add bridges to it.</see></para>
      </summary>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetBridgeCreator" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetObstacles(yWorks.Controls.IRenderContext)">
      <summary>
        <para>Returns <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreatePath" /> unless <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" /> yields <c>false</c> for the provided context and <see cref="P:yWorks.Controls.IRenderContext.Clip" />.</para>
      </summary>
      <param name="context">
        <para>The context to yield the obstacles for.</para>
      </param>
      <returns>
        <para>Either <c>null</c> or the result of <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreatePath" />.</para>
      </returns>
      <seealso cref="T:yWorks.Controls.IObstacleProvider" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetSmoothingLength">
      <summary>
        <para>Gets the value that determines the radius of the smoothing arcs that can be added to the path at the bends.</para>
      </summary>
      <remarks>
        <para>This implementation returns <c>0.0d</c>, which effectively turns off path smoothing.</para>
      </remarks>
      <returns>
        <para>The radius of the arcs to use at the bends of the path.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetPen">
      <summary>
        <para>Gets the pen to use for painting the path.</para>
      </summary>
      <returns>
        <para>The pen or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>This method is overridden for performance reasons.</para>
      </summary>
      <remarks>
        <para>This implementation uses <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" /> as an early exit indicator. If <c>IsVisible</c> returns <c>false</c> for a certain rectangle, the instance will not be configured but a non-hit will be assumed. Otherwise this instance will be configured and the standard path based hit test routine <br /> Subclasses should not depend on the fact that <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /> has already been called. This may not be the case. If your subclass depends on Configure being called, override <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetHitTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" /> and call <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /> after the base class call.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetHitTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" />
      <param name="context" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetHitTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="edge" /> parameters and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>This implementation does not call <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" />. If subclasses depend on a configured instance in an override of <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />, they need to override this method, too and call <see cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" /> if the base call returns a non-<c>null</c> value.</para>
      </remarks>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.Configure" />
      <seealso cref="M:yWorks.Graph.Styles.IEdgeStyleRenderer.GetHitTestable(yWorks.Graph.IEdge,yWorks.Graph.Styles.IEdgeStyle)" />
      <param name="edge" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetBounds(yWorks.Controls.ICanvasContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreateSelfLoopPath(System.Boolean)">
      <summary>
        <para>Special implementation that will create a self loop path.</para>
      </summary>
      <returns />
      <param name="roundSelfLoop" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreateRectangleSelfLoop(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Static utility method that creates a rectangular self loop path.</para>
      </summary>
      <param name="sx">
        <para>The x coordinate of the source port.</para>
      </param>
      <param name="sy">
        <para>The y coordinate of the source port.</para>
      </param>
      <param name="oppositeX">
        <para>The x coordinate of the single control point.</para>
      </param>
      <param name="oppositeY">
        <para>The y coordinate of the single control point.</para>
      </param>
      <param name="tx">
        <para>The x coordinate of the target port.</para>
      </param>
      <param name="ty">
        <para>The y coordinate of the target port.</para>
      </param>
      <returns>
        <para>A path that describes a rectangular self loop.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreateSelfLoopPath(System.Boolean)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreateRoundSelfLoop(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Static utility method that creates a round self loop path.</para>
      </summary>
      <param name="sx">
        <para>The x coordinate of the source port.</para>
      </param>
      <param name="sy">
        <para>The y coordinate of the source port.</para>
      </param>
      <param name="oppositeX">
        <para>The x coordinate of the single control point.</para>
      </param>
      <param name="oppositeY">
        <para>The y coordinate of the single control point.</para>
      </param>
      <param name="tx">
        <para>The x coordinate of the target port.</para>
      </param>
      <param name="ty">
        <para>The y coordinate of the target port.</para>
      </param>
      <returns>
        <para>A path that describes a round self loop.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.CreateSelfLoopPath(System.Boolean)" />
    </member>
    <member name="P:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.SelfLoopDistance">
      <summary>
        <para>Gets or sets the distance between the node's layout and its self loop control points.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.PathBasedEdgeStyleRenderer`1.GetPath" />
    <member name="T:yWorks.Graph.Styles.PolylineEdgeStyleRenderer">
      <summary>
        <para>An <see cref="T:yWorks.Graph.Styles.IEdgeStyleRenderer" /> that will render <see cref="T:yWorks.Graph.Styles.PolylineEdgeStyle" /> instances.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyleRenderer.CreatePath" />
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyleRenderer.GetSmoothingLength">
      <summary>
        <para>Gets the value that determines the radius of the smoothing arcs that can be added to the path at the bends.</para>
      </summary>
      <returns>
        <para>The radius of the arcs to use at the bends of the path.</para>
      </returns>
      <remarks>
        <para>This implementation returns <see cref="P:yWorks.Graph.Styles.PolylineEdgeStyle.SmoothingLength" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyleRenderer.GetPen" />
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyleRenderer.GetTangent(System.Double)">
      <param name="ratio" />
    </member>
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyleRenderer.GetTangent(System.Int32,System.Double)">
      <param name="segmentIndex" />
      <param name="ratio" />
    </member>
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyleRenderer.GetSegmentCount" />
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyleRenderer.GetTargetArrow">
      <summary>
        <para>Gets the target arrow from the style via <see cref="P:yWorks.Graph.Styles.IArrowOwner.TargetArrow" />.</para>
      </summary>
      <returns>
        <para>The arrow to use.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyleRenderer.GetSourceArrow">
      <summary>
        <para>Gets the source arrow from the style via <see cref="P:yWorks.Graph.Styles.IArrowOwner.SourceArrow" />.</para>
      </summary>
      <returns>
        <para>The arrow to use.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.PolylineEdgeStyle">
      <summary>
        <para>A polygonal <see cref="T:yWorks.Graph.Styles.IEdgeStyle" /> where straight line segments are used to connect the bends.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyle.#ctor">
      <summary>
        <para>Creates a new instance using <see cref="T:yWorks.Graph.Styles.PolylineEdgeStyleRenderer" /> as renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyle.#ctor(yWorks.Graph.Styles.PolylineEdgeStyleRenderer)">
      <summary>
        <para>Creates a new instance using the provided renderer.</para>
      </summary>
      <param name="renderer">
        <para>The custom renderer for this style instance.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.PolylineEdgeStyle.Pen">
      <summary>
        <para>Gets or sets the <see cref="T:System.Drawing.Pen" /> for the line.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="P:System.Drawing.Pens.Black" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.PolylineEdgeStyle.SmoothingLength">
      <summary>
        <para>Gets or sets the smoothing length used for creating smooth bends.</para>
      </summary>
      <remarks>
        <para>A value of <c>0.0d</c> will disable smoothing.</para>
        <para>The default value is <c>0</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.PolylineEdgeStyle.TargetArrow">
      <summary>
        <para>Gets or sets the visual arrow at the target end of edges that use this style.</para>
      </summary>
      <remarks>
        <para>Arrow instances may be shared between multiple style instances.</para>
        <para>This property may not be <c>null</c>. To have no target arrow set, use <see cref="F:yWorks.Graph.Styles.Arrows.None" /> instead.</para>
        <para>The default value is <see cref="F:yWorks.Graph.Styles.Arrows.None" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.PolylineEdgeStyle.SourceArrow">
      <summary>
        <para>Gets or sets the visual arrow at the source end of edges that use this style.</para>
      </summary>
      <remarks>
        <para>Arrow instances may be shared between multiple style instances.</para>
        <para>This property may not be <c>null</c>. To have no source arrow set, use <see cref="F:yWorks.Graph.Styles.Arrows.None" /> instead.</para>
        <para>The default value is <see cref="F:yWorks.Graph.Styles.Arrows.None" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.PolylineEdgeStyle.Renderer">
      <summary>
        <para>Gets the renderer implementation that has been supplied to this instance in the constructor.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.PolylineEdgeStyle.Clone">
      <summary>
        <para>Performs a <see cref="M:System.Object.MemberwiseClone" /></para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.PortStyleBase`1">
      <summary>
        <para>An abstract base class that makes it possible to easily implement a custom <see cref="T:yWorks.Graph.Styles.IPortStyle" />.</para>
      </summary>
      <remarks>
        <para>Only <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IPort)" /> and <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.IPort)" /> need to be implemented by subclasses, however to improve rendering performance it is highly recommended to implement at least <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IPort)" />, too.</para>
        <para>This implementation differs from the straightforward <see cref="T:yWorks.Graph.Styles.IPortStyle" /> implementation in that there is no visible separation between the style and its <see cref="T:yWorks.Graph.Styles.IPortStyleRenderer" />. Instead the renderer used by the base class is fixed and delegates all calls back to the style instance.</para>
      </remarks>
      <typeparam name="TVisual">
        <para>The type of the visual this instance will create. Subclasses will probably declare a fixed type to make the implementation of <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IPort)" /> and <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IPort)" /> more convenient.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Graph.Styles.PortStyleBase`1.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.PortStyleBase`1" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.PortStyleBase`1.Renderer">
      <summary>
        <para>Gets the renderer implementation for this instance.</para>
      </summary>
      <remarks>
        <para>The private implementation will delegate all API calls back to this instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.PortStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IPort)">
      <summary>
        <para>Callback that creates the visual.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.PortStyleBase`1.Renderer" />.</para>
      </remarks>
      <param name="context">
        <para>The render context.</para>
      </param>
      <param name="port">
        <para>The port to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual as required by the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> interface.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PortStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IPort)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PortStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IPort)">
      <summary>
        <para>Callback that updates the visual previously created by <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IPort)" />.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.PortStyleBase`1.Renderer" />. This implementation simply delegates to <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IPort)" /> so subclasses should override to improve rendering performance.</para>
      </remarks>
      <param name="context">
        <para>The render context.</para>
      </param>
      <param name="oldVisual">
        <para>The visual that has been created in the call to <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IPort)" />.</para>
      </param>
      <param name="port">
        <para>The port to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual as required by the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> interface.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.PortStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IPort)" />
    </member>
    <member name="M:yWorks.Graph.Styles.PortStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.IPort)">
      <summary>
        <para>Callback that returns the bounds of the visual for the port in the given context.</para>
      </summary>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="port">
        <para>The port to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual bounds of the visual representation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PortStyleBase`1.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD,yWorks.Graph.IPort)">
      <summary>
        <para>Determines whether the visualization for the specified port is visible in the context.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisibilityTestable.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.PortStyleBase`1.Renderer" />. This implementation simply tests whether the <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.IPort)">bounds</see> intersect the clip.</para>
      </remarks>
      <param name="context">
        <para>The canvas context.</para>
      </param>
      <param name="rectangle">
        <para>The clipping rectangle.</para>
      </param>
      <param name="port">
        <para>The port to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified port is visible in the clipping rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PortStyleBase`1.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Graph.IPort)">
      <summary>
        <para>Determines whether the visual representation of the port has been hit at the given location.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.PortStyleBase`1.Renderer" />.</para>
        <para>This implementation uses the <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.IPort)">bounds</see> to determine whether the port has been hit.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="location">
        <para>The point to test.</para>
      </param>
      <param name="port">
        <para>The port to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified port representation is hit; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PortStyleBase`1.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD,yWorks.Graph.IPort)">
      <summary>
        <para>Determines whether the visualization for the specified port is included in the marquee selection.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.Input.IMarqueeTestable.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.PortStyleBase`1.Renderer" />.</para>
        <para>This implementation simply tests whether the <see cref="M:yWorks.Graph.Styles.PortStyleBase`1.GetBounds(yWorks.Controls.ICanvasContext,yWorks.Graph.IPort)">bounds</see> intersect the marquee box.</para>
      </remarks>
      <param name="context">
        <para>The input mode context.</para>
      </param>
      <param name="rectangle">
        <para>The marquee selection box.</para>
      </param>
      <param name="port">
        <para>The port to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified port is visible is selected by the marquee rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PortStyleBase`1.Lookup(yWorks.Graph.IPort,System.Type)">
      <summary>
        <para>Performs the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> operation for the <see cref="M:yWorks.Graph.Styles.IPortStyleRenderer.GetContext(yWorks.Graph.IPort,yWorks.Graph.Styles.IPortStyle)" /> that has been queried from the <see cref="P:yWorks.Graph.Styles.PortStyleBase`1.Renderer" />.</para>
      </summary>
      <remarks>
        <para>This implementation yields <c>null</c> for everything but:</para>
        <list type="bullet">
          <item>
            <see cref="T:yWorks.Controls.Input.IHitTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IVisualCreator" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IBoundsProvider" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.IVisibilityTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Controls.Input.IMarqueeTestable" />
          </item>
          <item>
            <see cref="T:yWorks.Graph.ILookup" />
          </item>
        </list>
        <para>For these interfaces an implementation will be returned that delegates to the methods in this instance.</para>
      </remarks>
      <param name="port">
        <para>The port to use for the context lookup.</para>
      </param>
      <param name="type">
        <para>The type to query.</para>
      </param>
      <returns>
        <para>An implementation of the <paramref name="type" /> or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.PortStyleBase`1.Clone">
      <summary>
        <para>Creates a new object that is a copy of the current instance.</para>
      </summary>
      <remarks>
        <para>Immutable subclasses should consider returning <c>this</c>.</para>
      </remarks>
      <returns>
        <para>A new object that is a copy of this instance using <see cref="M:System.Object.MemberwiseClone" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.ShadowNodeStyleDecorator">
      <summary>
        <para>Decorates other node styles with a smooth drop shadow.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ShadowNodeStyleDecorator.#ctor">
      <summary>
        <para>Creates a new instance wrapping a simple <see cref="T:yWorks.Graph.Styles.ShapeNodeStyle" />.</para>
      </summary>
      <remarks>
        <para>The provided instance is used by reference, so subsequent changes to the style will affect the appearance of this style.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.Styles.ShadowNodeStyleDecorator.Wrapped" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShadowNodeStyleDecorator.#ctor(yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Creates a new instance wrapping the provided style.</para>
      </summary>
      <remarks>
        <para>The provided instance is used by reference, so subsequent changes to the style will affect the appearance of this style.</para>
      </remarks>
      <param name="wrapped">
        <para>The style to wrap.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.ShadowNodeStyleDecorator.Wrapped">
      <summary>
        <para>Gets or sets the wrapped node style instance by reference.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ShadowNodeStyleDecorator.Clone" />
    <member name="T:yWorks.Graph.Styles.ShapeNodeShape">
      <summary>
        <para>This enumeration predefines some often used shapes that can be used together with <see cref="T:yWorks.Graph.Styles.ShapeNodeStyle" /> instances</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Rectangle">
      <summary>
        <para>A rectangular shape</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.RoundRectangle">
      <summary>
        <para>A rectangular shape with rounded edges</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Ellipse">
      <summary>
        <para>An elliptical shape</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Triangle">
      <summary>
        <para>A triangular shape that points to the top</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Triangle2">
      <summary>
        <para>A triangular shape that points to the bottom</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.ShearedRectangle">
      <summary>
        <para>A rectangle that is sheared in the horizontal direction to the right</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.ShearedRectangle2">
      <summary>
        <para>A rectangle that is sheared in the horizontal direction to the left</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Trapez">
      <summary>
        <para>A trapezoid shape that is smaller at the bottom</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Trapez2">
      <summary>
        <para>A trapezoid shape that is smaller at the top</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Star5">
      <summary>
        <para>A 5-star shape</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Star6">
      <summary>
        <para>A 6-star shape</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Star8">
      <summary>
        <para>An 8-star shape</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.FatArrow">
      <summary>
        <para>An arrow like shape that points to the right</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.FatArrow2">
      <summary>
        <para>An arrow like shape that points to the left</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Diamond">
      <summary>
        <para>A symmetric parallelogram shape that has sloped edges</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Octagon">
      <summary>
        <para>A regular eight-sided shape,</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.ShapeNodeShape.Hexagon">
      <summary>
        <para>A regular six-sided shape,</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.ShapeNodeStyleRenderer">
      <summary>
        <para>Default renderer implementation that can be used for <see cref="T:yWorks.Graph.Styles.ShapeNodeStyle" /> instances.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node">
      <summary>
        <para>Gets or sets the currently configured node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the <see cref="T:yWorks.Controls.IVisualCreator" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query hit test with. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="node">
        <para>The node to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="node">
        <para>The node to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Lookup(System.Type)">
      <summary>
        <para>Implements the <see cref="T:yWorks.Graph.ILookup" /> interface.</para>
      </summary>
      <remarks>
        <para>This method will be used by default if <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> has been queried for a lookup implementation. Note that it cannot be assumed that <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" /> has already been invoked. However, normally <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node" /> and <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> will be correctly configured if invoked directly after <c>GetContext</c>. Subclass implementations should make sure to configure this instance before they return <c>this</c> as a result of a successful lookup. This implementation will check if <c>type.IsInstanceOfType(this)</c> and will call <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" /> on success and return <c>this</c>.</para>
      </remarks>
      <param name="type">
        <para>The type to query for.</para>
      </param>
      <returns>
        <para>An implementation or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Tests the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node">node</see> using the current <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> for an intersection with the given box.</para>
      </summary>
      <param name="context">
        <para>the current input mode context</para>
      </param>
      <param name="rectangle">
        <para>the box describing the marquee's bounds</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the node is considered to be captured by the marquee</para>
      </returns>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Layout" /> to determine whether the node is in the box.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Determines visibility by checking for an intersection with the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Layout" />.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="rectangle">
        <para>The current clip</para>
      </param>
      <returns>
        <para>Whether the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Layout" /> is visible in the clip.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <summary>
        <para>Returns the layout bounds as an upper bound for the painting bound.</para>
      </summary>
      <param name="context">
        <para>the context to calculate the bounds for</para>
      </param>
      <returns>
        <para>the bounds or <c>null</c> to indicate an unbound area</para>
      </returns>
      <remarks>
        <para>This implementation simply sets the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Layout" />'s bounds to the scratch variable and returns.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node" /> properties, calls <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the shape geometry for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Layout">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.INode.Layout" /> of the node this renderer is currently configured for.</para>
      </summary>
      <remarks>
        <para>Returns <c>Node.Layout</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.RoundRectArcRadius">
      <summary>
        <para>Gets or sets the radius that is used to draw rounded edges.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.NormalizeBrushes">
      <summary>
        <para>Determines whether brushes should be normalized.</para>
      </summary>
      <returns>
        <para>
          <see cref="P:yWorks.Graph.Styles.ShapeNodeStyle.NormalizeBrushes" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="inner" />
      <param name="outer" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)">
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetShape">
      <summary>
        <para>Get the shape that is currently used by this renderer.</para>
      </summary>
      <remarks>
        <para>This implementation retrieves the shape from the owning style</para>
      </remarks>
      <returns>
        <para>The shape that is currently used by this renderer.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetBrush">
      <summary>
        <para>Get the brush that is currently used by this renderer.</para>
      </summary>
      <remarks>
        <para>This implementation retrieves the brush from the owning style. If <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.NormalizeBrushes" /> returns <c>true</c> the brush is normalized if it is not a <see cref="T:System.Drawing.SolidBrush" />.</para>
      </remarks>
      <returns>
        <para>The brush that is currently used by this renderer.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetPen">
      <summary>
        <para>Get the pen that is currently used by this renderer.</para>
      </summary>
      <remarks>
        <para>This implementation retrieves the pen from the owning style</para>
      </remarks>
      <returns>
        <para>The pen that is currently used by this renderer.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and node have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.ShapeNodeStyleRenderer.Node" /> properies have been populated by the <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, or <see cref="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> methods.</para>
        <para>This is an empty implementation. Subclasses might have to override this method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyleRenderer.GetOutline" />
    <member name="T:yWorks.Graph.Styles.ShapeNodeStyle">
      <summary>
        <para>Node style implementation that can show predefined shapes of type <see cref="T:yWorks.Graph.Styles.ShapeNodeShape" />.</para>
      </summary>
      <remarks>
        <para>This style can be used together with <see cref="T:yWorks.Graph.Styles.ShapeNodeStyleRenderer" /> instances.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyle.#ctor">
      <summary>
        <para>Creates a new instance using <see cref="T:yWorks.Graph.Styles.ShapeNodeStyleRenderer" /> as renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyle.#ctor(yWorks.Graph.Styles.ShapeNodeStyleRenderer)">
      <summary>
        <para>Creates a new instance using the provided renderer.</para>
      </summary>
      <param name="renderer">
        <para>Custom renderer instance for this style.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.ShapeNodeStyle.Pen">
      <summary>
        <para>Gets or sets the <see cref="T:System.Drawing.Pen" /> for this style.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="P:System.Drawing.Pens.Black" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ShapeNodeStyle.Brush">
      <summary>
        <para>Gets or sets the <see cref="T:System.Drawing.Brush" /> for this style.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="P:System.Drawing.Brushes.White" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ShapeNodeStyle.Shape">
      <summary>
        <para>Gets or sets the shape for this style.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="F:yWorks.Graph.Styles.ShapeNodeShape.Rectangle" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ShapeNodeStyle.NormalizeBrushes">
      <summary>
        <para>Gets or sets whether to normalize the brush.</para>
      </summary>
      <remarks>
        <para>Applies a matrix on non-<see cref="T:System.Drawing.SolidBrush" />es to ensure that e.g. gradients are stretched over the entire node.</para>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.ShapeNodeStyle.Clone" />
    <member name="T:yWorks.Graph.Styles.ShinyPlateNodeStyle">
      <summary>
        <para>Implementation of the <see cref="T:yWorks.Graph.Styles.INodeStyle" /> which creates rectangular nodes with rounded corners and a highlighted ('shiny plate') interior.</para>
      </summary>
      <remarks>
        <para>By default, this style renders a drop shadow by itself.</para>
        <para>This style uses the <see cref="T:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer" /> to visualize a node.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyle.#ctor">
      <summary>
        <para>Creates a new instance using <see cref="T:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer" /> as renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyle.#ctor(yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer)">
      <summary>
        <para>Creates a new instance using the provided renderer.</para>
      </summary>
      <param name="renderer" />
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyle.Brush">
      <summary>
        <para>Gets or sets the background brush for this style.</para>
      </summary>
      <remarks>
        <para>The default value is <see cref="P:System.Drawing.Brushes.Black" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyle.Pen">
      <summary>
        <para>Gets or sets the pen to use for the outline.</para>
      </summary>
      <remarks>
        <para>The default value is <c>null</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyle.Radius">
      <summary>
        <para>Gets or sets the corner radius of the rounded rectangle</para>
      </summary>
      <remarks>
        <para>The default value is <c>5</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyle.DrawShadow">
      <summary>
        <para>Gets or sets a value indicating whether to draw a drop shadow.</para>
      </summary>
      <remarks>
        <para>The default value is <c>true</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyle.Insets">
      <summary>
        <para>Gets or sets the instance to use that provides the insets for this style.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer" /> will use these insets and return them via an <see cref="T:yWorks.Controls.Input.INodeInsetsProvider" /> if such an instance is queried through the <see cref="M:yWorks.Graph.Styles.INodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">context lookup</see>.</para>
        <para>The default insets are set to (5,5,5,5).</para>
      </remarks>
      <seealso cref="T:yWorks.Controls.Input.INodeInsetsProvider" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyle.Clone" />
    <member name="T:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer">
      <summary>
        <para>A <see cref="T:yWorks.Graph.Styles.INodeStyle" /> <see cref="T:yWorks.Graph.Styles.INodeStyleRenderer">renderer</see> implementation that draws a simple floating shinyPlate with a slight gradient, a thin border and a simple drop shadow.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.Styles.ShinyPlateNodeStyle" />
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node">
      <summary>
        <para>Gets or sets the currently configured node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the <see cref="T:yWorks.Controls.IVisualCreator" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query hit test with. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="node">
        <para>The node to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="node">
        <para>The node to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Tests the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node">node</see> using the current <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style" /> for an intersection with the given box.</para>
      </summary>
      <param name="context">
        <para>the current input mode context</para>
      </param>
      <param name="rectangle">
        <para>the box describing the marquee's bounds</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the node is considered to be captured by the marquee</para>
      </returns>
      <remarks>
        <para>This implementation uses the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Layout" /> to determine whether the node is in the box.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node" /> properties, calls <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the shape geometry for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Layout">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.INode.Layout" /> of the node this renderer is currently configured for.</para>
      </summary>
      <remarks>
        <para>Returns <c>Node.Layout</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="inner" />
      <param name="outer" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)">
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetOutline" />
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and node have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Node" /> properties have been populated by the <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, or <see cref="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> methods.</para>
        <para>This is an empty implementation. Subclasses might have to override this method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.DrawShadow">
      <summary>
        <para>Determines whether to draw the drop shadow.</para>
      </summary>
      <returns>
        <para>
          <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyle.DrawShadow" />.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Brush">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Brush" /> from the style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Pen">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Pen" /> from the style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Radius">
      <summary>
        <para>Gets the radius from the style.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="M:yWorks.Graph.Styles.ShinyPlateNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <param name="context" />
    </member>
    <member name="T:yWorks.Graph.Styles.TableRenderingOrder">
      <summary>
        <para>Enumeration that is used to specify the drawing order for rows and columns</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.TableRenderingOrder.ColumnsFirst">
      <summary>
        <para>Draw columns, then rows</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Styles.TableRenderingOrder.RowsFirst">
      <summary>
        <para>Draw rows, then columns</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.StripeHitTester">
      <summary>
        <para>Support class that allows to iterate over hits on table elements or subregions of table elements.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.StripeHitTester.Table">
      <summary>
        <para>Gets the table that is currently used by this instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Input.StripeHitTester.TableRenderingOrder">
      <summary>
        <para>Return the hit test order that is currently used by this instance</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.StripeHitTester.#ctor(yWorks.Graph.ITable,yWorks.Graph.Styles.TableRenderingOrder)">
      <summary>
        <para>Create a new instance for a specific table instance that use the order specified by <paramref name="tableRenderingOrder" /> to determine the order of the hit test results.</para>
      </summary>
      <param name="table">
        <para>The table to use</para>
      </param>
      <param name="tableRenderingOrder">
        <para>The hit test order. This determines the order in which stripes are returned by <see cref="M:yWorks.Controls.Input.StripeHitTester.EnumerateHits(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Graph.INode)" /></para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.StripeHitTester.EnumerateHits(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD,yWorks.Graph.INode)">
      <summary>
        <para>Return a collection of hits at <paramref name="location" />.</para>
      </summary>
      <remarks>
        <para>This implementation returns the hits in the following order:</para>
        <list type="number">
          <item>First all <see cref="T:yWorks.Graph.IRow" />s or <see cref="T:yWorks.Graph.IColumn" />s at the given location, in the order specified by the <see cref="P:yWorks.Controls.Input.StripeHitTester.TableRenderingOrder" /> property.</item>
          <item>For each stripe type, the stripes are returned in bottom up order, i.e. children are returned before their parents.</item>
          <item>For each stripe, the subregions are returned in the order <see cref="F:yWorks.Controls.Input.StripeSubregionTypes.NearBorder" />, <see cref="F:yWorks.Controls.Input.StripeSubregionTypes.FarBorder" />, <see cref="F:yWorks.Controls.Input.StripeSubregionTypes.LeadingHeader" />, <see cref="F:yWorks.Controls.Input.StripeSubregionTypes.TrailingHeader" />,<see cref="F:yWorks.Controls.Input.StripeSubregionTypes.Stripe" />, e.g. a header hit is always returned before a hit on the whole stripe.</item>
        </list>
      </remarks>
      <param name="context">
        <para>The input mode context to use.</para>
      </param>
      <param name="location">
        <para>The location in absolute coordinates.</para>
      </param>
      <param name="node">
        <para>The node where the table instance is currently bound to.</para>
      </param>
      <returns>
        <para>A collection of <see cref="T:yWorks.Controls.Input.StripeSubregion" />s at <paramref name="location" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.StripeStyleBase`1">
      <summary>
        <para>An abstract base class that makes it possible to easily implement a custom <see cref="T:yWorks.Graph.Styles.IStripeStyle" />.</para>
      </summary>
      <remarks>
        <para>The only method that needs to be implemented by subclasses is <see cref="M:yWorks.Graph.Styles.StripeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IStripe)" />, however to improve rendering performance it is highly recommended to implement at least <see cref="M:yWorks.Graph.Styles.StripeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IStripe)" />, too.</para>
        <para>This implementation differs from the straightforward <see cref="T:yWorks.Graph.Styles.IStripeStyle" /> implementation in that there is no visible separation between the style and its <see cref="T:yWorks.Graph.Styles.IStripeStyleRenderer" />. Instead the renderer used by the base class is fixed and delegates all calls back to the style instance.</para>
      </remarks>
      <typeparam name="TVisual">
        <para>The type of the visual this instance will create. Subclasses will probably declare a fixed type to make the implementation of <see cref="M:yWorks.Graph.Styles.StripeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IStripe)" /> and <see cref="M:yWorks.Graph.Styles.StripeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IStripe)" /> more convenient.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Graph.Styles.StripeStyleBase`1.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.Styles.StripeStyleBase`1" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.StripeStyleBase`1.Renderer">
      <summary>
        <para>Gets the renderer implementation for this instance.</para>
      </summary>
      <remarks>
        <para>The private implementation will delegate all API calls back to this instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.StripeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IStripe)">
      <summary>
        <para>Callback that creates the visual.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.StripeStyleBase`1.Renderer" />.</para>
      </remarks>
      <param name="context" />
      <param name="stripe">
        <para>The stripe to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual as required by the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> interface.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.StripeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IStripe)" />
    </member>
    <member name="M:yWorks.Graph.Styles.StripeStyleBase`1.UpdateVisual(yWorks.Controls.IRenderContext,`0,yWorks.Graph.IStripe)">
      <summary>
        <para>Callback that updates the visual previously created by <see cref="M:yWorks.Graph.Styles.StripeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IStripe)" />.</para>
      </summary>
      <remarks>
        <para>This method is called in response to a <see cref="M:yWorks.Controls.IVisualCreator.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" /> call to the instance that has been queried from the <see cref="P:yWorks.Graph.Styles.StripeStyleBase`1.Renderer" />. This implementation simply delegates to <see cref="M:yWorks.Graph.Styles.StripeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IStripe)" /> so subclasses should override to improve rendering performance.</para>
      </remarks>
      <param name="context" />
      <param name="oldVisual">
        <para>The visual that has been created in the call to <see cref="M:yWorks.Graph.Styles.StripeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IStripe)" />.</para>
      </param>
      <param name="stripe">
        <para>The stripe to which this style instance is assigned.</para>
      </param>
      <returns>
        <para>The visual as required by the <see cref="M:yWorks.Controls.IVisualCreator.CreateVisual(yWorks.Controls.IRenderContext)" /> interface.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.StripeStyleBase`1.CreateVisual(yWorks.Controls.IRenderContext,yWorks.Graph.IStripe)" />
    </member>
    <member name="M:yWorks.Graph.Styles.StripeStyleBase`1.Lookup(yWorks.Graph.IStripe,System.Type)">
      <summary>
        <para>Performs the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> operation for the <see cref="M:yWorks.Graph.Styles.IStripeStyleRenderer.GetContext(yWorks.Graph.IStripe,yWorks.Graph.Styles.IStripeStyle)" /> that has been queried from the <see cref="P:yWorks.Graph.Styles.StripeStyleBase`1.Renderer" />.</para>
      </summary>
      <remarks>
        <para>This implementation yields <c>null</c> for everything but:</para>
        <list type="bullet">
          <item>
            <see cref="T:yWorks.Controls.IVisualCreator" />
          </item>
          <item>
            <see cref="T:yWorks.Graph.ILookup" />
          </item>
        </list>
        <para>For these interfaces an implementation will be returned that delegates to the methods in this instance.</para>
      </remarks>
      <param name="stripe">
        <para>The stripe to use for the context lookup.</para>
      </param>
      <param name="type">
        <para>The type to query.</para>
      </param>
      <returns>
        <para>An implementation of the <paramref name="type" /> or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.StripeStyleBase`1.Clone">
      <summary>
        <para>Creates a new object that is a copy of the current instance.</para>
      </summary>
      <remarks>
        <para>Immutable subclasses should consider returning <c>this</c>.</para>
      </remarks>
      <returns>
        <para>A new object that is a copy of this instance using <see cref="M:System.Object.MemberwiseClone" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.Styles.TableNodeStyle">
      <summary>
        <para>A <see cref="T:yWorks.Graph.Styles.INodeStyle" /> for <see cref="T:yWorks.Graph.ITable">tables</see>.</para>
      </summary>
      <remarks>
        <para>This implementations stores the table instance and therefore, its instances cannot be shared among different table instances.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyle.#ctor">
      <summary>
        <para>Default constructor that creates an empty table.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyle.#ctor(yWorks.Graph.ITable,yWorks.Graph.Styles.TableNodeStyleRenderer)">
      <summary>
        <para>Constructor with a custom renderer implementation that uses <paramref name="table" /> as backing table model.</para>
      </summary>
      <param name="table">
        <para>The table instance that defines the tabular structure.</para>
      </param>
      <param name="renderer">
        <para>Custom renderer instance for this style.</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.TableNodeStyle.TableRenderingOrder">
      <summary>
        <para>Gets or sets the order in which rows and columns are rendered.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.TableNodeStyle.BackgroundStyle">
      <summary>
        <para>Gets or sets the style that is used to draw the background of the table</para>
      </summary>
    </member>
    <member name="E:yWorks.Graph.Styles.TableNodeStyle.PropertyChanged">
      <summary>
        <para>Occurs when the value of the <see cref="P:yWorks.Graph.Styles.TableNodeStyle.Table" /> property changes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyle.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
      <summary>
        <para>Raises the <see cref="E:yWorks.Graph.Styles.TableNodeStyle.PropertyChanged" /> event.</para>
      </summary>
      <remarks>
        <para>Called when the value of the <see cref="P:yWorks.Graph.Styles.TableNodeStyle.Table" /> property changes.</para>
      </remarks>
      <param name="e">
        <para>The <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> instance containing the event data.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyle.Clone" />
    <member name="M:yWorks.Graph.Styles.TableNodeStyle.CopyBackgroundStyle(yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Create a copy of the background style when this style instance is cloned</para>
      </summary>
      <param name="style">
        <para>The original background node style</para>
      </param>
      <returns>
        <para>This implementation always returns the original <paramref name="style" /> instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyle.CopyTable(yWorks.Graph.ITable)">
      <summary>
        <para>Create a copy of the table when this style instance is cloned</para>
      </summary>
      <param name="table">
        <para>The original table instance</para>
      </param>
      <returns>
        <para>This implementation always tries to <see cref="M:System.ICloneable.Clone" /> clone the original <paramref name="table" /> instance, if possible, otherwise it returns <paramref name="table" /> unchanged.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.Styles.TableNodeStyle.Table">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Graph.ITable" /> instance that defines the tabular structure.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.TableNodeStyleRenderer">
      <summary>
        <para>Default renderer implementation that can be used for <see cref="T:yWorks.Graph.Styles.TableNodeStyle" /> instances.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.TableNodeStyleRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.TableNodeStyleRenderer.Node">
      <summary>
        <para>Gets or sets the currently configured node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and node have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.TableNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.TableNodeStyleRenderer.Node" /> properties have been populated by the <see cref="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, or <see cref="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> methods.</para>
        <para>This is an empty implementation. Subclasses might have to override this method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <param name="node" />
      <param name="style" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <param name="context" />
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <param name="inner" />
      <param name="outer" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)">
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetOutline" />
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetTable">
      <summary>
        <para>Gets the table object that should be used for rendering.</para>
      </summary>
      <remarks>
        <para>This implementation delegates to the Table provided by the <see cref="P:yWorks.Graph.Styles.TableNodeStyle.Table" /> property.</para>
      </remarks>
      <returns>
        <para>The table that should be used for the rendering process.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetTableRenderingOrder">
      <summary>
        <para>Get the <see cref="T:yWorks.Graph.Styles.TableRenderingOrder" /> that is currently used by this renderer.</para>
      </summary>
      <remarks>
        <para>This implementation retrieves the <see cref="T:yWorks.Graph.Styles.TableRenderingOrder" /> from the owning style</para>
      </remarks>
      <returns>
        <para>The <see cref="T:yWorks.Graph.Styles.TableRenderingOrder" /> that is currently used by this renderer.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.GetBackgroundStyle">
      <summary>
        <para>Get the <see cref="T:yWorks.Graph.Styles.INodeStyle">background style</see> that is currently used by this renderer.</para>
      </summary>
      <remarks>
        <para>This implementation retrieves the <see cref="P:yWorks.Graph.Styles.TableNodeStyle.BackgroundStyle" /> from the owning style</para>
      </remarks>
      <returns>
        <para>The <see cref="T:yWorks.Graph.Styles.INodeStyle">background style</see> that is currently used by this renderer.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.TableNodeStyleRenderer.Lookup(System.Type)">
      <param name="type" />
    </member>
    <member name="T:yWorks.Graph.Styles.UriImageNodeStyleRenderer">
      <summary>
        <para>A style renderer implementation that can be used together with <see cref="T:yWorks.Graph.Styles.UriImageNodeStyle" /> instances.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style">
      <summary>
        <para>Gets or sets the currently configured style.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node">
      <summary>
        <para>Gets or sets the currently configured node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure">
      <summary>
        <para>Prepares this instance for subsequent calls after the style and node have been initialized.</para>
      </summary>
      <remarks>
        <para>Upon invocation the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node" /> properties have been populated by the <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" />, or <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> methods.</para>
        <para>This is an empty implementation. Subclasses might have to override this method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetVisualCreator(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the <see cref="T:yWorks.Controls.IVisualCreator" /> for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)" />
      <seealso cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetBoundsProvider(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the bounds provider for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetHitTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query hit test with. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetMarqueeTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, calls <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to query marquee intersection tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetVisibilityTestable(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>Unlike most of the other methods this implementation does <b>not</b> call <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" />. If the subclass implementation depends on this instance to be configured, it needs to call <c>Configure</c> in <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />.</para>
      </remarks>
      <param name="node">
        <para>The node to query visibility tests. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <paramref name="style" /> and <paramref name="node" /> parameters, does <b>not</b> call <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <remarks>
        <para>As this method may be called often it will not automatically call <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" />, instead subclasses should ensure that in the <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Lookup(System.Type)" /> method call they should call <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" /> only if needed, i.e. if they decide to return <c>this</c> or an instance that depends on a correctly configured <c>this</c>.</para>
      </remarks>
      <param name="node">
        <para>The node to query the context for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Lookup(System.Type)" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Lookup(System.Type)">
      <summary>
        <para>Implements the <see cref="T:yWorks.Graph.ILookup" /> interface.</para>
      </summary>
      <remarks>
        <para>This method will be used by default if <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetContext(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)" /> has been queried for a lookup implementation. Note that it cannot be assumed that <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" /> has already been invoked. However, normally <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node" /> and <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style" /> will be correctly configured if invoked directly after <c>GetContext</c>. Subclass implementations should make sure to configure this instance before they return <c>this</c> as a result of a successful lookup. This implementation will check if <c>type.IsInstanceOfType(this)</c> and will call <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" /> on success and return <c>this</c>.</para>
      </remarks>
      <param name="type">
        <para>The type to query for.</para>
      </param>
      <returns>
        <para>An implementation or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.IsVisible(yWorks.Controls.ICanvasContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Determines visibility by checking for an intersection with the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Layout" />.</para>
      </summary>
      <param name="context">
        <para>The context.</para>
      </param>
      <param name="rectangle">
        <para>The current clip</para>
      </param>
      <returns>
        <para>Whether the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Layout" /> is visible in the clip.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetBounds(yWorks.Controls.ICanvasContext)">
      <summary>
        <para>Returns the layout bounds as an upper bound for the painting bound.</para>
      </summary>
      <param name="context">
        <para>the context to calculate the bounds for</para>
      </param>
      <returns>
        <para>the bounds or <c>null</c> to indicate an unbound area</para>
      </returns>
      <remarks>
        <para>This implementation simply sets the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Layout" />'s bounds to the scratch variable and returns.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetShapeGeometry(yWorks.Graph.INode,yWorks.Graph.Styles.INodeStyle)">
      <summary>
        <para>Configures the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style" /> and <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node" /> properties, calls <see cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Configure" /> and returns <c>this</c>.</para>
      </summary>
      <param name="node">
        <para>The node to retrieve the shape geometry for. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Node" /> property.</para>
      </param>
      <param name="style">
        <para>The style to associate with the node. The value will be stored in the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Style" /> property.</para>
      </param>
      <returns>
        <para>
          <c>this</c>
        </para>
      </returns>
      <seealso cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)" />
      <seealso cref="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)" />
    </member>
    <member name="P:yWorks.Graph.Styles.UriImageNodeStyleRenderer.Layout">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.INode.Layout" /> of the node this renderer is currently configured for.</para>
      </summary>
      <remarks>
        <para>Returns <c>Node.Layout</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetImage">
      <summary>
        <para>Get the image that is currently used to render the style.</para>
      </summary>
      <returns />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.#ctor">
      <summary>
        <para>Create a new instance of this renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.CreateVisual(yWorks.Controls.IRenderContext)">
      <param name="context" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.UpdateVisual(yWorks.Controls.IRenderContext,yWorks.Controls.IVisual)">
      <param name="context" />
      <param name="oldVisual" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)">
      <summary>
        <para>Tries to use <see cref="P:yWorks.Graph.Styles.UriImageNodeStyle.OutlineShape" /> to perform the hit test analysis, otherwise reverts to default (rectangular) behavior.</para>
      </summary>
      <param name="context">
        <para>the context the hit test is performed in</para>
      </param>
      <param name="location">
        <para>the coordinates in world coordinate system</para>
      </param>
      <returns>
        <para>whether something has been hit</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetInterpolationMode">
      <summary>
        <para>Gets the interpolation mode for to set on the graphics context for rendering of the image.</para>
      </summary>
      <remarks>
        <para>A value of <see cref="F:System.Drawing.Drawing2D.InterpolationMode.Invalid" /> is interpreted as follows: use the value currently set on the graphics context.</para>
      </remarks>
      <returns>
        <para>
          <see cref="F:System.Drawing.Drawing2D.InterpolationMode.Invalid" />
        </para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)">
      <summary>
        <para>Tries to use the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyle.OutlineShape" /> to perform the marquee intersection analysis, otherwise reverts to default (rectangular) behavior.</para>
      </summary>
      <param name="context" />
      <param name="rectangle" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetIntersection(yWorks.Geometry.PointD,yWorks.Geometry.PointD)">
      <summary>
        <para>Tries to use the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyle.OutlineShape" /> to perform the intersection calculation, otherwise reverts to default (rectangular) behavior.</para>
      </summary>
      <param name="inner" />
      <param name="outer" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.IsInside(yWorks.Geometry.PointD)">
      <summary>
        <para>Tries to use the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyle.OutlineShape" /> to perform the contains test, otherwise reverts to default (rectangular) behavior.</para>
      </summary>
      <param name="location" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyleRenderer.GetOutline">
      <summary>
        <para>Tries to use the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyle.OutlineShape" /> to create the outline shape path, otherwise reverts to default (rectangular) behavior.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Styles.UriImageNodeStyle">
      <summary>
        <para>An <see cref="T:yWorks.Graph.Styles.INodeStyle" /> implementation which renders images retrieved from a given URI.</para>
      </summary>
      <remarks>
        <para>This implementation retrieves the image data from a given uri. In contrast to <see cref="T:yWorks.Graph.Styles.MemoryImageNodeStyle" />, only this uri is (de)serialized to GraphML.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.Styles.UriImageNodeStyle.Uri">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyle.Uri" /> where the image is located.</para>
      </summary>
      <remarks>
        <para>Setting this property will result in rereading the image data from the uri.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyle.#ctor">
      <summary>
        <para>Create a new instance of this style with a default renderer.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyle.#ctor(System.Uri)">
      <summary>
        <para>Create a new instance of this style with a default renderer. The image is read from <paramref name="uri" />.</para>
      </summary>
      <param name="uri" />
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyle.#ctor(yWorks.Graph.Styles.UriImageNodeStyleRenderer)">
      <summary>
        <para>Create a new instance of this style with a custom renderer instance</para>
      </summary>
      <param name="styleRenderer">
        <para>The custom renderer for this instance</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyle.#ctor(System.Uri,yWorks.Graph.Styles.UriImageNodeStyleRenderer)">
      <summary>
        <para>Create a new instance of this style with a custom renderer instance. The image is read from <paramref name="uri" />.</para>
      </summary>
      <param name="uri">
        <para>The URI to use.</para>
      </param>
      <param name="styleRenderer">
        <para>The custom renderer for this instance</para>
      </param>
    </member>
    <member name="P:yWorks.Graph.Styles.UriImageNodeStyle.Image">
      <summary>
        <para>Gets the image that is used for the style instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.Styles.UriImageNodeStyle.OutlineShape">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Geometry.GeneralPath" /> of the outline of the image that will be displayed.</para>
      </summary>
      <remarks>
        <para>This shape will be used to satisfy requests to <see cref="M:yWorks.Controls.Input.IMarqueeTestable.IsInBox(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.RectD)" /> and <see cref="M:yWorks.Controls.Input.IHitTestable.IsHit(yWorks.Controls.Input.IInputModeContext,yWorks.Geometry.PointD)" /> and may be left <c>null</c> to indicate default (rectangular) behavior.</para>
        <para>The default value is <c>null</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.Styles.UriImageNodeStyle.Clone">
      <summary>
        <para>This implementation performs a shallow copy with respect to the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyle.Image" /> property.</para>
      </summary>
      <remarks>
        <para>If clients need to have a deep copy of this instance, they need to manually clone and reassign the <see cref="P:yWorks.Graph.Styles.UriImageNodeStyle.Image" /> to the clone.</para>
      </remarks>
      <returns>
        <para>A shallow copy of this instance.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.AdjacentNodesGraphBuilder`2">
      <summary>
        <para>Populates a graph from custom data where objects corresponding to nodes know their neighbors.</para>
      </summary>
      <remarks>
        <para>This class can be used when the data specifies a collection of nodes in which each node knows its direct neighbors, and—optionally—a collection of groups. The properties <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" /> and <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" /> define the source collections from which nodes and groups will be created.</para>
        <para>Generally, using the <see cref="T:yWorks.Graph.AdjacentNodesGraphBuilder`2" /> class consists of a few basic steps:</para>
        <list type="number">
          <item>Set up the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.Graph" /> with the proper defaults for items (<see cref="P:yWorks.Graph.IGraph.NodeDefaults" />, <see cref="P:yWorks.Graph.IGraph.GroupNodeDefaults" />, <see cref="P:yWorks.Graph.IGraph.EdgeDefaults" />)</item>
          <item>Create an <see cref="T:yWorks.Graph.AdjacentNodesGraphBuilder`2" />.</item>
          <item>Set the items sources. At the very least the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" /> is needed. Note that the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" /> does not have to contain all nodes, as nodes that are implicitly specified through the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.PredecessorProvider" /> and <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.SuccessorProvider" /> are automatically added to the graph as well. If the items in the nodes collection are grouped somehow, then also set the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" /> property.</item>
          <item>Set up the bindings so that a graph structure can actually be created from the items sources. This involves at least setting up either the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.PredecessorProvider" /> or <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.SuccessorProvider" /> property so that edges can be created. If the node objects don't actually contain their neighboring node objects, but instead identifiers of other node objects, then <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.PredecessorProvider" /> and <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.SuccessorProvider" /> would return those identifiers and <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeIdProvider" /> must be set to return that identifier when given a node object.</item>
          <item>If <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" /> is set, then you also need to set the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupProvider" /> property to enable mapping nodes to groups. Just like with edges and their source and target nodes, if the node object only contains an identifier for a group node and not the actual group object, then return the identifier in the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupProvider" /> and set up the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupIdProvider" /> to map group node objects to their identifiers. If group nodes can nest, you also need the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.ParentGroupProvider" />.</item>
          <item>You can also easily create labels for nodes, groups, and edges by using the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeLabelProvider" />, <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupLabelProvider" />, and <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeLabelProvider" /> properties.</item>
          <item>Call <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph" /> to populate the graph. You can apply a layout algorithm afterward to make the graph look nice.</item>
          <item>If your items or collections change later, call <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" /> to make those changes visible in the graph.</item>
        </list>
        <para>You can further customize how nodes, groups, and edges are created by adding event handlers to the various events and modifying the items there. This can be used to modify items in ways that are not directly supported by the available bindings or defaults. This includes scenarios such as the following:</para>
        <list type="bullet">
          <item>Setting node positions or adding bends to edges. Often a layout is applied to the graph after building it, so these things are only rarely needed.</item>
          <item>Modifying individual items, such as setting a different style for every nodes, depending on the bound object.</item>
          <item>Adding more than one label for an item, as the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeLabelProvider" /> and <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeLabelProvider" /> will only create a single label, or adding labels to group nodes.</item>
        </list>
        <para>There are creation and update events for all three types of items, which allows separate customization when nodes, groups, and edges are created or updated. For completely static graphs where <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" /> is not needed, the update events can be safely ignored.</para>
        <para>Depending on how the source data is laid out, you may also consider using <see cref="T:yWorks.Graph.TreeBuilder`2" />, where the graph is a tree and node objects know their children, or <see cref="T:yWorks.Graph.GraphBuilder`3" /> which is a more general approach to creating arbitrary graphs.</para>
      </remarks>
      <typeparam name="TNode">
        <para>The type of object nodes are created from. This type must implement <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.Object.GetHashCode" /> properly.</para>
      </typeparam>
      <typeparam name="TGroup">
        <para>The type of object group nodes are created from. This type must implement <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.Object.GetHashCode" /> properly.</para>
      </typeparam>
      <seealso cref="T:yWorks.Graph.GraphBuilder`3" />
      <seealso cref="T:yWorks.Graph.TreeBuilder`2" />
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.#ctor(yWorks.Graph.IGraph)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.AdjacentNodesGraphBuilder`2" /> class that operates on the given graph.</para>
      </summary>
      <remarks>
        <para>The <paramref name="graph" /> will be <see cref="M:yWorks.Graph.GraphExtensions.Clear(yWorks.Graph.IGraph)">cleared</see> and re-built from the data in <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" /> and <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" /> when <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph" /> is called.</para>
      </remarks>
      <param name="graph" />
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.Graph">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.IGraph">graph</see> used by this class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource">
      <summary>
        <para>Gets or sets the objects to be represented as nodes of the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.Graph" />.</para>
      </summary>
      <remarks>
        <para>Note that it is not necessary to include all nodes in this property, if they can be reached via the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.PredecessorProvider" /> or <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.SuccessorProvider" />. In this case it suffices to include all root nodes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource">
      <summary>
        <para>Gets or sets the objects to be represented as group nodes of the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.Graph" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeIdProvider">
      <summary>
        <para>Gets or sets a delegate that maps node objects to their identifier.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a node to its identifier. This is needed when <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.PredecessorProvider">predecessors</see> or <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.SuccessorProvider">successors</see> are represented only by an identifier of nodes instead of pointing directly to the respective node objects.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.PredecessorProvider" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.SuccessorProvider" />
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeLabelProvider">
      <summary>
        <para>Gets or sets a delegate that maps a node object to a label.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a node to an object that represents the label for the node.</para>
        <para>The resulting object will be converted into a string to be displayed as the label's text. If this is insufficient, a label can also be created directly in an event handler of the <see cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeCreated" /> event.</para>
        <para>Returning <c>null</c> from the delegate will not create a label for that node.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" />
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupProvider">
      <summary>
        <para>Gets or sets a delegate that maps node objects to their containing groups.</para>
      </summary>
      <remarks>
        <para>This maps an object <i>N</i> that represents a node to another object <i>G</i> that specifies the containing group of <i>N</i>. If <i>G</i> is contained in <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" />, then the node for <i>N</i> becomes a child node of the group for <i>G</i>.</para>
        <para>If a <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupIdProvider" /> is set, the returned object <i>G</i> must be the ID of the object that specifies the group instead of that object itself.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupIdProvider" />
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeLabelProvider">
      <summary>
        <para>Gets or sets a delegate that maps an edge, represented by its source and target node object, to a label.</para>
      </summary>
      <remarks>
        <para>This maps the source and target node objects to an object that represents the label for the edge.</para>
        <para>The resulting object will be converted into a string to be displayed as the label's text. If this is insufficient, a label can also be created directly in an event handler of the <see cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeCreated" /> event.</para>
        <para>Returning <c>null</c> from the delegate will not create a label for that edge.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupIdProvider">
      <summary>
        <para>Gets or sets a delegate that maps group objects to their identifier.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a group node to its identifier. This is needed when <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource">node objects</see> only contain an identifier to specify the group they belong to instead of pointing directly to the respective group object. The same goes for the parent group in group objects.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupProvider" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.ParentGroupProvider" />
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupLabelProvider">
      <summary>
        <para>Gets or sets a delegate that maps a group object to a label.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a group node to an object that represents the label for the group node.</para>
        <para>The resulting object will be converted into a string to be displayed as the label's text. If this is insufficient, a label can also be created directly in an event handler of the <see cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupNodeCreated" /> event.</para>
        <para>Returning <c>null</c> from the delegate will not create a label for that group node.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" />
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.ParentGroupProvider">
      <summary>
        <para>Gets or sets a delegate that maps group objects to their containing groups.</para>
      </summary>
      <remarks>
        <para>This maps an object <i>G</i> that represents a group node to another object <i>P</i> that specifies the containing group of <i>G</i>. If <i>P</i> is contained in <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" />, then the group node for <i>G</i> becomes a child node of the group for <i>P</i>.</para>
        <para>If a <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupIdProvider" /> is set, the returned object <i>P</i> must be the ID of the object that specifies the group instead of that object itself.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupIdProvider" />
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph">
      <summary>
        <para>Populates the graph with items generated from the bound data.</para>
      </summary>
      <remarks>
        <para>The graph is cleared, and then new nodes, groups, and edges are created as defined by the source collections.</para>
      </remarks>
      <returns>
        <para>The created graph.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" />
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph">
      <summary>
        <para>Updates the graph after changes in the bound data.</para>
      </summary>
      <remarks>
        <para>In contrast to <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph" />, the graph is not cleared. Instead, graph elements corresponding to objects that are still present in the source collections are kept, new graph elements are created for new objects in the collections, and obsolete ones are removed.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.CreateNode(yWorks.Graph.IGraph,yWorks.Graph.INode,System.Object,`0)">
      <summary>
        <para>Creates a node with the specified parent from the given <paramref name="nodeObject" /> and <paramref name="labelData" />.</para>
      </summary>
      <remarks>
        <para>This method is called for every node that is created either when <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph">building the graph</see>, or when new items appear in the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" /> when <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph">updating it</see>.</para>
        <para>The default behavior is to create the node with the given parent node, assign the <paramref name="nodeObject" /> to the node's <see cref="P:yWorks.Graph.ITagOwner.Tag" /> property, and create a label from <paramref name="labelData" />, if present.</para>
        <para>Customizing how nodes are created is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeCreated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The graph in which to create the node.</para>
      </param>
      <param name="parent">
        <para>The node's parent node.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the node if an <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeLabelProvider" /> is specified.</para>
      </param>
      <param name="nodeObject">
        <para>The object from <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" /> from which to create the node.</para>
      </param>
      <returns>
        <para>The created node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateNode(yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.INode,System.Object,`0)">
      <summary>
        <para>Updates an existing node when the <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph">graph is updated</see>.</para>
      </summary>
      <remarks>
        <para>This method is called during <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph">updating the graph</see> for every node that already exists in the graph where its corresponding object from <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" /> is also still present.</para>
        <para>Customizing how nodes are updated is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeUpdated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The node's containing graph.</para>
      </param>
      <param name="node">
        <para>The node to update.</para>
      </param>
      <param name="parent">
        <para>The node's parent node.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the node if an <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeLabelProvider" /> is specified.</para>
      </param>
      <param name="nodeObject">
        <para>The object from <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" /> from which the node has been created.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGroupNode(yWorks.Graph.IGraph,yWorks.Graph.INode,System.Object,`1)">
      <summary>
        <para>Updates an existing group node when the <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph">graph is updated</see>.</para>
      </summary>
      <remarks>
        <para>This method is called during <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph">updating the graph</see> for every group node that already exists in the graph where its corresponding object from <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" /> is also still present.</para>
        <para>Customizing how group nodes are updated is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupNodeUpdated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The group node's containing graph.</para>
      </param>
      <param name="groupNode">
        <para>The group node to update.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the group node if an <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupLabelProvider" /> is specified.</para>
      </param>
      <param name="groupObject">
        <para>The object from <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" /> from which the group node has been created.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.CreateGroupNode(yWorks.Graph.IGraph,System.Object,`1)">
      <summary>
        <para>Creates a group node from the given <paramref name="groupObject" /> and <paramref name="labelData" />.</para>
      </summary>
      <remarks>
        <para>This method is called for every group node that is created either when <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph">building the graph</see>, or when new items appear in the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" /> when <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph">updating it</see>.</para>
        <para>The default behavior is to create the group node, assign the <paramref name="groupObject" /> to the group node's <see cref="P:yWorks.Graph.ITagOwner.Tag" /> property, and create a label from <paramref name="labelData" />, if present.</para>
        <para>Customizing how group nodes are created is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupNodeCreated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The graph in which to create the group node.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the group node if an <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupLabelProvider" /> is specified.</para>
      </param>
      <param name="groupObject">
        <para>The object from <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" /> from which to create the group node.</para>
      </param>
      <returns>
        <para>The created group node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.GetSourceObject(yWorks.Graph.IModelItem)">
      <summary>
        <para>Retrieves the object from which a given item has been created.</para>
      </summary>
      <param name="item">
        <para>The item to get the object for.</para>
      </param>
      <returns>
        <para>The object from which the graph item has been created.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.GetNode(`0)" />
      <seealso cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.GetGroup(`1)" />
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.GetNode(`0)">
      <summary>
        <para>Retrieves the node associated with an object from the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" />.</para>
      </summary>
      <param name="nodeObject">
        <para>An object from the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" />.</para>
      </param>
      <returns>
        <para>The node associated with <paramref name="nodeObject" />, or <c>null</c> in case there is no node associated with that object. This can happen if <paramref name="nodeObject" /> is new since the last call to <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.GetGroup(`1)" />
      <seealso cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.GetSourceObject(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.GetGroup(`1)">
      <summary>
        <para>Retrieves the group node associated with an object from the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" />.</para>
      </summary>
      <param name="groupObject">
        <para>An object from the <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" />.</para>
      </param>
      <returns>
        <para>The group node associated with <paramref name="groupObject" />, or <c>null</c> in case there is no group node associated with that object. This can happen if <paramref name="groupObject" /> is new since the last call to <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.GetNode(`0)" />
      <seealso cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.GetSourceObject(yWorks.Graph.IModelItem)" />
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.SuccessorProvider">
      <summary>
        <para>Gets or sets a delegate that maps node objects to their successors.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a node to a set of other objects that represent its successor nodes, i.e. other nodes connected with an outgoing edge.</para>
        <para>If a <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeIdProvider" /> is set, the returned objects must be the IDs of node objects instead of the node objects themselves.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.PredecessorProvider" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeIdProvider" />
    </member>
    <member name="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.PredecessorProvider">
      <summary>
        <para>Gets or sets a delegate that maps node objects to their predecessors.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a node to a set of other objects that represent its predecessor nodes, i.e. other nodes connected with an incoming edge.</para>
        <para>If a <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeIdProvider" /> is set, the returned objects must be the IDs of node objects instead of the node objects themselves.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.SuccessorProvider" />
      <seealso cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeIdProvider" />
    </member>
    <member name="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeCreated">
      <summary>
        <para>Occurs when a node has been created.</para>
      </summary>
      <remarks>
        <para>This event can be used to further customize the created node.</para>
        <para>New nodes are created either in response to calling <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph" />, or in response to calling <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" /> when there are new items in <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeUpdated" />
    </member>
    <member name="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeUpdated">
      <summary>
        <para>Occurs when a node has been updated.</para>
      </summary>
      <remarks>
        <para>This event can be used to update customizations added in an event handler for <see cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeCreated" />.</para>
        <para>Nodes are updated in response to calling <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" /> for items that haven't been added anew in <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodesSource" /> since the last call to <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph" /> or <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.NodeCreated" />
    </member>
    <member name="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeCreated">
      <summary>
        <para>Occurs when an edge has been created.</para>
      </summary>
      <remarks>
        <para>This event can be used to further customize the created edge.</para>
        <para>New edges are created either in response to calling <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph" />, or in response to calling <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" /> when there are new items in <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.PredecessorProvider" /> or <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.SuccessorProvider" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeUpdated" />
    </member>
    <member name="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeUpdated">
      <summary>
        <para>Occurs when an edge has been updated.</para>
      </summary>
      <remarks>
        <para>This event can be used to update customizations added in an event handler for <see cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeCreated" />.</para>
        <para>Edges are updated in response to calling <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" /> for items that haven't been added anew in <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.PredecessorProvider" /> or <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.SuccessorProvider" /> since the last call to <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph" /> or <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" />.</para>
        <para>Depending on how the source data is structured, this event can be raised during <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph" />, or multiple times for the same edge during <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeCreated" />
    </member>
    <member name="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupNodeCreated">
      <summary>
        <para>Occurs when a group node has been created.</para>
      </summary>
      <remarks>
        <para>This event can be used to further customize the created group node.</para>
        <para>New group nodes are created either in response to calling <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph" />, or in response to calling <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" /> when there are new items in <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupNodeUpdated" />
    </member>
    <member name="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupNodeUpdated">
      <summary>
        <para>Occurs when a group node has been updated.</para>
      </summary>
      <remarks>
        <para>This event can be used to update customizations added in an event handler for <see cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupNodeCreated" />.</para>
        <para>Group nodes are updated in response to calling <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" /> for items that haven't been added anew in <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupsSource" /> since the last call to <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.BuildGraph" /> or <see cref="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateGraph" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.AdjacentNodesGraphBuilder`2.GroupNodeCreated" />
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.CreateEdge(yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.INode,System.Object)">
      <summary>
        <para>Creates a new edge connecting the given nodes.</para>
      </summary>
      <remarks>
        <para>This class calls this method to create all new edges, and customers may override it to customize edge creation.</para>
      </remarks>
      <param name="graph">
        <para>The graph.</para>
      </param>
      <param name="source">
        <para>The source node of the edge.</para>
      </param>
      <param name="target">
        <para>The target node of the edge.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the edge if an <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeLabelProvider" /> is specified.</para>
      </param>
      <returns>
        <para>The created edge.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.AdjacentNodesGraphBuilder`2.UpdateEdge(yWorks.Graph.IGraph,yWorks.Graph.IEdge,System.Object)">
      <summary>
        <para>Updates an existing edge connecting the given nodes when <see cref="M:yWorks.Graph.GraphBuilderHelper`2.UpdateGraph" /> is called and the edge should remain in the graph.</para>
      </summary>
      <param name="graph">
        <para>The graph.</para>
      </param>
      <param name="edge">
        <para>The edge to update.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the edge if an <see cref="P:yWorks.Graph.AdjacentNodesGraphBuilder`2.EdgeLabelProvider" /> is specified.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.GraphBuilder`3">
      <summary>
        <para>Populates a graph from custom data.</para>
      </summary>
      <remarks>
        <para>This class can be used when the data specifies a collection of nodes, a collection of edges, and—optionally—a collection of groups. The properties <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />, <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />, and <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" /> define the source collections from which nodes, groups, and edges will be created.</para>
        <para>Generally, using the <see cref="T:yWorks.Graph.GraphBuilder`3" /> class consists of a few basic steps:</para>
        <list type="number">
          <item>Set up the <see cref="P:yWorks.Graph.GraphBuilder`3.Graph" /> with the proper defaults for items (<see cref="P:yWorks.Graph.IGraph.NodeDefaults" />, <see cref="P:yWorks.Graph.IGraph.GroupNodeDefaults" />, <see cref="P:yWorks.Graph.IGraph.EdgeDefaults" />)</item>
          <item>Create a <see cref="T:yWorks.Graph.GraphBuilder`3" />.</item>
          <item>Set the items sources. At the very least the <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" /> (unless using <see cref="P:yWorks.Graph.GraphBuilder`3.LazyNodeDefinition" />) and <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" /> are needed. If the items in the nodes collection are grouped somehow, then also set the <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" /> property.</item>
          <item>Set up the bindings so that a graph structure can actually be created from the items sources. This involves at least setting up the <see cref="P:yWorks.Graph.GraphBuilder`3.SourceNodeProvider" /> and <see cref="P:yWorks.Graph.GraphBuilder`3.TargetNodeProvider" /> properties so that edges can be created. If the edge objects don't actually contain the node objects as source and target, but instead an identifier of the node objects, then <see cref="P:yWorks.Graph.GraphBuilder`3.SourceNodeProvider" /> and <see cref="P:yWorks.Graph.GraphBuilder`3.TargetNodeProvider" /> would return those identifiers and <see cref="P:yWorks.Graph.GraphBuilder`3.NodeIdProvider" /> must be set to return that identifier when given a node object.</item>
          <item>If <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" /> is set, then you also need to set the <see cref="P:yWorks.Graph.GraphBuilder`3.GroupProvider" /> property to enable mapping nodes to groups. Just like with edges and their source and target nodes, if the node object only contains an identifier for a group node and not the actual group object, then return the identifier in the <see cref="P:yWorks.Graph.GraphBuilder`3.GroupProvider" /> and set up the <see cref="P:yWorks.Graph.GraphBuilder`3.GroupIdProvider" /> to map group node objects to their identifiers. If group nodes can nest, you also need the <see cref="P:yWorks.Graph.GraphBuilder`3.ParentGroupProvider" />.</item>
          <item>You can also easily create labels for nodes, groups, and edges by using the <see cref="P:yWorks.Graph.GraphBuilder`3.NodeLabelProvider" />, <see cref="P:yWorks.Graph.GraphBuilder`3.GroupLabelProvider" />, and <see cref="P:yWorks.Graph.GraphBuilder`3.EdgeLabelProvider" /> properties.</item>
          <item>Call <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph" /> to populate the graph. You can apply a layout algorithm afterward to make the graph look nice.</item>
          <item>If your items or collections change later, call <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" /> to make those changes visible in the graph.</item>
        </list>
        <para>You can further customize how nodes, groups, and edges are created by adding event handlers to the various events and modifying the items there. This can be used to modify items in ways that are not directly supported by the available bindings or defaults. This includes scenarios such as the following:</para>
        <list type="bullet">
          <item>Setting node positions or adding bends to edges. Often a layout is applied to the graph after building it, so these things are only rarely needed.</item>
          <item>Modifying individual items, such as setting a different style for every nodes, depending on the bound object.</item>
          <item>Adding more than one label for an item, as the <see cref="P:yWorks.Graph.GraphBuilder`3.NodeLabelProvider" /> and <see cref="P:yWorks.Graph.GraphBuilder`3.EdgeLabelProvider" /> will only create a single label, or adding labels to group nodes.</item>
        </list>
        <para>There are creation and update events for all three types of items, which allows separate customization when nodes, groups, and edges are created or updated. For completely static graphs where <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" /> is not needed, the update events can be safely ignored.</para>
        <para>Depending on how the source data is laid out, you may also consider using <see cref="T:yWorks.Graph.AdjacentNodesGraphBuilder`2" />, where node objects know their neighbors, or <see cref="T:yWorks.Graph.TreeBuilder`2" /> where the graph is a tree and node objects know their children. Both of those other graph builders make edges implicit through the relationships between nodes and thus have no <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" />.</para>
      </remarks>
      <typeparam name="TNode">
        <para>The type of object nodes are created from. This type must implement <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.Object.GetHashCode" /> properly.</para>
      </typeparam>
      <typeparam name="TEdge">
        <para>The type of object edges are created from. This type must implement <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.Object.GetHashCode" /> properly.</para>
      </typeparam>
      <typeparam name="TGroup">
        <para>The type of object group nodes are created from. This type must implement <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.Object.GetHashCode" /> properly.</para>
      </typeparam>
      <seealso cref="T:yWorks.Graph.AdjacentNodesGraphBuilder`2" />
      <seealso cref="T:yWorks.Graph.TreeBuilder`2" />
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.#ctor(yWorks.Graph.IGraph)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.GraphBuilder`3" /> class that operates on the given graph.</para>
      </summary>
      <remarks>
        <para>The <paramref name="graph" /> will be <see cref="M:yWorks.Graph.GraphExtensions.Clear(yWorks.Graph.IGraph)">cleared</see> and re-built from the data in <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />, <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />, and <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" /> when <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph" /> is called.</para>
      </remarks>
      <param name="graph" />
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.Graph">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.IGraph">graph</see> used by this class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.LazyNodeDefinition">
      <summary>
        <para>Gets or sets a value indicating whether or not to automatically create nodes for values returned from <see cref="P:yWorks.Graph.GraphBuilder`3.SourceNodeProvider" /> and <see cref="P:yWorks.Graph.GraphBuilder`3.TargetNodeProvider" /> that don't exist in <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />.</para>
      </summary>
      <remarks>
        <para>When this property is set to <c>false</c>, nodes in the graph are <em>only</em> created from <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />, and edge objects that result in source or target nodes not in <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" /> will have no edge created.</para>
        <para>If this property is set to <c>true</c>, edges will always be created, and if <see cref="P:yWorks.Graph.GraphBuilder`3.SourceNodeProvider" /> or <see cref="P:yWorks.Graph.GraphBuilder`3.TargetNodeProvider" /> return values not in <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />, additional nodes are created as needed.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" />
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.NodesSource">
      <summary>
        <para>Gets or sets the objects to be represented as nodes of the <see cref="P:yWorks.Graph.GraphBuilder`3.Graph" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.EdgesSource">
      <summary>
        <para>Gets or sets the objects to be represented as edges of the <see cref="P:yWorks.Graph.GraphBuilder`3.Graph" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.GroupsSource">
      <summary>
        <para>Gets or sets the objects to be represented as group nodes of the <see cref="P:yWorks.Graph.GraphBuilder`3.Graph" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.NodeIdProvider">
      <summary>
        <para>Gets or sets a delegate that maps node objects to their identifier.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a node to its identifier. This is needed when <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource">edge objects</see> only contain an identifier to specify their source and target nodes instead of pointing directly to the respective node object.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.SourceNodeProvider" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.TargetNodeProvider" />
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.NodeLabelProvider">
      <summary>
        <para>Gets or sets a delegate that maps a node object to a label.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a node to an object that represents the label for the node.</para>
        <para>The resulting object will be converted into a string to be displayed as the label's text. If this is insufficient, a label can also be created directly in an event handler of the <see cref="E:yWorks.Graph.GraphBuilder`3.NodeCreated" /> event.</para>
        <para>Returning <c>null</c> from the delegate will not create a label for that node.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.GroupProvider">
      <summary>
        <para>Gets or sets a delegate that maps node objects to their containing groups.</para>
      </summary>
      <remarks>
        <para>This maps an object <i>N</i> that represents a node to another object <i>G</i> that specifies the containing group of <i>N</i>. If <i>G</i> is contained in <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />, then the node for <i>N</i> becomes a child node of the group for <i>G</i>.</para>
        <para>If a <see cref="P:yWorks.Graph.GraphBuilder`3.GroupIdProvider" /> is set, the returned object <i>G</i> must be the ID of the object that specifies the group instead of that object itself.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.GroupIdProvider" />
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.EdgeLabelProvider">
      <summary>
        <para>Gets or sets a delegate that maps an edge object to a label.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents an edge to an object that represents the label for the edge.</para>
        <para>The resulting object will be converted into a string to be displayed as the label's text. If this is insufficient, a label can also be created directly in an event handler of the <see cref="E:yWorks.Graph.GraphBuilder`3.EdgeCreated" /> event.</para>
        <para>Returning <c>null</c> from the delegate will not create a label for that edge.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" />
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.SourceNodeProvider">
      <summary>
        <para>Gets or sets a delegate that maps edge objects to their source node.</para>
      </summary>
      <remarks>
        <para>This maps an object <i>E</i> that represents an edge to another object <i>N</i> that specifies the source node of <i>E</i>.</para>
        <para>If a <see cref="P:yWorks.Graph.GraphBuilder`3.NodeIdProvider" /> is set, the returned object <i>N</i> must be the ID of the object that specifies the node instead of that object itself.</para>
        <para>If <see cref="P:yWorks.Graph.GraphBuilder`3.LazyNodeDefinition" /> is <c>true</c>, the resulting node object does not have to exist in <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />; instead, nodes are created as needed.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.TargetNodeProvider" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.NodeIdProvider" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.LazyNodeDefinition" />
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.TargetNodeProvider">
      <summary>
        <para>Gets or sets a delegate that maps edge objects to their target node.</para>
      </summary>
      <remarks>
        <para>This maps an object <i>E</i> that represents an edge to another object <i>N</i> that specifies the target node of <i>E</i>.</para>
        <para>If a <see cref="P:yWorks.Graph.GraphBuilder`3.NodeIdProvider" /> is set, the returned object <i>N</i> must be the ID of the object that specifies the node instead of that object itself.</para>
        <para>If <see cref="P:yWorks.Graph.GraphBuilder`3.LazyNodeDefinition" /> is <c>true</c>, the resulting node object does not have to exist in <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />; instead, nodes are created as needed.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.SourceNodeProvider" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.NodeIdProvider" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.LazyNodeDefinition" />
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.GroupIdProvider">
      <summary>
        <para>Gets or sets a delegate that maps group objects to their identifier.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a group node to its identifier. This is needed when <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource">node objects</see> only contain an identifier to specify the group they belong to instead of pointing directly to the respective group object. The same goes for the parent group in group objects.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.GroupProvider" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.ParentGroupProvider" />
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.GroupLabelProvider">
      <summary>
        <para>Gets or sets a delegate that maps a group object to a label.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a group node to an object that represents the label for the group node.</para>
        <para>The resulting object will be converted into a string to be displayed as the label's text. If this is insufficient, a label can also be created directly in an event handler of the <see cref="E:yWorks.Graph.GraphBuilder`3.GroupNodeCreated" /> event.</para>
        <para>Returning <c>null</c> from the delegate will not create a label for that group node.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />
    </member>
    <member name="P:yWorks.Graph.GraphBuilder`3.ParentGroupProvider">
      <summary>
        <para>Gets or sets a delegate that maps group objects to their containing groups.</para>
      </summary>
      <remarks>
        <para>This maps an object <i>G</i> that represents a group node to another object <i>P</i> that specifies the containing group of <i>G</i>. If <i>P</i> is contained in <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />, then the group node for <i>G</i> becomes a child node of the group for <i>P</i>.</para>
        <para>If a <see cref="P:yWorks.Graph.GraphBuilder`3.GroupIdProvider" /> is set, the returned object <i>P</i> must be the ID of the object that specifies the group instead of that object itself.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />
      <seealso cref="P:yWorks.Graph.GraphBuilder`3.GroupIdProvider" />
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.BuildGraph">
      <summary>
        <para>Populates the graph with items generated from the bound data.</para>
      </summary>
      <remarks>
        <para>The graph is cleared, and then new nodes, groups, and edges are created as defined by the source collections.</para>
      </remarks>
      <returns>
        <para>The created graph.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" />
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.UpdateGraph">
      <summary>
        <para>Updates the graph after changes in the bound data.</para>
      </summary>
      <remarks>
        <para>In contrast to <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph" />, the graph is not cleared. Instead, graph elements corresponding to objects that are still present in the source collections are kept, new graph elements are created for new objects in the collections, and obsolete ones are removed.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.CreateNode(yWorks.Graph.IGraph,yWorks.Graph.INode,System.Object,`0)">
      <summary>
        <para>Creates a node with the specified parent from the given <paramref name="nodeObject" /> and <paramref name="labelData" />.</para>
      </summary>
      <remarks>
        <para>This method is called for every node that is created either when <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph">building the graph</see>, or when new items appear in the <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" /> when <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph">updating it</see>.</para>
        <para>The default behavior is to create the node with the given parent node, assign the <paramref name="nodeObject" /> to the node's <see cref="P:yWorks.Graph.ITagOwner.Tag" /> property, and create a label from <paramref name="labelData" />, if present.</para>
        <para>Customizing how nodes are created is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.GraphBuilder`3.NodeCreated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The graph in which to create the node.</para>
      </param>
      <param name="parent">
        <para>The node's parent node.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the node if an <see cref="P:yWorks.Graph.GraphBuilder`3.NodeLabelProvider" /> is specified.</para>
      </param>
      <param name="nodeObject">
        <para>The object from <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" /> from which to create the node.</para>
      </param>
      <returns>
        <para>The created node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.UpdateNode(yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.INode,System.Object,`0)">
      <summary>
        <para>Updates an existing node when the <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph">graph is updated</see>.</para>
      </summary>
      <remarks>
        <para>This method is called during <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph">updating the graph</see> for every node that already exists in the graph where its corresponding object from <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" /> is also still present.</para>
        <para>Customizing how nodes are updated is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.GraphBuilder`3.NodeUpdated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The node's containing graph.</para>
      </param>
      <param name="node">
        <para>The node to update.</para>
      </param>
      <param name="parent">
        <para>The node's parent node.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the node if an <see cref="P:yWorks.Graph.GraphBuilder`3.NodeLabelProvider" /> is specified.</para>
      </param>
      <param name="nodeObject">
        <para>The object from <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" /> from which the node has been created.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.CreateEdge(yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.INode,System.Object,`1)">
      <summary>
        <para>Creates an edge from the given <paramref name="edgeObject" /> and <paramref name="labelData" />.</para>
      </summary>
      <remarks>
        <para>This method is called for every edge that is created either when <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph">building the graph</see>, or when new items appear in the <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" /> when <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph">updating it</see>.</para>
        <para>The default behavior is to create the edge, assign the <paramref name="edgeObject" /> to the edge's <see cref="P:yWorks.Graph.ITagOwner.Tag" /> property, and create a label from <paramref name="labelData" />, if present.</para>
        <para>Customizing how edges are created is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.GraphBuilder`3.EdgeCreated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The graph in which to create the edge.</para>
      </param>
      <param name="source">
        <para>The source node for the edge.</para>
      </param>
      <param name="target">
        <para>The target node for the edge.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the edge if an <see cref="P:yWorks.Graph.GraphBuilder`3.EdgeLabelProvider" /> is specified.</para>
      </param>
      <param name="edgeObject">
        <para>The object from <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" /> from which to create the edge.</para>
      </param>
      <returns>
        <para>The created edge.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.UpdateEdge(yWorks.Graph.IGraph,yWorks.Graph.IEdge,System.Object,`1)">
      <summary>
        <para>Updates an existing edge when the <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph">graph is updated</see>.</para>
      </summary>
      <remarks>
        <para>This method is called during <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph">updating the graph</see> for every edge that already exists in the graph where its corresponding object from <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" /> is also still present.</para>
        <para>Customizing how edges are updated is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.GraphBuilder`3.EdgeUpdated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The edge's containing graph.</para>
      </param>
      <param name="edge">
        <para>The edge to update.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the edge if an <see cref="P:yWorks.Graph.GraphBuilder`3.EdgeLabelProvider" /> is specified.</para>
      </param>
      <param name="edgeObject">
        <para>The object from <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" /> from which the edge has been created.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.CreateGroupNode(yWorks.Graph.IGraph,System.Object,`2)">
      <summary>
        <para>Creates a group node from the given <paramref name="groupObject" /> and <paramref name="labelData" />.</para>
      </summary>
      <remarks>
        <para>This method is called for every group node that is created either when <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph">building the graph</see>, or when new items appear in the <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" /> when <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph">updating it</see>.</para>
        <para>The default behavior is to create the group node, assign the <paramref name="groupObject" /> to the group node's <see cref="P:yWorks.Graph.ITagOwner.Tag" /> property, and create a label from <paramref name="labelData" />, if present.</para>
        <para>Customizing how group nodes are created is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.GraphBuilder`3.GroupNodeCreated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The graph in which to create the group node.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the group node if an <see cref="P:yWorks.Graph.GraphBuilder`3.GroupLabelProvider" /> is specified.</para>
      </param>
      <param name="groupObject">
        <para>The object from <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" /> from which to create the group node.</para>
      </param>
      <returns>
        <para>The created group node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.UpdateGroupNode(yWorks.Graph.IGraph,yWorks.Graph.INode,System.Object,`2)">
      <summary>
        <para>Updates an existing group node when the <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph">graph is updated</see>.</para>
      </summary>
      <remarks>
        <para>This method is called during <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph">updating the graph</see> for every group node that already exists in the graph where its corresponding object from <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" /> is also still present.</para>
        <para>Customizing how group nodes are updated is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.GraphBuilder`3.GroupNodeUpdated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The group node's containing graph.</para>
      </param>
      <param name="groupNode">
        <para>The group node to update.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the group node if an <see cref="P:yWorks.Graph.GraphBuilder`3.GroupLabelProvider" /> is specified.</para>
      </param>
      <param name="groupObject">
        <para>The object from <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" /> from which the group node has been created.</para>
      </param>
    </member>
    <member name="E:yWorks.Graph.GraphBuilder`3.NodeCreated">
      <summary>
        <para>Occurs when a node has been created.</para>
      </summary>
      <remarks>
        <para>This event can be used to further customize the created node.</para>
        <para>New nodes are created either in response to calling <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph" />, or in response to calling <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" /> when there are new items in <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.GraphBuilder`3.NodeUpdated" />
    </member>
    <member name="E:yWorks.Graph.GraphBuilder`3.NodeUpdated">
      <summary>
        <para>Occurs when a node has been updated.</para>
      </summary>
      <remarks>
        <para>This event can be used to update customizations added in an event handler for <see cref="E:yWorks.Graph.GraphBuilder`3.NodeCreated" />.</para>
        <para>Nodes are updated in response to calling <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" /> for items that haven't been added anew in <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" /> since the last call to <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph" /> or <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.GraphBuilder`3.NodeCreated" />
    </member>
    <member name="E:yWorks.Graph.GraphBuilder`3.EdgeCreated">
      <summary>
        <para>Occurs when an edge has been created.</para>
      </summary>
      <remarks>
        <para>This event can be used to further customize the created edge.</para>
        <para>New edges are created either in response to calling <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph" />, or in response to calling <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" /> when there are new items in <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.GraphBuilder`3.EdgeUpdated" />
    </member>
    <member name="E:yWorks.Graph.GraphBuilder`3.EdgeUpdated">
      <summary>
        <para>Occurs when an edge has been updated.</para>
      </summary>
      <remarks>
        <para>This event can be used to update customizations added in an event handler for <see cref="E:yWorks.Graph.GraphBuilder`3.EdgeCreated" />.</para>
        <para>Edges are updated in response to calling <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" /> for items that haven't been added anew in <see cref="P:yWorks.Graph.GraphBuilder`3.EdgesSource" /> since the last call to <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph" /> or <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.GraphBuilder`3.EdgeCreated" />
    </member>
    <member name="E:yWorks.Graph.GraphBuilder`3.GroupNodeCreated">
      <summary>
        <para>Occurs when a group node has been created.</para>
      </summary>
      <remarks>
        <para>This event can be used to further customize the created group node.</para>
        <para>New group nodes are created either in response to calling <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph" />, or in response to calling <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" /> when there are new items in <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.GraphBuilder`3.GroupNodeUpdated" />
    </member>
    <member name="E:yWorks.Graph.GraphBuilder`3.GroupNodeUpdated">
      <summary>
        <para>Occurs when a group node has been updated.</para>
      </summary>
      <remarks>
        <para>This event can be used to update customizations added in an event handler for <see cref="E:yWorks.Graph.GraphBuilder`3.GroupNodeCreated" />.</para>
        <para>Group nodes are updated in response to calling <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" /> for items that haven't been added anew in <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" /> since the last call to <see cref="M:yWorks.Graph.GraphBuilder`3.BuildGraph" /> or <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.GraphBuilder`3.GroupNodeCreated" />
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.GetSourceObject(yWorks.Graph.IModelItem)">
      <summary>
        <para>Retrieves the object from which a given item has been created.</para>
      </summary>
      <param name="item">
        <para>The item to get the object for.</para>
      </param>
      <returns>
        <para>The object from which the graph item has been created.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetNode(`0)" />
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetEdge(`1)" />
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetGroup(`2)" />
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.GetNode(`0)">
      <summary>
        <para>Retrieves the node associated with an object from the <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />.</para>
      </summary>
      <param name="nodeObject">
        <para>An object from the <see cref="P:yWorks.Graph.GraphBuilder`3.NodesSource" />.</para>
      </param>
      <returns>
        <para>The node associated with <paramref name="nodeObject" />, or <c>null</c> in case there is no node associated with that object. This can happen if <paramref name="nodeObject" /> is new since the last call to <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetEdge(`1)" />
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetGroup(`2)" />
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetSourceObject(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.GetEdge(`1)">
      <summary>
        <para>Retrieves the group node associated with an object from the <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />.</para>
      </summary>
      <param name="edgeObject">
        <para>An object from the <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />.</para>
      </param>
      <returns>
        <para>The group node associated with <paramref name="edgeObject" />, or <c>null</c> in case there is no group node associated with that object. This can happen if <paramref name="edgeObject" /> is new since the last call to <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetNode(`0)" />
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetGroup(`2)" />
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetSourceObject(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Graph.GraphBuilder`3.GetGroup(`2)">
      <summary>
        <para>Retrieves the group node associated with an object from the <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />.</para>
      </summary>
      <param name="groupObject">
        <para>An object from the <see cref="P:yWorks.Graph.GraphBuilder`3.GroupsSource" />.</para>
      </param>
      <returns>
        <para>The group node associated with <paramref name="groupObject" />, or <c>null</c> in case there is no group node associated with that object. This can happen if <paramref name="groupObject" /> is new since the last call to <see cref="M:yWorks.Graph.GraphBuilder`3.UpdateGraph" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetNode(`0)" />
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetEdge(`1)" />
      <seealso cref="M:yWorks.Graph.GraphBuilder`3.GetSourceObject(yWorks.Graph.IModelItem)" />
    </member>
    <member name="T:yWorks.Graph.GraphBuilderItemEventArgs`2">
      <summary>
        <para>Event arguments for item events in <see cref="T:yWorks.Graph.GraphBuilder`3" />, <see cref="T:yWorks.Graph.AdjacentNodesGraphBuilder`2" />, and <see cref="T:yWorks.Graph.TreeBuilder`2" />.</para>
      </summary>
      <typeparam name="TItem">
        <para>The type of the item contained in the argument.</para>
      </typeparam>
      <typeparam name="TObject">
        <para>The type of object that the item was created from.</para>
      </typeparam>
    </member>
    <member name="P:yWorks.Graph.GraphBuilderItemEventArgs`2.Graph">
      <summary>
        <para>Gets the graph that can be used to modify the <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.GraphBuilderItemEventArgs`2.SourceObject">
      <summary>
        <para>Gets the object the <see cref="P:yWorks.Utils.ItemEventArgs`1.Item" /> has been created from.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.GraphBuilderItemEventArgs`2.#ctor(yWorks.Graph.IGraph,`0,`1)">
      <summary>
        <para>Creates a new instance of the <see cref="T:yWorks.Graph.GraphBuilderItemEventArgs`2" /> class with the given graph, item, and source object.</para>
      </summary>
      <param name="graph">
        <para>The graph that can be used to modify <paramref name="item" />.</para>
      </param>
      <param name="item">
        <para>The item created from <paramref name="sourceObject" />.</para>
      </param>
      <param name="sourceObject">
        <para>The object <paramref name="item" /> was created from.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.EdgeLabelProvider`1">
      <summary>
        <para>A delegate that maps an edge represented by its source and target node object to a label.</para>
      </summary>
      <typeparam name="TNode">
        <para>The type of the node objects.</para>
      </typeparam>
      <param name="source">
        <para>The source node object.</para>
      </param>
      <param name="target">
        <para>The target node object.</para>
      </param>
      <returns>
        <para>The label data to use for the edge between <paramref name="source" /> and <paramref name="target" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.TreeBuilder`2">
      <summary>
        <para>Populates a graph from custom data where objects corresponding to nodes have a parent-child relationship.</para>
      </summary>
      <remarks>
        <para>This class can be used when the data specifies a collection of nodes, each of which knows its child nodes, and—optionally—a collection of groups. The properties <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" /> and <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" /> define the source collections from which nodes and groups will be created.</para>
        <para>Generally, using the <see cref="T:yWorks.Graph.TreeBuilder`2" /> class consists of a few basic steps:</para>
        <list type="number">
          <item>Set up the <see cref="P:yWorks.Graph.TreeBuilder`2.Graph" /> with the proper defaults for items (<see cref="P:yWorks.Graph.IGraph.NodeDefaults" />, <see cref="P:yWorks.Graph.IGraph.GroupNodeDefaults" />, <see cref="P:yWorks.Graph.IGraph.EdgeDefaults" />)</item>
          <item>Create a <see cref="T:yWorks.Graph.TreeBuilder`2" />.</item>
          <item>Set the items sources. At the very least the <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" /> is needed. Note that the <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" /> does not have to contain all nodes, as nodes that are implicitly specified through the <see cref="P:yWorks.Graph.TreeBuilder`2.ChildProvider" /> are automatically added to the graph as well. If the items in the nodes collection are grouped somehow, then also set the <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" /> property.</item>
          <item>Set up the bindings so that a graph structure can actually be created from the items sources. This involves setting up the <see cref="P:yWorks.Graph.TreeBuilder`2.ChildProvider" /> property so that edges can be created. If the node objects don't actually contain their children objects, but instead identifiers of other node objects, then <see cref="P:yWorks.Graph.TreeBuilder`2.ChildProvider" /> would return those identifiers and <see cref="P:yWorks.Graph.TreeBuilder`2.NodeIdProvider" /> must be set to return that identifier when given a node object.</item>
          <item>If <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" /> is set, then you also need to set the <see cref="P:yWorks.Graph.TreeBuilder`2.GroupProvider" /> property to enable mapping nodes to groups. Just like with a node's children, if the node object only contains an identifier for a group node and not the actual group object, then return the identifier in the <see cref="P:yWorks.Graph.TreeBuilder`2.GroupProvider" /> and set up the <see cref="P:yWorks.Graph.TreeBuilder`2.GroupIdProvider" /> to map group node objects to their identifiers. If group nodes can nest, you also need the <see cref="P:yWorks.Graph.TreeBuilder`2.ParentGroupProvider" />.</item>
          <item>You can also easily create labels for nodes, groups, and edges by using the <see cref="P:yWorks.Graph.TreeBuilder`2.NodeLabelProvider" />, <see cref="P:yWorks.Graph.TreeBuilder`2.GroupLabelProvider" />, and <see cref="P:yWorks.Graph.TreeBuilder`2.EdgeLabelProvider" /> properties.</item>
          <item>Call <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph" /> to populate the graph. You can apply a layout algorithm afterward to make the graph look nice.</item>
          <item>If your items or collections change later, call <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" /> to make those changes visible in the graph.</item>
        </list>
        <para>You can further customize how nodes, groups, and edges are created by adding event handlers to the various events and modifying the items there. This can be used to modify items in ways that are not directly supported by the available bindings or defaults. This includes scenarios such as the following:</para>
        <list type="bullet">
          <item>Setting node positions or adding bends to edges. Often a layout is applied to the graph after building it, so these things are only rarely needed.</item>
          <item>Modifying individual items, such as setting a different style for every nodes, depending on the bound object.</item>
          <item>Adding more than one label for an item, as the <see cref="P:yWorks.Graph.TreeBuilder`2.NodeLabelProvider" /> and <see cref="P:yWorks.Graph.TreeBuilder`2.EdgeLabelProvider" /> will only create a single label, or adding labels to group nodes.</item>
        </list>
        <para>There are creation and update events for all three types of items, which allows separate customization when nodes, groups, and edges are created or updated. For completely static graphs where <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" /> is not needed, the update events can be safely ignored.</para>
        <para>Depending on how the source data is laid out, you may also consider using <see cref="T:yWorks.Graph.AdjacentNodesGraphBuilder`2" />, where node objects know their neighbors, or <see cref="T:yWorks.Graph.GraphBuilder`3" /> which is a more general approach to creating arbitrary graphs.</para>
      </remarks>
      <typeparam name="TNode">
        <para>The type of object nodes are created from. This type must implement <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.Object.GetHashCode" /> properly.</para>
      </typeparam>
      <typeparam name="TGroup">
        <para>The type of object group nodes are created from. This type must implement <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.Object.GetHashCode" /> properly.</para>
      </typeparam>
      <seealso cref="T:yWorks.Graph.GraphBuilder`3" />
      <seealso cref="T:yWorks.Graph.AdjacentNodesGraphBuilder`2" />
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.#ctor(yWorks.Graph.IGraph)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.TreeBuilder`2" /> class that operates on the given graph.</para>
      </summary>
      <remarks>
        <para>The <paramref name="graph" /> will be <see cref="M:yWorks.Graph.GraphExtensions.Clear(yWorks.Graph.IGraph)">cleared</see> and re-built from the data in <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" /> and <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" /> when <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph" /> is called.</para>
      </remarks>
      <param name="graph" />
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.Graph">
      <summary>
        <para>Gets the <see cref="T:yWorks.Graph.IGraph">graph</see> used by this class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.NodesSource">
      <summary>
        <para>Gets or sets the objects to be represented as nodes of the <see cref="P:yWorks.Graph.TreeBuilder`2.Graph" />.</para>
      </summary>
      <remarks>
        <para>Note that it is not necessary to include all nodes in this property, if they can be reached via the <see cref="P:yWorks.Graph.TreeBuilder`2.ChildProvider" />. In this case it suffices to include all root nodes.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.GroupsSource">
      <summary>
        <para>Gets or sets the objects to be represented as group nodes of the <see cref="P:yWorks.Graph.TreeBuilder`2.Graph" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.NodeIdProvider">
      <summary>
        <para>Gets or sets a delegate that maps node objects to their identifier.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a node to its identifier. This is needed when <see cref="P:yWorks.Graph.TreeBuilder`2.ChildProvider">children</see> are represented only by an identifier of nodes instead of pointing directly to the respective node objects.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" />
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.ChildProvider" />
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.NodeLabelProvider">
      <summary>
        <para>Gets or sets a delegate that maps a node object to a label.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a node to an object that represents the label for the node.</para>
        <para>The resulting object will be converted into a string to be displayed as the label's text. If this is insufficient, a label can also be created directly in an event handler of the <see cref="E:yWorks.Graph.TreeBuilder`2.NodeCreated" /> event.</para>
        <para>Returning <c>null</c> from the delegate will not create a label for that node.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" />
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.ChildProvider">
      <summary>
        <para>Gets or sets a delegate that maps node objects to their child nodes.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a node to a set of other objects that represent its child nodes.</para>
        <para>If a <see cref="P:yWorks.Graph.TreeBuilder`2.NodeIdProvider" /> is set, the returned objects must be the IDs of node objects instead of the node objects themselves.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" />
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.NodeIdProvider" />
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.GroupProvider">
      <summary>
        <para>Gets or sets a delegate that maps node objects to their containing groups.</para>
      </summary>
      <remarks>
        <para>This maps an object <i>N</i> that represents a node to another object <i>G</i> that specifies the containing group of <i>N</i>. If <i>G</i> is contained in <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" />, then the node for <i>N</i> becomes a child node of the group for <i>G</i>.</para>
        <para>If a <see cref="P:yWorks.Graph.TreeBuilder`2.GroupIdProvider" /> is set, the returned object <i>G</i> must be the ID of the object that specifies the group instead of that object itself.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" />
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" />
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.GroupIdProvider" />
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.EdgeLabelProvider">
      <summary>
        <para>Gets or sets a delegate that maps a node object representing the edge's target node to a label.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents an edge to an object that represents the label for the edge.</para>
        <para>The resulting object will be converted into a string to be displayed as the label's text. If this is insufficient, a label can also be created directly in an event handler of the <see cref="E:yWorks.Graph.TreeBuilder`2.EdgeCreated" /> event.</para>
        <para>Returning <c>null</c> from the delegate will not create a label for that edge.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.GroupIdProvider">
      <summary>
        <para>Gets or sets a delegate that maps group objects to their identifier.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a group node to its identifier. This is needed when <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource">node objects</see> only contain an identifier to specify the group they belong to instead of pointing directly to the respective group object. The same goes for the parent group in group objects.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" />
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.GroupProvider" />
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.ParentGroupProvider" />
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.GroupLabelProvider">
      <summary>
        <para>Gets or sets a delegate that maps a group object to a label.</para>
      </summary>
      <remarks>
        <para>This maps an object that represents a group node to an object that represents the label for the group node.</para>
        <para>The resulting object will be converted into a string to be displayed as the label's text. If this is insufficient, a label can also be created directly in an event handler of the <see cref="E:yWorks.Graph.TreeBuilder`2.GroupNodeCreated" /> event.</para>
        <para>Returning <c>null</c> from the delegate will not create a label for that group node.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" />
    </member>
    <member name="P:yWorks.Graph.TreeBuilder`2.ParentGroupProvider">
      <summary>
        <para>Gets or sets a delegate that maps group objects to their containing groups.</para>
      </summary>
      <remarks>
        <para>This maps an object <i>G</i> that represents a group node to another object <i>P</i> that specifies the containing group of <i>G</i>. If <i>P</i> is contained in <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" />, then the group node for <i>G</i> becomes a child node of the group for <i>P</i>.</para>
        <para>If a <see cref="P:yWorks.Graph.TreeBuilder`2.GroupIdProvider" /> is set, the returned object <i>P</i> must be the ID of the object that specifies the group instead of that object itself.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" />
      <seealso cref="P:yWorks.Graph.TreeBuilder`2.GroupIdProvider" />
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.BuildGraph">
      <summary>
        <para>Populates the graph with items generated from the bound data.</para>
      </summary>
      <remarks>
        <para>The graph is cleared, and then new nodes, groups, and edges are created as defined by the source collections.</para>
      </remarks>
      <returns>
        <para>The created graph.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" />
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.UpdateGraph">
      <summary>
        <para>Updates the graph after changes in the bound data.</para>
      </summary>
      <remarks>
        <para>In contrast to <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph" />, the graph is not cleared. Instead, graph elements corresponding to objects that are still present in the source collections are kept, new graph elements are created for new objects in the collections, and obsolete ones are removed.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.CreateNode(yWorks.Graph.IGraph,yWorks.Graph.INode,System.Object,`0)">
      <summary>
        <para>Creates a node with the specified parent from the given <paramref name="nodeObject" /> and <paramref name="labelData" />.</para>
      </summary>
      <remarks>
        <para>This method is called for every node that is created either when <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph">building the graph</see>, or when new items appear in the <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" /> when <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph">updating it</see>.</para>
        <para>The default behavior is to create the node with the given parent node, assign the <paramref name="nodeObject" /> to the node's <see cref="P:yWorks.Graph.ITagOwner.Tag" /> property, and create a label from <paramref name="labelData" />, if present.</para>
        <para>Customizing how nodes are created is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.TreeBuilder`2.NodeCreated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The graph in which to create the node.</para>
      </param>
      <param name="parent">
        <para>The node's parent node.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the node if an <see cref="P:yWorks.Graph.TreeBuilder`2.NodeLabelProvider" /> is specified.</para>
      </param>
      <param name="nodeObject">
        <para>The object from <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" /> from which to create the node.</para>
      </param>
      <returns>
        <para>The created node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.UpdateNode(yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.INode,System.Object,`0)">
      <summary>
        <para>Updates an existing node when the <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph">graph is updated</see>.</para>
      </summary>
      <remarks>
        <para>This method is called during <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph">updating the graph</see> for every node that already exists in the graph where its corresponding object from <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" /> is also still present.</para>
        <para>Customizing how nodes are updated is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.TreeBuilder`2.NodeUpdated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The node's containing graph.</para>
      </param>
      <param name="node">
        <para>The node to update.</para>
      </param>
      <param name="parent">
        <para>The node's parent node.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the node if an <see cref="P:yWorks.Graph.TreeBuilder`2.NodeLabelProvider" /> is specified.</para>
      </param>
      <param name="nodeObject">
        <para>The object from <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" /> from which the node has been created.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.CreateEdge(yWorks.Graph.IGraph,yWorks.Graph.INode,yWorks.Graph.INode,System.Object)">
      <summary>
        <para>Creates an edge from the given <paramref name="source" />, <paramref name="target" />, and <paramref name="labelData" />.</para>
      </summary>
      <remarks>
        <para>This method is called for every edge that is created either when <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph">building the graph</see>, or when new items appear in the <see cref="P:yWorks.Graph.TreeBuilder`2.ChildProvider" /> when <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph">updating it</see>.</para>
        <para>The default behavior is to create the edge and create a label from <paramref name="labelData" />, if present.</para>
        <para>Customizing how edges are created is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.TreeBuilder`2.EdgeCreated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The graph in which to create the edge.</para>
      </param>
      <param name="source">
        <para>The source node for the edge.</para>
      </param>
      <param name="target">
        <para>The target node for the edge.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the edge if an <see cref="P:yWorks.Graph.TreeBuilder`2.EdgeLabelProvider" /> is specified.</para>
      </param>
      <returns>
        <para>The created edge.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.UpdateEdge(yWorks.Graph.IGraph,yWorks.Graph.IEdge,System.Object)">
      <summary>
        <para>Updates an existing edge when the <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph">graph is updated</see>.</para>
      </summary>
      <remarks>
        <para>This method is called during <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph">updating the graph</see> for every edge that already exists in the graph where its corresponding source and target node objects also still exist.</para>
        <para>Customizing how edges are updated is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.TreeBuilder`2.EdgeUpdated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The edge's containing graph.</para>
      </param>
      <param name="edge">
        <para>The edge to update.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the edge if an <see cref="P:yWorks.Graph.TreeBuilder`2.NodeLabelProvider" /> is specified.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.CreateGroupNode(yWorks.Graph.IGraph,System.Object,`1)">
      <summary>
        <para>Creates a group node from the given <paramref name="groupObject" /> and <paramref name="labelData" />.</para>
      </summary>
      <remarks>
        <para>This method is called for every group node that is created either when <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph">building the graph</see>, or when new items appear in the <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" /> when <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph">updating it</see>.</para>
        <para>The default behavior is to create the group node, assign the <paramref name="groupObject" /> to the group node's <see cref="P:yWorks.Graph.ITagOwner.Tag" /> property, and create a label from <paramref name="labelData" />, if present.</para>
        <para>Customizing how group nodes are created is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.TreeBuilder`2.GroupNodeCreated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The graph in which to create the group node.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the group node if an <see cref="P:yWorks.Graph.TreeBuilder`2.GroupLabelProvider" /> is specified.</para>
      </param>
      <param name="groupObject">
        <para>The object from <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" /> from which to create the group node.</para>
      </param>
      <returns>
        <para>The created group node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.UpdateGroupNode(yWorks.Graph.IGraph,yWorks.Graph.INode,System.Object,`1)">
      <summary>
        <para>Updates an existing group node when the <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph">graph is updated</see>.</para>
      </summary>
      <remarks>
        <para>This method is called during <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph">updating the graph</see> for every group node that already exists in the graph where its corresponding object from <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" /> is also still present.</para>
        <para>Customizing how group nodes are updated is usually easier by adding an event handler to the <see cref="E:yWorks.Graph.TreeBuilder`2.GroupNodeUpdated" /> event than by overriding this method.</para>
      </remarks>
      <param name="graph">
        <para>The group node's containing graph.</para>
      </param>
      <param name="groupNode">
        <para>The group node to update.</para>
      </param>
      <param name="labelData">
        <para>The optional label data of the group node if an <see cref="P:yWorks.Graph.TreeBuilder`2.GroupLabelProvider" /> is specified.</para>
      </param>
      <param name="groupObject">
        <para>The object from <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" /> from which the group node has been created.</para>
      </param>
    </member>
    <member name="E:yWorks.Graph.TreeBuilder`2.NodeCreated">
      <summary>
        <para>Occurs when a node has been created.</para>
      </summary>
      <remarks>
        <para>This event can be used to further customize the created node.</para>
        <para>New nodes are created either in response to calling <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph" />, or in response to calling <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" /> when there are new items in <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.TreeBuilder`2.NodeUpdated" />
    </member>
    <member name="E:yWorks.Graph.TreeBuilder`2.NodeUpdated">
      <summary>
        <para>Occurs when a node has been updated.</para>
      </summary>
      <remarks>
        <para>This event can be used to update customizations added in an event handler for <see cref="E:yWorks.Graph.TreeBuilder`2.NodeCreated" />.</para>
        <para>Nodes are updated in response to calling <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" /> for items that haven't been added anew in <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" /> since the last call to <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph" /> or <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.TreeBuilder`2.NodeCreated" />
    </member>
    <member name="E:yWorks.Graph.TreeBuilder`2.EdgeCreated">
      <summary>
        <para>Occurs when an edge has been created.</para>
      </summary>
      <remarks>
        <para>This event can be used to further customize the created edge.</para>
        <para>New edges are created either in response to calling <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph" />, or in response to calling <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" /> when there are new items in <see cref="P:yWorks.Graph.TreeBuilder`2.ChildProvider" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.TreeBuilder`2.EdgeUpdated" />
    </member>
    <member name="E:yWorks.Graph.TreeBuilder`2.EdgeUpdated">
      <summary>
        <para>Occurs when an edge has been updated.</para>
      </summary>
      <remarks>
        <para>This event can be used to update customizations added in an event handler for <see cref="E:yWorks.Graph.TreeBuilder`2.EdgeCreated" />.</para>
        <para>Edges are updated in response to calling <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" /> for items that haven't been added anew in <see cref="P:yWorks.Graph.TreeBuilder`2.ChildProvider" /> since the last call to <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph" /> or <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.TreeBuilder`2.EdgeCreated" />
    </member>
    <member name="E:yWorks.Graph.TreeBuilder`2.GroupNodeCreated">
      <summary>
        <para>Occurs when a group node has been created.</para>
      </summary>
      <remarks>
        <para>This event can be used to further customize the created group node.</para>
        <para>New group nodes are created either in response to calling <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph" />, or in response to calling <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" /> when there are new items in <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.TreeBuilder`2.GroupNodeUpdated" />
    </member>
    <member name="E:yWorks.Graph.TreeBuilder`2.GroupNodeUpdated">
      <summary>
        <para>Occurs when a group node has been updated.</para>
      </summary>
      <remarks>
        <para>This event can be used to update customizations added in an event handler for <see cref="E:yWorks.Graph.TreeBuilder`2.GroupNodeCreated" />.</para>
        <para>Group nodes are updated in response to calling <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" /> for items that haven't been added anew in <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" /> since the last call to <see cref="M:yWorks.Graph.TreeBuilder`2.BuildGraph" /> or <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" />.</para>
      </remarks>
      <seealso cref="E:yWorks.Graph.TreeBuilder`2.GroupNodeCreated" />
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.GetSourceObject(yWorks.Graph.IModelItem)">
      <summary>
        <para>Retrieves the object from which a given item has been created.</para>
      </summary>
      <param name="item">
        <para>The item to get the object for.</para>
      </param>
      <returns>
        <para>The object from which the graph item has been created.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.TreeBuilder`2.GetNode(`0)" />
      <seealso cref="M:yWorks.Graph.TreeBuilder`2.GetGroup(`1)" />
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.GetNode(`0)">
      <summary>
        <para>Retrieves the node associated with an object from the <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" />.</para>
      </summary>
      <param name="nodeObject">
        <para>An object from the <see cref="P:yWorks.Graph.TreeBuilder`2.NodesSource" />.</para>
      </param>
      <returns>
        <para>The node associated with <paramref name="nodeObject" />, or <c>null</c> in case there is no node associated with that object. This can happen if <paramref name="nodeObject" /> is new since the last call to <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.TreeBuilder`2.GetGroup(`1)" />
      <seealso cref="M:yWorks.Graph.TreeBuilder`2.GetSourceObject(yWorks.Graph.IModelItem)" />
    </member>
    <member name="M:yWorks.Graph.TreeBuilder`2.GetGroup(`1)">
      <summary>
        <para>Retrieves the group node associated with an object from the <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" />.</para>
      </summary>
      <param name="groupObject">
        <para>An object from the <see cref="P:yWorks.Graph.TreeBuilder`2.GroupsSource" />.</para>
      </param>
      <returns>
        <para>The group node associated with <paramref name="groupObject" />, or <c>null</c> in case there is no group node associated with that object. This can happen if <paramref name="groupObject" /> is new since the last call to <see cref="M:yWorks.Graph.TreeBuilder`2.UpdateGraph" />.</para>
      </returns>
      <seealso cref="M:yWorks.Graph.TreeBuilder`2.GetNode(`0)" />
      <seealso cref="M:yWorks.Graph.TreeBuilder`2.GetSourceObject(yWorks.Graph.IModelItem)" />
    </member>
    <member name="T:yWorks.Controls.Input.EventRecognizers">
      <summary>
        <para>Utility class that holds implementation singletons and utility methods for simple <see cref="T:yWorks.Controls.Input.EventRecognizer" />s.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.EventRecognizers.Always">
      <summary>
        <para>A callback that will always return true;</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.EventRecognizers.Never">
      <summary>
        <para>A callback that will always return false;</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.EventRecognizers.CreateAndRecognizer(yWorks.Controls.Input.EventRecognizer[])">
      <summary>
        <para>Creates an instance that is the logical 'and' combination of the provided recognizers.</para>
      </summary>
      <param name="recognizers">
        <para>The recognizers to perform the logical operation on.</para>
      </param>
      <returns>
        <para>An instance that is the result of the logical 'and' operation of the provided instances.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.EventRecognizers.CreateOrRecognizer(yWorks.Controls.Input.EventRecognizer[])">
      <summary>
        <para>Creates an instance that is the logical 'or' combination of the provided recognizers.</para>
      </summary>
      <param name="recognizers">
        <para>The recognizers to perform the logical operation on.</para>
      </param>
      <returns>
        <para>An instance that is the result of the logical 'or' operation of the provided instances.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Input.KeyEventRecognizers">
      <summary>
        <para>Utility class with simple <see cref="T:yWorks.Controls.Input.EventRecognizer" />s that work on <see cref="T:yWorks.Controls.CompoundKeyEventArgs" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.EscapeTyped">
      <summary>
        <para>An event recognizer that recognizes when Escape has been typed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.KeyPressed">
      <summary>
        <para>An event recognizer that recognizes when any key has been pressed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.KeyTyped">
      <summary>
        <para>An event recognizer that recognizes when any key has been typed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.KeyReleased">
      <summary>
        <para>An event recognizer that recognizes when any key has been released.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.EscapePressed">
      <summary>
        <para>An event recognizer that recognizes when Escape has been pressed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.DeletePressed">
      <summary>
        <para>An event recognizer that recognizes when Delete has been pressed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.EscapeReleased">
      <summary>
        <para>An event recognizer that recognizes when Escape has been released.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.ShiftPressed">
      <summary>
        <para>An event recognizer that recognizes when the Shift modifier is active.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.AltPressed">
      <summary>
        <para>An event recognizer that recognizes when the Alt modifier is active.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlPressed">
      <summary>
        <para>An event recognizer that recognizes when the Ctrl modifier is active.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.ShiftDown">
      <summary>
        <para>An event recognizer that recognizes when the Shift modifier is being pressed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.ShiftUp">
      <summary>
        <para>An event recognizer that recognizes when the Shift modifier is being released.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlDown">
      <summary>
        <para>An event recognizer that recognizes when the Ctrl modifier is being pressed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.KeyEventRecognizers.CtrlUp">
      <summary>
        <para>An event recognizer that recognizes when the Ctrl modifier is being released.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.KeyEventRecognizers.CreateKeyEventRecognizer(yWorks.Controls.CompoundKeyEventType,System.Windows.Forms.Keys,System.Windows.Forms.Keys)">
      <summary>
        <para>Creates an event recognizer for a given key and type using a given set of modifiers.</para>
      </summary>
      <param name="type">
        <para>The type of the event.</para>
      </param>
      <param name="data">
        <para>The key that is subject of the event.</para>
      </param>
      <param name="modifiers">
        <para>The state of the modifiers that must be set. This is <see cref="F:System.Windows.Forms.Keys.None" /> if not set.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Input.KeyEventRecognizers.CreateKeyEventRecognizer(System.Char)">
      <summary>
        <para>Creates an event recognizer that recognizes a key being typed.</para>
      </summary>
      <param name="character">
        <para>The text that has been typed.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.CompoundKeyEventType">
      <summary>
        <para>The type of a <see cref="T:yWorks.Controls.CompoundKeyEventArgs" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.CompoundKeyEventType.None">
      <summary>
        <para>Neither Pressed, nor Typed, nor Released.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.CompoundKeyEventType.Pressed">
      <summary>
        <para>The key has been pressed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.CompoundKeyEventType.Typed">
      <summary>
        <para>The character has been typed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.CompoundKeyEventType.Released">
      <summary>
        <para>The key has been released.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.CompoundKeyEventArgs">
      <summary>
        <para>Event argument class for key events that carries the type of event.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.CompoundKeyEventArgs.EventType">
      <summary>
        <para>Gets the type of the event.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CompoundKeyEventArgs.#ctor(yWorks.Controls.CompoundKeyEventType,System.Windows.Forms.KeyEventArgs)">
      <summary>
        <para>Constructs a new event.</para>
      </summary>
      <param name="type">
        <para>The type to use</para>
      </param>
      <param name="args">
        <para>The KeyEventArgs to use.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.CompoundKeyEventArgs.Handled">
      <summary>
        <para>Gets or sets a value that indicates whether this event has been handled.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CompoundKeyEventArgs.#ctor(System.Windows.Forms.KeyPressEventArgs,System.Windows.Forms.Keys)">
      <summary>
        <para>Constructs a new event for a key that has been typed.</para>
      </summary>
      <param name="modifiers">
        <para>The modifiers to use.</para>
      </param>
      <param name="args">
        <para>The KeyPressEventArgs to use.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.CompoundKeyEventArgs.KeyCode">
      <summary>
        <para>Returns the key code.</para>
      </summary>
      <remarks>
        <para>This will be <see cref="F:System.Windows.Forms.Keys.None" /> for typed event.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.CompoundKeyEventArgs.KeyValue">
      <summary>
        <para>Returns the value of the character that has been typed.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.CompoundKeyEventArgs.Modifiers">
      <summary>
        <para>Returns the state of the modifiers at the time of the event.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.EventRecognizer">
      <summary>
        <para>A callback that recognizes events.</para>
      </summary>
      <remarks>
        <para>Given a sender and an event argument, delegates decide whether the event is treated as a match depending on the context.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Input.EventRecognizerExtensions">
      <summary>
        <para>Utility class that contains extension methods for <see cref="T:yWorks.Controls.Input.EventRecognizer" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Input.EventRecognizerExtensions.And(yWorks.Controls.Input.EventRecognizer,yWorks.Controls.Input.EventRecognizer)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that performs a logical and operation between this and the other callback.</para>
      </summary>
      <param name="recognizer">
        <para>The recognizer to operate on.</para>
      </param>
      <param name="other">
        <para>The other recognizer.</para>
      </param>
      <returns>
        <para>An implementation that performs the logical and for the two arguments.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.EventRecognizerExtensions.Or(yWorks.Controls.Input.EventRecognizer,yWorks.Controls.Input.EventRecognizer)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that performs a logical or operation between this and the other callback.</para>
      </summary>
      <param name="recognizer">
        <para>The recognizer to operate on.</para>
      </param>
      <param name="other">
        <para>The other recognizer.</para>
      </param>
      <returns>
        <para>An implementation that performs the logical and for the two arguments.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.Input.EventRecognizerExtensions.Inverse(yWorks.Controls.Input.EventRecognizer)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Controls.Input.EventRecognizer" /> instance that yields the boolean inverse of the given <see cref="T:yWorks.Controls.Input.EventRecognizer" />.</para>
      </summary>
      <param name="recognizer">
        <para>The recognizer to invert.</para>
      </param>
      <returns>
        <para>An implementation that performs the logical negation for the argument.</para>
      </returns>
    </member>
    <member name="T:yWorks.Controls.Mouse2DEventTypes">
      <summary>
        <para>Enumeration of the possible <see cref="T:yWorks.Controls.Mouse2DEventArgs" /> types.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Mouse2DEventTypes.None">
      <summary>
        <para>Not a mouse event.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Mouse2DEventTypes.Moved">
      <summary>
        <para>The mouse has been moved.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Mouse2DEventTypes.Dragged">
      <summary>
        <para>The mouse has been dragged, which means it has been moved while at least one button has been pressed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Mouse2DEventTypes.Pressed">
      <summary>
        <para>A button has been pressed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Mouse2DEventTypes.Released">
      <summary>
        <para>A button has been released.</para>
      </summary>
      <remarks>
        <para>If there was no drag event since the last press event, this will result in a click.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Mouse2DEventTypes.Entered">
      <summary>
        <para>The mouse has entered the control's bounds.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Mouse2DEventTypes.Exited">
      <summary>
        <para>The mouse has exited the control's bounds.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Mouse2DEventTypes.WheelTurned">
      <summary>
        <para>The mouse wheel has been turned.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Mouse2DEventTypes.Clicked">
      <summary>
        <para>A mouse click has been recognized.</para>
      </summary>
      <remarks>
        <para>This is the case if a press has directly been followed by a release.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Mouse2DEventTypes.LostCapture">
      <summary>
        <para>Mouse input capture has been lost.</para>
      </summary>
      <remarks>
        <para>This can happen during mouse drags, if any button is pressed and the focus is taken from the application or transferred to another component by other means then moving the mouse.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.Mouse2DEventArgs">
      <summary>
        <para>Complex event arguments that is used by the <see cref="T:yWorks.Controls.CanvasControl" /> to indicate mouse events in world coordinates.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Mouse2DEventArgs.#ctor(yWorks.Controls.Mouse2DEventTypes,yWorks.Geometry.PointD,System.Windows.Forms.MouseButtons,System.Windows.Forms.Keys,System.Windows.Forms.MouseButtons,System.Windows.Forms.Keys)">
      <summary>
        <para>Constructs a new mouse event argument.</para>
      </summary>
      <param name="eventType">
        <para>The type of the event</para>
      </param>
      <param name="location">
        <para>the position of the mouse in world coordinates at the time of the event</para>
      </param>
      <param name="changedButtons">
        <para>the mouse buttons that have changed state if the type of event is <see cref="F:yWorks.Controls.Mouse2DEventTypes.Pressed" /> or <see cref="F:yWorks.Controls.Mouse2DEventTypes.Released" /></para>
      </param>
      <param name="changedModifiers">
        <para>the modifier Keys that have been changed</para>
      </param>
      <param name="buttons">
        <para>the current state of the MouseButtons</para>
      </param>
      <param name="modifiers">
        <para>the current state of the modifier Keys</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Mouse2DEventArgs.#ctor(yWorks.Controls.Mouse2DEventTypes,yWorks.Geometry.PointD,System.Windows.Forms.MouseButtons,System.Windows.Forms.Keys,System.Windows.Forms.MouseButtons,System.Windows.Forms.Keys,System.Int32,System.Int32)">
      <summary>
        <para>Constructs a new mouse event argument.</para>
      </summary>
      <param name="eventType">
        <para>The type of the event</para>
      </param>
      <param name="location">
        <para>the position of the mouse in world coordinates at the time of the event</para>
      </param>
      <param name="changedButtons">
        <para>the mouse buttons that have changed state if the type of event is <see cref="F:yWorks.Controls.Mouse2DEventTypes.Pressed" /> or <see cref="F:yWorks.Controls.Mouse2DEventTypes.Released" /></para>
      </param>
      <param name="changedModifiers">
        <para>the modifier Keys that have been changed</para>
      </param>
      <param name="buttons">
        <para>the current state of the MouseButtons</para>
      </param>
      <param name="modifiers">
        <para>the current state of the modifier Keys</para>
      </param>
      <param name="clickCount">
        <para>the number of clicks this event represents, 2 for a double click</para>
      </param>
      <param name="mouseWheelDelta">
        <para>the signed number of mouse wheel turn units</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.Mouse2DEventArgs.EventType">
      <summary>
        <para>Gets the type of this event.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Mouse2DEventArgs.Location">
      <summary>
        <para>Gets the coordinates in the world coordinate space associated with this event.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Mouse2DEventArgs.ClickCount">
      <summary>
        <para>Gets the number of clicks the current event represents if it is of type <see cref="F:yWorks.Controls.Mouse2DEventTypes.Clicked" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Mouse2DEventArgs.WheelDelta">
      <summary>
        <para>Gets the signed number of mouse wheel turn units.</para>
      </summary>
      <remarks>
        <para>Note that this can, for high-precision mouse wheels, include fractional turns.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Mouse2DEventArgs.ScrollAmount">
      <summary>
        <para>Gets the distance to scroll at once when <see cref="P:yWorks.Controls.Mouse2DEventArgs.ScrollType" /> is <see cref="F:yWorks.Controls.ScrollType.Lines" />.</para>
      </summary>
      <remarks>
        <para>This is a system setting that only applies to scrolling (not zooming) and usually translates to the number of small scroll increments per scroll wheel notch.</para>
        <para>This property has a value of <c>1</c> if <see cref="P:yWorks.Controls.Mouse2DEventArgs.ScrollType" /> is <see cref="F:yWorks.Controls.ScrollType.Page" />, as it is not applicable in that case.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Mouse2DEventArgs.ScrollType">
      <summary>
        <para>Gets the scrolling behavior.</para>
      </summary>
      <remarks>
        <para>This is a system setting that only applies to scrolling (not zooming) and can be either <see cref="F:yWorks.Controls.ScrollType.Lines" />, in which case <see cref="P:yWorks.Controls.Mouse2DEventArgs.ScrollAmount" /> will contain the number of "lines" to scroll with each scroll wheel notch, or <see cref="F:yWorks.Controls.ScrollType.Page" /> in which case a single scroll wheel notch should scroll a "page" at a time.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Controls.Mouse2DEventArgs.ChangedModifiers">
      <summary>
        <para>Gets the modifier keys that have changed for this event.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Mouse2DEventArgs.Modifiers" />
    </member>
    <member name="P:yWorks.Controls.Mouse2DEventArgs.ChangedButtons">
      <summary>
        <para>Gets the mouse buttons that have changed for this event.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Mouse2DEventArgs.Buttons" />
    </member>
    <member name="P:yWorks.Controls.Mouse2DEventArgs.Modifiers">
      <summary>
        <para>Gets the state of the modifier keys at the time of the event creation.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.Mouse2DEventArgs.Buttons">
      <summary>
        <para>Gets the state of the mouse buttons at the time of the event creation.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Mouse2DEventArgs.ToString">
      <summary>
        <para>Provides a human readable string representation of this event.</para>
      </summary>
      <returns />
    </member>
    <member name="T:yWorks.Controls.ScrollType">
      <summary>
        <para>An enumeration containing values for different mouse wheel scroll behavior.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.ScrollType.Lines">
      <summary>
        <para>Scrolling should scroll a set number of lines per mouse wheel notch.</para>
      </summary>
      <seealso cref="P:yWorks.Controls.Mouse2DEventArgs.ScrollAmount" />
    </member>
    <member name="F:yWorks.Controls.ScrollType.Page">
      <summary>
        <para>Scrolling should scroll a single "page" per mouse wheel notch.</para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.Input.MouseEventRecognizers">
      <summary>
        <para>A utility class that offers <see cref="T:yWorks.Controls.Input.EventRecognizer" />s that deal with <see cref="T:yWorks.Controls.Mouse2DEventArgs" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.Moved">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies mouse movements that are not drags.</para>
      </summary>
      <seealso cref="F:yWorks.Controls.Input.MouseEventRecognizers.Dragged" />
      <seealso cref="F:yWorks.Controls.Input.MouseEventRecognizers.MovedOrDragged" />
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.MovedOrDragged">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies mouse movements.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.Pressed">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies mouse movements.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.Released">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies mouse movements.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.LostCapture">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies mouse input capture lost events.</para>
      </summary>
      <remarks>
        <para>This event will occur often, especially after all mouse buttons have been released. More relevant for <see cref="T:yWorks.Controls.Input.IInputMode" />s is the <see cref="F:yWorks.Controls.Input.MouseEventRecognizers.LostCaptureDuringDrag" /> event recognizer.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.LostCaptureDuringDrag">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies mouse input capture lost events while at least one mouse button was pressed.</para>
      </summary>
      <remarks>
        <para>Since the mouse capture has been lost, the necessary <see cref="F:yWorks.Controls.Mouse2DEventTypes.Released" /> events will never be triggered. This recognizer is useful for identifying this situation.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.LeftClicked">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies left mouse button clicks.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.Clicked">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies button clicks.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.MultiClicked">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies button multi-clicks.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.RightClicked">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies right mouse button clicks.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.MiddleClicked">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies middle mouse button clicks.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.LeftDoubleClicked">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies left mouse button double clicks.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.RightDoubleClicked">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies right mouse button double clicks.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.MiddleDoubleClicked">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies middle mouse button double clicks.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.LeftPressed">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies left mouse button press events.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.LeftReleased">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies left mouse button release events.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.RightPressed">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies right mouse button press events.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.RightReleased">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies right mouse button release events.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.Dragged">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies mouse drag events.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.LeftDragged">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies left mouse button drags.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.Exited">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies when the has left the control.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.Entered">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies when the mouse has entered the control.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.RightDragged">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies right mouse button drags.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Input.MouseEventRecognizers.MiddleDragged">
      <summary>
        <para>An <see cref="T:yWorks.Controls.Input.EventRecognizer" /> that identifies middle mouse button drags.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.CompositeUndoUnit">
      <summary>
        <para>A group of <see cref="T:yWorks.Graph.IUndoUnit" />s that are undone/redone as a single unit.</para>
      </summary>
      <remarks>
        <para>Clients can use this class to build an <see cref="T:yWorks.Graph.IUndoUnit" /> that groups together multiple <see cref="T:yWorks.Graph.IUndoUnit" />s. The <see cref="T:yWorks.Graph.IUndoUnit" />s added to this unit are undone/redone in the order in which they were added. This implementation will try to <see cref="M:yWorks.Graph.IUndoUnit.TryMergeUnit(yWorks.Graph.IUndoUnit)">merge</see> or <see cref="M:yWorks.Graph.IUndoUnit.TryReplaceUnit(yWorks.Graph.IUndoUnit)">replace</see> units that are <see cref="M:yWorks.Graph.CompositeUndoUnit.Add(yWorks.Graph.IUndoUnit)">added</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.#ctor">
      <summary>
        <para>Creates a new instance with null names.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.#ctor(System.String,System.String)">
      <summary>
        <para>Creates a new instance using the provided names.</para>
      </summary>
      <param name="undoName" />
      <param name="redoName" />
    </member>
    <member name="P:yWorks.Graph.CompositeUndoUnit.Count">
      <summary>
        <para>Gets the number of units that are contained in this compound unit.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.CompositeUndoUnit.RedoName">
      <summary>
        <para>Gets or sets the current redo name.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.CompositeUndoUnit.UndoName">
      <summary>
        <para>Gets or sets the current redo name.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.Add(yWorks.Graph.IUndoUnit)">
      <summary>
        <para>Adds a new <see cref="T:yWorks.Graph.IUndoUnit" /> to the queue.</para>
      </summary>
      <param name="unit">
        <para>The unit of work to add.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.Clear">
      <summary>
        <para>Clears the internal collection of units.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.Undo">
      <summary>
        <para>Undoes the next <see cref="T:yWorks.Graph.IUndoUnit" />.</para>
      </summary>
      <exception cref="T:System.NotSupportedException">
        <para>If an undo operation is already in progress.</para>
      </exception>
      <exception cref="T:System.Exception">
        <para>If <see cref="M:yWorks.Graph.CompositeUndoUnit.CanUndo" /> would yield <c>false</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.Redo">
      <summary>
        <para>Redoes the next <see cref="T:yWorks.Graph.IUndoUnit" />.</para>
      </summary>
      <exception cref="T:System.NotSupportedException">
        <para>If an undo operation is already in progress.</para>
      </exception>
      <exception cref="T:System.Exception">
        <para>If <see cref="M:yWorks.Graph.CompositeUndoUnit.CanRedo" /> would yield <c>false</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.RemoveUnit(yWorks.Graph.IUndoUnit)">
      <summary>
        <para>Tries to remove a given unit from this compound unit.</para>
      </summary>
      <remarks>
        <para>This method will throw an exception if this unit has been undone or an undo or redo is in progress or this unit has already been disposed. This method will not automatically <see cref="M:System.IDisposable.Dispose">Dispose</see> removed units.</para>
      </remarks>
      <param name="unit">
        <para>The unit to remove.</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff the unit has been removed from this instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.CanUndo">
      <summary>
        <para>Determines whether a call to <see cref="M:yWorks.Graph.CompositeUndoUnit.Undo" /> can be made.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.CanRedo">
      <summary>
        <para>Determines whether a call to <see cref="M:yWorks.Graph.CompositeUndoUnit.Redo" /> can be made.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.Dispose">
      <summary>
        <para>Disposes this unit and all of its contents.</para>
      </summary>
      <remarks>
        <para>This unit cannot be used anymore after this has been invoked.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.CompositeUndoUnit.Disposed">
      <summary>
        <para>Gets whether this instance has been <see cref="M:yWorks.Graph.CompositeUndoUnit.Dispose">disposed.</see></para>
      </summary>
      <remarks>
        <para>An instance that has been disposed cannot be <see cref="M:yWorks.Graph.CompositeUndoUnit.Undo">undone</see> or <see cref="M:yWorks.Graph.CompositeUndoUnit.Redo">redone</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.CompositeUndoUnit.ToString" />
    <member name="T:yWorks.Controls.Contexts">
      <summary>
        <para>Static utility class that servers as a factory for various <see cref="T:yWorks.Controls.ICanvasContext" /> or <see cref="T:yWorks.Controls.Input.IInputModeContext" /> implementations.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.Contexts.CreateCanvasContext(yWorks.Controls.CanvasControl,System.Double,System.Double,System.Double)">
      <summary>
        <para>Provides a default immutable <see cref="T:yWorks.Controls.ICanvasContext" /> with the given values.</para>
      </summary>
      <remarks>
        <para>If the values for zoom or hitTestRadius are not specified, the values will be obtained from the given canvas.</para>
      </remarks>
      <param name="canvas">
        <para>the canvas</para>
      </param>
      <param name="zoom">
        <para>the zoom level</para>
      </param>
      <param name="scale">
        <para>the additional scale factor</para>
      </param>
      <param name="hitTestRadius">
        <para>the hit test radius</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.Contexts.CreateInputModeContext(yWorks.Controls.Input.IInputMode,yWorks.Graph.ILookup)">
      <summary>
        <para>Factory method that creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> that uses the provided parent mode and lookup decoration.</para>
      </summary>
      <param name="parent" />
      <param name="lookup" />
    </member>
    <member name="M:yWorks.Controls.Contexts.CreateInputModeContext(yWorks.Controls.Input.IInputMode,yWorks.Graph.LookupCallback)">
      <summary>
        <para>Factory method that creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> that uses the provided parent mode and lookup decoration.</para>
      </summary>
      <param name="parent" />
      <param name="lookupCallback" />
    </member>
    <member name="M:yWorks.Controls.Contexts.CreateInputModeContext(yWorks.Controls.Input.IInputMode,yWorks.Controls.Input.IInputModeContext,yWorks.Graph.ILookup)">
      <summary>
        <para>Factory method that creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> that uses the provided parent mode, parent context, and lookup decoration.</para>
      </summary>
      <param name="parent" />
      <param name="parentContext" />
      <param name="lookup" />
    </member>
    <member name="M:yWorks.Controls.Contexts.CreateInputModeContext(yWorks.Controls.Input.IInputMode,yWorks.Controls.Input.IInputModeContext,yWorks.Graph.LookupCallback)">
      <summary>
        <para>Factory method that creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> that uses the provided parent mode, parent context, and lookup decoration.</para>
      </summary>
      <param name="parent" />
      <param name="parentContext" />
      <param name="lookupCallback" />
    </member>
    <member name="M:yWorks.Controls.Contexts.CreateInputModeContext(yWorks.Controls.CanvasControl,yWorks.Controls.Input.IInputMode,yWorks.Graph.ILookup)">
      <summary>
        <para>Factory method that creates an <see cref="T:yWorks.Controls.Input.IInputModeContext" /> that uses the provided values.</para>
      </summary>
      <param name="canvas">
        <para>The <see cref="T:yWorks.Controls.CanvasControl" /> to use, may not be <c>null</c>.</para>
      </param>
      <param name="parent">
        <para>The mode to set as the parent. This may be <c>null</c> for the canvas' context.</para>
      </param>
      <param name="lookup">
        <para>The lookup to use.</para>
      </param>
    </member>
    <member name="F:yWorks.Controls.Contexts.Default">
      <summary>
        <para>Provides a default immutable context with a hit radius of 3 and a zoom level of 1.</para>
      </summary>
    </member>
    <member name="F:yWorks.Controls.Contexts.Empty">
      <summary>
        <para>An empty context where both the inputmode and the canvas is <c>null</c>.</para>
      </summary>
      <remarks>
        <para>The lookup always yields null, also.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.DictionaryLookup">
      <summary>
        <para>A simple mutable <see cref="T:yWorks.Graph.ILookup" /> implementation that is backed by a dictionary.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.DictionaryLookup.#ctor">
      <summary>
        <para>Creates an instance with an initially empty map as backing store.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.DictionaryLookup.#ctor(System.Collections.Generic.IDictionary{System.Type,System.Object})">
      <summary>
        <para>Creates an instance with the given map as the backing store.</para>
      </summary>
      <param name="map" />
      <exception cref="T:System.ArgumentNullException">
        <para>if the <paramref name="map" /> is <c>null</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.DictionaryLookup.Put(System.Type,System.Object)">
      <summary>
        <para>Adds an in instance to the map for the given type.</para>
      </summary>
      <remarks>
        <para>If <paramref name="value" /> is <c>null</c> the entry is removed from the map.</para>
      </remarks>
      <param name="type">
        <para>the type that will be used as a key for queries</para>
      </param>
      <param name="value">
        <para>the instance implementing <paramref name="type" /> or <c>null</c></para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the parameters do not match</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.DictionaryLookup.Lookup(System.Type)">
      <summary>
        <para>Performs the lookup using the map as the backing store.</para>
      </summary>
      <param name="type">
        <para>the type to query</para>
      </param>
      <returns>
        <para>the instance found in the map or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DictionaryLookup.HasLookup(System.Type)">
      <summary>
        <para>Determines whether the specified type exists in this lookup.</para>
      </summary>
      <param name="type">
        <para>The type to look up.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified type exists in this lookup; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.DictionaryLookup.Remove(System.Type)">
      <summary>
        <para>Removes the specified type from this lookup.</para>
      </summary>
      <param name="type">
        <para>The type to remove from this instance.</para>
      </param>
    </member>
    <member name="T:yWorks.Controls.CommandExtensions">
      <summary>
        <para>Utility class that contains extension methods that bind <see cref="T:yWorks.Controls.ICommand" />s to buttons and the like.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ButtonBase,yWorks.Controls.ICommand,System.Object,System.Windows.Forms.Control)">
      <summary>
        <para>Sets the command, parameter, and target to the provided button.</para>
      </summary>
      <remarks>
        <para>Upon click, the command will be executed using the provided target and command parameter.</para>
      </remarks>
      <param name="button">
        <para>The button.</para>
      </param>
      <param name="command">
        <para>The command.</para>
      </param>
      <param name="parameter">
        <para>The parameter.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ToolStripButton,yWorks.Controls.ICommand,System.Object,System.Windows.Forms.Control)">
      <summary>
        <para>Sets the command, parameter, and target to the provided button.</para>
      </summary>
      <remarks>
        <para>Upon click, the command will be executed using the provided target and command parameter.</para>
      </remarks>
      <param name="button">
        <para>The button.</para>
      </param>
      <param name="command">
        <para>The command.</para>
      </param>
      <param name="parameter">
        <para>The parameter.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ToolStripMenuItem,yWorks.Controls.ICommand,System.Object,System.Windows.Forms.Control)">
      <summary>
        <para>Sets the command, parameter, and target to the provided menu item.</para>
      </summary>
      <remarks>
        <para>Upon click, the command will be executed using the provided target and command parameter.</para>
      </remarks>
      <param name="menuItem">
        <para>The menu item.</para>
      </param>
      <param name="command">
        <para>The command.</para>
      </param>
      <param name="parameter">
        <para>The parameter.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ToolStripItem,yWorks.Controls.ICommand,System.Object,System.Windows.Forms.Control)">
      <summary>
        <para>Sets the command, parameter, and target to the provided item.</para>
      </summary>
      <remarks>
        <para>Upon click, the command will be executed using the provided target and command parameter.</para>
      </remarks>
      <param name="menuItem">
        <para>The menu item.</para>
      </param>
      <param name="command">
        <para>The command.</para>
      </param>
      <param name="parameter">
        <para>The parameter.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ButtonBase,yWorks.Controls.ICommand,System.Windows.Forms.Control)">
      <summary>
        <para>Sets the command and target to the provided button.</para>
      </summary>
      <remarks>
        <para>Upon click, the command will be executed using the provided target and a <c>null</c> command parameter.</para>
      </remarks>
      <param name="button">
        <para>The button.</para>
      </param>
      <param name="command">
        <para>The command.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ToolStripButton,yWorks.Controls.ICommand,System.Windows.Forms.Control)">
      <summary>
        <para>Sets the command and target to the provided button.</para>
      </summary>
      <remarks>
        <para>Upon click, the command will be executed using the provided target and a <c>null</c> command parameter.</para>
      </remarks>
      <param name="button">
        <para>The button.</para>
      </param>
      <param name="command">
        <para>The command.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ToolStripMenuItem,yWorks.Controls.ICommand,System.Windows.Forms.Control)">
      <summary>
        <para>Sets the command and target to the provided menu item.</para>
      </summary>
      <remarks>
        <para>Upon click, the command will be executed using the provided target and a <c>null</c> command parameter.</para>
      </remarks>
      <param name="menuItem">
        <para>The menu item.</para>
      </param>
      <param name="command">
        <para>The command.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ToolStripItem,yWorks.Controls.ICommand,System.Windows.Forms.Control)">
      <summary>
        <para>Sets the command and target to the provided item.</para>
      </summary>
      <remarks>
        <para>Upon click, the command will be executed using the provided target and a <c>null</c> command parameter.</para>
      </remarks>
      <param name="menuItem">
        <para>The menu item.</para>
      </param>
      <param name="command">
        <para>The command.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.Add(System.Windows.Forms.ToolStripItemCollection,yWorks.Controls.ICommand,System.Windows.Forms.Control)">
      <summary>
        <para>Adds the specified command to the collection and wires it to the command using <see cref="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ToolStripMenuItem,yWorks.Controls.ICommand,System.Windows.Forms.Control)" />.</para>
      </summary>
      <param name="items">
        <para>The items to add a new item to.</para>
      </param>
      <param name="command">
        <para>The command to use.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
      <returns>
        <para>The newly created item.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.Add(System.Windows.Forms.ToolStripItemCollection,yWorks.Controls.ICommand,System.Object,System.Windows.Forms.Control)">
      <summary>
        <para>Adds the specified command to the collection and wires it to the command using <see cref="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ToolStripMenuItem,yWorks.Controls.ICommand,System.Windows.Forms.Control)" />.</para>
      </summary>
      <param name="items">
        <para>The items to add a new item to.</para>
      </param>
      <param name="command">
        <para>The command to use.</para>
      </param>
      <param name="parameter">
        <para>The parameter for the command.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
      <returns>
        <para>The newly created item.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.Add(System.Windows.Forms.ToolStripItemCollection,System.Drawing.Image,yWorks.Controls.ICommand,System.Windows.Forms.Control)">
      <summary>
        <para>Adds the specified command to the collection and wires it to the command using <see cref="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ToolStripMenuItem,yWorks.Controls.ICommand,System.Windows.Forms.Control)" />.</para>
      </summary>
      <param name="items">
        <para>The items to add a new item to.</para>
      </param>
      <param name="image">
        <para>The image to use for the item.</para>
      </param>
      <param name="command">
        <para>The command to use.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
      <returns>
        <para>The newly created item.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.CommandExtensions.Add(System.Windows.Forms.ToolStripItemCollection,System.Drawing.Image,yWorks.Controls.ICommand,System.Object,System.Windows.Forms.Control)">
      <summary>
        <para>Adds the specified command to the collection and wires it to the command using <see cref="M:yWorks.Controls.CommandExtensions.SetCommand(System.Windows.Forms.ToolStripMenuItem,yWorks.Controls.ICommand,System.Windows.Forms.Control)" />.</para>
      </summary>
      <param name="items">
        <para>The items to add a new item to.</para>
      </param>
      <param name="image">
        <para>The image to use for the icon.</para>
      </param>
      <param name="command">
        <para>The command to use.</para>
      </param>
      <param name="parameter">
        <para>The parameter to pass to the command.</para>
      </param>
      <param name="target">
        <para>The target.</para>
      </param>
      <returns>
        <para>The newly created item.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.LookupExtensions">
      <summary>
        <para>Extension method holder class that extends the <see cref="T:yWorks.Graph.ILookup" /> and <see cref="T:yWorks.Graph.ILookupDecorator" /> types with utility methods.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.ILookup" />
      <seealso cref="T:yWorks.Graph.ILookupDecorator" />
    </member>
    <member name="M:yWorks.Graph.LookupExtensions.Lookup``1(yWorks.Graph.ILookup)">
      <summary>
        <para>Typesafe convenience method for the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method.</para>
      </summary>
      <typeparam name="T">
        <para>The type to query, this is passed to the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method using <c>typeof</c>. The result of the query will safely be converted to this type.</para>
      </typeparam>
      <param name="lookup">
        <para>The lookup to operate on (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The result of the query, or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LookupExtensions.SafeLookup``1(yWorks.Graph.ILookup)">
      <summary>
        <para>Typesafe convenience method for the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method.</para>
      </summary>
      <typeparam name="T">
        <para>The type to query, this is passed to the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> method using <c>typeof</c>. The result of the query will be converted to this type.</para>
      </typeparam>
      <param name="lookup">
        <para>The lookup to operate on (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The result of the query, never <c>null</c>.</para>
      </returns>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">
        <para>If the lookup did not yield a non-<c>null</c> result for the type.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.LookupExtensions.Lookup``1(yWorks.Graph.IContextLookup,System.Object)">
      <summary>
        <para>Typesafe convenience method for the <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> method.</para>
      </summary>
      <typeparam name="T">
        <para>The type to query, this is passed to the <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> method using <c>typeof</c>. The result of the query will be converted to this type.</para>
      </typeparam>
      <param name="lookup">
        <para>The context lookup to operate on (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="item">
        <para>The item to pass to the <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> method.</para>
      </param>
      <returns>
        <para>The result of the query, or <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LookupExtensions.SafeLookup``1(yWorks.Graph.IContextLookup,System.Object)">
      <summary>
        <para>Typesafe convenience method for the <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> method.</para>
      </summary>
      <typeparam name="T">
        <para>The type to query, this is passed to the <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> method using <c>typeof</c>. The result of the query will be converted to this type.</para>
      </typeparam>
      <param name="lookup">
        <para>The context lookup to operate on (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="item">
        <para>The item to pass to the <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> method.</para>
      </param>
      <returns>
        <para>The result of the query, never <c>null</c>.</para>
      </returns>
      <exception cref="T:System.Collections.Generic.KeyNotFoundException">
        <para>If the context lookup did not yield a non-<c>null</c> result for the type.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.LookupExtensions.Add``2(yWorks.Graph.ILookupDecorator,System.Func{``0,``1},System.Boolean)">
      <summary>
        <para>Adds a lookup implementation for a given type using a <see cref="T:System.Func`2" />.</para>
      </summary>
      <typeparam name="TContext">
        <para>The type of the context subject.</para>
      </typeparam>
      <typeparam name="TResult">
        <para>The type of the query, which is a base type or the type of the result.</para>
      </typeparam>
      <param name="decorator">
        <para>The decorator instance to use, which may be <c>null</c>. (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <param name="factory">
        <para>The factory delegate that will be used to satisfy queries of type <typeparamref name="TResult" />.</para>
      </param>
      <param name="nullIsFallback">
        <para>Whether to treat <c>null</c>-results of the <paramref name="factory" /> as hints to use the remainder of the chain link or to actually yield the value as the final result.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.IContextLookupChainLink" /> instance as returned by the <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" /> call or <c>null</c>, if either <paramref name="decorator" /> was <c>null</c>, or it <see cref="M:yWorks.Graph.ILookupDecorator.CanDecorate(System.Type)">could not decorate</see> the <typeparamref name="TContext" /> type.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LookupExtensions.Add``2(yWorks.Graph.LookupChain,System.Func{``0,``1},System.Boolean)">
      <summary>
        <para>A convenience method that adds a <see cref="T:yWorks.Graph.IContextLookupChainLink" /> to the given chain that is based on a <see cref="T:System.Func`2" />.</para>
      </summary>
      <remarks>
        <para>Depending on <paramref name="nullIsFallback" />, <c>null</c> return values of the <paramref name="factory" /> will be interpreted as the final result or indicate to the implementation that the chain should be queried for the result.</para>
      </remarks>
      <typeparam name="TContext">
        <para>The type of the context.</para>
      </typeparam>
      <typeparam name="TResult">
        <para>The type of the result.</para>
      </typeparam>
      <param name="chain">
        <para>The chain to add the link to.</para>
      </param>
      <param name="factory">
        <para>The factory that will be called for queries to <typeparamref name="TResult" />.</para>
      </param>
      <param name="nullIsFallback">
        <para>If set to <c>true</c>, <c>null</c> return values of the factory method will be interpreted as the final result, otherwise the request will propagate down the chain.</para>
      </param>
      <returns>
        <para>The link that has been registered with the chain.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LookupExtensions.Add``2(yWorks.Graph.ILookupDecorator,System.Func{``0,``1,``1},System.Boolean)">
      <summary>
        <para>Adds a lookup implementation for a given type using a <see cref="T:System.Func`3" />.</para>
      </summary>
      <remarks>
        <para>This method is closely related to the <see cref="M:yWorks.Graph.LookupExtensions.Add``2(yWorks.Graph.ILookupDecorator,System.Func{``0,``1},System.Boolean)" /> method, however it passes the result of the remaining chain to the delegate for convenient wrapping of the result. Note that if the implementation does not depend on the previous result in order to wrap it, it is better to use the <see cref="T:System.Func`2" /> variant, in order to avoid the possibly costly evaluation of the remainder of the lookup chain.</para>
      </remarks>
      <typeparam name="TContext">
        <para>The type of the context subject.</para>
      </typeparam>
      <typeparam name="TResult">
        <para>The type of the query, which is a base type or the type of the result.</para>
      </typeparam>
      <param name="decorator">
        <para>The decorator instance to use, which may be <c>null</c>. (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <param name="wrapperFactory">
        <para>The factory delegate that will be used to satisfy queries of type <typeparamref name="TResult" /></para>
      </param>
      <param name="decorateNull">
        <para>Whether to actually decorate <c>null</c> results of remainder of the chain. If this is set to <c>false</c>, the <paramref name="wrapperFactory" /> will never be called with <c>null</c> as the second argument but the result of the query for this chain link will be the <c>null</c> value.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.IContextLookupChainLink" /> instance as returned by the <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" /> call or <c>null</c>, if either <paramref name="decorator" /> was <c>null</c>, or it <see cref="M:yWorks.Graph.ILookupDecorator.CanDecorate(System.Type)">could not decorate</see> the <typeparamref name="TContext" /> type.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LookupExtensions.Add``2(yWorks.Graph.LookupChain,System.Func{``0,``1,``1},System.Boolean)">
      <summary>
        <para>A convenience method that adds a <see cref="T:yWorks.Graph.IContextLookupChainLink" /> to the given chain that is based on a <see cref="T:System.Func`3" />.</para>
      </summary>
      <remarks>
        <para>Depending on <paramref name="decorateNull" />, <c>null</c> results of the underlying chain will be passed to the <paramref name="wrapperFactory" />, or simply yielded as the final result.</para>
      </remarks>
      <typeparam name="TContext">
        <para>The type of the context.</para>
      </typeparam>
      <typeparam name="TResult">
        <para>The type of the result.</para>
      </typeparam>
      <param name="chain">
        <para>The chain to add the link to.</para>
      </param>
      <param name="wrapperFactory">
        <para>The wrapper factory that will be called for queries to <typeparamref name="TResult" /> to wrap the result of the query to the remainder of the chain.</para>
      </param>
      <param name="decorateNull">
        <para>if set to <c>true</c> <c>null</c> return values of the remainder of the chain will be passed to the wrapper factory so that it can decorate the null, otherwise null will be yielded as the final result.</para>
      </param>
      <returns>
        <para>The link that has been registered with the chain.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LookupExtensions.AddConstant``2(yWorks.Graph.ILookupDecorator,``1)">
      <summary>
        <para>Add a lookup implementation for a given type that always yields a constant result.</para>
      </summary>
      <remarks>
        <para>Note that in order to work correctly, the type parameter (<typeparamref name="TResult" />) should be specified instead of being inferred by the compiler, because the parameter is used to compare with the query type in the <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> call.</para>
      </remarks>
      <typeparam name="TContext">
        <para>The type of the context subject.</para>
      </typeparam>
      <typeparam name="TResult">
        <para>The type of the query, which is a base type or the type of the result.</para>
      </typeparam>
      <param name="decorator">
        <para>The decorator instance to use, which may be <c>null</c>. (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <param name="result">
        <para>The constant value to yield if the chain is queried for an implementation of type <typeparamref name="TResult" />.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.IContextLookupChainLink" /> instance as returned by the <see cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" /> call or <c>null</c>, if either <paramref name="decorator" /> was <c>null</c>, or it <see cref="M:yWorks.Graph.ILookupDecorator.CanDecorate(System.Type)">could not decorate</see> the <typeparamref name="TContext" /> type.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.LookupExtensions.AddConstant``1(yWorks.Graph.LookupChain,``0)">
      <summary>
        <para>Convenience method that can be used instead of the <see cref="M:yWorks.Graph.LookupChain.Add(yWorks.Graph.IContextLookupChainLink)" /> method to easily add a lookup implementation for a given type that always yields a constant result.</para>
      </summary>
      <remarks>
        <para>Note that in order to work correctly, the type parameter (<typeparamref name="TResult" />) should be specified instead of being inferred by the compiler, because the parameter is used to compare with the query type in the <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> call.</para>
      </remarks>
      <typeparam name="TResult">
        <para>The type of the query, which is a base type or the type of the result.</para>
      </typeparam>
      <param name="chain">
        <para>The chain instance to use (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <param name="result">
        <para>The constant value to yield if the chain is queried for an implementation of type <typeparamref name="TResult" />.</para>
      </param>
      <returns>
        <para>The <see cref="T:yWorks.Graph.IContextLookupChainLink" /> instance that has been added to the chain.</para>
      </returns>
    </member>
    <member name="T:yWorks.Geometry.OrientedRectangleExtensions">
      <summary>
        <para>Extension method holder class that extends the <see cref="T:yWorks.Geometry.IOrientedRectangle" /> and <see cref="T:yWorks.Geometry.IMutableOrientedRectangle" /> types with utility methods.</para>
      </summary>
      <seealso cref="T:yWorks.Geometry.IOrientedRectangle" />
      <seealso cref="T:yWorks.Geometry.IMutableOrientedRectangle" />
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.GetUp(yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Gets the up vector of the oriented rectangle as a <see cref="T:yWorks.Geometry.PointD" /> struct.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to get the up vector from (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <returns>
        <para>The value of the up vector of the rectangle at the time of the invocation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.Contains(yWorks.Geometry.IOrientedRectangle,yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Determines whether the given oriented rectangle contains the provided point, using an epsilon value.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to test (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <param name="point">
        <para>The coordinates of the point to test.</para>
      </param>
      <param name="eps">
        <para>A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than or equal to that value, it will be considered a hit.</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff the point lies inside the rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.CreateTransform(yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Creates a transformation matrix that can be used to transform points that are in the local coordinate system of the oriented rectangle if the top-left corner is the origin.</para>
      </summary>
      <param name="rectangle">
        <para>The oriented rectangle to use for defining the coordinate space.</para>
      </param>
      <returns>
        <para>A matrix that can be used to transform from oriented rectangle coordinates to world coordinates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.SetUpVector(yWorks.Geometry.IMutableOrientedRectangle,yWorks.Geometry.PointD)">
      <summary>
        <para>Sets up vector of the oriented rectangle to the given value.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to set the up vector to (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <param name="up">
        <para>The coordinates of the new up vector.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.SetCenter(yWorks.Geometry.IMutableOrientedRectangle,yWorks.Geometry.PointD)">
      <summary>
        <para>Sets the center of the oriented rectangle to the given value.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to set the center of (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <param name="center">
        <para>The coordinates of the new center.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.SetAnchor(yWorks.Geometry.IMutableOrientedRectangle,yWorks.Geometry.PointD)">
      <summary>
        <para>Sets the anchor vector of the oriented rectangle to the given value.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to set the anchor (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <param name="location">
        <para>The coordinates of the new anchor location.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.GetAnchorLocation(yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Gets the anchor location of the oriented rectangle as a <see cref="T:yWorks.Geometry.PointD" /> struct.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to get the anchor from (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <returns>
        <para>The anchor location of the rectangle at the time of the invocation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.GetTopLeftLocation(yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Gets the location of the top left corner of the oriented rectangle as a <see cref="T:yWorks.Geometry.PointD" />.</para>
      </summary>
      <remarks>
        <para>The top left corner is the one the up vector points to.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to get the top left from (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <returns>
        <para>The top left location of the rectangle at the time of the invocation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.GetSize(yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Gets the size of the oriented rectangle.</para>
      </summary>
      <param name="rectangle">
        <para>The oriented rectangle to get the size properties from.</para>
      </param>
      <returns>
        <para>The width and height of the oriented rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.GetCenter(yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Gets the current center of the oriented rectangle as a <see cref="T:yWorks.Geometry.PointD" /> struct.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle that will be used for providing the center (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The current coordinates of the center.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.Hits(yWorks.Geometry.IOrientedRectangle,yWorks.Geometry.PointD,System.Double)">
      <summary>
        <para>Determines whether the oriented rectangle contains the provided point, using an epsilon value.</para>
      </summary>
      <param name="rectangle">
        <para>The oriented rectangle (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="location">
        <para>The coordinates of the point to test.</para>
      </param>
      <param name="eps">
        <para>A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than or equal to that value, it will be considered a hit.</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff the point lies inside the rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.OrientedRectangleExtensions.GetBounds(yWorks.Geometry.IOrientedRectangle)">
      <summary>
        <para>Determines the bounds of an oriented rectangle.</para>
      </summary>
      <remarks>
        <para>Bounding rectangles are parallel to the coordinate axes.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to determine the bounds (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The bounds.</para>
      </returns>
    </member>
    <member name="T:yWorks.Geometry.PointExtensions">
      <summary>
        <para>Extension method holder class that extends the <see cref="T:yWorks.Geometry.IPoint" /> and <see cref="T:yWorks.Geometry.IMutablePoint" /> types with utility methods.</para>
      </summary>
      <seealso cref="T:yWorks.Geometry.IPoint" />
      <seealso cref="T:yWorks.Geometry.IMutablePoint" />
    </member>
    <member name="M:yWorks.Geometry.PointExtensions.Relocate(yWorks.Geometry.IMutablePoint,yWorks.Geometry.PointD)">
      <summary>
        <para>Sets the coordinates of the point to the given values.</para>
      </summary>
      <param name="point">
        <para>The point setter to use for setting the values (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="location">
        <para>The new location.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.PointExtensions.Relocate(yWorks.Geometry.IMutablePoint,System.Double,System.Double)">
      <summary>
        <para>Sets the coordinates of the point to the given values.</para>
      </summary>
      <param name="point">
        <para>The point setter to use for setting the values (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="x">
        <para>The new x coordinate</para>
      </param>
      <param name="y">
        <para>The new y coordinate</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.PointExtensions.Relocate(yWorks.Geometry.IMutablePoint,yWorks.Geometry.IPoint)">
      <summary>
        <para>Sets the coordinates of the point to the given values.</para>
      </summary>
      <param name="point">
        <para>The point setter to use for setting the values (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="location">
        <para>The new location.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.PointExtensions.ToPointD(yWorks.Geometry.IPoint)">
      <summary>
        <para>Copies the current values of the coordinates of the point to a <see cref="T:yWorks.Geometry.PointD" /> struct.</para>
      </summary>
      <remarks>
        <para>This method is useful to obtain a copy of the state and for making use of the various utility methods that are provided by <see cref="T:yWorks.Geometry.PointD" />.</para>
      </remarks>
      <param name="point">
        <para>The point (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The current values of the coordinates of the point.</para>
      </returns>
      <seealso cref="M:yWorks.Geometry.PointD.ToMutablePoint" />
      <seealso cref="M:yWorks.Geometry.PointExtensions.Relocate(yWorks.Geometry.IMutablePoint,yWorks.Geometry.PointD)" />
    </member>
    <member name="M:yWorks.Geometry.PointExtensions.DistanceTo(yWorks.Geometry.IPoint,yWorks.Geometry.IPoint)">
      <summary>
        <para>Calculates the Euclidean distance between two points.</para>
      </summary>
      <param name="point1">
        <para>The first point (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="point2">
        <para>The second point.</para>
      </param>
      <returns>
        <para>The distance between the two points.</para>
      </returns>
    </member>
    <member name="T:yWorks.Geometry.RectangleExtensions">
      <summary>
        <para>Extension method holder class that extends the <see cref="T:yWorks.Geometry.IRectangle" />, and <see cref="T:yWorks.Geometry.IMutableRectangle" /> types with utility methods.</para>
      </summary>
      <seealso cref="T:yWorks.Geometry.IRectangle" />
      <seealso cref="T:yWorks.Geometry.IMutableRectangle" />
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.SetCenter(yWorks.Geometry.IMutableRectangle,yWorks.Geometry.PointD)">
      <summary>
        <para>Sets the center of the rectangle to the provided value.</para>
      </summary>
      <param name="rectangle">
        <para>The oriented rectangle (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="center">
        <para>The new center coordinates.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.Reshape(yWorks.Geometry.IMutableRectangle,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Applies a new position and size to a given mutable rectangle.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to change.</para>
      </param>
      <param name="x">
        <para>The new x coordinate of the upper left corner of the rectangle.</para>
      </param>
      <param name="y">
        <para>The new y coordinate of the upper left corner of the rectangle.</para>
      </param>
      <param name="width">
        <para>The new width of the rectangle.</para>
      </param>
      <param name="height">
        <para>The new height of the rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.Reshape(yWorks.Geometry.IMutableRectangle,yWorks.Geometry.IRectangle)">
      <summary>
        <para>Applies a new position and size to a given mutable rectangle.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to change.</para>
      </param>
      <param name="newRectangle">
        <para>The bounds to set to the <paramref name="rectangle" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.Reshape(yWorks.Geometry.IMutableRectangle,yWorks.Geometry.IPoint,yWorks.Geometry.ISize)">
      <summary>
        <para>Applies a new position and size to a given mutable rectangle.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to change.</para>
      </param>
      <param name="position">
        <para>The new location.</para>
      </param>
      <param name="size">
        <para>The new size.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.Reshape(yWorks.Geometry.IMutableRectangle,yWorks.Geometry.RectD)">
      <summary>
        <para>Applies a new position and size to a given mutable rectangle.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to change.</para>
      </param>
      <param name="newRectangle">
        <para>The bounds to set to the <paramref name="rectangle" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.Reshape(yWorks.Geometry.IMutableRectangle,System.Drawing.RectangleF)">
      <summary>
        <para>Calls <see cref="M:yWorks.Geometry.RectangleExtensions.Reshape(yWorks.Geometry.IMutableRectangle,System.Double,System.Double,System.Double,System.Double)" /> method using the respective values obtained from the provided instance.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to change.</para>
      </param>
      <param name="newRectangle">
        <para>The rectangle to read the state from.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.GetSize(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Gets the current size of the rectangle as a <see cref="T:yWorks.Geometry.SizeD" /> struct.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The current size of the rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.Resize(yWorks.Geometry.IMutableRectangle,yWorks.Geometry.SizeD)">
      <summary>
        <para>Sets the size of the rectangle to the values of a <see cref="T:yWorks.Geometry.SizeD" /> struct.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="size">
        <para>The new size to set to the rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.Contains(yWorks.Geometry.IRectangle,yWorks.Geometry.IPoint)">
      <summary>
        <para>Determines whether the given rectangle contains the provided point.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="point">
        <para>The point to test.</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff the point lies inside the rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.Contains(yWorks.Geometry.IRectangle,yWorks.Geometry.PointD)">
      <summary>
        <para>Determines whether the given rectangle contains the provided point.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="point">
        <para>The point to test.</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff the point lies inside the rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.SetToUnion(yWorks.Geometry.IMutableRectangle,yWorks.Geometry.IRectangle,yWorks.Geometry.IRectangle)">
      <summary>
        <para>Creates the union of two rectangles, placing the result in the this parameter.</para>
      </summary>
      <remarks>
        <para>Either of the two parameters rectangles may be the same as the first parameter. The result is placed into the this parameter. This method treats rectangles with negative width or height as empty.</para>
      </remarks>
      <param name="rectangle1">
        <para>The first rectangle to create the union of.</para>
      </param>
      <param name="rectangle2">
        <para>The second rectangle to create the union of.</para>
      </param>
      <param name="rectangle">
        <para>The rectangle to hold the result (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.ToRectD(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Copies the current values of the rectangle to <see cref="T:yWorks.Geometry.RectD" /> struct.</para>
      </summary>
      <remarks>
        <para>This method can be used to obtain a copy of the current state of the rectangle and for using the utility methods that are available for the <see cref="T:yWorks.Geometry.RectD" /> type.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to read the values from (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Geometry.RectD" /> that holds the values of the <paramref name="rectangle" /> at the time of the invocation.</para>
      </returns>
      <seealso cref="M:yWorks.Geometry.RectangleExtensions.Reshape(yWorks.Geometry.IMutableRectangle,System.Double,System.Double,System.Double,System.Double)" />
      <seealso cref="M:yWorks.Geometry.RectD.ToMutableRectangle" />
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.GetTopLeft(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Gets the coordinates of the top left corner of the rectangle as a <see cref="T:yWorks.Geometry.PointD" />.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to read the coordinates from (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The current coordinates of the corner.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.GetBottomLeft(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Gets the coordinates of the bottom left corner of the rectangle as a <see cref="T:yWorks.Geometry.PointD" />.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to read the coordinates from (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The current coordinates of the corner.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.GetCenter(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Gets the coordinates of the center of the rectangle as a <see cref="T:yWorks.Geometry.PointD" />.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to read the coordinates from (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The current coordinates of the center.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.GetMaxX(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Gets the maximum X coordinate of the rectangle.</para>
      </summary>
      <remarks>
        <para>This is the x coordinate of the right side of the rectangle, or the left side if the rectangle is <see cref="M:yWorks.Geometry.RectangleExtensions.IsEmpty(yWorks.Geometry.IRectangle)" />.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The maximum x coordinate of the rectangle's corners.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.IsEmpty(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Determines whether the specified rectangle is empty.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Geometry.IRectangle" /> instances are considered empty if their <see cref="P:yWorks.Geometry.ISize.Width" /> or <see cref="P:yWorks.Geometry.ISize.Height" /> is less than <c>0.0d</c>.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified rectangle is empty; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.GetMaxY(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Gets the maximum Y coordinate of the rectangle.</para>
      </summary>
      <remarks>
        <para>This is the y coordinate of the bottom side of the rectangle, or the top side if the rectangle is <see cref="M:yWorks.Geometry.RectangleExtensions.IsEmpty(yWorks.Geometry.IRectangle)" />.</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The maximum y coordinate of the rectangle's corners.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.GetTopRight(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Gets the coordinates of the top right corner of the rectangle as a <see cref="T:yWorks.Geometry.PointD" />.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to read the coordinates from (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The current coordinates of the corner.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.GetBottomRight(yWorks.Geometry.IRectangle)">
      <summary>
        <para>Gets the coordinates of the bottom right corner of the rectangle as a <see cref="T:yWorks.Geometry.PointD" />.</para>
      </summary>
      <param name="rectangle">
        <para>The rectangle to read the coordinates from (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <returns>
        <para>The current coordinates of the corner.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.Add(yWorks.Geometry.IMutableRectangle,yWorks.Geometry.IRectangle)">
      <summary>
        <para>Adds a rectangle to another one.</para>
      </summary>
      <remarks>
        <para>The result is placed into the first rectangle, which is returned. If either of the two rectangles is empty, i.e. it's width or height is negative, the result will be the other rectangle.</para>
      </remarks>
      <param name="rectangle1">
        <para>The rectangle to modify (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="rectangle2">
        <para>The rectangle to be added.</para>
      </param>
      <returns>
        <para>The first rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Geometry.RectangleExtensions.Add(yWorks.Geometry.IMutableRectangle,yWorks.Geometry.IPoint)">
      <summary>
        <para>Adds a point to a rectangle, possibly enlarging the rectangle.</para>
      </summary>
      <remarks>
        <para>If the rectangle is initially empty, i.e. its width or height is negative, the bounds of the rectangle will be set to (p.x, p.y, 0, 0)</para>
      </remarks>
      <param name="rectangle">
        <para>The rectangle to add to (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="point">
        <para>The coordinate to include in the bounds.</para>
      </param>
      <returns>
        <para>the resulting rectangle, which is <paramref name="rectangle" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Geometry.SizeExtensions">
      <summary>
        <para>Extension method holder class that extends the <see cref="T:yWorks.Geometry.ISize" /> type with utility methods.</para>
      </summary>
      <seealso cref="T:yWorks.Geometry.ISize" />
    </member>
    <member name="M:yWorks.Geometry.SizeExtensions.Resize(yWorks.Geometry.IMutableSize,System.Double,System.Double)">
      <summary>
        <para>Sets the coordinates of the size to the given values.</para>
      </summary>
      <param name="size">
        <para>The size setter to use for setting the values (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="newWidth">
        <para>The new x coordinate</para>
      </param>
      <param name="newHeight">
        <para>The new y coordinate</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.SizeExtensions.Resize(yWorks.Geometry.IMutableSize,yWorks.Geometry.ISize)">
      <summary>
        <para>Sets the coordinates of the size to the given values.</para>
      </summary>
      <param name="size">
        <para>The size setter to use for setting the values (a <c>this</c> parameter so that this method can be used as an extension method.).</para>
      </param>
      <param name="newSize">
        <para>The new location.</para>
      </param>
    </member>
    <member name="M:yWorks.Geometry.SizeExtensions.ToSizeD(yWorks.Geometry.ISize)">
      <summary>
        <para>Converts the <see cref="T:yWorks.Geometry.ISize" /> to a <see cref="T:yWorks.Geometry.SizeD" /> struct.</para>
      </summary>
      <param name="size">
        <para>The size to convert (a <c>this</c> parameter so that this method can be used as an extension method.)</para>
      </param>
      <returns>
        <para>A <see cref="T:yWorks.Geometry.SizeD" /> struct that has been initialized with the current values of <paramref name="size" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.Utils.Future`1">
      <summary>
        <para>A helper holder class that can contain a <see cref="P:yWorks.Utils.Future`1.Value" /> of a specific type.</para>
      </summary>
      <remarks>
        <para>Typically <see cref="P:yWorks.Utils.Future`1.HasValue" /> will be <c>false</c> until at a later point in time <see cref="M:yWorks.Utils.Future`1.OnValueDetermined(`0)" /> is called and the <see cref="P:yWorks.Utils.Future`1.Value" /> and <see cref="P:yWorks.Utils.Future`1.HasValue" /> properties are being updated and the <see cref="E:yWorks.Utils.Future`1.PropertyChanged" /> event is triggered.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the <see cref="P:yWorks.Utils.Future`1.Value" /></para>
      </typeparam>
    </member>
    <member name="P:yWorks.Utils.Future`1.Value">
      <summary>
        <para>Gets the value of this future, which may only be queried if <see cref="P:yWorks.Utils.Future`1.HasValue" /> yields <c>true</c>.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>If this property is queried although <see cref="P:yWorks.Utils.Future`1.HasValue" /> returns <c>false</c>.</para>
      </exception>
    </member>
    <member name="P:yWorks.Utils.Future`1.HasValue">
      <summary>
        <para>Gets a value indicating whether this instance has been <see cref="M:yWorks.Utils.Future`1.OnValueDetermined(`0)">assigned</see> a <see cref="P:yWorks.Utils.Future`1.Value" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this instance has been assigned a value; <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Utils.Future`1.OnValueDetermined(`0)">
      <summary>
        <para>Called when the <see cref="P:yWorks.Utils.Future`1.Value" /> property of this future has been determined.</para>
      </summary>
      <remarks>
        <para>This will set the <see cref="P:yWorks.Utils.Future`1.HasValue" /> property to <c>true</c> and assign the <see cref="P:yWorks.Utils.Future`1.Value" /> property. Also the corresponding <see cref="E:yWorks.Utils.Future`1.PropertyChanged" /> events will be triggered if necessary.</para>
      </remarks>
      <param name="value">
        <para>The value.</para>
      </param>
    </member>
    <member name="E:yWorks.Utils.Future`1.PropertyChanged">
      <summary>
        <para>Occurs when a property value changes.</para>
      </summary>
      <remarks>
        <para>This event will be triggered for <see cref="P:yWorks.Utils.Future`1.HasValue" /> changes and changes of the <see cref="P:yWorks.Utils.Future`1.Value" /> property. Note that if the determined future value is the same as the default, the event will only be triggered for the <see cref="P:yWorks.Utils.Future`1.HasValue" /> property.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.ICompoundEdit">
      <summary>
        <para>This interface is a means to bracket several <see cref="T:yWorks.Graph.IUndoUnit" />s, that is a collection of units that are treated as one (for example they are always undone or redone as a single unit).</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Graph.ICompoundEdit" />s have two states: <i>active</i> and <i>disposed</i>. Whenever an <see cref="T:yWorks.Graph.ICompoundEdit" /> is retrieved from the <see cref="T:yWorks.Graph.UndoEngine" /> or the graph instance, it automatically is <i>active</i>. While an edit is in the <i>active</i> state, it gathers <see cref="T:yWorks.Graph.IUndoUnit" />s until the <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> or <see cref="M:yWorks.Graph.ICompoundEdit.Cancel" /> methods are called. Calling the <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> method commits all gathered <see cref="T:yWorks.Graph.IUndoUnit" />s to the <see cref="T:yWorks.Graph.UndoEngine" />, while canceling will dispose them. Calling either method will put the edit in the <i>disposed</i> state. In this state, the edit does not gather units anymore and is not reusable.</para>
        <para>Additionally, this interface extends the <see cref="T:System.IDisposable" /> interface. This enables the usage in <c>using</c> statements that will automatically <see cref="M:yWorks.Graph.ICompoundEdit.Commit" /> the edit.</para>
        <para>
          <see cref="T:yWorks.Graph.ICompoundEdit" />s can also be nested, in this case the changes of the inner edit are not committed directly to the <see cref="T:yWorks.Graph.UndoEngine" /> but to the outer edit. Only when the outer edit is committed, the units are committed to the <see cref="T:yWorks.Graph.UndoEngine" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.UndoEngine" />
      <seealso cref="T:yWorks.Graph.IUndoUnit" />
    </member>
    <member name="M:yWorks.Graph.ICompoundEdit.Cancel">
      <summary>
        <para>This method cancels the compound editing process.</para>
      </summary>
      <remarks>
        <para>The recorded <see cref="T:yWorks.Graph.IUndoUnit" />s are disposed and the edit is not usable anymore.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.ICompoundEdit.Commit">
      <summary>
        <para>This method commits the compound editing process.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Graph.IUndoUnit" />s are enqueued into the corresponding <see cref="T:yWorks.Graph.UndoEngine" /> instance and the edit is not usable anymore. Alternatively client code can use the <see cref="M:System.IDisposable.Dispose" /> method of this instance to end this instance. This can be done conveniently using a <c>using</c> statement.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.LookupCallback">
      <summary>
        <para>Callback delegate that can be used to query results of a virtual <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> call on objects that don't necessarily implement <c>ILookup</c>.</para>
      </summary>
      <param name="subject">
        <para>the subject for which a lookup shall be made</para>
      </param>
      <param name="type">
        <para>the type to look up</para>
      </param>
      <returns>
        <para>an instance that can be assigned to type or <c>null</c></para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.ILookup">
      <summary>
        <para>The basic lookup interface that allows for retrieving implementations for different aspects of the current instance.</para>
      </summary>
      <remarks>
        <para>The lookup idiom allows for dynamically providing, adding, changing, and removing implementation aspects of an instance that would not be possible to achieve using ordinary object oriented methods.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.Lookups" />
    </member>
    <member name="M:yWorks.Graph.ILookup.Lookup(System.Type)">
      <summary>
        <para>Returns an instance that implements the given type or <c>null</c>.</para>
      </summary>
      <remarks>
        <para>Typically, this method will be called in order to obtain a different view or aspect of the current instance. This is quite similar to casting or using a super type or interface of this instance, but is not limited to inheritance or compile time constraints. An instance implementing this method is not required to return non-<c>null</c> implementations for the types, nor does it have to return the same instance any time. Also it depends on the type and context whether the instance returned stays up to date or needs to be reobtained for subsequent use.</para>
      </remarks>
      <param name="type">
        <para>the type for which an instance shall be returned</para>
      </param>
      <returns>
        <para>an instance that is assignable to type or <c>null</c></para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.IContextLookup">
      <summary>
        <para>An interface for instances that can provide a <see cref="T:yWorks.Graph.ILookup" /> capabilities for a given object.</para>
      </summary>
      <remarks>
        <para>This is useful in the case where lookup functionality is not intrinsic to an item or where an existing object cannot implement the interface or when an item needs to be decorated externally with new lookup functionality.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.ILookup" />
      <seealso cref="T:yWorks.Graph.LookupCallback" />
    </member>
    <member name="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)">
      <summary>
        <para>Tries to create or retrieve an implementation of the given type for a given item.</para>
      </summary>
      <param name="item">
        <para>the item to lookup a type for</para>
      </param>
      <param name="type">
        <para>the type to look up</para>
      </param>
      <returns>
        <para>an implementation or <c>null</c></para>
      </returns>
      <seealso cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" />
    </member>
    <member name="T:yWorks.Graph.IContextLookupChainLink">
      <summary>
        <para>An interface for instances that can be used to chain lookup operations.</para>
      </summary>
      <remarks>
        <para>Implementations will perform the lookup in the <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> method and delegate to the next implementation in the chain if they cannot satisfy the request.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.IContextLookupChainLink.SetNext(yWorks.Graph.IContextLookup)">
      <summary>
        <para>This method is called by the framework to register the fallback lookup implementation that should be used during a call to <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" />.</para>
      </summary>
      <remarks>
        <para>If the implementation cannot satisfy the query, it will use the provided context as a fallback. Note that implementations can also use the results returned by the next lookup and decorate it appropriately.</para>
      </remarks>
      <param name="next">
        <para>The context to use as a fallback.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.ILookupDecorator">
      <summary>
        <para>Interface that can be used to decorate the lookup result for a set of types.</para>
      </summary>
      <seealso cref="T:yWorks.Graph.ILookup" />
      <seealso cref="T:yWorks.Graph.IContextLookupChainLink" />
    </member>
    <member name="M:yWorks.Graph.ILookupDecorator.CanDecorate(System.Type)">
      <summary>
        <para>Determines whether this instance can be used to decorate the lookup for a certain type.</para>
      </summary>
      <param name="t">
        <para>The type to decorate the lookup for.</para>
      </param>
      <returns />
    </member>
    <member name="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">
      <summary>
        <para>Adds a lookup chain element to the chain of lookups for a given type.</para>
      </summary>
      <remarks>
        <para>The lookup chain is context specific. This method will not generally decorate the lookup of all instances of type <paramref name="t" />, but only those that stand in context of this instance. This method will only succeed if <see cref="M:yWorks.Graph.ILookupDecorator.CanDecorate(System.Type)" /> yields <c>true</c> for <paramref name="t" />.</para>
      </remarks>
      <param name="t">
        <para>The type to decorate the lookup.</para>
      </param>
      <param name="lookup">
        <para>The chain element to add to the lookup of the given type.</para>
      </param>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.RemoveLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
      <seealso cref="M:yWorks.Graph.LookupExtensions.Add``2(yWorks.Graph.ILookupDecorator,System.Func{``0,``1},System.Boolean)" />
      <seealso cref="M:yWorks.Graph.LookupExtensions.Add``2(yWorks.Graph.ILookupDecorator,System.Func{``0,``1,``1},System.Boolean)" />
      <seealso cref="M:yWorks.Graph.LookupExtensions.AddConstant``2(yWorks.Graph.ILookupDecorator,``1)" />
    </member>
    <member name="M:yWorks.Graph.ILookupDecorator.RemoveLookup(System.Type,yWorks.Graph.IContextLookupChainLink)">
      <summary>
        <para>Removes a previously registered lookup chain element from the chain of lookups for a given type.</para>
      </summary>
      <param name="t">
        <para>The type to remove the decorator from.</para>
      </param>
      <param name="lookup">
        <para>The chain element to remove from the lookup of the given type.</para>
      </param>
      <seealso cref="M:yWorks.Graph.ILookupDecorator.AddLookup(System.Type,yWorks.Graph.IContextLookupChainLink)" />
    </member>
    <member name="T:yWorks.Graph.ITagOwner">
      <summary>
        <para>Interface implemented by items that can be tagged with arbitrary objects.</para>
      </summary>
      <remarks>
        <para>The object held by implementations of this interface is usually a user defined object. Implementations don't depend on this tag. They just serve as a storage for the tag that will be used by other parts of the implementation.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.ITagOwner.Tag">
      <summary>
        <para>Gets or sets the tag associated with this instance.</para>
      </summary>
      <value>
        <para>The user object associated with this instance.</para>
      </value>
      <remarks>
        <para>The implementation itself does not normally depend on the tag associated with it. It serves as storage for the object only.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Graph.LookupChain">
      <summary>
        <para>An implementation of a chain of <see cref="T:yWorks.Graph.IContextLookupChainLink" />s.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LookupChain.Add(yWorks.Graph.IContextLookupChainLink)">
      <summary>
        <para>Adds the given link to the end of the chain.</para>
      </summary>
      <param name="lookup">
        <para>The link to add.</para>
      </param>
      <seealso cref="M:yWorks.Graph.LookupChain.Remove(yWorks.Graph.IContextLookupChainLink)" />
    </member>
    <member name="M:yWorks.Graph.LookupChain.Remove(yWorks.Graph.IContextLookupChainLink)">
      <summary>
        <para>Removes the link that has previously been added to this instance from this chain.</para>
      </summary>
      <param name="link">
        <para>The link to remove.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.LookupChain.NotifyChange">
      <summary>
        <para>Can be called by client code to trigger the <see cref="E:yWorks.Graph.LookupChain.PropertyChanged" /> event manually.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.LookupChain.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
      <summary>
        <para>Notifies client code that the lookup of this instance might have changed.</para>
      </summary>
      <param name="eventArgs">
        <para>The arguments</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.LookupChain.Lookup(System.Object,System.Type)">
      <summary>
        <para>Performs the actual lookup operation.</para>
      </summary>
      <remarks>
        <para>This call will traverse the chain to satisfy the query.</para>
      </remarks>
      <param name="item">
        <para>The item to use as the context.</para>
      </param>
      <param name="type">
        <para>The type of the query.</para>
      </param>
      <returns>
        <para>The result of the query.</para>
      </returns>
    </member>
    <member name="E:yWorks.Graph.LookupChain.PropertyChanged">
      <summary>
        <para>Occurs when the lookup of this instance has changed for some or all of the types or items.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.Lookups">
      <summary>
        <para>Provides factories for various <see cref="T:yWorks.Graph.ILookup" /> implementations and static utility methods that simplify the usage of <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> calls.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Lookups.Empty">
      <summary>
        <para>An <c>ILookup</c> instance that always returns <c>null</c>.</para>
      </summary>
    </member>
    <member name="F:yWorks.Graph.Lookups.EmptyContextLookup">
      <summary>
        <para>An <c>ILookupContext</c> instance that always returns <c>null</c>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.Lookups.Lookup``1(yWorks.Graph.ILookup)">
      <summary>
        <para>Utility method that helps keeping code more clean when using <see cref="T:yWorks.Graph.ILookup" /> <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)">()</see> calls.</para>
      </summary>
      <typeparam name="T">
        <para>The type that is the target of the lookup.</para>
      </typeparam>
      <param name="lookup">
        <para>The actual lookup provider.</para>
      </param>
      <returns>
        <para>The value returned by <paramref name="lookup" /> which may be <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.Lookup``1(yWorks.Graph.ILookup,``0)">
      <summary>
        <para>Utility method that helps keeping code more clean when using <see cref="T:yWorks.Graph.ILookup" /> <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)" /> calls.</para>
      </summary>
      <typeparam name="T">
        <para>The type that is the target of the lookup.</para>
      </typeparam>
      <param name="lookup">
        <para>The actual lookup provider.</para>
      </param>
      <param name="fallback">
        <para>The fallback value to use if the lookup yields <c>null</c></para>
      </param>
      <returns>
        <para>The value returned by <paramref name="lookup" /> or <paramref name="fallback" /> if the former yields <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.Lookup``1(System.Object,yWorks.Graph.IContextLookup)">
      <summary>
        <para>Utility method that helps keeping code more clean when using <see cref="T:yWorks.Graph.IContextLookup" /> <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> calls.</para>
      </summary>
      <typeparam name="T">
        <para>The type that is the target of the lookup.</para>
      </typeparam>
      <param name="context">
        <para>The context object to pass to the <paramref name="lookup" />.</para>
      </param>
      <param name="lookup">
        <para>The actual lookup provider.</para>
      </param>
      <returns>
        <para>The value returned by <paramref name="lookup" /> which may be <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.Lookup``1(System.Object,yWorks.Graph.IContextLookup,``0)">
      <summary>
        <para>Utility method that helps keeping code more clean when using <see cref="T:yWorks.Graph.IContextLookup" /> <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)" /> calls.</para>
      </summary>
      <typeparam name="T">
        <para>The type that is the target of the lookup.</para>
      </typeparam>
      <param name="context">
        <para>The context object to pass to the <paramref name="lookup" />.</para>
      </param>
      <param name="lookup">
        <para>The actual lookup provider.</para>
      </param>
      <param name="fallback">
        <para>The fallback value to use if the lookup yields <c>null</c></para>
      </param>
      <returns>
        <para>The value returned by <paramref name="lookup" /> or <paramref name="fallback" /> if the former yields <c>null</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.Single(System.Object,System.Type)">
      <summary>
        <para>Creates a simple lookup implementation that yields <c>subject</c> if <c>type</c> is queried.</para>
      </summary>
      <param name="subject">
        <para>the subject to yield</para>
      </param>
      <param name="type">
        <para>the type that should yield the subject</para>
      </param>
      <returns>
        <para>an ILookup implementation</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.Single``1(``0)">
      <summary>
        <para>Creates a simple lookup implementation that yields <c>subject</c> if <c>type</c> is queried.</para>
      </summary>
      <typeparam name="T">
        <para>The type of the subject that will be used as a key for the lookup process.</para>
      </typeparam>
      <param name="subject">
        <para>the subject to yield</para>
      </param>
      <returns>
        <para>an ILookup implementation</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.CreateContextLookupChainLink(yWorks.Graph.LookupCallback)">
      <summary>
        <para>Creates a lookup chain link that is backed by the given callback.</para>
      </summary>
      <remarks>
        <para>If the callback returns <c>null</c> the request is passed to the chain.</para>
      </remarks>
      <param name="callback">
        <para>The callback to invoke.</para>
      </param>
      <returns>
        <para>The implementation of the link that uses the callback.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.Wrapped(yWorks.Graph.ILookup,yWorks.Graph.ILookup)">
      <summary>
        <para>Creates a lookup implementation that wraps an existing <c>ILookup</c> instance using an additional lookup implementations.</para>
      </summary>
      <remarks>
        <para>For each lookup call that the <c>additionalLookup</c> would yield <c>null</c>, the <paramref name="basicLookup" /> will be queried instead.</para>
      </remarks>
      <param name="basicLookup">
        <para>the fallback lookup implementation</para>
      </param>
      <param name="additionalLookup">
        <para>the lookup that has precedence over the fallback</para>
      </param>
      <returns>
        <para>an implementation that decorates the first with the latter</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.HidingLookupChainLink(System.Type)">
      <summary>
        <para>Factory method for a lookup chain element that removes the entry from the lookup chain for a given type.</para>
      </summary>
      <param name="type">
        <para>The type to hide from the lookup.</para>
      </param>
      <returns>
        <para>An instance that can be used in a lookup chain.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.FactoryLookupChainLink``2(System.Func{``0,``1})">
      <summary>
        <para>Factory method for a lookup chain element that uses a <see cref="T:System.Func`2" /> to yield a <typeparamref name="TResult" /> for a specific <typeparamref name="TContext" />.</para>
      </summary>
      <remarks>
        <para>If the resulting link is <see cref="M:yWorks.Graph.IContextLookup.Lookup(System.Object,System.Type)">queried</see> for <typeparamref name="TResult" /> and the context is of type <typeparamref name="TContext" />, the <paramref name="factory" /> method will be queried and the result will be returned. Otherwise the <see cref="M:yWorks.Graph.IContextLookupChainLink.SetNext(yWorks.Graph.IContextLookup)">next</see> chain link will be delegated the request to.</para>
      </remarks>
      <param name="factory">
        <para>The factory delegate to use that yields the result for a given context.</para>
      </param>
      <returns>
        <para>An instance that can be used in a lookup chain.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.AddingLookupChainLink(System.Type,System.Object)">
      <summary>
        <para>Factory method for a lookup chain element that simply adds an entry to a lookup chain.</para>
      </summary>
      <param name="type">
        <para>The type to add to the lookup.</para>
      </param>
      <param name="instance">
        <para>The instance to return if the <paramref name="type" /> is being looked up.</para>
      </param>
      <returns>
        <para>An instance that can be used in a lookup chain.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.AddingLookupChainLink(System.Object)">
      <summary>
        <para>Factory method for a lookup chain element that adds an dynamic instance to a lookup chain.</para>
      </summary>
      <remarks>
        <para>The instance returned will check whether <paramref name="instance" /> is of the queried type and will then return the instance.</para>
      </remarks>
      <param name="instance">
        <para>The instance to query the type from dynamically.</para>
      </param>
      <returns>
        <para>An instance that can be used in a lookup chain.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.AddingLookupChainLink(yWorks.Graph.ILookup)">
      <summary>
        <para>Factory method for a lookup chain element that adds an <see cref="T:yWorks.Graph.ILookup" /> layer to a lookup chain.</para>
      </summary>
      <remarks>
        <para>If the lookup returns <c>null</c>, the call will be propagated to the chain.</para>
      </remarks>
      <param name="lookup">
        <para>The lookup to use.</para>
      </param>
      <returns>
        <para>An instance that can be used in a lookup chain.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.Dynamic(System.Object)">
      <summary>
        <para>Creates a dynamic lookup implementation that for each type that the given subject can be assigned to yields that subject.</para>
      </summary>
      <param name="subject">
        <para>the subject to yield if it is assignable to the type in the lookup query</para>
      </param>
      <returns>
        <para>an instance that will either yield <paramref name="subject" /> or <c>null</c></para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.Lookups.CreateDictionaryLookup(System.Collections.Generic.Dictionary{System.Type,System.Object})">
      <summary>
        <para>Creates a simple mutable <see cref="T:yWorks.Graph.ILookup" /> implementation that is backed by a dictionary.</para>
      </summary>
      <remarks>
        <para>The <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)">lookup</see> method uses the specified type as key when delegating to the <paramref name="backingDictionary" />.</para>
      </remarks>
      <param name="backingDictionary">
        <para>The backing <see cref="T:System.Collections.Generic.Dictionary`2" /> that is used in the <see cref="M:yWorks.Graph.ILookup.Lookup(System.Type)">lookup</see> calls.</para>
      </param>
      <returns>
        <para>A simple mutable <see cref="T:yWorks.Graph.ILookup" /> implementation that is backed by a dictionary.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.TypedKey`1">
      <summary>
        <para>A utility class that can be used as a key in dictionary like use cases to provide type-safe values.</para>
      </summary>
      <typeparam name="T">
        <para>The type of the value that is associated with this key.</para>
      </typeparam>
      <remarks>
        <para>Equality and <see cref="M:yWorks.GraphML.TypedKey`1.GetHashCode">hash code</see> is based on both the type and the <see cref="P:yWorks.GraphML.TypedKey`1.Name" /></para>
      </remarks>
    </member>
    <member name="M:yWorks.GraphML.TypedKey`1.#ctor(System.String,`0)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.GraphML.TypedKey`1" /> class.</para>
      </summary>
      <param name="name">
        <para>The name.</para>
      </param>
      <param name="defaultValue">
        <para>The <see cref="P:yWorks.GraphML.TypedKey`1.DefaultValue">default value</see>.</para>
      </param>
      <seealso cref="P:yWorks.GraphML.TypedKey`1.Name" />
    </member>
    <member name="P:yWorks.GraphML.TypedKey`1.Name">
      <summary>
        <para>Gets the name for this key.</para>
      </summary>
      <value>
        <para>The name.</para>
      </value>
    </member>
    <member name="P:yWorks.GraphML.TypedKey`1.DefaultValue">
      <summary>
        <para>Gets a default value that can be used if there is no value explicitly defined for this key.</para>
      </summary>
      <remarks>
        <para>It is up to the implementation that makes use of this key whether this value is interpreted.</para>
      </remarks>
      <value>
        <para>The default value.</para>
      </value>
    </member>
    <member name="M:yWorks.GraphML.TypedKey`1.Equals(yWorks.GraphML.TypedKey{`0})">
      <summary>
        <para>Determines equality based on the type and <see cref="P:yWorks.GraphML.TypedKey`1.Name" />.</para>
      </summary>
      <param name="other">
        <para>The other instance.</para>
      </param>
      <returns>
        <para>Whether the items are of the exact same type and have the same <see cref="P:yWorks.GraphML.TypedKey`1.Name" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.TypedKey`1.Equals(System.Object)">
      <summary>
        <para>Determines equality based on the type, type parameter, and <see cref="P:yWorks.GraphML.TypedKey`1.Name" />.</para>
      </summary>
      <param name="obj">
        <para>The other instance.</para>
      </param>
      <returns>
        <para>Whether the items are of the exact same type and have the same <see cref="P:yWorks.GraphML.TypedKey`1.Name" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.TypedKey`1.GetHashCode">
      <summary>
        <para>Returns a hash code for this instance based on the type parameter and the <see cref="P:yWorks.GraphML.TypedKey`1.Name" />.</para>
      </summary>
      <returns>
        <para>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.TypedKey`1.ToString">
      <summary>
        <para>Returns the <see cref="P:yWorks.GraphML.TypedKey`1.Name" />.</para>
      </summary>
      <returns>
        <para>Returns the <see cref="P:yWorks.GraphML.TypedKey`1.Name" />.</para>
      </returns>
    </member>
    <member name="T:yWorks.GraphML.TypedKeyMapper">
      <summary>
        <para>A specialized <see cref="T:yWorks.Graph.IMapper`2" />-like implementation that uses <see cref="T:yWorks.GraphML.TypedKey`1" />s as the keys and their corresponding strongly typed values as the values.</para>
      </summary>
    </member>
    <member name="M:yWorks.GraphML.TypedKeyMapper.Get``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Finds the associated value for the given key in the mapping or (re-)associates the given key with the value provided, removing previous associations.</para>
      </summary>
      <remarks>
        <para>In order to remove an association the <see cref="M:yWorks.GraphML.TypedKeyMapper.RemoveValue``1(yWorks.GraphML.TypedKey{``0})" /> method should be preferred over calling this method using a default value.</para>
      </remarks>
      <param name="key">
        <para>The key to use as the index.</para>
      </param>
      <seealso cref="M:yWorks.GraphML.TypedKeyMapper.RemoveValue``1(yWorks.GraphML.TypedKey{``0})" />
    </member>
    <member name="M:yWorks.GraphML.TypedKeyMapper.Set``1(yWorks.GraphML.TypedKey{``0},``0)">
      <summary>
        <para>Sets the specified key/value pair.</para>
      </summary>
      <remarks>
        <para>Previous values are overwritten.</para>
      </remarks>
      <typeparam name="T">
        <para>The type of the value.</para>
      </typeparam>
      <param name="key">
        <para>The key.</para>
      </param>
      <param name="value">
        <para>The value.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.TypedKeyMapper.RemoveValue``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Removes a previously created association with the given key.</para>
      </summary>
      <param name="key">
        <para>The key to remove from the mapping.</para>
      </param>
    </member>
    <member name="M:yWorks.GraphML.TypedKeyMapper.Contains``1(yWorks.GraphML.TypedKey{``0})">
      <summary>
        <para>Determines whether this instance contains the specified key.</para>
      </summary>
      <typeparam name="T">
        <para>The type of the value.</para>
      </typeparam>
      <param name="key">
        <para>The key.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this instance contains the specified key; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.GraphML.TypedKeyMapper.Clear">
      <summary>
        <para>Clears this instance.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.UndoEngine">
      <summary>
        <para>The main class to provide undo and redo functionality.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Graph.UndoEngine" /> is in charge of <see cref="M:yWorks.Graph.UndoEngine.BeginCompoundEdit(System.String,System.String)">recording</see>, <see cref="M:yWorks.Graph.UndoEngine.AddUnit(yWorks.Graph.IUndoUnit)">managing</see> and <see cref="M:yWorks.Graph.UndoEngine.Undo">executing</see> single units of work that can be undone and redone, represented by the interface <see cref="T:yWorks.Graph.IUndoUnit" />.</para>
        <para>These units are <b>managed</b> in a queue-like structure and can be added manually to the queue by calling the <see cref="M:yWorks.Graph.UndoEngine.AddUnit(yWorks.Graph.IUndoUnit)" /> method.</para>
        <para>
          <b>Executing</b> the units is done by client code or commands by calling <see cref="M:yWorks.Graph.UndoEngine.Undo" /> or <see cref="M:yWorks.Graph.UndoEngine.Redo" />. The engine automatically manages the queue so that calling these two methdos will consistently move the units in the queue.</para>
        <para>The <see cref="M:yWorks.Graph.UndoEngine.BeginCompoundEdit(System.String,System.String)" /> method allows to <b>record</b> units by bracketing serveral changes in an <see cref="T:yWorks.Graph.ICompoundEdit" />. Implementations of the <see cref="T:yWorks.Graph.ICompoundEdit" /> interface record all subsequent changes until it is <see cref="M:yWorks.Graph.ICompoundEdit.Commit">committed</see> and therefore all recorded units are added to the engine. For more information and examples see <see cref="T:yWorks.Graph.ICompoundEdit" />.</para>
        <para>Depending on the properties <see cref="P:yWorks.Graph.UndoEngine.MergeUnits" /> and <see cref="P:yWorks.Graph.UndoEngine.AutoMergeTime" />, the engine tries to collapse added <see cref="T:yWorks.Graph.IUndoUnit" />s if possible. This enhances the performance and reduces the required memory for undo changes. For example, when a node is moved interactively, instead of saving every position that the node had when being dragged the engine will only hold one <see cref="T:yWorks.Graph.IUndoUnit" /> at the end to undo the entire movement.</para>
        <para>
          <br /> <b>Customizing Undo/Redo</b> <ul>
   <li>
     In general, to be able to undo or redo certain work client code can <b>implement <see cref="T:yWorks.Graph.IUndoUnit" /> or subclass 
     <see cref="T:yWorks.Graph.UndoUnitBase">UndoUnitBase</see></b>. The client application needs to encapsulate 
     changes in this implementation and provide the logic to completely undo and redo these changes. 
     Instances of your custom <see cref="T:yWorks.Graph.IUndoUnit" /> implementations need to be added to the <see cref="T:yWorks.Graph.UndoEngine" /> 
     manually via <see cref="M:yWorks.Graph.UndoEngine.AddUnit(yWorks.Graph.IUndoUnit)" />.
   </li>
   <li>
     In certain cases it is difficult or not efficient to track and save the changes between certain states,
     and better to save the states themselves and to restore these. For example when there are potentially
     many intermediate steps between two states of interest and it would be complicated
     to produce <see cref="T:yWorks.Graph.IUndoUnit" />s for each intermediate step and merge them in the end.
     In such cases client code should <b>implement <see cref="T:yWorks.Graph.IMementoSupport" /></b> instead.
     See the documentation of <see cref="T:yWorks.Graph.IMementoSupport" /> for examples and guidelines on how to implement
     this memento design pattern concept.
   </li>
   <li>
     <b>It is generally not necessary to subclass <see cref="T:yWorks.Graph.UndoEngine" /></b> unless you want to customize the internal
     handling of the units, which is both complicated and prone to errors. In most use cases it is sufficient 
     to provide custom <see cref="T:yWorks.Graph.IUndoUnit" />s or <see cref="T:yWorks.Graph.IMementoSupport" />.
   </li>
 </ul></para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IUndoUnit" />
      <seealso cref="T:yWorks.Graph.UndoUnitBase" />
      <seealso cref="T:yWorks.Graph.IMementoSupport" />
      <seealso cref="T:yWorks.Graph.ICompoundEdit" />
    </member>
    <member name="M:yWorks.Graph.UndoEngine.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Graph.UndoEngine" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.UndoEngine.MergeUnits">
      <summary>
        <para>Gets or sets a value that indicates whether or not this instance should try to merge newly added units.</para>
      </summary>
      <remarks>
        <para>If <c>true</c> this instance will try to <see cref="M:yWorks.Graph.IUndoUnit.TryMergeUnit(yWorks.Graph.IUndoUnit)">merge</see> or <see cref="M:yWorks.Graph.IUndoUnit.TryReplaceUnit(yWorks.Graph.IUndoUnit)">replace</see> units in the queue. Note that when the <see cref="P:yWorks.Graph.UndoEngine.AutoMergeTime" /> property is set to <see cref="F:System.TimeSpan.Zero" /> and this property is set to <c>true</c>, the engine will always try to merge incoming units. Otherwise the <see cref="P:yWorks.Graph.UndoEngine.AutoMergeTime" /> dictates whether the engine will try to merge a unit or not.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.UndoEngine.AutoMergeTime" />
    </member>
    <member name="P:yWorks.Graph.UndoEngine.AutoMergeTime">
      <summary>
        <para>Gets or sets the duration during which the engine will try to merge newly added units.</para>
      </summary>
      <remarks>
        <para>If this is set to <see cref="F:System.TimeSpan.Zero" />, the engine will try to merge incoming units depending on the <see cref="P:yWorks.Graph.UndoEngine.MergeUnits" /> property. Otherwise, if the time span between the last added unit and the new unit exceeds the set value, the engine does not try to merge the units regardless what the <see cref="P:yWorks.Graph.UndoEngine.MergeUnits" /> property is set to. Likewise, if the time span is smaller than the set value, the engine will always try to merge units.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.UndoEngine.MergeUnits" />
    </member>
    <member name="M:yWorks.Graph.UndoEngine.AddUnit(yWorks.Graph.IUndoUnit)">
      <summary>
        <para>Adds a new <see cref="T:yWorks.Graph.IUndoUnit" /> to the queue.</para>
      </summary>
      <remarks>
        <para>This implementation will automatically group multiple units into a single unit if the time since the last add is less than <see cref="P:yWorks.Graph.UndoEngine.AutoMergeTime" />.</para>
      </remarks>
      <param name="unit">
        <para>The unit of work to add.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.UndoEngine.BeginCompoundEdit(System.String,System.String)">
      <summary>
        <para>Begins a compound edit that will use the provided name.</para>
      </summary>
      <remarks>
        <para>This will create a new edit that can independently be <see cref="M:yWorks.Graph.ICompoundEdit.Cancel">canceled</see> or <see cref="M:yWorks.Graph.ICompoundEdit.Commit">committed</see>. Note that only if the outer-most instances is committed, the corresponding <see cref="T:yWorks.Graph.IUndoUnit" /> units will be enqueued into this instance.</para>
      </remarks>
      <param name="undoName">
        <para>The undo name to use for the edit.</para>
      </param>
      <param name="redoName">
        <para>The redo name to use for the edit.</para>
      </param>
      <returns>
        <para>A compound edit implementation that needs to be <see cref="M:yWorks.Graph.ICompoundEdit.Cancel">canceled</see> or <see cref="M:yWorks.Graph.ICompoundEdit.Commit">committed</see> later.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.UndoEngine.GetToken">
      <summary>
        <para>Returns a token that can be used to store and compare the state of the undo queue.</para>
      </summary>
      <remarks>
        <para>E.g. an application can retrieve the token once the user has saved his document. Comparing the token returned by this instance with another one retrieved at a later point in time enables the application to determine whether the document is in the same state.</para>
      </remarks>
      <returns>
        <para>An object that can be checked against other tokens via the <see cref="M:System.Object.Equals(System.Object)" /> method.</para>
      </returns>
    </member>
    <member name="P:yWorks.Graph.UndoEngine.Size">
      <summary>
        <para>Gets or sets the maximum size of the undo queue this instance is managing.</para>
      </summary>
      <remarks>
        <para>A size of <c>0</c> effectively disables this implementation.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.UndoEngine.UndoName">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.IUndoUnit.UndoName" /> of the next <see cref="M:yWorks.Graph.UndoEngine.Undo" /> operation.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.UndoEngine.RedoName">
      <summary>
        <para>Gets the <see cref="P:yWorks.Graph.IUndoUnit.RedoName" /> of the next <see cref="M:yWorks.Graph.UndoEngine.Redo" /> operation.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.UndoEngine.Clear">
      <summary>
        <para>Clears the internal queue and <see cref="M:System.IDisposable.Dispose">disposes</see> all units in it.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.UndoEngine.Undo">
      <summary>
        <para>Undoes the next <see cref="T:yWorks.Graph.IUndoUnit" />.</para>
      </summary>
      <exception cref="T:System.NotSupportedException">
        <para>If an undo operation is already in progress.</para>
      </exception>
      <exception cref="T:System.Exception">
        <para>If <see cref="M:yWorks.Graph.UndoEngine.CanUndo" /> would yield <c>false</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Graph.UndoEngine.Redo">
      <summary>
        <para>Redoes the next <see cref="T:yWorks.Graph.IUndoUnit" />.</para>
      </summary>
      <exception cref="T:System.NotSupportedException">
        <para>If an undo operation is already in progress.</para>
      </exception>
      <exception cref="T:System.Exception">
        <para>If <see cref="M:yWorks.Graph.UndoEngine.CanRedo" /> would yield <c>false</c>.</para>
      </exception>
    </member>
    <member name="P:yWorks.Graph.UndoEngine.PerformingUndo">
      <summary>
        <para>Gets whether this instance is currently performing an undo operation.</para>
      </summary>
    </member>
    <member name="P:yWorks.Graph.UndoEngine.PerformingRedo">
      <summary>
        <para>Gets whether this instance is currently performing a redo operation.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.UndoEngine.CanUndo">
      <summary>
        <para>Determines whether a call to <see cref="M:yWorks.Graph.UndoEngine.Undo" /> can be made.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.UndoEngine.CanRedo">
      <summary>
        <para>Determines whether a call to <see cref="M:yWorks.Graph.UndoEngine.Redo" /> can be made.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.UndoEngine.OnPropertyChanged(System.String)">
      <summary>
        <para>This will trigger the corresponding <see cref="E:yWorks.Graph.UndoEngine.PropertyChanged" /> event.</para>
      </summary>
      <param name="name">
        <para>The name of the property that changed.</para>
      </param>
    </member>
    <member name="E:yWorks.Graph.UndoEngine.PropertyChanged">
      <summary>
        <para>Occurs when <see cref="M:yWorks.Graph.UndoEngine.CanUndo" />, <see cref="M:yWorks.Graph.UndoEngine.CanRedo" />, <see cref="P:yWorks.Graph.UndoEngine.UndoName" />, or <see cref="P:yWorks.Graph.UndoEngine.RedoName" /> changed its value.</para>
      </summary>
    </member>
    <member name="E:yWorks.Graph.UndoEngine.UnitUndone">
      <summary>
        <para>Occurs when the engine has successfully executed the <see cref="M:yWorks.Graph.IUndoUnit.Undo" /> operation of an <see cref="T:yWorks.Graph.IUndoUnit" />.</para>
      </summary>
    </member>
    <member name="E:yWorks.Graph.UndoEngine.UnitRedone">
      <summary>
        <para>Occurs when the engine has successfully executed the <see cref="M:yWorks.Graph.IUndoUnit.Redo" /> operation of an <see cref="T:yWorks.Graph.IUndoUnit" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.UndoEngine.ToString" />
    <member name="T:yWorks.Graph.IUndoUnit">
      <summary>
        <para>Represents a unit of work that can be undone and redone.</para>
      </summary>
      <remarks>
        <para>Clients should use this interface when certain actions, changes or events should be monitored and have undoability provided for them. If you simply want to track the state of certain items between two states of interest, you should consider using <see cref="T:yWorks.Graph.IMementoSupport">mementos</see> instead.</para>
        <para>The central methods of this interface are <see cref="M:yWorks.Graph.IUndoUnit.Undo" /> and <see cref="M:yWorks.Graph.IUndoUnit.Redo" /> which contain the logic to undo or redo a unit of work. Keep in mind that undo/redo are sensible operations and should maintain a consistent state before and after each operation since they may be executed potentially often one after another.</para>
        <para>The requirement for an <see cref="T:yWorks.Graph.IUndoUnit" /> is that when a program is in a certain state and a call to <see cref="M:yWorks.Graph.IUndoUnit.Undo" /> is followed by a call to <see cref="M:yWorks.Graph.IUndoUnit.Redo" /> then the program is in the exact same state as before (the same holds true for the other way around).</para>
        <para>A default implementation of this interface is the abstract class <see cref="T:yWorks.Graph.UndoUnitBase" /> which forces only the implementation of the undo/redo logic and defaults the other methods. Clients should primarily extend this class instead of implementing the whole interface.</para>
        <para>IUndoUnits are managed by the <see cref="T:yWorks.Graph.UndoEngine" />. Custom units can always be added to the engine using the method <see cref="M:yWorks.Graph.UndoEngine.AddUnit(yWorks.Graph.IUndoUnit)" />. Also consider to use one of the convenience implementations: <see cref="T:yWorks.Graph.DelegateUndoUnit`1" /> takes delegates for the undo/redo operations and <see cref="T:yWorks.Graph.CompositeUndoUnit" /> creates a bracketing unit comprising several other units.</para>
        <para>Also note that in order to keep a consistent state, methods of objects of this type should not be called by clientcode directly but use the <see cref="T:yWorks.Graph.UndoEngine" /> instead.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.IUndoUnit.Undo">
      <summary>
        <para>Undoes the work that is represented by this unit.</para>
      </summary>
      <remarks>
        <para>Undo/redo are sensible operations and should maintain a consistent state before and after each operation since they may be executed potentially often one after another.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.IUndoUnit.UndoName" />
    </member>
    <member name="M:yWorks.Graph.IUndoUnit.Redo">
      <summary>
        <para>Redoes the work that is represented by this unit.</para>
      </summary>
      <remarks>
        <para>Undo/redo are sensible operations and should maintain a consistent state before and after each operation since they may be executed potentially often one after another.</para>
      </remarks>
      <seealso cref="P:yWorks.Graph.IUndoUnit.RedoName" />
    </member>
    <member name="P:yWorks.Graph.IUndoUnit.UndoName">
      <summary>
        <para>Gets the name of the undo unit.</para>
      </summary>
      <remarks>
        <para>Depending on the implementation and context this might be a human readable representation of the undo action or a symbolic name that needs localization.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Graph.IUndoUnit.RedoName">
      <summary>
        <para>Gets the name of the redo unit.</para>
      </summary>
      <remarks>
        <para>Depending on the implementation and context this might be a human readable representation of the redo action or a symbolic name that needs localization.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Graph.IUndoUnit.TryMergeUnit(yWorks.Graph.IUndoUnit)">
      <summary>
        <para>Tries to merge the given unit with this one.</para>
      </summary>
      <remarks>
        <para>This method is called when <c>this</c> unit is the head of an <see cref="T:yWorks.Graph.UndoEngine" />'s or <see cref="T:yWorks.Graph.CompositeUndoUnit" />'s queue and a new unit is added. It is meant to try to incorporate the change of the given <paramref name="unit" /> into <c>this</c> and if successful return <c>true</c>. This should be the case when the end state of <c>this</c> unit is equal to the start state of the given <paramref name="unit" />.</para>
        <para>For example, if <c>this</c> unit is the head of the queue and represents the work from state <c>A</c> to state <c>B</c> and the given unit the work from state <c>B</c> to state <c>C</c>, then this method should try to make <c>this</c> unit shift from state <c>A</c> to state <c>C</c>. If this is successful, the method is expected to return <c>true</c>. The other unit is then <see cref="M:System.IDisposable.Dispose">disposed</see> by the <see cref="T:yWorks.Graph.UndoEngine" /> afterwards.</para>
        <para>Clients don't necessarily have to implement this method if the unit doesn't happen very often. In fact, the default implementation of <see cref="M:yWorks.Graph.UndoUnitBase.TryMergeUnit(yWorks.Graph.IUndoUnit)" /> simply returns <c>false</c>. Implementing this method faithfully will cause multiple units of work to inseparably appear as one and undoing/redoing it will undo/redo the work of all collapsed units. Depending on the situation this may be reasonable, for example when there are potentially a lot of changes where not every intermediate step is required to be recorded. In this case implementing this method faithfully will greatly improve the performance and reduce the required amount of memory of the undo process. If you want to group together multiple units as a single block but still want to be able to separate each step, consider to use a <see cref="T:yWorks.Graph.CompositeUndoUnit" /> instead.</para>
      </remarks>
      <param name="unit">
        <para>The unit to incorporate that happened after this unit.</para>
      </param>
      <returns>
        <para>Whether the state change of <paramref name="unit" /> has been incorporated into this unit and <paramref name="unit" /> can be disposed of.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IUndoUnit.TryReplaceUnit(yWorks.Graph.IUndoUnit)">
      <summary>
        <para>Tries to replace the given unit with this one.</para>
      </summary>
      <remarks>
        <para>This method is called if a newly added unit couldn't be <see cref="M:yWorks.Graph.IUndoUnit.TryMergeUnit(yWorks.Graph.IUndoUnit)">merged</see> with the head unit of the queue (i.e. returned false). Instead of trying to merge a newly added unit, this method tries to replace the given unit (which is the head of the queue) with <c>this</c> by incorporating the change of the given <paramref name="unit" /> into <c>this</c> and if successful return <c>true</c>. This should be the case when the start state of <c>this</c> unit is equal to the end state of the given <paramref name="unit" />.</para>
        <para>For example, if the given <paramref name="unit" /> represents the work from state <c>A</c> to state <c>B</c> and <c>this</c> unit the work from state <c>B</c> to state <c>C</c>, then this method should try to make <c>this</c> unit shift from state <c>A</c> to state <c>C</c>. If this is successful, the method is expected to return <c>true</c>. The given <paramref name="unit" /> is then <see cref="M:System.IDisposable.Dispose">disposed</see> by the <see cref="T:yWorks.Graph.UndoEngine" /> afterwards and replaced with <c>this</c> unit in the queue.</para>
        <para>Clients don't necessarily have to implement this method if the unit doesn't happen very often. In fact, the default implementation of <see cref="M:yWorks.Graph.UndoUnitBase.TryReplaceUnit(yWorks.Graph.IUndoUnit)" /> simply returns <c>false</c>. Implementing this method faithfully will cause multiple units of work to inseparably appear as one and undoing/redoing it will undo/redo the work of all collapsed units. Depending on the situation this may be reasonable, for example when there are potentially a lot of changes where not every intermediate step is required to be recorded. In this case implementing this method faithfully will greatly improve the performance and reduce the required amount of memory of the undo process. If you want to group together multiple units as a single block but still want to be able to separate each step, consider to use a <see cref="T:yWorks.Graph.CompositeUndoUnit" /> instead.</para>
      </remarks>
      <param name="unit">
        <para>The unit to incorporate that happened before this unit.</para>
      </param>
      <returns>
        <para>Whether the state change of <c>this</c> unit has been incorporated into the given <paramref name="unit" /> and <c>this</c> can be disposed of.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.IMementoSupport">
      <summary>
        <para>This interface provides access to the memento design pattern to provide undoability for arbitrary models.</para>
      </summary>
      <remarks>
        <para>By implementing this interface as well as <see cref="T:yWorks.Graph.ILookup" />, clients can add undoability for changes to their model classes. The yFiles undo mechanism uses the return value of <see cref="M:yWorks.Graph.IMementoSupport.GetState(System.Object)" /> to retrieve a state of an item at the beginning of the compound editing process. When the process ends, another state will be retrieved of the same item and compared to the original state. If they differ, an <see cref="T:yWorks.Graph.IUndoUnit" /> is created that uses the <see cref="M:yWorks.Graph.IMementoSupport.ApplyState(System.Object,System.Object)" /> method to apply either state to the item in case of <see cref="M:yWorks.Graph.IUndoUnit.Undo">undo</see> or <see cref="M:yWorks.Graph.IUndoUnit.Redo">redo</see>. This represents an abstraction to the undo mechanism where it is only needed to define "states" of items and hides the more complicated mechanism of creating and inserting <see cref="T:yWorks.Graph.IUndoUnit" />s.</para>
        <para>The following is an example implementation of an item that is being managed using <see cref="T:yWorks.Graph.IMementoSupport" />:</para>
        <para>A collection of items from this type can then be watched using the following code snippet:</para>
        <para>Implementing the <see cref="T:yWorks.Graph.IMementoSupport" /> interface is quite unrestrained, the type of the state returned by <see cref="M:yWorks.Graph.IMementoSupport.GetState(System.Object)" /> method can by anything as long as the <see cref="M:yWorks.Graph.IMementoSupport.ApplyState(System.Object,System.Object)" /> and <see cref="M:yWorks.Graph.IMementoSupport.StateEquals(System.Object,System.Object)" /> methods can deal with it:</para>
        <para>In summary, use this concept when you want to track the state of items during certain operations for undo/redo. This is efficient if it's easier to handle an item's state than the changes to the item themselves. If you want to focus on the changes or on certain events, you should use custom <see cref="T:yWorks.Graph.IUndoUnit" /> implementations instead.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.ILookup" />
      <seealso cref="T:yWorks.Graph.ICompoundEdit" />
      <seealso cref="T:yWorks.Graph.UndoEngine" />
    </member>
    <member name="M:yWorks.Graph.IMementoSupport.GetState(System.Object)">
      <summary>
        <para>Retrieves an object representing the state at the moment this method is called.</para>
      </summary>
      <remarks>
        <para>The returned state may be reapplied later to the subject in the <see cref="M:yWorks.Graph.IMementoSupport.ApplyState(System.Object,System.Object)" /> method.</para>
      </remarks>
      <param name="subject">
        <para>The subject to read the state from</para>
      </param>
      <returns>
        <para>An object that describes the current state of <paramref name="subject" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Graph.IMementoSupport.ApplyState(System.Object,System.Object)">
      <summary>
        <para>Reapplies a previously queried state object to a given subject.</para>
      </summary>
      <remarks>
        <para>The state object has been created using the <see cref="M:yWorks.Graph.IMementoSupport.GetState(System.Object)" /> method.</para>
      </remarks>
      <param name="subject">
        <para>The subject to modify the state.</para>
      </param>
      <param name="state">
        <para>The state object as returned by <see cref="M:yWorks.Graph.IMementoSupport.GetState(System.Object)" /></para>
      </param>
    </member>
    <member name="M:yWorks.Graph.IMementoSupport.StateEquals(System.Object,System.Object)">
      <summary>
        <para>Determines whether two state objects are equal.</para>
      </summary>
      <remarks>
        <para>The undo mechanism in yFiles calls this method to determine if the subject has changed and whether an <see cref="T:yWorks.Graph.IUndoUnit" /> should be created for these changes. If this method returns <c>false</c>, an <see cref="T:yWorks.Graph.IUndoUnit" /> is created for the two states that can reapply either state (for either undo or redo). If this method returns <c>true</c> the state is considered not to have changed and no undo unit will be created. Conservative implementations my simply return <c>false</c>.</para>
      </remarks>
      <param name="state1">
        <para>The first state as obtained from <see cref="M:yWorks.Graph.IMementoSupport.GetState(System.Object)" /></para>
      </param>
      <param name="state2">
        <para>The second state as obtained from <see cref="M:yWorks.Graph.IMementoSupport.GetState(System.Object)" /></para>
      </param>
      <returns>
        <para>
          <c>true</c> if the states are equal; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="T:yWorks.Graph.MementoSupportProvider`1">
      <summary>
        <para>A simple function that is used to retrieve an <see cref="T:yWorks.Graph.IMementoSupport" /> for any given object.</para>
      </summary>
      <param name="item">
        <para>The item to provide the <see cref="T:yWorks.Graph.IMementoSupport" /> for.</para>
      </param>
    </member>
    <member name="T:yWorks.Graph.DelegateUndoUnit`1">
      <summary>
        <para>A convenience implementation of the <see cref="T:yWorks.Graph.IUndoUnit" /> interface that uses simple delegates for the actual undo and redo operations.</para>
      </summary>
      <typeparam name="T">
        <para>The type of the single parameter that is passed to the delegate.</para>
      </typeparam>
    </member>
    <member name="T:yWorks.Graph.DelegateUndoUnit`1.DoHandlerDelegate">
      <summary>
        <para>The delegate that is used by <see cref="T:yWorks.Graph.DelegateUndoUnit`1" />.</para>
      </summary>
      <param name="param">
        <para>An usage dependent parameter that is passed to the delegate.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DelegateUndoUnit`1.#ctor(System.String,yWorks.Graph.DelegateUndoUnit{`0}.DoHandlerDelegate,`0,`0)">
      <summary>
        <para>Creates a new instance using the provided name and a undo/redo handler as well as the parameters to pass to the delegates.</para>
      </summary>
      <param name="undoName">
        <para>The name of the undo.</para>
      </param>
      <param name="undoRedo">
        <para>The undo and redo handler delegate.</para>
      </param>
      <param name="undoParam">
        <para>The undo parameter to pass to the delegate.</para>
      </param>
      <param name="redoParam">
        <para>The redo parameter to pass to the delegate.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DelegateUndoUnit`1.#ctor(System.String,yWorks.Graph.DelegateUndoUnit{`0}.DoHandlerDelegate,yWorks.Graph.DelegateUndoUnit{`0}.DoHandlerDelegate,`0,`0)">
      <summary>
        <para>Creates a new instance using the provided name and a undo and redo handler as well as the parameters to pass to the delegates.</para>
      </summary>
      <param name="undoName">
        <para>The name of the undo.</para>
      </param>
      <param name="undo">
        <para>The undo handler delegate.</para>
      </param>
      <param name="redo">
        <para>The redo handler delegate.</para>
      </param>
      <param name="undoParam">
        <para>The undo parameter to pass to the delegate.</para>
      </param>
      <param name="redoParam">
        <para>The redo parameter to pass to the delegate.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.DelegateUndoUnit`1.Undo">
      <summary>
        <para>Calls the undo delegate using the undo parameter.</para>
      </summary>
    </member>
    <member name="M:yWorks.Graph.DelegateUndoUnit`1.Redo">
      <summary>
        <para>Calls the redo delegate using the redo parameter.</para>
      </summary>
    </member>
    <member name="T:yWorks.Graph.UndoUnitBase">
      <summary>
        <para>An abstract convenience implementation of <see cref="T:yWorks.Graph.IUndoUnit" />.</para>
      </summary>
      <remarks>
        <para>This class defaults most methods required by the <see cref="T:yWorks.Graph.IUndoUnit" /> interface. Subclasses only have to implement the undo/redo logic. Most notably, <see cref="M:yWorks.Graph.IUndoUnit.TryMergeUnit(yWorks.Graph.IUndoUnit)" /> and <see cref="M:yWorks.Graph.IUndoUnit.TryReplaceUnit(yWorks.Graph.IUndoUnit)" /> are implemented to return <c>false</c>. Subclasses are of course allowed to override more methods if clients want to enable additional functionality.</para>
        <para>Use this class for simple custom implementations of <see cref="T:yWorks.Graph.IUndoUnit" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Graph.IUndoUnit" />
      <seealso cref="T:yWorks.Graph.UndoEngine" />
    </member>
    <member name="M:yWorks.Graph.UndoUnitBase.#ctor(System.String,System.String)">
      <summary>
        <para>Creates a new instance using the given name as undo and redo name.</para>
      </summary>
      <param name="undoName">
        <para>The undo name.</para>
      </param>
      <param name="redoName">
        <para>The redo name.</para>
      </param>
    </member>
    <member name="M:yWorks.Graph.UndoUnitBase.Undo" />
    <member name="M:yWorks.Graph.UndoUnitBase.Redo" />
    <member name="M:yWorks.Graph.UndoUnitBase.TryMergeUnit(yWorks.Graph.IUndoUnit)">
      <param name="unit" />
    </member>
    <member name="M:yWorks.Graph.UndoUnitBase.TryReplaceUnit(yWorks.Graph.IUndoUnit)">
      <param name="unit" />
    </member>
    <member name="M:yWorks.Graph.UndoUnitBase.Dispose" />
    <member name="M:yWorks.Graph.UndoUnitBase.ToString" />
    <member name="T:yWorks.Controls.ApplicationResources">
      <summary>
        <para>Helper class that can be used to store and retrieve application wide resources.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ApplicationResources.#ctor">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.ApplicationResources" /> class.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ApplicationResources.Instance">
      <summary>
        <para>Gets the single static instance of this class for the current application.</para>
      </summary>
      <value>
        <para>The instance.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.ApplicationResources.TryGetValue(yWorks.Controls.ResourceKey,System.Object@)">
      <summary>
        <para>Tries to retrieve the value for the provided resource key.</para>
      </summary>
      <param name="resourceKey">
        <para>The resource key.</para>
      </param>
      <param name="value">
        <para>The value.</para>
      </param>
      <returns>
        <para>Whether the value has been found.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ApplicationResources.ContainsKey(yWorks.Controls.ResourceKey)">
      <summary>
        <para>Determines whether the specified key is contained in this resources.</para>
      </summary>
      <param name="key">
        <para>The key.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified key is contained; otherwise, <c>false</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ApplicationResources.Remove(yWorks.Controls.ResourceKey)">
      <summary>
        <para>Removes the specified key from this instance.</para>
      </summary>
      <param name="key">
        <para>The key to remove.</para>
      </param>
      <returns>
        <para>Whether the key was contained in this instance.</para>
      </returns>
    </member>
    <member name="P:yWorks.Controls.ApplicationResources.Item(yWorks.Controls.ResourceKey)">
      <summary>
        <para>Gets or sets the item with the specified key.</para>
      </summary>
      <value>
        <para>The value to store with the key.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.CanExecuteCommandEventArgs">
      <summary>
        <para>Event argument used by the <see cref="T:System.EventHandler`1" /> delegate.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.CanExecuteCommandEventArgs.#ctor(yWorks.Controls.ICommand,System.Object,System.Object)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.CanExecuteCommandEventArgs" /> class.</para>
      </summary>
      <param name="command">
        <para>The command.</para>
      </param>
      <param name="parameter">
        <para>The parameter.</para>
      </param>
      <param name="source">
        <para>The source that triggered the event</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.CanExecuteCommandEventArgs.Command">
      <summary>
        <para>Gets the command which is affected by the query.</para>
      </summary>
      <value>
        <para>The command.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.CanExecuteCommandEventArgs.ContinueRouting">
      <summary>
        <para>Gets or sets a value indicating whether to continue event routing, even if this argument is <see cref="P:yWorks.Controls.CanExecuteCommandEventArgs.Handled" />.</para>
      </summary>
      <remarks>
        <para>The default is <c>false</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if routing of the event should be continued; otherwise, <c>false</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.CanExecuteCommandEventArgs.Parameter">
      <summary>
        <para>Gets or sets the parameter that is associated with this event.</para>
      </summary>
      <value>
        <para>The parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.CanExecuteCommandEventArgs.Source">
      <summary>
        <para>Gets the source of the event.</para>
      </summary>
      <value>
        <para>The source.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.CanExecuteCommandEventArgs.CanExecute">
      <summary>
        <para>Gets or sets a value indicating whether the command can be executed.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the command can be executed; otherwise, <c>false</c>.</para>
      </value>
      <seealso cref="P:yWorks.Controls.CanExecuteCommandEventArgs.Handled" />
    </member>
    <member name="P:yWorks.Controls.CanExecuteCommandEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Controls.CanExecuteCommandEventArgs" /> is Handled.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if handled; otherwise, <c>false</c>.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.CommandManager">
      <summary>
        <para>A static helper class that provides access to the attached properties of type <see cref="T:yWorks.Controls.ICommand" /> for <see cref="T:System.Windows.Forms.Control" />s.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Controls.ICommand" />s are a simplified implementation of WPF's routed command pattern. Most of the classes of the WPF implementation have been reimplemented here. The <c>KeyBindings</c> and <c>CommandBindings</c> properties have been implemented as attached properties. For an overview of the concepts please see the corresponding documentation of the WPF implementation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.CommandManager.InvalidateRequerySuggested">
      <summary>
        <para>Suggests a requery of the <see cref="M:yWorks.Controls.ICommand.CanExecute(System.Object,System.Windows.Forms.Control)">executability</see> of all routed commands that are known to the system to adjust the UI to properly reflect the state.</para>
      </summary>
      <remarks>
        <para>This will enqueue a delayed query into the event queue.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Controls.ComponentResourceKey">
      <summary>
        <para>A <see cref="T:yWorks.Controls.ResourceKey">key</see> for resources that are bound to a specific type.</para>
      </summary>
      <remarks>
        <para>This class exists for WPF compatibility reasons. The <see cref="M:yWorks.Controls.ComponentResourceKey.GetString(System.Type,System.Object)" /> result is used for the lookup in the resources.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Controls.ComponentResourceKey.#ctor(System.Type,System.Object)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.ComponentResourceKey" /> class.</para>
      </summary>
      <param name="type">
        <para>The type for which this resource is created.</para>
      </param>
      <param name="value">
        <para>The identifier that further specifies the resource. The <see cref="M:System.Object.ToString" /> of this instance will be used for the key.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ComponentResourceKey.GetString(System.Type,System.Object)">
      <summary>
        <para>Gets the string representation for this key that will be used to lookup the resource in the <see cref="T:yWorks.Controls.ApplicationResources" />.</para>
      </summary>
      <returns>
        <para>A string where all '.' in the namespace of the type are replaced by '_', followed by ':', the type name, a '.' and the value.</para>
      </returns>
      <param name="type" />
      <param name="value" />
    </member>
    <member name="T:yWorks.Controls.ExecutedCommandEventArgs">
      <summary>
        <para>The event argument that is used by <see cref="T:System.EventHandler`1" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ExecutedCommandEventArgs.#ctor(yWorks.Controls.ICommand,System.Object)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.ExecutedCommandEventArgs" /> class.</para>
      </summary>
      <param name="command">
        <para>The command instance.</para>
      </param>
      <param name="parameter">
        <para>The parameter for the execution of the command.</para>
      </param>
    </member>
    <member name="M:yWorks.Controls.ExecutedCommandEventArgs.#ctor(System.Object,yWorks.Controls.ICommand,System.Object)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.ExecutedCommandEventArgs" /> class.</para>
      </summary>
      <param name="source">
        <para>The source of the command execution.</para>
      </param>
      <param name="command">
        <para>The command instance.</para>
      </param>
      <param name="parameter">
        <para>The parameter for the execution of the command.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.ExecutedCommandEventArgs.Handled">
      <summary>
        <para>Gets or sets a value indicating whether this <see cref="T:yWorks.Controls.ExecutedCommandEventArgs" /> is handled.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if handled; otherwise, <c>false</c>.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.ExecutedCommandEventArgs.Parameter">
      <summary>
        <para>Gets the parameter that is associated with this execution of the command.</para>
      </summary>
      <value>
        <para>The parameter.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.ExecutedCommandEventArgs.Source">
      <summary>
        <para>Gets the source of the event.</para>
      </summary>
      <value>
        <para>The source.</para>
      </value>
    </member>
    <member name="P:yWorks.Controls.ExecutedCommandEventArgs.Command">
      <summary>
        <para>Gets the command that shall be executed.</para>
      </summary>
      <value>
        <para>The command to execute.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.ICommand">
      <summary>
        <para>Base interface for a command that can be executed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ICommand.CanExecute(System.Object,System.Windows.Forms.Control)">
      <summary>
        <para>Determines whether this command be executed with respect to the given parameter and target.</para>
      </summary>
      <param name="parameter">
        <para>The parameter or <c>null</c></para>
      </param>
      <param name="target">
        <para>The target to execute the command on or <c>null</c></para>
      </param>
      <returns>
        <para>Whether <see cref="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)" /> can be called with the given <paramref name="parameter" /> and <paramref name="target" />.</para>
      </returns>
    </member>
    <member name="M:yWorks.Controls.ICommand.Execute(System.Object,System.Windows.Forms.Control)">
      <summary>
        <para>Executes this command with respect to the given parameter and target.</para>
      </summary>
      <param name="parameter">
        <para>The parameter or <c>null</c></para>
      </param>
      <param name="target">
        <para>The target to execute the command on or <c>null</c></para>
      </param>
    </member>
    <member name="E:yWorks.Controls.ICommand.CanExecuteChanged">
      <summary>
        <para>Triggered to signal that the result of a call to <see cref="M:yWorks.Controls.ICommand.CanExecute(System.Object,System.Windows.Forms.Control)" /> may yield a different result.</para>
      </summary>
    </member>
    <member name="P:yWorks.Controls.ICommand.Text">
      <summary>
        <para>Gets the text to display in a UI component.</para>
      </summary>
      <value>
        <para>The text.</para>
      </value>
    </member>
    <member name="T:yWorks.Controls.ResourceKey">
      <summary>
        <para>The base class for <see cref="T:yWorks.Controls.ComponentResourceKey" /> that exists for compatibility with WPF classes</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ResourceKey.#ctor(System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Controls.ResourceKey" /> class using the given string as the key.</para>
      </summary>
      <param name="key">
        <para>The key.</para>
      </param>
    </member>
    <member name="P:yWorks.Controls.ResourceKey.Key">
      <summary>
        <para>Gets the key that is used by this instance.</para>
      </summary>
      <value>
        <para>The key.</para>
      </value>
    </member>
    <member name="M:yWorks.Controls.ResourceKey.ToString">
      <summary>
        <para>Returns the <see cref="P:yWorks.Controls.ResourceKey.Key" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Controls.ResourceKey.Equals(System.Object)">
      <summary>
        <para>Overridden to compare for the same <see cref="P:yWorks.Controls.ResourceKey.Key" /></para>
      </summary>
      <param name="obj" />
    </member>
    <member name="M:yWorks.Controls.ResourceKey.GetHashCode">
      <summary>
        <para>Overridden to yield the hash for the <see cref="P:yWorks.Controls.ResourceKey.Key" /></para>
      </summary>
    </member>
    <member name="T:yWorks.Controls.ResourceKeyConverter" />
    <member name="M:yWorks.Controls.ResourceKeyConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
      <param name="context" />
      <param name="sourceType" />
    </member>
    <member name="M:yWorks.Controls.ResourceKeyConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
      <param name="context" />
      <param name="destinationType" />
    </member>
    <member name="M:yWorks.Controls.ResourceKeyConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
      <param name="context" />
      <param name="culture" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Controls.ResourceKeyConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
      <param name="context" />
      <param name="culture" />
      <param name="value" />
      <param name="destinationType" />
    </member>
  </members>
</doc>